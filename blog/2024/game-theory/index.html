<!DOCTYPE html> <html lang="zh"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> A Brief Introduction of Game Theory | Kaiser's Homepage </title> <meta name="author" content="Kaiser Yang"> <meta name="description" content="This post introduce some simple examples of game theory."> <meta name="keywords" content="C/C++, Java, Python"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kaiser-yang.github.io/blog/2024/game-theory/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Kaiser's Homepage </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">Ctrl K <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main" style="min-width: 60%;"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">A Brief Introduction of Game Theory</h1> <p class="post-meta"> Created in June 17, 2024 , last updated in May 17, 2025 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/mathematics"> <i class="fa-solid fa-hashtag fa-sm"></i> Mathematics</a>   <a href="/blog/tag/game-theory"> <i class="fa-solid fa-hashtag fa-sm"></i> Game Theory</a>   ·   <a href="/blog/category/potpourri"> <i class="fa-solid fa-tag fa-sm"></i> Potpourri</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="nim-game">Nim Game</h2> <h3 id="the-simplest-one">The Simplest One</h3> <h4 id="description">Description</h4> <p>You are playing the following Nim Game with your friend:</p> <p>There is a heap of stones on the table, each time one of you take turns to remove \(1\) to \(3\) stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. How to know if you can win the game?</p> <p>For example, if there are \(4\) stones in the heap and now it’s your turn, you will never win the game. No matter \(1\), \(2\), or \(3\) stones you remove, the last stone will always be removed by your friend. Another example: If there are \(5\) stones in the heap and now it’s your turn, you will win the game. You can remove \(1\)stone, then no matter how many stones your friend remove, you can remove the last stone and win the game.</p> <h4 id="solution">Solution</h4> <p>Let’s start with the simplest one. If there are \(1\), \(2\), or \(3\) stones, you can win the game. And from the examples, we know that when there is \(4\) stones, you will lose. But when there are \(5\) stones, you will win.</p> <p>What’s the next? Actually:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Theorem 1</code>: When the number of the stones is multiple of \(4\), you will lose the game. Otherwise, you will win the game.</li> </ul> <p>But why? In order to prove this, we must introduce some important definitions:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Winning State</code>: The state you will win the game.</li> <li> <code class="language-plaintext highlighter-rouge">Losing State</code>: The state you will lose the game.</li> </ul> <p>We can find that if a state is a winning state, we can make a move to change the state to a losing state (make your opposite lose). And if a state is a losing state, no mater which move we choose, the state will be changed to a winning state (make your opposite win).</p> <p>Now, we can prove the <code class="language-plaintext highlighter-rouge">theorem 1</code> by proving the following two claims:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Claim 1</code>: If the number of the stones is multiple of \(4\), any move will make the number of the rest stones not multiple of \(4\) (from <code class="language-plaintext highlighter-rouge">losing state</code> to <code class="language-plaintext highlighter-rouge">winning state</code>).</li> <li> <code class="language-plaintext highlighter-rouge">Claim 2</code>: If the number of the stones is not multiple of \(4\), we can make a move to make the number of the rest stones multiple of \(4\) (from <code class="language-plaintext highlighter-rouge">winning state</code> to <code class="language-plaintext highlighter-rouge">losing state</code>).</li> </ul> <p>The proof of the <code class="language-plaintext highlighter-rouge">claim 1</code> is obvious. Because you can only remove \(1\), \(2\), or \(3\) stones at a time, if the number of the stones is multiple of \(4\), no matter how many stones you remove, the number of the rest stones will not be multiple of \(4\).</p> <p>For <code class="language-plaintext highlighter-rouge">claim 2</code>, suppose the number of the stones is \(n\), and \(n\) is not multiple of \(4\). We just need remove \(n \mod 4\) stones, then the number of the rest stones will be \(n - n \mod 4\), which is multiple of \(4\).</p> <p>Then we know that \(0\) is the simplest losing state. Then we have proven the <code class="language-plaintext highlighter-rouge">theorem 1</code> by induction (compare the claims and the definitions of the winning state and the losing state).</p> <h3 id="multiple-piles">Multiple Piles</h3> <h4 id="description-1">Description</h4> <p>There are several piles of stones. You and your friend will take turns to remove stones from the piles. On each turn, a player can remove any number of stones from a single pile. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p> <p>For example, if there are two piles of stones, the first one with \(2\) stones and the second one with \(3\) stones, you will win the game. You can remove \(1\) stone from the second pile, then no matter how many stones your friend remove, you just to make a move to make the two piles have the same number of stones, then you will win the game.</p> <h4 id="solution-1">Solution</h4> <p>We can solve this problem by using the <code class="language-plaintext highlighter-rouge">Nim Sum</code>. The <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is the bitwise <code class="language-plaintext highlighter-rouge">XOR</code> of the numbers.</p> <p><code class="language-plaintext highlighter-rouge">XOR</code>: If two bits of binary representations are different, the result is \(1\), otherwise, the result is \(0\).</p> <p>For the problem, the solution is below:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Theorem 2</code>: The <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is \(0\) if and only if the set of numbers is in the losing state.</li> </ul> <p>We can prove the <code class="language-plaintext highlighter-rouge">theorem 2</code> similarly as the <code class="language-plaintext highlighter-rouge">theorem 1</code>. We can prove the following two claims:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Claim 3</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is \(0\), any move will make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers not \(0\).</li> <li> <code class="language-plaintext highlighter-rouge">Claim 4</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is not \(0\), we can make a move to make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers \(0\).</li> </ul> <p>The proof of the <code class="language-plaintext highlighter-rouge">claim 3</code> is easy. Suppose we remove \(x\) stones from a pile, and the number of the rest stones of the pile is \(r\). Then the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers is \((x + r) \oplus r\). When this number is \(0\), \(x\) must be \(0\), which is not a legal move.</p> <p><strong>NOTE</strong>: You may ask why the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers is \((x + r) \oplus r\). This is because the <code class="language-plaintext highlighter-rouge">XOR</code> operation is associative and commutative. After removing \(x\) stones, we change the number from \(x + r\) to \(r\). We can use the origin <code class="language-plaintext highlighter-rouge">Nim Sum</code> \(0\) to calculate the new <code class="language-plaintext highlighter-rouge">Nim Sum</code>: $0 \oplus (x + r) \oplus r$. The \(\oplus (x + r)\) means we remove the whole pile, and the \(\oplus r\) means we add new pile of \(r\) stones. By the two steps, we can make a pile from \(x + r\) stones to \(r\) stones. And \(0\) is the identity element of the <code class="language-plaintext highlighter-rouge">XOR</code> operation. Therefore the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers is \((x + r) \oplus r\).</p> <p>The proof of the <code class="language-plaintext highlighter-rouge">claim 4</code> is a little bit complex. Suppose the \(i\)-th bit of the <code class="language-plaintext highlighter-rouge">Nim Sum</code> is \(b_i\) (the right most bit’s index is \(1\)), and the left most bit is \(b_m\). Note that \(b_m = 1\). Then we can find at least one pile of stones whose \(m\)-th bit is \(1\). Now we try to remove some stones from this pile to make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers \(0\). We just need to consider the rightmost \(m\) bits of the pile. We consider each bit of the rightmost \(m\) bits of the pile, if the corresponding <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit is \(1\), we must make the bit of the rest number changed to change the <code class="language-plaintext highlighter-rouge">Nim Sum</code>’s bit to \(0\); if the corresponding <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit is \(0\), we must make the bit of the rest number unchanged to keep the <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit to be \(0\). We could record each bit of the result. Subtracting the result number from the origin number’s rightmost \(m\) bits could get the number of stones we should remove from the pile. Because the \(m\)-th bit of the rest is not \(0\), we can find that the number of removed stones is positive.</p> <p>Then we have proven the <code class="language-plaintext highlighter-rouge">theorem 2</code> by induction.</p> <p>This proof may be complex, there is a example of how to make a move to make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> \(0\) when the original <code class="language-plaintext highlighter-rouge">Nim Sum</code> is not \(0\).</p> <p>There are three piles of stones: \(1\), \(10\), \(13\).</p> <p>The binary representations: \(1\), \(1010\), \(1101\).</p> <p>The <code class="language-plaintext highlighter-rouge">Nim Sum</code> is \(110\), we can find \(1101\) is the pile whose 3rd bit is \(1\): \(1(1)01\). Now we consider each bit of the right \(3\) bits of the pile \(1101\), the first one is \(1\): \(110(1)\), and the corresponding <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit is \(0\): \(11(0)\), we keep this; the second one is \(0\): \(11(0)1\), and the corresponding <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit is \(1\): \(1(1)0\), we change this; the third one is \(1\): \(1(1)01\), and the corresponding <code class="language-plaintext highlighter-rouge">Nim Sum</code> bit is \(1\): \(1(1)0\), we change this. After the three steps, we get a number \(011\), then we use the rightmost \(3\) bits of pile \(1(101)\) to subtract the number \(011\), then we get \(10\), which is \(2\) in decimal. Therefore we remove \(2\) stones from the pile. After this move, the rest three piles will be: \(1\), \(1010\), \(1011\), whose <code class="language-plaintext highlighter-rouge">Nim Sum</code> is \(0\).</p> <h3 id="staircase-nim">Staircase Nim</h3> <h4 id="description-2">Description</h4> <p>There are several piles of stones. You and your friend will take turns to move one or more stones from a pile that is not the left most one to the one adjacent to its left side. The one who moves the last stone will be the winner. You will take the first turn to move the stones.</p> <h4 id="solution-2">Solution</h4> <p>We index the left most one as \(0\), and the right most one as \(n\). Let me show you the solution first:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Theorem 3</code>: When the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the odd index piles is \(0\), you will lose the game. Otherwise, you will win the game.</li> </ul> <p>Let me explain this. We still can prove by proving the following two claims:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Claim 5</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the odd index piles is \(0\), any move will make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest odd index numbers not \(0\).</li> <li> <code class="language-plaintext highlighter-rouge">Claim 6</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the odd index piles is not \(0\), we can make a move to make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest odd index numbers \(0\).</li> </ul> <p>Actually, we have proven this two already.</p> <p>For <code class="language-plaintext highlighter-rouge">claim 5</code>, consider one move from a odd position to its left, this is same with removing some stones from it, which we have proved. For one move from a even position to its left, after the move, one number participating calculation of the <code class="language-plaintext highlighter-rouge">Nim Sum</code> will be increased a positive number, we record this number as \(r\), and the original one as \(x\), then the new number is \(x + r\), and the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers is \((x + r) \oplus x = r\), which is not \(0\).</p> <p>For <code class="language-plaintext highlighter-rouge">claim 6</code>, we just do what we have done in proof of the <code class="language-plaintext highlighter-rouge">claim 4</code>. We can find the pile and move some stones to its left.</p> <p>Then we have proven the <code class="language-plaintext highlighter-rouge">theorem 3</code> by induction.</p> <h2 id="variations-of-nim-game">Variations of Nim Game</h2> <h3 id="variation-1">Variation 1</h3> <h4 id="description-3">Description</h4> <p>There are several buckets from \(0\) to \(n\) (from left to right). Some buckets are empty, and some buckets have some cookies. You and your friend will take turns to move one cookie from a bucket that is not the bucket \(0\) to any one which is at the left side of the bucket. The one who moves the last cookie will be the winner . You will take the first turn to move the cookie.</p> <h4 id="solution-3">Solution</h4> <p>This one is the same as the <a href="###multiple-piles">multiple piles</a> problem. For each cookie, we can consider it as a pile of stones, and the number of the stones is the index of the bucket. Then we can use the <code class="language-plaintext highlighter-rouge">Nim Sum</code> to solve this problem.</p> <h3 id="variation-2">Variation 2</h3> <h4 id="description-4">Description</h4> <p>There are several piles of stones. Initially, the numbers are non-descending. You and your friend will take turns to remove stones from a pile and make sure that the rest numbers are non-descending. The one who moves the last stone will be the winner. You will take the first turn to move the stones.</p> <h4 id="solution-4">Solution</h4> <p>We can calculate the difference between the adjacent piles. For example, the differences of \(1, 2, 2, 3\) are \(1, 1, 0, 1\). We can find that the differences are non-negative. For one move, supposed we remove \(x\) stones from the \(i\)-th pile, then the difference between the \(i\)-th pile and the \(i+1\)-th pile will increase by \(x\), and the difference between the \(i\)-th pile and the \(i-1\)-th pile will decrease by \(x\). This is similar with the move in the <a href="###staircase-nim">Staircase Nim</a> problem. The only difference in this case is that we move the stones to the one adjacent to its right side, rather than the left side.</p> <h3 id="variation-3">Variation 3</h3> <h4 id="description-5">Description</h4> <p>There are several buckets from \(0\) to \(n\). Some buckets are empty, and some buckets have one cookie. You and your friend will take turns to move one cookie from a bucket that is not the bucket \(0\) to any one which is at the left side of the bucket, but you can not jump over any buckets that contains cookies. The one who moves the last cookie will be the winner. You will take the first turn to move the cookie.</p> <p>This one is similar with <a href="###variation-2">variation 2</a>. For each cookie, we just need to consider it as a pile of stones, and the number of the stones is the index of the bucket. Then this one becomes exactly the same as <code class="language-plaintext highlighter-rouge">variation 2</code>.</p> <h3 id="variation-4">Variation 4</h3> <h4 id="description-6">Description</h4> <p>There are several coins on a line. Some coins are heads up, and some coins are tails up. You and your friend will take turns to choose one head-up coin and any other coin that is at the left side of the chosen coin, and flip them. The one who flips the last coin will be the winner. You will take the first turn to flip the coins.</p> <h4 id="solution-5">Solution</h4> <p>This one is similar with the <a href="###multiple-piles">multiple piles</a> problem. We consider the head-up coins as the stones, and the number of the stones are the index of the coins. For the chosen two head-up coins, it is same with removing the whole two piles of stones. If the left chosen coin is tail-up, the result is we remove some stones from a pile.</p> <p>With this conversion, we can find that we can not make any two piles of stones with the same number. This looks different from <a href="###multiple-piles">multiple piles</a>, but actually they are the same, we have two claims below:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Claim 7</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is \(0\), any move will make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers not \(0\).</li> <li> <code class="language-plaintext highlighter-rouge">Claim 8</code>: If the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of a set of numbers is not \(0\), we can make a move to make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> of the rest numbers \(0\).</li> </ul> <p>For the <code class="language-plaintext highlighter-rouge">claim 7</code>, we only need consider if we can make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> \(0\) by removing two piles at the times. For any two piles \(x\) and \(y\), they must have different numbers of stones. So after removing, the <code class="language-plaintext highlighter-rouge">Nim Sum</code> is not \(0\).</p> <p>For the <code class="language-plaintext highlighter-rouge">Claim 8</code>, suppose we can make two piles same. After one move, if the <code class="language-plaintext highlighter-rouge">Nim Sum</code> \(0\) and there are two same piles, actually we can remove the two same piles when take the move and the <code class="language-plaintext highlighter-rouge">Nim Sum</code> is still \(0\).</p> <h2 id="the-waiting-move">The Waiting Move</h2> <h3 id="the-simplest-one-1">The Simplest One</h3> <p>What is the waiting move? Let me show you by a simple example:</p> <p>There are \(n\) numbers, and they are \(1, 2, 3, ..., n\) from left to right. You and your friend take turn to remove one number and remove all its divisors. For example, if you remove $6$, the $1, 2 ,3$ will be removed too. The one who can not move will lose.</p> <p>In this example, the first player will always win. We can prove this by the proof by contradiction, suppose there is a \(n\) that is a losing state. Now we remove the number \(1\). And now it’s the second player’s turn, because current state is a winning state, the second player can remove one number and reach a losing statement. But we can note that no matter which number the second player remove, the state is same with the first playing removing that number at beginning. And the state is a winning and losing state at same time, which is contradictory. Therefor the supposition is not correct and the first player will always win.</p> <p>In this case, removing number \(1\) is the waiting move.</p> <h3 id="the-tree">The Tree</h3> <p>There is a tree with \(n\) nodes. You and your friend take turn to choose a node and mark all the nodes of the path from the chosen nodes to the root. When all the nodes are marked, the game is over. The one who can not move will lose.</p> <p>In this case marking the root is the waiting move, so the first player will always win.</p> <h3 id="the-chocolate">The Chocolate</h3> <p>There is a chocolate whose shape is a \(n \times m\) rectangle. You and your friend take turn to chose a piece of chocolate, and eat all the pieces that are in the rectangle whose right top corner is the chosen piece, and the bottom left corner is the bottom left corner of the chocolate. The one who eat the last piece will lose.</p> <p>In this case eating the left bottom piece is the waiting move, so the first player will always win.</p> <p>I’ve given you three examples of games with a waiting move which can be taken advantages by the first player to win the game. But you may ask how the first player can win? What is the concrete strategy? Actually, only the smartest one in playing games can find the strategy, obvious is the fact that I am not the one.</p> <h2 id="the-sg-theorem">The SG Theorem</h2> <h3 id="the-mex">The Mex</h3> <p>The <code class="language-plaintext highlighter-rouge">Mex</code> is a function whose domain of definition are sets consists of natural numbers. The <code class="language-plaintext highlighter-rouge">Mex</code> of a set is the smallest natural number that is not in the set. For example, the <code class="language-plaintext highlighter-rouge">Mex</code> of ${0, 1, 2, 4}$ is $3$.</p> <p>With this we can converting any game to a <code class="language-plaintext highlighter-rouge">DAG</code> and solve the game by calculation the <code class="language-plaintext highlighter-rouge">SG</code> value.</p> <h3 id="the-conversion">The Conversion</h3> <p>Actually, any game are a state machine. We can find all the states that a game contains, and find all the states that one state can reach, and then we can get a <code class="language-plaintext highlighter-rouge">DAG</code> which is the state machine of the game.</p> <p>With this graph, we define the <code class="language-plaintext highlighter-rouge">SG</code> value of a state as the <code class="language-plaintext highlighter-rouge">Mex</code> of the <code class="language-plaintext highlighter-rouge">SG</code> values of all the states that can be reached from the current state. And the <code class="language-plaintext highlighter-rouge">SG</code> value of the final state is $0$. We have the statement that the first player will win if the <code class="language-plaintext highlighter-rouge">SG</code> value of the initial state is not $0$. The proof of this is very simple, we just need prove the following claims:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Claim 9 </code>: If the <code class="language-plaintext highlighter-rouge">SG</code> value of a state is $0$, we can not reach a state whose <code class="language-plaintext highlighter-rouge">SG</code> value is $0$.</li> <li> <code class="language-plaintext highlighter-rouge">Claim 10</code>: If the <code class="language-plaintext highlighter-rouge">SG</code> value of a state is not $0$, we can reach a state whose <code class="language-plaintext highlighter-rouge">SG</code> value is $0$.</li> </ul> <p>The proofs of the two claims are simple, so I’m not going to prove them. But I recommend you to prove them by yourself.</p> <h3 id="the-sg-theorem-1">The SG Theorem</h3> <p>The <code class="language-plaintext highlighter-rouge">SG</code> theorem is for solving the game with multiple sub-games. For this game, when the last sub-game is over, the game is over, and the one who can not move will lose.</p> <p>The <code class="language-plaintext highlighter-rouge">SG</code> theorem gives the statement below:</p> <blockquote> <p>The <code class="language-plaintext highlighter-rouge">SG</code> value of a state is the <code class="language-plaintext highlighter-rouge">XOR</code> of the <code class="language-plaintext highlighter-rouge">SG</code> values of all the sub-games.</p> </blockquote> <p>Let me explain why this is true. We must know that for every state whose <code class="language-plaintext highlighter-rouge">SG</code> value is \(k\), we can reach \(k\) states whose <code class="language-plaintext highlighter-rouge">SG</code> value are \(0, 1, 2, ..., k-1\) separately. For every move, we actually find one sub-game and change the <code class="language-plaintext highlighter-rouge">SG</code> value of the chosen sub-game. This is same with removing some stones from a pile. But you may ask how about a move make the <code class="language-plaintext highlighter-rouge">SG</code> value of the sub-game greater than \(k\)? Yes, this is possible, but this really does not matter. Let me explain this for you by a simple way:</p> <p>Consider that one in a winning state, he or she will not make the <code class="language-plaintext highlighter-rouge">SG</code> value of a sub-game greater than \(k\). He or she knows that there is a move that can make the <code class="language-plaintext highlighter-rouge">Nim Sum</code> \(0\), so he will try this one. For the one in a losing state, he or she may consider take a move that make the <code class="language-plaintext highlighter-rouge">SG</code> value of a sub-game greater than \(k\). But for this, the opposite can make the <code class="language-plaintext highlighter-rouge">SG</code> value be \(k\) definitely. Therefore when there is no move that makes the <code class="language-plaintext highlighter-rouge">SG</code> value of a sub-game greater, the one has to move like removing stones from a pile. You may prove this by a formal one if you like. Bur for most, this simple one is enough.</p> <h3 id="the-chain-game">The Chain Game</h3> <h4 id="description-7">Description</h4> <p>There is a chain with \(n\) nodes. You and your friend take turn to remove a node connected to any removed one or remove two connected nodes meeting any of them connected to a removed one. At first, any node can be removed. The one who can not move will lose.</p> <p>For example, if the length of the chain is \(6\). At first, there is no node removed, the first player can remove any one. Let the first player remove the third node. Now the chain is \(1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6\), then the second player can remove the one connected to the moved one, \(2\) or \(4\) can be removed, or remove two connected nodes meeting any of them connected to a removed one, \((1, 2)\) (\(2\) is connected with \(3\)) or \((4, 5)\) (\(4\) is connected with \(3\)) can be removed at same time.</p> <h4 id="solution-6">Solution</h4> <p>To solve the problem, we can define a new game:</p> <p>There is a pile of \(n\) stones. You and your friend take turn to remove a stone or two stones. The one who can not move will lose.</p> <p>We now define the original game as game A, and the new one as game B.</p> <p>For the game A, if we remove one node from the end of the chain at beginning, the game will change to the game B with \(n-1\) stones.</p> <p>If we remove one node from the middle of the chain at beginning, it will become two B games.</p> <p>If we define \(SG_A(n)\) as the <code class="language-plaintext highlighter-rouge">SG</code> value of the game A with \(n\) nodes, and \(SG_B(n)\) as the <code class="language-plaintext highlighter-rouge">SG</code> value of the game B with \(n\) stones, then we have the following:</p> \[SG_A(n) = mex(\{SG_B(n-1),\ SG_B(1) \oplus SG_B(n - 2),\ SG_B(2) \oplus SG_B(n - 3),\ \dots,\ SG_B(\lfloor \frac{n}{2} \rfloor) \oplus SG_B(n - 1 - \lfloor \frac{n}{2} \rfloor)\})\] </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/question-and-answer/">Q&amp;A</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/blink-cmp-git-contribution/">Contributing to blink-cmp-git</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/gcs-deploy/">gcs 部署</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/ieeextreme-18-solution/">IEEE Xtreme 18.0 题解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/marathon-4-hours-preparation/">马拉松 4 小时挑战记录</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Kaiser-Yang/Kaiser-Yang.github.io","data-repo-id":"R_kgDOMlCR5A","data-category":"Announcements","data-category-id":"DIC_kwDOMlCR5M4ChxBw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-input-position":"top","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Kaiser Yang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: May 18, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"post-q-amp-a",title:"Q&amp;A",description:"Some questions that I have encountered in my work.",section:"Posts",handler:()=>{window.location.href="/blog/2025/question-and-answer/"}},{id:"post-contributing-to-blink-cmp-git",title:"Contributing to blink-cmp-git",description:"A guide to adding support for new Git hosting services in blink-cmp-git.",section:"Posts",handler:()=>{window.location.href="/blog/2025/blink-cmp-git-contribution/"}},{id:"post-gcs-\u90e8\u7f72",title:"gcs \u90e8\u7f72",description:"\u4e3b\u8981\u4ecb\u7ecd\u5982\u4f55\u90e8\u7f72 `gcs`\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-deploy/"}},{id:"post-ieee-xtreme-18-0-\u9898\u89e3",title:"IEEE Xtreme 18.0 \u9898\u89e3",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/ieeextreme-18-solution/"}},{id:"post-\u9a6c\u62c9\u677e-4-\u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",title:"\u9a6c\u62c9\u677e 4 \u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/marathon-4-hours-preparation/"}},{id:"post-ssh-port-forwarding",title:"SSH Port Forwarding",description:"This post introduces the three types of SSH port forwarding.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ssh-port-forwarding/"}},{id:"post-\u670d\u52a1\u5668\u4e0a\u521b\u5efa-git-\u8fdc\u7a0b\u4ed3\u5e93",title:"\u670d\u52a1\u5668\u4e0a\u521b\u5efa git \u8fdc\u7a0b\u4ed3\u5e93",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/create-git-remote-repository-on-server/"}},{id:"post-spring-boot-test-\u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",title:"Spring Boot Test \u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-boot-test-custom-test-class-order/"}},{id:"post-spring-\u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",title:"Spring \u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-read-request-body-multiple-times/"}},{id:"post-long-\u5728-swagger-\u4e2d\u7cbe\u5ea6\u4e22\u5931",title:"Long \u5728 Swagger \u4e2d\u7cbe\u5ea6\u4e22\u5931",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/long-precision-lost-in-swagger/"}},{id:"post-spring-validation-\u8def\u5f84\u53d8\u91cf\u4e0e\u8bf7\u6c42\u53c2\u6570\u6821\u9a8c",title:"Spring Validation \u8def\u5f84\u53d8\u91cf\u4e0e\u8bf7\u6c42\u53c2\u6570\u6821\u9a8c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-path-variable-and-request-param/"}},{id:"post-linux-\u5927\u6742\u70e9",title:"Linux \u5927\u6742\u70e9",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/linux-potpourri/"}},{id:"post-spring-validation-\u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",title:"Spring-Validation \u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-custom-error-code/"}},{id:"post-jjwt-spring-filter-\u5b9e\u73b0-token-\u9a8c\u8bc1",title:"JJWT + Spring Filter \u5b9e\u73b0 Token \u9a8c\u8bc1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/filter-jjwt-intro/"}},{id:"post-spring-filter-\u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",title:"Spring Filter \u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/exception-handler-intro/"}},{id:"post-\u4f7f\u7528-spring-validation-\u8fdb\u884c\u6570\u636e\u6821\u9a8c",title:"\u4f7f\u7528 Spring-Validation \u8fdb\u884c\u6570\u636e\u6821\u9a8c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-intro/"}},{id:"post-python-\u9ad8\u7ea7\u6280\u5de7\u5b66\u4e60",title:"Python \u9ad8\u7ea7\u6280\u5de7\u5b66\u4e60",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-advanced-skills/"}},{id:"post-\u4f7f\u7528-spring-doc-\u751f\u6210\u63a5\u53e3\u6587\u6863",title:"\u4f7f\u7528 Spring-Doc \u751f\u6210\u63a5\u53e3\u6587\u6863",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-doc-intro/"}},{id:"post-mybatis-plus-\u7b80\u4ecb",title:"MyBatis-Plus \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mybatis-plus-intro/"}},{id:"post-spring-mvc-\u7b80\u4ecb",title:"Spring MVC \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-mvc-intro/"}},{id:"post-mock-mvc-\u7b80\u4ecb",title:"Mock Mvc \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mock-mvc-intro/"}},{id:"post-spring-\u7b80\u4ecb",title:"Spring \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-intro/"}},{id:"post-gcs-back-end-v0-1-0-\u5f00\u53d1\u5b9e\u5f55",title:"gcs-back-end v0.1.0 \u5f00\u53d1\u5b9e\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/gcs-back-end-v0.1.0/"}},{id:"post-\u5728-nvim-\u4e2d\u4f7f\u7528-rime-ls-\u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",title:"\u5728 nvim \u4e2d\u4f7f\u7528 rime-ls \u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/nvim-input-method/"}},{id:"post-a-brief-introduction-of-game-theory",title:"A Brief Introduction of Game Theory",description:"This post introduce some simple examples of game theory.",section:"Posts",handler:()=>{window.location.href="/blog/2024/game-theory/"}},{id:"post-c-value-categories-references-move-semantics-and-perfect-forwarding",title:"C++ Value Categories, References, Move Semantics and Perfect Forwarding",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/value-categories-cpp/"}},{id:"news-working-on-gcs-back-end-https-github-com-cmipt-gcs-back-end",title:"Working on [gcs-back-end](https://github.com/CMIPT/gcs-back-end).",description:"",section:"News"},{id:"projects-gcs-back-end",title:"gcs-back-end",description:"",section:"Projects",handler:()=>{window.location.href="/projects/gcs-back-end/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6B%61%69%73%65%72%71%7A%79%75%65@%66%6F%78%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Kaiser-Yang","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>