<!DOCTYPE html> <html lang="zh"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++ Multi-threading | Kaiser's Homepage </title> <meta name="author" content="Kaiser Yang"> <meta name="description" content="This post introduces the C++ multi-threading library and its usage."> <meta name="keywords" content="C/C++, Java, Python"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kaiser-yang.github.io/blog/2023/cpp-multi-thread/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Kaiser's Homepage </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">Ctrl K <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main" style="min-width: 60%;"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++ Multi-threading</h1> <p class="post-meta"> Created in December 12, 2023 , last updated in May 22, 2025 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/english-posts"> <i class="fa-solid fa-hashtag fa-sm"></i> English Posts</a>   ·   <a href="/blog/category/c-c"> <i class="fa-solid fa-tag fa-sm"></i> C/C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="forward">Forward</h2> <p>Before <code class="language-plaintext highlighter-rouge">C++11</code>, we must use the operating system’s interface (such as <code class="language-plaintext highlighter-rouge">pthread</code> in <code class="language-plaintext highlighter-rouge">Linux</code>) to implement multi-threading, which is not cross-platform. Since <code class="language-plaintext highlighter-rouge">C++11</code>, the <code class="language-plaintext highlighter-rouge">std</code> library has provided support for multi-threading, so we only need to write the code once for different operating systems.</p> <p>In this post, we will record the new features since <code class="language-plaintext highlighter-rouge">C++11</code>. Those below are included:</p> <ul> <li><code class="language-plaintext highlighter-rouge">std::function</code></li> <li><code class="language-plaintext highlighter-rouge">std::result_of / std::invoke_result</code></li> <li><code class="language-plaintext highlighter-rouge">std::bind</code></li> <li><code class="language-plaintext highlighter-rouge">std::thread</code></li> <li><code class="language-plaintext highlighter-rouge">std::packaged_task</code></li> <li><code class="language-plaintext highlighter-rouge">std::future</code></li> <li><code class="language-plaintext highlighter-rouge">std::promise</code></li> <li><code class="language-plaintext highlighter-rouge">std::shared_future</code></li> <li><code class="language-plaintext highlighter-rouge">std::async</code></li> <li><code class="language-plaintext highlighter-rouge">std::mutex</code></li> <li><code class="language-plaintext highlighter-rouge">std::timed_mutex</code></li> <li><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code></li> <li><code class="language-plaintext highlighter-rouge">std::recursive_timed_mutex</code></li> <li><code class="language-plaintext highlighter-rouge">std::shared_mutex</code></li> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code></li> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code></li> <li><code class="language-plaintext highlighter-rouge">std::shared_lock</code></li> <li><code class="language-plaintext highlighter-rouge">std::try_lock</code></li> <li><code class="language-plaintext highlighter-rouge">std::lock</code></li> <li><code class="language-plaintext highlighter-rouge">std::condition_variable</code></li> <li><code class="language-plaintext highlighter-rouge">std::counting_semaphore / std::binary_semaphore</code></li> </ul> <p><strong>NOTE</strong>: Unless otherwise noted, all methods and types are supported since <code class="language-plaintext highlighter-rouge">C++11</code>.</p> <h2 id="functions">Functions</h2> <h3 id="use-stdfunction-to-replace-function-pointers">Use <code class="language-plaintext highlighter-rouge">std::function</code> to Replace Function Pointers</h3> <p>With <code class="language-plaintext highlighter-rouge">std::function</code>, we can replace function pointers and <code class="language-plaintext highlighter-rouge">typedef</code> or <code class="language-plaintext highlighter-rouge">using</code> to define a function type:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">using</span> <span class="n">CallbackFunction</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">CallbackFunction</span> <span class="n">cb1</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
<span class="c1">// using std::function has the same effects.</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cb2</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
<span class="n">cb1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">cb2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div> <p>We can use <code class="language-plaintext highlighter-rouge">std::function</code> to receive the callback function, which is more flexible than function pointers:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Args</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are some examples of using <code class="language-plaintext highlighter-rouge">std::function</code>:</p> <ul> <li>Using <code class="language-plaintext highlighter-rouge">std::function</code> to implement a recursive function inside an anonymous function;</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">factorial</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">fac</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="c1">// this doesn't work, cause it cannot get &amp;fac1 in itself.        </span>
    <span class="c1">// auto fac1 = [&amp;](int n) { return (n &lt; 2) ? 1 : n * fac1(n - 1); };</span>
    <span class="k">return</span> <span class="nf">fac</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li>Binding a member function to <code class="language-plaintext highlighter-rouge">std::function</code>:</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">num_</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">print_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">num_</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">num_</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f_add_display</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">print_add</span><span class="p">;</span>
<span class="n">Foo</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">314159</span><span class="p">);</span>
<span class="n">f_add_display</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// same as foo.print_add(1);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">num_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 314160</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">copy_f_add_display</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">print_add</span><span class="p">;</span>
<span class="n">copy_f_add_display</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// same as Foo(foo).print_add(1);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">num_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 314160</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ptr_f_add_display</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">print_add</span><span class="p">;</span>
<span class="n">ptr_f_add_display</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// same as (&amp;foo)-&gt;print_add(1);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">num_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 314161</span>
</code></pre></div></div> <p><strong>NOTE</strong>: In the code above, if the first parameter is a reference or pointer, the operation is performed on the original object. If the first parameter is not a reference or pointer, a copy constructor is used to bind the object to the parameter.</p> <ul> <li>Binding a member variable to <code class="language-plaintext highlighter-rouge">std::function</code> to get the value of the member variable:</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f_num</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">num_</span><span class="p">;</span>
<span class="n">f_num</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// same as foo.num_, but f_num(foo) is a rvalue, rather than lvalue;</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">copy_f_num</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">num_</span><span class="p">;</span>
<span class="n">copy_f_num</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// same as Foo(foo).num_, but copy_f_num(foo) is a rvalue, rather than lvalue;</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ptr_f_num</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">num_</span><span class="p">;</span>
<span class="n">ptr_f_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span> <span class="c1">// same as (&amp;foo)-&gt;num_, but copy_f_num(foo) is a rvalue, rather than lvalue;</span>
</code></pre></div></div> <p><strong>NOTE</strong>: In the code above, you should also note the difference between the first parameter type being a reference or pointer and not being a reference or pointer. And you should also note that if the return value is defined as a non-reference, the result is an rvalue; when the return value is defined as a reference type, the result is an lvalue.</p> <h3 id="use-stdresult_of-or-stdinvoke_result-to-get-the-return-type-of-a-function">Use <code class="language-plaintext highlighter-rouge">std::result_of</code> or <code class="language-plaintext highlighter-rouge">std::invoke_result</code> to Get the Return Type of a Function</h3> <p><code class="language-plaintext highlighter-rouge">std::result_of&lt;F(Args...)&gt;</code> is deprecated in <code class="language-plaintext highlighter-rouge">C++17</code> and removed in <code class="language-plaintext highlighter-rouge">C++20</code>. <code class="language-plaintext highlighter-rouge">std::invoke_result&lt;F, Args...&gt;</code> will replace it.</p> <p>From <code class="language-plaintext highlighter-rouge">cppreference</code>, the main reason for deprecating <code class="language-plaintext highlighter-rouge">std::result_of</code> is that when the template passed in is not a callable type, <code class="language-plaintext highlighter-rouge">std::result_of</code>’s behavior is undefined; <code class="language-plaintext highlighter-rouge">std::invoke_result</code> will use a SFINAE rather than an UB. Besides, <code class="language-plaintext highlighter-rouge">std::result_of</code> has some strange characteristics in some cases:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">F</code> can not be a function type or an array type (but can be a reference to them);</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="c1">// You can not use the function type directly, but this is OK in `std::invoke_result`</span>
<span class="c1">// std::result_of&lt;decltype(test)(int, int)&gt;::type a;</span>
<span class="c1">// This is OK</span>
<span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div> <ul> <li>Array as a parameter or return type will be converted to a pointer;</li> <li>The types of return value or parameters cannot be abstract classes;</li> <li>Top-level <code class="language-plaintext highlighter-rouge">const</code> and <code class="language-plaintext highlighter-rouge">volatile</code> qualifiers will be discarded;</li> <li>The parameter type cannot be <code class="language-plaintext highlighter-rouge">void</code>;</li> </ul> <p>Those below are some examples of <code class="language-plaintext highlighter-rouge">std::result_of</code> and <code class="language-plaintext highlighter-rouge">std::invoke_result</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">),</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// since C++ 17</span>
<span class="c1">// or</span>
<span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// since C++ 17</span>
<span class="c1">// a, b, and c are all int.</span>

<span class="c1">// Using invoke_of in template function, we must using &amp;&amp; to get the type.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">test1</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="c1">// Same effects with decltype</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">test2</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="c1">// When parameter is std::funciton</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">test3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="c1">// When parameter is std::funciton and using decltype</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">test4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">test1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">test2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">test3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{</span><span class="n">x</span><span class="p">});</span>
<span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="n">test4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{</span><span class="n">x</span><span class="p">});</span>
</code></pre></div></div> <h3 id="stdbind"><code class="language-plaintext highlighter-rouge">std::bind</code></h3> <p><code class="language-plaintext highlighter-rouge">std::bind</code> is used to give a function an alias or redefine the order of function parameters and default values.</p> <p>For example, we have the following function:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do someting...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">sdt</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div> <p>In some cases, we may need to pass in default values, so the function may be written in the following form:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">sdt</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// this is OK, it is same with func(1, 2, 3);</span>
</code></pre></div></div> <p>In some cases, we may need use <code class="language-plaintext highlighter-rouge">func</code> as <code class="language-plaintext highlighter-rouge">func(1, x, y)</code> frequently, but the default parameter can only appear after the non-default parameter. In this case, we need to change the order of the parameters. So we may need to redefine a function:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// func(int, int) and func(int, int, int = 3) are same, </span>
<span class="c1">// so we need convert to make sure the call unambiguous.</span>
<span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">func</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div> <p>The above code is a little bit ugly, and every time we call it, we need to convert it. If we only need use <code class="language-plaintext highlighter-rouge">func(1, x, y)</code> in a certain scope, using <code class="language-plaintext highlighter-rouge">std::bind</code> is a better choice:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span> <span class="c1">// this if for placeholders: _1 and _2</span>
<span class="k">auto</span> <span class="n">newFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">newFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// this is same with func(1, x, y);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">_1</code> and <code class="language-plaintext highlighter-rouge">_2</code> are the placeholders for the parameters. <code class="language-plaintext highlighter-rouge">_1</code> is for the first actual parameter, and <code class="language-plaintext highlighter-rouge">_2</code> is for the second actual parameter. There is an example to show different order of the parameters:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">newFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_1</span><span class="p">);</span> <span class="c1">// this will call func(1, _2, _1);</span>
<span class="n">newFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// this is same with func(1, y, x); because y is _2 and x is _1.</span>
</code></pre></div></div> <p>The return value can be assigned to <code class="language-plaintext highlighter-rouge">std::function</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the template parameter is decided by the return type of func and the num of placehoders.</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">newFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">newFunc2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_3</span><span class="p">);</span>
</code></pre></div></div> <p>When the parameters are reference types, we need to use <code class="language-plaintext highlighter-rouge">std::ref</code> or <code class="language-plaintext highlighter-rouge">std::cref</code> (for constant reference types) to wrap the parameters. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">modifyA</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">badFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">modifyA</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="n">badFunc</span><span class="p">();</span> <span class="c1">// After this, a will be still 0.</span>
<span class="k">auto</span> <span class="n">goodFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">modifyA</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="n">goodFunc</span><span class="p">();</span> <span class="c1">// After this, a will become -1.</span>
</code></pre></div></div> <p>The above examples can also be implemented with lambda functions:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">newFunc</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">newFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// Same with func(1, x, y);</span>

<span class="k">auto</span> <span class="n">anotherGoodFunc</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">modifyA</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">anotherGoodFunc</span><span class="p">();</span> <span class="c1">// After this, a is -1.</span>
</code></pre></div></div> <h2 id="multi-threading">Multi-threading</h2> <h3 id="stdthread"><code class="language-plaintext highlighter-rouge">std::thread</code></h3> <p><code class="language-plaintext highlighter-rouge">std::thread</code> is very easy to use, you only need to pass a callable object and the parameters:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t1</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// t1 is another thread running func(1, 2, 3);</span>
<span class="c1">// t2 is another thread running a lambda function.</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t2</span><span class="p">([]()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello Thread!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">});</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">std::thread::join</code> is to wait for the thread to finish. Without <code class="language-plaintext highlighter-rouge">join</code>, the thread will be killed when the main thread finished. Using join is to make the main thread wait for the threads finish.</p> <p>Since <code class="language-plaintext highlighter-rouge">C++20</code>, you can use <code class="language-plaintext highlighter-rouge">std::jthread</code>, which will call <code class="language-plaintext highlighter-rouge">join</code> automatically.</p> <p>There is another important function called <code class="language-plaintext highlighter-rouge">detach</code> of <code class="language-plaintext highlighter-rouge">std::thread</code>, which makes the thread run independently. Using <code class="language-plaintext highlighter-rouge">detach</code> can make resounds released timely. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">daemonFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// do something...</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">oneThreadFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">integerP</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="mf">8e6</span><span class="p">]);</span> <span class="c1">// big data here</span>
    <span class="c1">// do something...</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">daemonT</span><span class="p">(</span><span class="n">daemonFunc</span><span class="p">);</span>
    <span class="n">daemonT</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    <span class="c1">// if we use daemonT.join() rather than daemonT.detach() to make sure daemonT finish, </span>
    <span class="c1">// the integerP will be released after the daemonT thread.</span>
<span class="p">}</span> <span class="c1">// integerP is released after this function.</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t1</span><span class="p">(</span><span class="n">oneThreadFunc</span><span class="p">);</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>In the destructor of <code class="language-plaintext highlighter-rouge">std::thread</code>, <code class="language-plaintext highlighter-rouge">std::terminate</code> is called if:</p> <ul> <li>the thread was not joined (with <code class="language-plaintext highlighter-rouge">join()</code>);</li> <li>or the thread was not detached (with <code class="language-plaintext highlighter-rouge">detach()</code>).</li> </ul> <p>Thus, you should always either <code class="language-plaintext highlighter-rouge">join</code> or <code class="language-plaintext highlighter-rouge">detach</code> the thread before it goes out of scope.</p> <p>You should be careful with <code class="language-plaintext highlighter-rouge">detach</code>. When you detach a thread, and the main thread may finish before the detached thread, which will cause the shared data to be released before the detached thread finish. Using the released shared data in the detached thread may cause an UB. Therefore, using <code class="language-plaintext highlighter-rouge">std::thread::detach()</code> is not recommended.</p> <h3 id="stdpackaged_task"><code class="language-plaintext highlighter-rouge">std::packaged_task</code></h3> <p>The creation of <code class="language-plaintext highlighter-rouge">std::packaged_task</code> is very similar with <code class="language-plaintext highlighter-rouge">std::function</code>.</p> <p><code class="language-plaintext highlighter-rouge">std::thread</code> is very useful, but what if we need to handle the return value of a multi-thread function?</p> <p>We can implement this without <code class="language-plaintext highlighter-rouge">std::packaged_task</code>. We just need to create a shared variable, and set the variable to the return value of the function when the thread function ends. However, this implementation often requires the use of condition variables or locks. When we need to consider locks, the program often becomes complex. Our requirement is very simple: to get the return value of a multi-thread function. Can we implement this without the programmer managing the locks?</p> <p>For a function with a return value, we can bind it to <code class="language-plaintext highlighter-rouge">std::packaged_task</code>, and then get the <code class="language-plaintext highlighter-rouge">std::future</code> object through <code class="language-plaintext highlighter-rouge">std::packaged_task::get_future</code>. After that, we bind the <code class="language-plaintext highlighter-rouge">std::packaged_task</code> to a thread, and when we call <code class="language-plaintext highlighter-rouge">std::future::get</code>, the main thread will wait for the thread to finish, and we can get the return value of the thread function. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">threadTask</span><span class="p">{</span><span class="n">threadFunc</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">threadTask</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">threadTask</span><span class="p">)};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>In the code above, we must use <code class="language-plaintext highlighter-rouge">t.join()</code> even if the thread function has returned. This is because when the function returns, we can use <code class="language-plaintext highlighter-rouge">std::future::get</code> to get the value, but the thread may not have completely stopped (it may be releasing resources).</p> <p><code class="language-plaintext highlighter-rouge">std::future</code> also can be used in a single-threaded program:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">threadTask</span><span class="p">{</span><span class="n">threadFunc</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">threadTask</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="c1">// run it in the main thread</span>
<span class="n">threadTask</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 0</span>

<span class="c1">// same implementation:</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">{</span><span class="n">threadFunc</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 0</span>
</code></pre></div></div> <h3 id="stdpromise"><code class="language-plaintext highlighter-rouge">std::promise</code></h3> <p><code class="language-plaintext highlighter-rouge">std::promise</code> is used to pass a value (of any type). Through <code class="language-plaintext highlighter-rouge">set_value</code>, we can set the value, and through <code class="language-plaintext highlighter-rouge">get_future</code>, we can get the <code class="language-plaintext highlighter-rouge">std::future</code> object. Similarly, when we call <code class="language-plaintext highlighter-rouge">std::future::get</code>, the thread will be blocked until the value is set.</p> <p>The functionality of <code class="language-plaintext highlighter-rouge">std::promise</code> can be implemented with condition variables, but using <code class="language-plaintext highlighter-rouge">std::promise</code> can simplify the code in some scenarios. Also, we don’t need to manually lock or unlock.</p> <p>The example from <code class="language-plaintext highlighter-rouge">cppreference</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">acc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// Notify future</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">do_work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">barrier</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">barrier</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">work_thread</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">accumulate_promise</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result="</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// wait for thread completion</span>

    <span class="c1">// For void we can use this as a barrier</span>
    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">barrier</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">barrier_future</span> <span class="o">=</span> <span class="n">barrier</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">new_work_thread</span><span class="p">(</span><span class="n">do_work</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">barrier</span><span class="p">));</span>
    <span class="n">barrier_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="n">new_work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="stdshared_future"><code class="language-plaintext highlighter-rouge">std::shared_future</code></h3> <p><code class="language-plaintext highlighter-rouge">std::shared_future</code> is a wrapper for <code class="language-plaintext highlighter-rouge">std::future</code>. It allows multiple threads to access the return value of a function through <code class="language-plaintext highlighter-rouge">get</code>.</p> <p>For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">ready</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{[</span><span class="n">sf</span><span class="p">]()</span> <span class="p">{</span> <span class="n">sf</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread 1 has started</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}};</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">{[</span><span class="n">sf</span><span class="p">]()</span> <span class="p">{</span> <span class="n">sf</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread 2 has started</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}};</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">{[</span><span class="n">sf</span><span class="p">]()</span> <span class="p">{</span> <span class="n">sf</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread 3 has started</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}};</span> 
<span class="c1">// sf.wait() and sf.get() are the same here.</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mx">2000ms</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Finish Some Preparation.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// This line will be output first.</span>
<span class="n">ready</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</code></pre></div></div> <h3 id="stdasync"><code class="language-plaintext highlighter-rouge">std::async</code></h3> <p><code class="language-plaintext highlighter-rouge">std::async</code> is a high-level interface for multi-threading. <code class="language-plaintext highlighter-rouge">std::async</code> is a function that can be used to run a function asynchronously. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">threadFunc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// Don't forget the std::ref to make it pass as a reference.</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> 
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">std::async</code> also supports lazy execution, which means that the thread will only start executing when <code class="language-plaintext highlighter-rouge">std::future::wait</code> or <code class="language-plaintext highlighter-rouge">std::future::get</code> is called. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread is running...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span> <span class="n">threadFunc</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mx">2000ms</span><span class="p">);</span>
<span class="n">result</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// threadFunc starts to run.</span>
</code></pre></div></div> <h2 id="locks">Locks</h2> <p>All the locks introduced below are <strong>unfair locks</strong>, which means that the blocked processes do not acquire the lock in the order they were blocked.</p> <h3 id="stdmutex"><code class="language-plaintext highlighter-rouge">std::mutex</code></h3> <p><code class="language-plaintext highlighter-rouge">std::mutex</code> can only be acquired by one thread at any time. It is very easy to use:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="c1">// do something.</span>
<span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">std::mutex::lock</code> will block current thread, if it can not acquire the lock. Use <code class="language-plaintext highlighter-rouge">std::mutex::try_lock</code> will not block current thread, but return <code class="language-plaintext highlighter-rouge">false</code> when the lock has been acquired by another thread:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mu</span><span class="p">.</span><span class="n">try_lock</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// do something... </span>
    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"failed to get mutex</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="stdtimed_mutex"><code class="language-plaintext highlighter-rouge">std::timed_mutex</code></h3> <p><code class="language-plaintext highlighter-rouge">std::mutex::try_lock</code> only tries to acquire the lock once. In many cases, we want to keep trying to acquire the lock for a period of time. <code class="language-plaintext highlighter-rouge">std::timed_mutex</code> can achieve this. <code class="language-plaintext highlighter-rouge">std::timed_mutex</code> is very similar to <code class="language-plaintext highlighter-rouge">std::mutex</code>, the only difference is that <code class="language-plaintext highlighter-rouge">std::timed_mutex</code> provides <code class="language-plaintext highlighter-rouge">std::timed_mutex::try_lock_for</code> and <code class="language-plaintext highlighter-rouge">std::timed_mutex::try_lock_until</code> to decide how long to try to acquire the lock. When the lock is acquired within the specified time, it returns <code class="language-plaintext highlighter-rouge">true</code>, otherwise it returns <code class="language-plaintext highlighter-rouge">false</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">timed_mutex</span> <span class="n">t_mu</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">t_mu</span><span class="p">.</span><span class="n">try_lock_for</span><span class="p">(</span><span class="mx">2000ms</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// ... do something</span>
    <span class="n">t_mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to get lock in 2000ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>NOTE</strong>: <code class="language-plaintext highlighter-rouge">lock</code> and <code class="language-plaintext highlighter-rouge">try_lock</code> are still available in <code class="language-plaintext highlighter-rouge">std::timed_mutex</code>.</p> <h3 id="stdrecursive_mutex"><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code></h3> <p><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code> is a recursive lock, which means that the same thread can acquire the same lock multiple times. If you try to acquire a <code class="language-plaintext highlighter-rouge">std::mutex</code> that has already been acquired by the same thread, the thread will be blocked (this is a deadlock for a single thread). <code class="language-plaintext highlighter-rouge">std::recursive_mutex</code> is used in recursive situations:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span> <span class="n">r_mu</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">fabonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r_mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="c1">// using lock to make sure the cout will be outputting right.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"trying to get fabonacci("</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r_mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fabonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">fabonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span>  <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">r_mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Every time we call <code class="language-plaintext highlighter-rouge">fabonacci</code>, we need to acquire the lock, and when we return from the function, we need to release the lock, which is not meet the <code class="language-plaintext highlighter-rouge">RAII</code> principle.</p> <h3 id="stdrecursive_timed_mutex"><code class="language-plaintext highlighter-rouge">std::recursive_timed_mutex</code></h3> <p><code class="language-plaintext highlighter-rouge">std::recursive_timed_mutex</code> is a recursive lock with time-out. It is very similar to <code class="language-plaintext highlighter-rouge">std::timed_mutex</code>, and the usage is similar with <code class="language-plaintext highlighter-rouge">std::timed_mutex</code>.</p> <h3 id="stdshared_mutex"><code class="language-plaintext highlighter-rouge">std::shared_mutex</code></h3> <p><code class="language-plaintext highlighter-rouge">std::shared_mutex</code> is introduced in <code class="language-plaintext highlighter-rouge">C++17</code>.</p> <p><code class="language-plaintext highlighter-rouge">std::shared_mutex</code> is like read-write lock. It allows multiple threads to read at the same time, but only one thread can write at a time. When a thread is writing, no other threads can read or write (<code class="language-plaintext highlighter-rouge">std::shared_mutex::lock</code>). When a thread is reading, other threads can read (<code class="language-plaintext highlighter-rouge">std::shared_mutex::shared_lock</code>) but not write.</p> <p>We can use <code class="language-plaintext highlighter-rouge">std::shared_mutex::lock</code> to implement the produce-consume model.</p> <p>The example from <code class="language-plaintext highlighter-rouge">cppreference</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ThreadSafeCounter</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ThreadSafeCounter</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// Multiple threads/readers can read the counter's value at the same time.</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="c1">// Only one thread/writer can increment/write the counter's value.</span>
    <span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="o">++</span><span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="c1">// Only one thread/writer can reset/write the counter's value.</span>
    <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
 
<span class="k">private</span><span class="o">:</span>
    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">mutex_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value_</span><span class="p">{};</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ThreadSafeCounter</span> <span class="n">counter</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">increment_and_print</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">{};</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
            <span class="n">std</span><span class="o">::</span><span class="n">osyncstream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> 
                <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// this osyncstream is since C++ 20.</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">thread1</span><span class="p">(</span><span class="n">increment_and_print</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">thread2</span><span class="p">(</span><span class="n">increment_and_print</span><span class="p">);</span>
    <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="writer-starvation">Writer Starvation</h4> <p>There is an important point to note when using <code class="language-plaintext highlighter-rouge">std::shared_mutex</code>. When a write thread is blocked by a read thread that has acquired <code class="language-plaintext highlighter-rouge">lock_shared</code>, and during this time, if there are many other read threads that acquire <code class="language-plaintext highlighter-rouge">lock_shared</code> to perform read operations, the write thread must wait for all read threads to finish their operations and release all read locks before it can acquire the write lock. This can cause serious delays in write operations. The reason for this is that all <code class="language-plaintext highlighter-rouge">C++</code> locks are unfair locks.</p> <p>One simple solution is to add a <code class="language-plaintext highlighter-rouge">std::mutex</code>. Regardless of whether it is a read operation or a write operation, before acquiring the lock, we need to acquire this <code class="language-plaintext highlighter-rouge">std::mutex</code>. At the same time, after acquiring the read lock (or write lock), we release this <code class="language-plaintext highlighter-rouge">std::mutex</code>. This ensures that the read thread and write thread will first compete for the unique lock before acquiring the shared lock. This way, we can ensure that the semantics are not violated while preventing writer starvation. However, this will add some overhead.</p> <h3 id="raii">RAII</h3> <p>RAII is a C++ programming idiom that binds the lifecycle of a resource to the lifetime of an object. In other words, when an object is created, the resource is acquired, and when the object is destroyed, the resource is released.</p> <p>In C++, the most common example of RAII is the use of smart pointers. When a smart pointer is created, it acquires the resource (memory), and when the smart pointer is destroyed, it releases the resource (memory).</p> <p>In multi-threading development, when we successfully acquire a lock, we also need to release the lock through <code class="language-plaintext highlighter-rouge">unlock</code>. This does not conform to the RAII principle. Therefore, <code class="language-plaintext highlighter-rouge">std</code> provides some types and methods that can automatically release the lock when the destructor is called.</p> <h4 id="stdlock_guard"><code class="language-plaintext highlighter-rouge">std::lock_guard</code></h4> <p><code class="language-plaintext highlighter-rouge">std::lock_guard</code> can bind to any object that has <code class="language-plaintext highlighter-rouge">lock</code> and <code class="language-plaintext highlighter-rouge">unlock</code> methods. When the object is created, it acquires the lock, and when the object is destroyed, it releases the lock. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span> <span class="n">lg</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="c1">// acquire the lock</span>
    <span class="c1">// do something...</span>
<span class="p">}</span> <span class="c1">// there is no need to unlock</span>
</code></pre></div></div> <h4 id="stdunique_lock"><code class="language-plaintext highlighter-rouge">std::unique_lock</code></h4> <p><code class="language-plaintext highlighter-rouge">std::unique_lock</code> is a more flexible version of <code class="language-plaintext highlighter-rouge">std::lock_guard</code>. It can be used to bind to any object that has <code class="language-plaintext highlighter-rouge">lock</code> and <code class="language-plaintext highlighter-rouge">unlock</code> methods. When the object is created, it acquires the lock, and when the object is destroyed, it releases the lock. Besides, <code class="language-plaintext highlighter-rouge">std::unique_lock</code> can also use <code class="language-plaintext highlighter-rouge">lock</code> and <code class="language-plaintext highlighter-rouge">unlock</code> to acquire and release the lock after the object is created:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span> <span class="n">ul</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="c1">// acquire the lock</span>
    <span class="c1">// do something...</span>
    <span class="n">ul</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// we can unlock if we need this lock no more.</span>
    <span class="c1">// do something...</span>
    <span class="n">ul</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// we can lock if we need this lock again.</span>
<span class="p">}</span> <span class="c1">// there is no need to unlock</span>
</code></pre></div></div> <p>And <code class="language-plaintext highlighter-rouge">std::unique_lock</code> can also release the second parameter:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">std::adopt_lock</code>: The default behavior, when the object is created, it acquires the lock;</li> <li> <code class="language-plaintext highlighter-rouge">std::try_lock</code>: The object will try to acquire the lock when it is created; <code class="language-plaintext highlighter-rouge">std::unique_lock</code> overloads the <code class="language-plaintext highlighter-rouge">bool</code> operator, so we can use <code class="language-plaintext highlighter-rouge">if (ul)</code> to check whether the lock is acquired successfully;</li> <li> <code class="language-plaintext highlighter-rouge">std::defer_lock</code>: The object will not acquire the lock when it is created, but we can use <code class="language-plaintext highlighter-rouge">lock</code> to acquire the lock later. This is usually used with <code class="language-plaintext highlighter-rouge">std::lock</code> to achieve the effect of acquiring multiple locks at the same time.</li> </ul> <h4 id="stdshared_lock"><code class="language-plaintext highlighter-rouge">std::shared_lock</code></h4> <p><code class="language-plaintext highlighter-rouge">std::shared_lock</code> is supported since <code class="language-plaintext highlighter-rouge">C++14</code>.</p> <p><code class="language-plaintext highlighter-rouge">std::shared_lock</code> is used to bind to any object that has <code class="language-plaintext highlighter-rouge">lock_shared</code> and <code class="language-plaintext highlighter-rouge">unlock_shared</code> methods. When the object is created, it acquires the lock (call <code class="language-plaintext highlighter-rouge">lock_shared</code>), and when the object is destroyed, it releases the lock (call <code class="language-plaintext highlighter-rouge">unlock_shared</code>). This usually used with <code class="language-plaintext highlighter-rouge">std::shared_mutex</code>.</p> <p>It can also receive the second parameter, which is the same as <code class="language-plaintext highlighter-rouge">std::unique_lock</code>’s.</p> <h3 id="acquire-multiple-locks">Acquire Multiple Locks</h3> <h4 id="stdtry_lock"><code class="language-plaintext highlighter-rouge">std::try_lock</code></h4> <p><code class="language-plaintext highlighter-rouge">std::try_lock</code> is a function that accepts multiple lock objects that support <code class="language-plaintext highlighter-rouge">try_lock</code>. It tries to acquire multiple locks at the same time. If any of the <code class="language-plaintext highlighter-rouge">try_lock</code> calls fail, the other locks that have been successfully acquired will be released, and it will return the index of the failed lock (starting from <code class="language-plaintext highlighter-rouge">0</code>). If all <code class="language-plaintext highlighter-rouge">try_lock</code> calls succeed, it will return <code class="language-plaintext highlighter-rouge">-1</code>. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">try_lock</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something...</span>
    <span class="n">m1</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">m2</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// don't forget release the locks.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// m1 and m2 are not got by this thread.</span>
<span class="p">}</span>
</code></pre></div></div> <p>We must manually release the locks after using <code class="language-plaintext highlighter-rouge">std::try_lock</code>. We can also use <code class="language-plaintext highlighter-rouge">std::unique_lock</code> to bind <code class="language-plaintext highlighter-rouge">std::mutex</code>, then use <code class="language-plaintext highlighter-rouge">std::try_lock</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ul1</span><span class="p">{</span><span class="n">m1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">},</span> <span class="n">ul2</span><span class="p">{</span><span class="n">m2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">try_lock</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// do something...</span>
 <span class="c1">// no need to release the locks.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="c1">// m1 and m2 are not got by this thread.</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="stdlock"><code class="language-plaintext highlighter-rouge">std::lock</code></h4> <p><code class="language-plaintext highlighter-rouge">std::lock</code> is a function that accepts multiple lock objects that support <code class="language-plaintext highlighter-rouge">lock</code>. It tries to acquire multiple locks at the same time. If any of the <code class="language-plaintext highlighter-rouge">lock</code> calls fail, the other locks that have been successfully acquired will be released, and it will block until all locks are acquired.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span> <span class="c1">// get m1 and m2 at same time.</span>
<span class="c1">// do something...</span>
<span class="n">m1</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="n">m2</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// don't forget release the locks.</span>
</code></pre></div></div> <p>Similarly, we can also use <code class="language-plaintext highlighter-rouge">std::unique_lock</code> to bind <code class="language-plaintext highlighter-rouge">std::mutex</code>, then use <code class="language-plaintext highlighter-rouge">std::lock</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ul1</span><span class="p">{</span><span class="n">m1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">},</span> <span class="n">ul2</span><span class="p">{</span><span class="n">m2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span> <span class="c1">// get m1 and m2 at same time.</span>
<span class="c1">// do something...</span>
<span class="c1">// no need to release the locks.</span>
</code></pre></div></div> <h4 id="question">Question</h4> <p>Why is there no <code class="language-plaintext highlighter-rouge">std::lock_shared</code> to acquire multiple shared locks at the same time?</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">std::lock_shared</code> is not needed because <code class="language-plaintext highlighter-rouge">std::shared_mutex</code> is a read-write lock. When we acquire a shared lock, we can acquire multiple shared locks at the same time.</p> </blockquote> <h2 id="stdcondition_variable"><code class="language-plaintext highlighter-rouge">std::condition_variable</code></h2> <p>Condition variables should be used with locks. <code class="language-plaintext highlighter-rouge">std::condition_variable</code> supports <code class="language-plaintext highlighter-rouge">wait</code> and <code class="language-plaintext highlighter-rouge">notify</code> operations. When we call <code class="language-plaintext highlighter-rouge">wait</code>, it will block the current thread and release the lock associated with the condition variable. When we call <code class="language-plaintext highlighter-rouge">notify</code>, it will wake up the blocked thread. When the thread is woken up, it will reacquire the lock that was released during <code class="language-plaintext highlighter-rouge">wait</code>. If the lock is already acquired by another thread, the thread will be blocked until it successfully acquires the lock.</p> <p>There is an example to show how to use <code class="language-plaintext highlighter-rouge">std::condition_variable</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">acc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">locker</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span> <span class="c1">// we usually use notify_all, cause we don't know who are waiting.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">work_thread</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">locker</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">locker</span><span class="p">,</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;});</span> <span class="c1">// wait until sum != -1;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>When using <code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>, we usually use <code class="language-plaintext highlighter-rouge">notify_all</code> to wake up all blocked threads. This is because we don’t know which threads are waiting and for what are they waiting. When we wake up all blocked threads, the threads that do not meet the exit condition of <code class="language-plaintext highlighter-rouge">wait</code> will be blocked again. At the same time, it is worth noting that <code class="language-plaintext highlighter-rouge">wait</code> will first check whether the exit condition is met, rather than blocking first and then waking up to check again, which means if the condition is met when <code class="language-plaintext highlighter-rouge">wait</code> is called, the thread will not be blocked.</p> <h4 id="question-1">Question</h4> <p>We must acquire the lock before calling <code class="language-plaintext highlighter-rouge">wait</code>, and do we need to acquire the lock before calling <code class="language-plaintext highlighter-rouge">notify</code>?</p> <blockquote> <p>It depends on the situation. In most cases, we need to acquire the lock before calling <code class="language-plaintext highlighter-rouge">notify</code> because we often need to modify the value of the shared variable. However, sometimes we may not need to modify the value of the shared variable before calling <code class="language-plaintext highlighter-rouge">notify</code>, so we can skip acquiring the lock. In other words, the lock is not associated with <code class="language-plaintext highlighter-rouge">notify</code>. Whether we need to acquire the lock is determined by whether we need to modify the shared variable, not by whether we need to call <code class="language-plaintext highlighter-rouge">notify</code>. The code below works well:</p> </blockquote> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">acc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">locker</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">locker</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span> <span class="c1">// we can notify without any locks.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">work_thread</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">locker</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">locker</span><span class="p">,</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;});</span> <span class="c1">// wait until sum != -1;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="stdcounting_semaphore--stdbinary_semaphore"><code class="language-plaintext highlighter-rouge">std::counting_semaphore / std::binary_semaphore</code></h2> <p><code class="language-plaintext highlighter-rouge">std::counting_semaphore</code> and <code class="language-plaintext highlighter-rouge">std::binary_semaphore</code> are introduced in <code class="language-plaintext highlighter-rouge">C++20</code>. <code class="language-plaintext highlighter-rouge">std::counting_semaphore</code> is a counting semaphore, which can be used to control the number of threads that can access a resource at the same time. <code class="language-plaintext highlighter-rouge">std::binary_semaphore</code> is a binary semaphore, which is a special case of <code class="language-plaintext highlighter-rouge">std::counting_semaphore</code> with a maximum count of <code class="language-plaintext highlighter-rouge">1</code>. <code class="language-plaintext highlighter-rouge">std::binary_semaphore</code> is the same as <code class="language-plaintext highlighter-rouge">std::counting_semaphore&lt;1&gt;</code>.</p> <p>You can use <code class="language-plaintext highlighter-rouge">std::counting_semaphore::acquire</code>, <code class="language-plaintext highlighter-rouge">std::counting_semaphore::try_acquire</code>, <code class="language-plaintext highlighter-rouge">std::counting_semaphore::try_acquire_for</code> or <code class="language-plaintext highlighter-rouge">std::counting_semaphore::try_acquire_until</code> to acquire the semaphore. You can use <code class="language-plaintext highlighter-rouge">std::counting_semaphore::release</code> to release the semaphore.</p> <p>Every time you acquire the semaphore, the count will be decreased by <code class="language-plaintext highlighter-rouge">1</code>. When the count is <code class="language-plaintext highlighter-rouge">0</code>, the next thread that tries to acquire the semaphore will be blocked (or failed with try semantics). When you release the semaphore, the count will be increased by <code class="language-plaintext highlighter-rouge">1</code>, and if there are any threads waiting for the semaphore, they will be woken up and can acquire the semaphore.</p> <p>You should note that if the semaphore is already at its maximum count, calling <code class="language-plaintext highlighter-rouge">release</code> will be an UB.</p> <h2 id="example">Example</h2> <h3 id="control-the-sequence-of-threads">Control the Sequence of Threads</h3> <p>There are three threads: <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>, and <code class="language-plaintext highlighter-rouge">C</code>. Every thread will print its name for three times. How to control the sequence of the threads to print their names?</p> <ul> <li>Serialization. We hope get the output <code class="language-plaintext highlighter-rouge">AAABBBCCC</code>.</li> <li>Interlace. We hope get the output <code class="language-plaintext highlighter-rouge">ABCABCABC</code>.</li> <li>Start at same time.</li> <li>Start at same time for each turn.We hope there is only one <code class="language-plaintext highlighter-rouge">A</code>, one <code class="language-plaintext highlighter-rouge">B</code>, and one <code class="language-plaintext highlighter-rouge">C</code> for every three letters.</li> </ul> <p>For serialisation, we can use three <code class="language-plaintext highlighter-rouge">std::mutex</code> to implement:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">mC</span><span class="p">;</span>
<span class="n">mB</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="n">mC</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mB</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">mA</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// BUG:</span>
    <span class="c1">// Releasing locks acquired by other threads is an UB</span>
    <span class="n">mA</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">mB</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mC</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">mB</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// BUG:</span>
    <span class="c1">// Releasing locks acquired by other threads is an UB</span>
    <span class="n">mB</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">mC</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mC</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">mC</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// BUG:</span>
    <span class="c1">// Releasing locks acquired by other threads is an UB</span>
    <span class="n">mC</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>In the code above, <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">C</code> must acquire their locks to start. At very beginning, we lock <code class="language-plaintext highlighter-rouge">mB</code> and <code class="language-plaintext highlighter-rouge">mC</code> in the main thread, so only thread <code class="language-plaintext highlighter-rouge">A</code> can start. When <code class="language-plaintext highlighter-rouge">A</code> finishes, it will release <code class="language-plaintext highlighter-rouge">B</code>’s lock, so that <code class="language-plaintext highlighter-rouge">B</code> can start; When <code class="language-plaintext highlighter-rouge">B</code> finishes, it will release <code class="language-plaintext highlighter-rouge">C</code>’s lock, so that <code class="language-plaintext highlighter-rouge">C</code> can start. However, the code above has a bug: releasing locks acquired by other threads is an UB. We can re-implement it with <code class="language-plaintext highlighter-rouge">std::counting_semaphore</code> (since <code class="language-plaintext highlighter-rouge">C++20</code>):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Same with std::counting_semaphore&lt;1&gt; semA(1), semB(0), semC(0);</span>
<span class="n">std</span><span class="o">::</span><span class="n">binary_semaphore</span> <span class="nf">semA</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">semB</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">semC</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semB</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">semA</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">semB</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semC</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">semB</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">semC</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semA</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">semC</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">semA</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>For interlace, we still can use the <code class="language-plaintext highlighter-rouge">std::mutex</code> to implement:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">mC</span><span class="p">;</span>
<span class="n">mB</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="n">mC</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mB</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mA</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span>
        <span class="c1">// BUG:</span>
        <span class="c1">// Releasing locks acquired by other threads is an UB</span>
        <span class="n">mB</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mC</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mB</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span> 
        <span class="c1">// BUG:</span>
        <span class="c1">// Releasing locks acquired by other threads is an UB</span>
        <span class="n">mC</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mA</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mC</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span> 
        <span class="c1">// BUG:</span>
        <span class="c1">// Releasing locks acquired by other threads is an UB</span>
        <span class="n">mA</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">mB</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="n">mC</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</code></pre></div></div> <p>In the code above, we just move the lock into the <code class="language-plaintext highlighter-rouge">for</code> loop. And <code class="language-plaintext highlighter-rouge">A</code> will unlock <code class="language-plaintext highlighter-rouge">B</code>’s lock, <code class="language-plaintext highlighter-rouge">B</code> will unlock <code class="language-plaintext highlighter-rouge">C</code>’s lock and <code class="language-plaintext highlighter-rouge">C</code> will unlock <code class="language-plaintext highlighter-rouge">A</code>’s lock. Similarly, we can re-implement it with <code class="language-plaintext highlighter-rouge">std::counting_semaphore</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Same with std::counting_semaphore&lt;1&gt; semA(1), semB(0), semC(0);</span>
<span class="n">std</span><span class="o">::</span><span class="n">binary_semaphore</span> <span class="nf">semA</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">semB</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">semC</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semB</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">semA</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span>
        <span class="n">semB</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semC</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">semB</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span>
        <span class="n">semC</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">semC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semA</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">semC</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span>
        <span class="n">semA</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>For starting at the same time, we can use <code class="language-plaintext highlighter-rouge">std::condition_variable</code> or <code class="language-plaintext highlighter-rouge">std::promise</code> to implement, there is an example using <code class="language-plaintext highlighter-rouge">std::promise</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">barrier</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">barrier_future</span> <span class="o">=</span> <span class="n">barrier</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">barrier_future</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">barrier_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span> <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">barrier_future</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">barrier_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span> <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">barrier_future</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">barrier_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span> <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">barrier</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>In the code above, we make every thread wait the barrier at their beginning. And we make the barrier ready after <code class="language-plaintext highlighter-rouge">10ms</code> to make sure every thread have been started.</p> <p>For the last requirement, we can use <code class="language-plaintext highlighter-rouge">std::condition_variable</code> to implement:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">canStart</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">A</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
            <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">canStart</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">});</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'A'</span><span class="p">;</span>
            <span class="n">canStart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// We can notify with no lock here,</span>
        <span class="c1">// and this is recommended.</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">B</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
            <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">canStart</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="p">});</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'B'</span><span class="p">;</span>
            <span class="n">canStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// We can notify with no lock here,</span>
        <span class="c1">// and this is recommended.</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">C</span><span class="p">([</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
            <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">canStart</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">});</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'C'</span><span class="p">;</span>
            <span class="n">canStart</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// We can notify with no lock here,</span>
        <span class="c1">// and this is recommended.</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">canStart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span><span class="n">canStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">canStart</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">canStart</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">canStart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">canStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">canStart</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">});</span>
<span class="p">}</span>
<span class="n">A</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">B</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">C</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div> <p>In the code above, we use a boolean array <code class="language-plaintext highlighter-rouge">canStart</code> to control whether the thread can start. When the main thread sets <code class="language-plaintext highlighter-rouge">canStart[i]</code> to <code class="language-plaintext highlighter-rouge">true</code>, it will notify all threads to wake up. When a thread wakes up, it will check whether <code class="language-plaintext highlighter-rouge">canStart[i]</code> is <code class="language-plaintext highlighter-rouge">true</code>. If it is <code class="language-plaintext highlighter-rouge">true</code>, the thread will print its name and set <code class="language-plaintext highlighter-rouge">canStart[i]</code> to <code class="language-plaintext highlighter-rouge">false</code>, then notify all threads to wake up again.</p> <h2 id="references">References</h2> <ul> <li><a href="https://en.cppreference.com/w/cpp/utility/functional/function" rel="external nofollow noopener" target="_blank">std::function cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/types/result_of" rel="external nofollow noopener" target="_blank">std::result_of / std::invoke_result cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/utility/functional/bind" rel="external nofollow noopener" target="_blank">std::bind cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/thread" rel="external nofollow noopener" target="_blank">std::thread cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/packaged_task" rel="external nofollow noopener" target="_blank">std::packaged_task cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/future" rel="external nofollow noopener" target="_blank">std::future cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/promise" rel="external nofollow noopener" target="_blank">std::promise cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/shared_future" rel="external nofollow noopener" target="_blank">std::shared_future cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/async" rel="external nofollow noopener" target="_blank">std::async cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/mutex" rel="external nofollow noopener" target="_blank">std::mutex cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/timed_mutex" rel="external nofollow noopener" target="_blank">std::timed_mutex cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/recursive_mutex" rel="external nofollow noopener" target="_blank">std::recursive_mutex cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex" rel="external nofollow noopener" target="_blank">std::recursive_timed_mutex cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/shared_mutex" rel="external nofollow noopener" target="_blank">std::shared_mutex cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard" rel="external nofollow noopener" target="_blank">std::lock_guard cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock" rel="external nofollow noopener" target="_blank">std::unique_lock cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/shared_lock" rel="external nofollow noopener" target="_blank">std::shared_lock cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/condition_variable" rel="external nofollow noopener" target="_blank">std::condition_variable cppreference</a></li> <li><a href="https://stackoverflow.com/a/22804813" rel="external nofollow noopener" target="_blank">The Answer from Stack Overflow</a></li> <li><a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore.html" rel="external nofollow noopener" target="_blank">std::counting_semaphore</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/vim-skills/">Vim 常用技巧</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/literature/">文学摘抄</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/go-learning/">Go 学习笔记</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/shoelace-formula/">鞋带公式</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/knapsack-problem/">多重背包优化</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Kaiser-Yang/Kaiser-Yang.github.io","data-repo-id":"R_kgDOMlCR5A","data-category":"Announcements","data-category-id":"DIC_kwDOMlCR5M4ChxBw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-input-position":"top","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Kaiser Yang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: January 11, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"post-vim-\u5e38\u7528\u6280\u5de7",title:"Vim \u5e38\u7528\u6280\u5de7",description:"\u672c\u6587\u4ecb\u7ecd\u81ea\u5df1\u5b66\u4e60\u5230\u7684\u4e00\u4e9b\u597d\u7528\u7684 Vim \u6280\u5de7\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/vim-skills/"}},{id:"post-\u6587\u5b66\u6458\u6284",title:"\u6587\u5b66\u6458\u6284",description:"\u672c\u6587\u6536\u96c6\u4e86\u4e00\u4e9b\u6211\u559c\u6b22\u7684\u6587\u5b66\u4f5c\u54c1\u4e2d\u7684\u6458\u6284\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/literature/"}},{id:"post-go-\u5b66\u4e60\u7b14\u8bb0",title:"Go \u5b66\u4e60\u7b14\u8bb0",description:"\u672c\u6587\u8bb0\u5f55\u4e86\u6211\u5728\u5b66\u4e60 Go \u8bed\u8a00\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e9b\u7b14\u8bb0\u548c\u601d\u8003\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/go-learning/"}},{id:"post-\u978b\u5e26\u516c\u5f0f",title:"\u978b\u5e26\u516c\u5f0f",description:"\u672c\u6587\u4ecb\u7ecd\u978b\u5e26\u516c\u5f0f\u7684\u539f\u7406\u53ca\u5176\u5b9e\u73b0\u65b9\u5f0f\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/shoelace-formula/"}},{id:"post-\u591a\u91cd\u80cc\u5305\u4f18\u5316",title:"\u591a\u91cd\u80cc\u5305\u4f18\u5316",description:"\u672c\u6587\u4ecb\u7ecd\u591a\u91cd\u80cc\u5305\u95ee\u9898\u7684\u4e24\u79cd\u4f18\u5316\u65b9\u6cd5\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/knapsack-problem/"}},{id:"post-\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u53ca\u5176\u6269\u5c55",title:"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u53ca\u5176\u6269\u5c55",description:"\u672c\u6587\u4ecb\u7ecd\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u4ee5\u53ca\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/chinese-reminder-theorem/"}},{id:"post-\u6a21\u9006\u5143",title:"\u6a21\u9006\u5143",description:"\u672c\u6587\u4ecb\u7ecd\u6a21\u9006\u5143\u7684\u5b9a\u4e49\u53ca\u5176\u8ba1\u7b97\u65b9\u6cd5\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/mod-inverse/"}},{id:"post-\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5",title:"\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5",description:"\u672c\u6587\u4ecb\u7ecd\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u7684\u539f\u7406\u53ca\u5e94\u7528\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/extended-euclidean-algorithm/"}},{id:"post-miller-rabin-\u7d20\u6570\u6d4b\u8bd5",title:"Miller Rabin \u7d20\u6570\u6d4b\u8bd5",description:"\u672c\u6587\u4ecb\u7ecd Miller Rabin \u7d20\u6570\u6d4b\u8bd5\u7684\u539f\u7406\u53ca\u5176\u5b9e\u73b0\u65b9\u5f0f\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/miller-rabin/"}},{id:"post-gcs-front-end-development",title:"gcs-front-end Development",description:"This post includes the main process of gcs-front-end development.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-front-end-development/"}},{id:"post-gcs-documentation",title:"gcs Documentation",description:"This post includes the index of gcs documentation.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-documentation/"}},{id:"post-gcs-back-end-development",title:"gcs-back-end Development",description:"This post includes the main process of gcs-back-end development.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-back-end-development/"}},{id:"post-q-amp-a",title:"Q&amp;A",description:"Some questions that I have encountered in my work.",section:"Posts",handler:()=>{window.location.href="/blog/2025/question-and-answer/"}},{id:"post-contributing-to-blink-cmp-git",title:"Contributing to blink-cmp-git",description:"A guide to adding support for new Git hosting services in blink-cmp-git.",section:"Posts",handler:()=>{window.location.href="/blog/2025/blink-cmp-git-contribution/"}},{id:"post-deploy-gcs",title:"Deploy gcs",description:"This post introduces how to deploy gcs on a server using Docker.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-deploy/"}},{id:"post-ieee-xtreme-18-0-\u9898\u89e3",title:"IEEE Xtreme 18.0 \u9898\u89e3",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/ieeextreme-18-solution/"}},{id:"post-\u9a6c\u62c9\u677e-4-\u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",title:"\u9a6c\u62c9\u677e 4 \u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/marathon-4-hours-preparation/"}},{id:"post-ssh-port-forwarding",title:"SSH Port Forwarding",description:"This post introduces the three types of SSH port forwarding.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ssh-port-forwarding/"}},{id:"post-creating-a-git-remote-repository-on-server",title:"Creating a Git Remote Repository on Server",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/create-git-remote-repository-on-server/"}},{id:"post-spring-boot-test-\u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",title:"Spring Boot Test \u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-boot-test-custom-test-class-order/"}},{id:"post-spring-\u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",title:"Spring \u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-read-request-body-multiple-times/"}},{id:"post-long-\u5728-swagger-\u4e2d\u7cbe\u5ea6\u4e22\u5931",title:"Long \u5728 Swagger \u4e2d\u7cbe\u5ea6\u4e22\u5931",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/long-precision-lost-in-swagger/"}},{id:"post-spring-validation-\u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",title:"Spring-Validation \u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-custom-error-code/"}},{id:"post-jjwt-spring-filter-\u5b9e\u73b0-token-\u9a8c\u8bc1",title:"JJWT + Spring Filter \u5b9e\u73b0 Token \u9a8c\u8bc1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/filter-jjwt-intro/"}},{id:"post-spring-filter-\u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",title:"Spring Filter \u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/exception-handler-intro/"}},{id:"post-spring-validation-introduction",title:"Spring Validation Introduction",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-intro/"}},{id:"post-\u4f7f\u7528-spring-doc-\u751f\u6210\u63a5\u53e3\u6587\u6863",title:"\u4f7f\u7528 Spring-Doc \u751f\u6210\u63a5\u53e3\u6587\u6863",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-doc-intro/"}},{id:"post-mybatis-plus-\u7b80\u4ecb",title:"MyBatis-Plus \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mybatis-plus-intro/"}},{id:"post-spring-mvc-\u7b80\u4ecb",title:"Spring MVC \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-mvc-intro/"}},{id:"post-mock-mvc-\u7b80\u4ecb",title:"Mock Mvc \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mock-mvc-intro/"}},{id:"post-the-brief-introduction-of-spring",title:"The Brief Introduction of Spring",description:"This post introduces some important concepts and commonly used annotations in the Spring Framework.",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-intro/"}},{id:"post-\u5728-nvim-\u4e2d\u4f7f\u7528-rime-ls-\u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",title:"\u5728 nvim \u4e2d\u4f7f\u7528 rime-ls \u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",description:"\u672c\u6587\u4ecb\u7ecd\u5982\u4f55\u5728 nvim \u4e2d\u4f7f\u7528 rime-ls \u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5\uff0c\u4ee5\u53ca\u76f8\u5173\u7684\u914d\u7f6e\u548c\u4f7f\u7528\u6280\u5de7\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2024/nvim-input-method/"}},{id:"post-a-brief-introduction-of-game-theory",title:"A Brief Introduction of Game Theory",description:"This post introduce some simple examples of game theory.",section:"Posts",handler:()=>{window.location.href="/blog/2024/game-theory/"}},{id:"post-python-\u4e2d\u53d8\u91cf\u4ea4\u6362\u7684\u5947\u602a\u73b0\u8c61",title:"Python \u4e2d\u53d8\u91cf\u4ea4\u6362\u7684\u5947\u602a\u73b0\u8c61",description:"\u672c\u6587\u4ecb\u7ecd\u67d0\u541b\u5728\u4f7f\u7528 Python \u8fdb\u884c\u53d8\u91cf\u4ea4\u6362\u65f6\u9047\u5230\u7684\u5947\u602a\u73b0\u8c61\u53ca\u5176\u539f\u56e0\u5206\u6790\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-swapping/"}},{id:"post-c-pack-from-static-loop-to-static-prime-check",title:"C++ Pack, from Static Loop to Static Prime Check",description:"This post introduces C++ Pack and Meta Programming: Static Loop and Static Prime Check.",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-pack-meta-programming/"}},{id:"post-the-introduction-of-c-smart-pointers",title:"The Introduction of C++ Smart Pointers",description:"This post introduces the RAII concept and three types of C++ smart pointers: std::unique_ptr, std::shared_ptr, and std::weak_ptr.",section:"Posts",handler:()=>{window.location.href="/blog/2023/cpp-smart-pointer/"}},{id:"post-c-multi-threading",title:"C++ Multi-threading",description:"This post introduces the C++ multi-threading library and its usage.",section:"Posts",handler:()=>{window.location.href="/blog/2023/cpp-multi-thread/"}},{id:"post-c-\u4e34\u65f6\u5bf9\u8c61\u751f\u547d\u5468\u671f",title:"C++\u4e34\u65f6\u5bf9\u8c61\u751f\u547d\u5468\u671f",description:"\u672c\u6587\u4ecb\u7ecd\u4e00\u4e2a\u5173\u4e8eC++\u4e2d\u4e34\u65f6\u5bf9\u8c61\u751f\u547d\u5468\u671f\u7684\u4f8b\u5b50",section:"Posts",handler:()=>{window.location.href="/blog/2023/cpp-temp-objects/"}},{id:"post-c-value-categories-references-move-semantics-and-perfect-forwarding",title:"C++ Value Categories, References, Move Semantics and Perfect Forwarding",description:"This post introduces C++ value categories, lvalue reference, rvalue reference, move semantics and perfect forwarding.",section:"Posts",handler:()=>{window.location.href="/blog/2023/value-categories-cpp/"}},{id:"post-unix-linux-fork\u51fd\u6570\u7684\u95ee\u9898-\u5e76\u4e0d\u9002\u5408\u5171\u4eab",title:"Unix/Linux fork\u51fd\u6570\u7684\u95ee\u9898 \u5e76\u4e0d\u9002\u5408\u5171\u4eab",description:"\u672c\u6587\u4ecb\u7ecd Unix/Linux \u7cfb\u7edf\u8c03\u7528 fork \u51fd\u6570\u5728\u865a\u62df\u5185\u5b58\u7ba1\u7406\u4e2d\u7684\u4e00\u4e9b\u95ee\u9898\uff0c\u8bf4\u660e\u5176\u5e76\u4e0d\u9002\u5408\u901a\u8fc7\u5168\u5c40\u53d8\u91cf\u8fdb\u884c\u901a\u4fe1\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2023/unix-fork-vm/"}},{id:"news-working-on-gcs-back-end-https-github-com-cmipt-gcs-back-end",title:"Working on [gcs-back-end](https://github.com/CMIPT/gcs-back-end).",description:"",section:"News"},{id:"projects-gcs-back-end",title:"gcs-back-end",description:"",section:"Projects",handler:()=>{window.location.href="/projects/gcs-back-end/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6B%61%69%73%65%72%71%7A%79%75%65@%66%6F%78%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Kaiser-Yang","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>