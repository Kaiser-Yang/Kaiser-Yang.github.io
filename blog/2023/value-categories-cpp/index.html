<!DOCTYPE html> <html lang="zh"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++ Value Categories, References, Move Semantics and Perfect Forwarding | Kaiser's Homepage </title> <meta name="author" content="Kaiser Yang"> <meta name="description" content="Sharing everything I know. "> <meta name="keywords" content="C/C++, Java, Python"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kaiser-yang.github.io/blog/2023/value-categories-cpp/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Kaiser's Homepage </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">Ctrl K <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main" style="min-width: 60%;"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++ Value Categories, References, Move Semantics and Perfect Forwarding</h1> <p class="post-meta"> Created in December 03, 2023 , last updated in May 18, 2025 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/category/c-c"> <i class="fa-solid fa-tag fa-sm"></i> C/C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In this post, those concepts will be introduced:</p> <ul> <li>Value Categories: glvalue, xvalue, lvalue, prvalue and rvalue</li> <li>lvalue reference and rvalue reference</li> <li>Move and Copy Semantics</li> <li>Reference collapsing, universal reference and perfect forwarding</li> </ul> <p>These contents are core features in <code class="language-plaintext highlighter-rouge">C++11</code>.</p> <h2 id="value-categories">Value Categories</h2> <p>In <code class="language-plaintext highlighter-rouge">C++ 98/03</code>, it’s OK if you don’t know what value categories are. Since <code class="language-plaintext highlighter-rouge">C++11</code>, the concept of value categories has changed a lot. If you don’t understand them, you may not write the code correctly, and you will not understand the move semantics, which is one of the most important feature in <code class="language-plaintext highlighter-rouge">C++11</code>.</p> <p>Before we dive in, we need to know the following concepts:</p> <ul> <li>identity: i.e. an address, a pointer the user can determine whether two copies are identical, etc.</li> </ul> <h3 id="glvalue-generalized-left-value">glvalue (generalized left value)</h3> <p>glvalue are those that have identity.</p> <p>You may still don’t know what glvalue is. Don’t worry, glvalue is also the union of lvalue and xvalue. After I introduce lvalue and xvalue, you will know what glvalue is.</p> <h3 id="lvalue-left-value">lvalue (left value)</h3> <p>There is a very detailed definition of lvalue in <code class="language-plaintext highlighter-rouge">cppreference</code>, but it’s too detailed to remember. We can simply understand lvalue as those whose address can be obtained by <code class="language-plaintext highlighter-rouge">&amp;</code>.</p> <p>There are some cases of lvalue:</p> <ul> <li>String literal, e.g. <code class="language-plaintext highlighter-rouge">"Hello World"</code>;</li> <li>The built-in pre-increment and pre-decrement operations, e.g. <code class="language-plaintext highlighter-rouge">--a, ++a</code>;</li> <li>The built-in assignment and compound assignment operations, e.g. <code class="language-plaintext highlighter-rouge">a = b</code>, <code class="language-plaintext highlighter-rouge">a += b</code>;</li> <li> <code class="language-plaintext highlighter-rouge">a, b</code>, the built-in comma expression, where <code class="language-plaintext highlighter-rouge">b</code> is an lvalue;</li> <li>A cast expression to lvalue reference type, e.g. <code class="language-plaintext highlighter-rouge">static_cast&lt;int&amp;&gt;(a)</code>;</li> <li> <code class="language-plaintext highlighter-rouge">a.*mp</code> or <code class="language-plaintext highlighter-rouge">p-&gt;*mp</code>, the built-in pointer to member of objecct or pointer to member of pointer expression, where <code class="language-plaintext highlighter-rouge">mp</code> is a data member;</li> <li> <code class="language-plaintext highlighter-rouge">a[n]</code> where <code class="language-plaintext highlighter-rouge">a</code> is an array lvalue.</li> <li>A constant template parameter of an lvalue reference type;</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">v</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// template parameter is lvalue</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// static variable, fixed address is known at compile-time</span>
 
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>NOTE</strong>: An array lvalue is an array that has an identifier, e.g. <code class="language-plaintext highlighter-rouge">int a[3]</code>, and <code class="language-plaintext highlighter-rouge">a</code> is an array lvalue.</p> <h3 id="prvalue-pure-right-value">prvalue (pure right value)</h3> <p>prvalue has no identity, and you can not get its address by <code class="language-plaintext highlighter-rouge">&amp;</code>.</p> <p>There are some cases of prvalue:</p> <ul> <li>The built-in post-increment and post-decrement operations, e.g. <code class="language-plaintext highlighter-rouge">a++, a--</code>;</li> <li>The built-in logical expression, e.g. <code class="language-plaintext highlighter-rouge">a &amp;&amp; b</code>, <code class="language-plaintext highlighter-rouge">a || b</code>;</li> <li>The built-in arithmetic expression, e.g. <code class="language-plaintext highlighter-rouge">a + b</code>, <code class="language-plaintext highlighter-rouge">a - b</code>;</li> <li>The built-in comparison expression, e.g. <code class="language-plaintext highlighter-rouge">a == b</code>, <code class="language-plaintext highlighter-rouge">a != b</code>;</li> <li>The built-in address-of expression, e.g. <code class="language-plaintext highlighter-rouge">&amp;a</code>;</li> <li> <code class="language-plaintext highlighter-rouge">a, b</code>, the built-in comma expression, where <code class="language-plaintext highlighter-rouge">b</code> is an prvalue;</li> <li> <code class="language-plaintext highlighter-rouge">a.m</code> or <code class="language-plaintext highlighter-rouge">p-&gt;m</code> where <code class="language-plaintext highlighter-rouge">m</code> is a non-static member function or member enumeration;</li> <li> <code class="language-plaintext highlighter-rouge">a.*mp</code> or <code class="language-plaintext highlighter-rouge">p-&gt;*mp</code>, the built-in pointer to member of objecct or pointer to member of pointer expression, where <code class="language-plaintext highlighter-rouge">mp</code> is a member function;</li> <li>A cast expression to non-reference type, e.g. <code class="language-plaintext highlighter-rouge">static_cast&lt;int&gt;(a)</code>;</li> <li> <code class="language-plaintext highlighter-rouge">this</code> pointer;</li> <li>An enumerator;</li> <li>A lambda expression;</li> <li>A constant template parameter of a scalar type;</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">v</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// not an lvalue, `v` is a template parameter of scalar type int</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span> <span class="c1">// ill-formed</span>
    <span class="n">v</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// ill-formed: lvalue required as left operand of assignment</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="xvalue-expiring-value">xvalue (expiring value)</h3> <p>xvalue has identity, but you can not get its address by <code class="language-plaintext highlighter-rouge">&amp;</code>.</p> <p>There are some cases of xvalue:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">a.m</code> where <code class="language-plaintext highlighter-rouge">a</code> is an rvalue and <code class="language-plaintext highlighter-rouge">m</code> is non-static data member;</li> <li> <code class="language-plaintext highlighter-rouge">a.*mp</code> where <code class="language-plaintext highlighter-rouge">a</code> is an rvalue and <code class="language-plaintext highlighter-rouge">mp</code> is pointer to data member;</li> <li> <code class="language-plaintext highlighter-rouge">a, b</code> where <code class="language-plaintext highlighter-rouge">b</code> is an xvalue;</li> <li>A function call whose return type of value is an rvalue reference type, e.g. <code class="language-plaintext highlighter-rouge">std::move(x)</code>;</li> <li>A cast expression to rvalue reference type, e.g. <code class="language-plaintext highlighter-rouge">static_cast&lt;int&amp;&amp;&gt;(a)</code>;</li> <li> <code class="language-plaintext highlighter-rouge">a[n]</code>, the built-in subscript operator, where <code class="language-plaintext highlighter-rouge">a</code> is an array rvalue;</li> <li>Any expression that designates a temporary object, after temporary materialization, e.g. <code class="language-plaintext highlighter-rouge">A().m</code>;</li> </ul> <p>Some expressions consisting of names of variables are lvalue expressions, but in some special cases , they are move-eligible. They are:</p> <ul> <li>A return statement;</li> <li>A co_return statement (Coroutines are the feature of <code class="language-plaintext highlighter-rouge">C++20</code>);</li> <li>A throw expression;</li> </ul> <p>Move-eligible expressions are defined as xvalue since <code class="language-plaintext highlighter-rouge">C++23</code>.</p> <p><strong>NOTE</strong>: An array rvalue is an array that has no identifier, e.g. <code class="language-plaintext highlighter-rouge">(int[3]){1, 2, 3}</code>.</p> <h3 id="rvalue-right-value">rvalue (right value)</h3> <p>rvalue is a union of prvalue and xvalue.</p> <blockquote> <p>Actually, there should be four types of value categories:</p> <ul> <li>has identity and can not be moved (lvalue);</li> <li>has identity and can be moved (xvalue);</li> <li>has no identity and can be moved (prvalue);</li> <li>has no identity and can not be moved.</li> </ul> <p>The last one is useless in <code class="language-plaintext highlighter-rouge">C++</code>.</p> </blockquote> <h2 id="references">References</h2> <h2 id="lvalue-reference">lvalue reference</h2> <p>lvalue reference is a reference to an lvalue.</p> <p>In my opinion, lvalue reference is syntactic sugar for constant pointer.</p> <p>Without lvalue reference, we must use pointer to pass parameters to a function, so that the modification of the parameter can be reflected to the argument.</p> <p>For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">badSwapTwoInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The code above can not swap two integers correctly, because the formal parameters are copies of the actual parameters. We must use pointers (before lvalue reference):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">goodSwapTwoInt</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div> <p>With lvalue reference, we can use the following code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">goodSwapTwoIntByRef</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="possible-implementation">Possible Implementation</h3> <p>The above code is almost equivalent to the following code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">goodSwapTwoIntAct</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are still some differences between the two codes. <code class="language-plaintext highlighter-rouge">cppreference</code> mentions that a reference has no extra space, but the above code needs extra space to store the address of the pointer.</p> <h2 id="rvalue-reference">rvalue reference</h2> <h3 id="why-rvalue-reference">Why rvalue reference?</h3> <p>rvalue reference is for move semantics. Before <code class="language-plaintext highlighter-rouge">C++11</code>, there is no move semantics, only copy semantics (copy constructor and copy assignment operator). For the class whose member variable contains pointers or user-defined types, we often need to implement a copy constructor and copy assignment operator by ourselves so that the data can be successfully copied (usually called deep copy), rather than just let the pointer point to the same memory (usually called shallow copy).</p> <p>When we pass a large object to a function, whose formal parameter is a non-pointer or lvalue reference type. The copy constructor or copy assignment operator will be called. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// when calling function a,</span>
<span class="c1">// and reaching c,</span>
<span class="c1">// there are three copies of data (a, b, c) in memory.</span>
<span class="kt">void</span> <span class="nf">C</span><span class="p">(</span><span class="n">BigData</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// do something }</span>
<span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="n">BigData</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">A</span><span class="p">(</span><span class="n">BigData</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div> <p>In some situations, we only need one copy of data in memory, so we can use lvalue reference or pointer to solve the problem. For example, the above code can be changed to:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// there are only one data (a, b and c are the same data) in memory.</span>
<span class="kt">void</span> <span class="nf">C</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// do something }</span>
<span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">A</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div> <p>However, the above code can not be used to pass a temporary object to a function. In order to support this, we can use <code class="language-plaintext highlighter-rouge">const</code> to pass a temporary object to a function:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// there are only one data (a, b and c are the same data) in memory.</span>
<span class="kt">void</span> <span class="nf">C</span><span class="p">(</span><span class="k">const</span> <span class="n">BigData</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// do something }</span>
<span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">BigData</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">A</span><span class="p">(</span><span class="k">const</span> <span class="n">BigData</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// OK, we can bind a temporary object to a const lvalue reference even before C++11</span>
<span class="n">A</span><span class="p">(</span><span class="n">BigData</span><span class="p">{</span><span class="s">"a.txt"</span><span class="p">});</span> <span class="c1">// read big data from data.txt</span>
</code></pre></div></div> <p>You may think this is good, and no need for rvalue reference. But NO! In some situations, we may need to update the parameter in the function. However, for this code, we can not.</p> <p>rvalue reference can be binded to any rvalue and also can be modified.</p> <p>For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigData</span> <span class="o">&amp;&amp;</span><span class="n">bigData</span> <span class="o">=</span> <span class="n">BigData</span><span class="p">{</span><span class="s">"a.txt"</span><span class="p">};</span>
</code></pre></div></div> <h2 id="move-semantics">Move Semantics</h2> <p>If you’ve learned other languages, you may know shallow copy and deep copy. Move semantics in <code class="language-plaintext highlighter-rouge">C++</code> is similar to shallow copy. In <code class="language-plaintext highlighter-rouge">C++</code>, we implement move semantics by make the pointer point to the same memory and then set the original pointer to <code class="language-plaintext highlighter-rouge">nullptr</code>, which may be a little bit different from shallow copy in other languages.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Move constructor</span>
<span class="n">ClassType</span><span class="p">(</span><span class="n">ClassType</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">);</span>
<span class="c1">// Move assignment operator</span>
<span class="n">ClassType</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ClassType</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">);</span>
</code></pre></div></div> <p>The compiler will automatically generate a move constructor and move assignment operator if you don’t define any of a copy constructor, copy assignment operator, move constructor or move assignment operator. The default move constructor and move assignment operator are same with the default copy constructor and copy assignment operator. So in most cases, we need to implement our own move constructor and move assignment operator to make them work with move semantics.</p> <p>There are some examples for move semantics:</p> <p>Initialization phase, if the right side of the assignment is an rvalue, then it will trigger the move constructor:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// std::string("HelloWorld") is rvalue, this will trigger move constructor</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"HelloWorld"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">temp</span><span class="p">)};</span>
</code></pre></div></div> <p>Without move semantics, the above code will create a temporary object and then copy it to <code class="language-plaintext highlighter-rouge">value</code> through the copy constructor; with move semantics, the above code will create a temporary object and then move it to <code class="language-plaintext highlighter-rouge">value</code> through the move constructor (if we don’t consider the optimization of the compiler). Move semantics reduces one time copy operation.</p> <p>Assignment phase, if the right side of the assignment is an rvalue, then it will trigger the move assignment operator:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
<span class="c1">// std::string("HelloWorld") is rvalue, this will trigger move assignment.</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"HelloWorld"</span><span class="p">);</span>
</code></pre></div></div> <p>If we bind a rvalue to a rvalue reference, no move semantics will occur:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">{</span><span class="s">"HelloWorld"</span><span class="p">};</span>
<span class="c1">// No movement occurs, value is still "HelloWorld".</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">rRef</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</code></pre></div></div> <p>In the above code, if we modify <code class="language-plaintext highlighter-rouge">rRef</code>, it will affect <code class="language-plaintext highlighter-rouge">value</code>,</p> <p>If we assign a rvalue reference to a variable, no move semantics will occur unless we use <code class="language-plaintext highlighter-rouge">std::move</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">rRef</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"HelloWorld"</span><span class="p">);</span>
<span class="c1">// No movement occurs, rRef is still "HelloWorld".</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="n">rRef</span><span class="p">;</span>
<span class="c1">// Move occurs, rRef is now "", and you should not use it any more.</span>
<span class="c1">// std::string value = std::move(rRef);</span>
</code></pre></div></div> <p>Now we can finish the previous problem with move semantics:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Now, we can modify the parameter in the function</span>
<span class="kt">void</span> <span class="nf">C</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// do something }</span>
<span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">A</span><span class="p">(</span><span class="n">BigData</span> <span class="o">&amp;&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">B</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="p">}</span>
<span class="n">A</span><span class="p">(</span><span class="n">BigData</span><span class="p">(</span><span class="s">"data.txt"</span><span class="p">));</span>
</code></pre></div></div> <p>In this code above, we must use <code class="language-plaintext highlighter-rouge">std::move</code> to convert the lvalue to an rvalue. It is worth noting that no matter what the type of a variable is, the expression is always an lvalue unless we use <code class="language-plaintext highlighter-rouge">std::move</code> to convert it to an rvalue.</p> <p><strong>NOTE</strong>: If we move a variable to the other, we should not use the original variable any more.</p> <p>There is an example in <code class="language-plaintext highlighter-rouge">cppreference</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Salut"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

<span class="c1">// Uses the push_back(const T&amp;) overload, which means </span>
<span class="c1">// we'll incur the cost of copying str</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After copy, str is "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="c1">// Uses the rvalue reference push_back(T&amp;&amp;) overload,</span>
<span class="c1">// which means no strings will be copied; instead, the contents</span>
<span class="c1">// of str will be moved into the vector. This is less</span>
<span class="c1">// expensive, but also means str might now be empty.</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After move, str is "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The contents of the vector are { "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
          <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">" }</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div> <p>Output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After copy, str is "Salut"
After move, str is ""
The contents of the vector are { "Salut", "Salut" }
</code></pre></div></div> <p>After the second call to <code class="language-plaintext highlighter-rouge">push_back</code>, the contents of <code class="language-plaintext highlighter-rouge">str</code> are moved into the vector, and the original <code class="language-plaintext highlighter-rouge">str</code> is now empty. We should not use <code class="language-plaintext highlighter-rouge">str</code> any more.</p> <h2 id="lvalue-vs-rvalue">lvalue VS rvalue</h2> <p>The simplest way to distinguish between lvalue and rvalue is to check if the expression can be binded to a lvalue reference or rvalue reference.</p> <p>Actually, if the expression can be binded to a lvalue reference, then it is an lvalue; if the expression can be binded to a rvalue reference, then it is an rvalue.</p> <h2 id="perfect-forwarding">Perfect Forwarding</h2> <h3 id="reference-collapsing">Reference Collapsing</h3> <p>Reference collapsing is a rule that determines the type of a reference when two references are combined. The rules are as follows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span><span class="o">&amp;</span>  <span class="n">lref</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">rref</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

<span class="n">lref</span><span class="o">&amp;</span>  <span class="n">r1</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// type of r1 is int&amp;</span>
<span class="n">lref</span><span class="o">&amp;&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// type of r2 is int&amp;</span>
<span class="n">rref</span><span class="o">&amp;</span>  <span class="n">r3</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// type of r3 is int&amp;</span>
<span class="n">rref</span><span class="o">&amp;&amp;</span> <span class="n">r4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// type of r4 is int&amp;&amp;</span>
</code></pre></div></div> <p>From the code above, we can find that only when two rvalue references are combined, the result is an rvalue reference.</p> <h3 id="universal-reference">Universal Reference</h3> <p>Universal reference is also called forwarding reference, which is proposed to solve the problem of perfect forwarding. The reason why it is called universal reference is that it can bind to both lvalue and rvalue. In general, universal reference is defined as follows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{};</span>

<span class="c1">// NOTE:</span>
<span class="c1">// This is not a forwarding reference, because forwarding reference must be cv-unqualified</span>
<span class="c1">// template&lt;class T&gt;</span>
<span class="c1">// void f(const T &amp;&amp;t);</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// call f(int &amp;&amp;t), T is int;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// call f(int &amp;t), T is int&amp;;</span>
<span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// call f(int &amp;&amp;t), T is int&amp;&amp;;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">lRef</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rRef</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">lRef</span><span class="p">);</span> <span class="c1">// call f(int &amp;t), T is int&amp;;</span>
<span class="n">f</span><span class="p">(</span><span class="n">rRef</span><span class="p">);</span> <span class="c1">// call f(int &amp;t), T is int&amp;;</span>
<span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lRef</span><span class="p">));</span> <span class="c1">// call f(int &amp;&amp;t), T is int&amp;&amp;;</span>
<span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rRef</span><span class="p">));</span> <span class="c1">// call f(int &amp;&amp;t), T is int&amp;&amp;;</span>
</code></pre></div></div> <p>In the code above, reference collapsing occurs unless the argument is a pure rvalue. We can find that when the actual parameter is an lvalue, the type of <code class="language-plaintext highlighter-rouge">t</code> is an lvalue reference, and when the actual parameter is an rvalue, the type of <code class="language-plaintext highlighter-rouge">t</code> is an rvalue reference.</p> <h3 id="what-is-perfect-forwarding">What is Perfect Forwarding?</h3> <p>The term forwading here refers to the process of passing parameters during function calls.</p> <p>Perfect forwarding means the process of passing parameters to another function while maintaining the original value category of the parameters. For example, if the parameter is an lvalue, it will be passed as an lvalue so that it can be binded to an lvalue reference; if the parameter is an rvalue, it will be passed as an rvalue so that it can be binded to an rvalue reference.</p> <h3 id="why-perfect-forwarding">Why Perfect Forwarding?</h3> <p>Perfect forwarding can reduce the number of copies of data in memory. When the actual parameter is an rvalue, we can use move semantics to pass the parameter to another function, so that we can avoid the copy constructor and copy assignment operator.</p> <h3 id="an-example-of-perfect-forwarding">An Example of Perfect Forwarding</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The receiver</span>
<span class="kt">void</span> <span class="nf">handleInt</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">handleInt</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">xx</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// The forwarding function</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">perfectForwarding</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something ...</span>

    <span class="c1">// call another function:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handleInt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// do something ...</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">lRef</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rRef</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// rvalue, so call handleInt(int &amp;&amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// lvalue, so call handleInt(int &amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">//  rvalue, so call handleInt(int &amp;&amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">lRef</span><span class="p">);</span> <span class="c1">// lvalue, so call handleInt(int &amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">rRef</span><span class="p">);</span> <span class="c1">// lvalue, so call handleInt(int &amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lRef</span><span class="p">));</span> <span class="c1">// rvalue, so call handleInt(int &amp;&amp;x);</span>
<span class="n">perfectForwarding</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rRef</span><span class="p">));</span> <span class="c1">// rvalue, so call handleInt(int &amp;&amp;x);</span>
</code></pre></div></div> <p>The source code of <code class="language-plaintext highlighter-rouge">std::forward</code> is as follows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">};</span>
</code></pre></div></div> <p>This source code using the reference collapsing rules to determine the type of the return value. If the type of the parameter is an lvalue reference, the return value is an lvalue reference; if the type of the parameter is an rvalue reference, the return value is an rvalue reference.</p> <p>The <code class="language-plaintext highlighter-rouge">std::remove_reference</code> can be implemented as follows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// Template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// Template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div> <h2 id="references-1">References</h2> <ul> <li><a href="https://en.cppreference.com/w/cpp/language/value_category" rel="external nofollow noopener" target="_blank">value category cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/utility/move#:~:text=C%2B%2B%20Utilities%20library%20std%3A%3Amove%20is%20used%20to%20indicate,to%20a%20static_cast%20to%20an%20rvalue%20reference%20type." rel="external nofollow noopener" target="_blank">std::move cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/language/reference" rel="external nofollow noopener" target="_blank">reference cppreference</a></li> <li><a href="https://en.cppreference.com/w/cpp/utility/forward" rel="external nofollow noopener" target="_blank">std::forward cppreference</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/chinese-reminder-theorem/">中国剩余定理及其扩展</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mod-inverse/">模逆元</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/extended-euclidean-algorithm/">扩展欧几里德算法</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/miller-rabin/">Miller Rabin 素数测试</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/oc-notes/">Cradle to Grave Devotion: Objective C Notes</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Kaiser-Yang/Kaiser-Yang.github.io","data-repo-id":"R_kgDOMlCR5A","data-category":"Announcements","data-category-id":"DIC_kwDOMlCR5M4ChxBw","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-input-position":"top","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Kaiser Yang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: October 21, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"post-\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u53ca\u5176\u6269\u5c55",title:"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u53ca\u5176\u6269\u5c55",description:"\u672c\u6587\u4ecb\u7ecd\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u4ee5\u53ca\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/chinese-reminder-theorem/"}},{id:"post-\u6a21\u9006\u5143",title:"\u6a21\u9006\u5143",description:"\u672c\u6587\u4ecb\u7ecd\u6a21\u9006\u5143\u7684\u5b9a\u4e49\u53ca\u5176\u8ba1\u7b97\u65b9\u6cd5\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/mod-inverse/"}},{id:"post-\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5",title:"\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5",description:"\u672c\u6587\u4ecb\u7ecd\u6269\u5c55\u6b27\u51e0\u91cc\u5fb7\u7b97\u6cd5\u7684\u539f\u7406\u53ca\u5e94\u7528\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/extended-euclidean-algorithm/"}},{id:"post-miller-rabin-\u7d20\u6570\u6d4b\u8bd5",title:"Miller Rabin \u7d20\u6570\u6d4b\u8bd5",description:"\u672c\u6587\u4ecb\u7ecd Miller Rabin \u7d20\u6570\u6d4b\u8bd5\u7684\u539f\u7406\u53ca\u5176\u5b9e\u73b0\u65b9\u5f0f\u3002",section:"Posts",handler:()=>{window.location.href="/blog/2025/miller-rabin/"}},{id:"post-cradle-to-grave-devotion-objective-c-notes",title:"Cradle to Grave Devotion: Objective C Notes",description:"This post includes some notes on Objective C.",section:"Posts",handler:()=>{window.location.href="/blog/2025/oc-notes/"}},{id:"post-gcs-front-end-development",title:"gcs-front-end Development",description:"This post includes the main process of gcs-front-end development.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-front-end-development/"}},{id:"post-gcs-documentation",title:"gcs Documentation",description:"This post includes the index of gcs documentation.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-documentation/"}},{id:"post-gcs-back-end-development",title:"gcs-back-end Development",description:"This post includes the main process of gcs-back-end development.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-back-end-development/"}},{id:"post-q-amp-a",title:"Q&amp;A",description:"Some questions that I have encountered in my work.",section:"Posts",handler:()=>{window.location.href="/blog/2025/question-and-answer/"}},{id:"post-contributing-to-blink-cmp-git",title:"Contributing to blink-cmp-git",description:"A guide to adding support for new Git hosting services in blink-cmp-git.",section:"Posts",handler:()=>{window.location.href="/blog/2025/blink-cmp-git-contribution/"}},{id:"post-deploy-gcs",title:"Deploy gcs",description:"This post introduces how to deploy gcs on a server using Docker.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gcs-deploy/"}},{id:"post-ieee-xtreme-18-0-\u9898\u89e3",title:"IEEE Xtreme 18.0 \u9898\u89e3",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/ieeextreme-18-solution/"}},{id:"post-\u9a6c\u62c9\u677e-4-\u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",title:"\u9a6c\u62c9\u677e 4 \u5c0f\u65f6\u6311\u6218\u8bb0\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/marathon-4-hours-preparation/"}},{id:"post-ssh-port-forwarding",title:"SSH Port Forwarding",description:"This post introduces the three types of SSH port forwarding.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ssh-port-forwarding/"}},{id:"post-creating-a-git-remote-repository-on-server",title:"Creating a Git Remote Repository on Server",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/create-git-remote-repository-on-server/"}},{id:"post-spring-boot-test-\u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",title:"Spring Boot Test \u81ea\u5b9a\u4e49\u6d4b\u8bd5\u7c7b\u987a\u5e8f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-boot-test-custom-test-class-order/"}},{id:"post-spring-\u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",title:"Spring \u591a\u6b21\u8bfb\u53d6\u8bf7\u6c42\u4f53",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-read-request-body-multiple-times/"}},{id:"post-long-\u5728-swagger-\u4e2d\u7cbe\u5ea6\u4e22\u5931",title:"Long \u5728 Swagger \u4e2d\u7cbe\u5ea6\u4e22\u5931",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/long-precision-lost-in-swagger/"}},{id:"post-linux-potpourri",title:"Linux Potpourri",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/linux-potpourri/"}},{id:"post-spring-validation-\u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",title:"Spring-Validation \u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-custom-error-code/"}},{id:"post-jjwt-spring-filter-\u5b9e\u73b0-token-\u9a8c\u8bc1",title:"JJWT + Spring Filter \u5b9e\u73b0 Token \u9a8c\u8bc1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/filter-jjwt-intro/"}},{id:"post-spring-filter-\u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",title:"Spring Filter \u5168\u5c40\u5f02\u5e38\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/exception-handler-intro/"}},{id:"post-spring-validation-introduction",title:"Spring Validation Introduction",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-validation-intro/"}},{id:"post-python-\u9ad8\u7ea7\u6280\u5de7\u5b66\u4e60",title:"Python \u9ad8\u7ea7\u6280\u5de7\u5b66\u4e60",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-advanced-skills/"}},{id:"post-\u4f7f\u7528-spring-doc-\u751f\u6210\u63a5\u53e3\u6587\u6863",title:"\u4f7f\u7528 Spring-Doc \u751f\u6210\u63a5\u53e3\u6587\u6863",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-doc-intro/"}},{id:"post-mybatis-plus-\u7b80\u4ecb",title:"MyBatis-Plus \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mybatis-plus-intro/"}},{id:"post-spring-mvc-\u7b80\u4ecb",title:"Spring MVC \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-mvc-intro/"}},{id:"post-mock-mvc-\u7b80\u4ecb",title:"Mock Mvc \u7b80\u4ecb",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/mock-mvc-intro/"}},{id:"post-the-brief-introduction-of-spring",title:"The Brief Introduction of Spring",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/spring-intro/"}},{id:"post-\u5728-nvim-\u4e2d\u4f7f\u7528-rime-ls-\u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",title:"\u5728 nvim \u4e2d\u4f7f\u7528 rime-ls \u914d\u7f6e\u4e2d\u6587\u8f93\u5165\u6cd5",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/nvim-input-method/"}},{id:"post-a-brief-introduction-of-game-theory",title:"A Brief Introduction of Game Theory",description:"This post introduce some simple examples of game theory.",section:"Posts",handler:()=>{window.location.href="/blog/2024/game-theory/"}},{id:"post-c-pack-from-static-loop-to-static-prime-check",title:"C++ Pack, from Static Loop to Static Prime Check",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-pack-meta-programming/"}},{id:"post-the-introduction-of-c-smart-pointers",title:"The Introduction of C++ Smart Pointers",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/cpp-smart-pointer/"}},{id:"post-c-multi-threading",title:"C++ Multi-threading",description:"This post introduces the C++ multi-threading library and its usage.",section:"Posts",handler:()=>{window.location.href="/blog/2023/cpp-multi-thread/"}},{id:"post-c-value-categories-references-move-semantics-and-perfect-forwarding",title:"C++ Value Categories, References, Move Semantics and Perfect Forwarding",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/value-categories-cpp/"}},{id:"news-working-on-gcs-back-end-https-github-com-cmipt-gcs-back-end",title:"Working on [gcs-back-end](https://github.com/CMIPT/gcs-back-end).",description:"",section:"News"},{id:"projects-gcs-back-end",title:"gcs-back-end",description:"",section:"Projects",handler:()=>{window.location.href="/projects/gcs-back-end/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6B%61%69%73%65%72%71%7A%79%75%65@%66%6F%78%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Kaiser-Yang","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>