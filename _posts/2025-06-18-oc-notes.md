---
layout: post
title: 'Cradle to Grave Devotion: Objective C Notes'
date: 2025-06-18 19:57:02+0800
last_updated: 2025-06-18 19:57:02+0800
description: This post includes some notes on Objective C.
tags:
  - Objective C
categories: Potpourri
featured:
giscus_comments: true
toc:
  sidebar: left
related_posts: true
pretty_table: true
---

## Categories of Objective C

There is a very interesting syntax in Objective C: the category.

A category is a way to add methods to an existing class without modifying the original class.

To use a category, you first need to define it in a header file (`.h` file)
and then implement it in an implementation file (`.m` file or `.mm` file).

Here is an example of a category that extends the `NSString`
class to add a method that reverses a string:

```objective-c
// NSString+Reverse.h
#import <Foundation/Foundation.h>
@interface NSString (Reverse)
- (NSString *)reversedString;
@end

// NSString+Reverse.m
#import "NSString+Reverse.h"
@implementation NSString (Reverse)
- (NSString *)reversedString {
    NSMutableString *reversed = [NSMutableString stringWithCapacity:[self length]];
    for (NSInteger i = [self length] - 1; i >= 0; i--) {
        [reversed appendFormat:@"%C", [self characterAtIndex:i]];
    }
    return reversed;
}
```

We usually name the files with the format `ClassName+CategoryName.h` and `ClassName+CategoryName.m`.
With these files, now you can use the `reversedString` method on any `NSString` object:

```objective-c
// import the category header file
#import "NSString+Reverse.h"

NSString *original = @"Hello, World!";
NSString *reversed = [original reversedString];
```

Of course, you can also add class methods (`+` methods) to a category.
But note that you cannot add new properties to a category,
and you cannot access the ivars (instance variables) of the original class directly.

You can define multiple categories for the same class,
but be careful to avoid method name conflicts.

You can also use the methods defined in a category in another category,
and you just need to import the category header file
in the implementation file of the other category.

## Class Extensions

Class extensions are also called anonymous categories.

Unlike normal categories,
class extensions are defined and implemented in implementation files,
and usually used to add private methods or properties to a class.

Here is an example of a class extension:

```objective-c
// Person.mm
#import "Person.h"
#import <Foundation/Foundation.h>
@interface Person ()
@property (nonatomic, strong) NSString *privateProperty;
- (void)privateMethod;
@end

@implementation Person
- (void)privateMethod {
    NSLog(@"This is a private method.");
}
@end

```

The `privateProperty` and `privateMethod` are only accessible within the `Person` class.

Actually, you can still access the private methods
from outside the class using `performSelector`. For example:

```objective-c
Person *person = [[Person alloc] init];
[person performSelector:@selector(privateMethod)];
// With parameters, but only support at most two parameters
[person performSelector:@selector(privateMethod:withArg:) withObject:@"arg1" withObject:@"arg2"];
```

## Protocols

Protocols in Objective C are similar to interfaces in other languages.
They define a set of methods that a class can implement.

You can use `@protocol` to define a protocol,
and then use `@optional` or `@required` to specify whether the methods are optional or required.
The default is `@required`. And when you use `@optional` or `@required`,
all the methods following it will be optional or required until the end of the protocol
or the next `@optional` or `@required`.

Here is an example of a protocol:

```objective-c
@protocol MyProtocol
@required
- (void)requiredMethod;
- (void)anotherRequiredMethod;
@optional
- (void)optionalMethod;
- (void)anotherOptionalMethod;
@end
```

To declare a class that conforms to a protocol,
you can use the `<ProtocolName>` syntax in the class declaration.
If the class implements more than one protocol,
you can separate them with commas.

```objective-c
@interface MyClass : NSObject <MyProtocol, AnotherProtocol>
@end
```

When a class conforms to a protocol,
it must implement all the required methods of the protocol.
If it does not implement all the required methods,
the compiler will generate a warning or error.

And you can specify that a property conforms to protocols,
like this:

```objective-c
@interface MyClass
// We use 'id' for properties that conform to protocols
@property (nonatomic, strong) id<MyProtocol> myProperty;
@end
```

For optional methods, you may want to check if the object responds to the method
before calling it, using `respondsToSelector:`:

```objective-c
if ([myObject respondsToSelector:@selector(optionalMethod)]) {
    [myObject optionalMethod];
}
```

It is possible to declare a protocol conforming to another protocol,
like this:

```objective-c
@protocol MyProtocol <AnotherProtocol>
// We just declare that 'MyProtocol' conforms to 'AnotherProtocol'
// and we don't need to implement any methods here.
@end
```

When you declare a class that conforms to a protocol,
you must implement all the required methods of the protocol. For example:

```objective-c
// In the .h file
@interface MyClass <MyProtocol>
@end

// In the .m file
@implementation MyClass
- (void)requiredMethod {
    // Implementation of the required method
}
@end
```
