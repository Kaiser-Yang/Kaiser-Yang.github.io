<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2024-09-25T03:49:57+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>This homepage is for sharing everything I know. </subtitle><entry><title type="html">服务器上创建 git 远程仓库</title><link href="https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server/" rel="alternate" type="text/html" title="服务器上创建 git 远程仓库"/><published>2024-09-23T03:12:56+00:00</published><updated>2024-09-23T03:12:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server/"><![CDATA[<p>本篇文章将会介绍如何在服务器上创建一个 <code class="language-plaintext highlighter-rouge">git</code> 中央服务器并且配置 <code class="language-plaintext highlighter-rouge">ssh</code> 连接。</p> <h1 id="必要工具">必要工具</h1> <ul> <li><code class="language-plaintext highlighter-rouge">git</code></li> <li><code class="language-plaintext highlighter-rouge">ssh</code></li> </ul> <h1 id="创建-git-用户">创建 <code class="language-plaintext highlighter-rouge">git</code> 用户</h1> <p>我们一般不会使用 <code class="language-plaintext highlighter-rouge">root</code> 用户来管理 <code class="language-plaintext highlighter-rouge">git</code> 仓库，所以我们可以创建一个用户专门用来管理 <code class="language-plaintext highlighter-rouge">git</code> 仓库，通常 这个用户的名字叫 <code class="language-plaintext highlighter-rouge">git</code>。可以通过以下命令创建一个 <code class="language-plaintext highlighter-rouge">git</code> 用户：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -m 用于创建用户的家目录：/home/git</span>
useradd <span class="nt">-m</span> git
</code></pre></div></div> <p>创建成功后， 我们需要为 <code class="language-plaintext highlighter-rouge">git</code> 用户设置密码：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 第一次可能需要输入 `sudo` 的密码，然后输入两次新密码</span>
<span class="nb">sudo </span>passwd git
</code></pre></div></div> <h1 id="创建仓库">创建仓库</h1> <p>仓库的创建非常简单，我们首先通过以下命令切换到 <code class="language-plaintext highlighter-rouge">git</code> 用户：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 需要输入 `git` 用户的密码，或者可以使用 `sudo su git` 切换，此时需要输入 `sudo` 的密码</span>
su git
</code></pre></div></div> <p>然后我们可以通过以下命令创建一个仓库 <code class="language-plaintext highlighter-rouge">a</code>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 将仓库放置在 /home/git/a.git 目录下</span>
git init <span class="nt">--bare</span> /home/git/a.git
</code></pre></div></div> <h1 id="设置远程-ssh">设置远程 <code class="language-plaintext highlighter-rouge">ssh</code></h1> <p>我们需要为 <code class="language-plaintext highlighter-rouge">git</code> 用户设置 <code class="language-plaintext highlighter-rouge">ssh</code>，这样我们才能通过 <code class="language-plaintext highlighter-rouge">ssh</code> 连接到 <code class="language-plaintext highlighter-rouge">git</code> 服务器。</p> <p>我们只需要通过以下命令创建相应的目录即可：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 切换到 git 用户，以保证目录的权限正确</span>
su git
<span class="c"># ~/.ssh 目录的权限必须是 700，~/.ssh/authorized_keys 的权限必须是 600</span>
<span class="nb">cd</span> ~
<span class="nb">mkdir</span> .ssh <span class="o">&amp;&amp;</span> <span class="nb">chmod </span>700 .ssh
<span class="nb">touch</span> .ssh/authorized_keys <span class="o">&amp;&amp;</span> <span class="nb">chmod </span>600 .ssh/authorized_keys
</code></pre></div></div> <h1 id="上传公钥">上传公钥</h1> <p>我们需要将我们的公钥上传到 <code class="language-plaintext highlighter-rouge">git</code> 服务器，这样我们才能通过 <code class="language-plaintext highlighter-rouge">ssh</code> 连接到 <code class="language-plaintext highlighter-rouge">git</code> 服务器。</p> <p>公钥的创建这里不多介绍。我们只需要将本地的公钥内容全部追加到 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 文件中即可。</p> <h1 id="克隆仓库">克隆仓库</h1> <p>如果一切正常，假定服务器域名为 <code class="language-plaintext highlighter-rouge">1.1.1.1</code>，端口为 <code class="language-plaintext highlighter-rouge">123</code> 的情况下，用户为 <code class="language-plaintext highlighter-rouge">git</code>，仓库路径为 <code class="language-plaintext highlighter-rouge">~/a.git</code>， 我们可以通过以下命令克隆仓库：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 会在当前目录下创建一个 a 目录</span>
git clone ssh://git@1.1.1.1:123/~/a.git
</code></pre></div></div> <p>通过克隆命令获取的仓库，我们可以通过 <code class="language-plaintext highlighter-rouge">git remote -v</code> 查看远程仓库的地址。</p> <p>如果想要手动添加远程仓库，可以通过以下命令：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加一个名为 origin 的远程仓库</span>
git remote add origin ssh://git@1.1.1.1:123/~/a.git
</code></pre></div></div> <h1 id="配置-git-shell">配置 <code class="language-plaintext highlighter-rouge">git-shell</code></h1> <p>如果我们不希望 <code class="language-plaintext highlighter-rouge">git</code> 用户能够登录到服务器，我们可以将 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">shell</code> 设置为 <code class="language-plaintext highlighter-rouge">git-shell</code>，这样 <code class="language-plaintext highlighter-rouge">git</code> 用户只能通过 <code class="language-plaintext highlighter-rouge">git</code> 命令来操作仓库。</p> <p>首先查看 <code class="language-plaintext highlighter-rouge">/etc/shells</code> 中是否有 <code class="language-plaintext highlighter-rouge">git-shell</code>，如果没有，我们需要将 <code class="language-plaintext highlighter-rouge">git-shell</code> 添加到 <code class="language-plaintext highlighter-rouge">/etc/shells</code> 中：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 /etc/shells 中是否有 git-shell</span>
<span class="nb">cat</span> /etc/shells | <span class="nb">grep </span>git-shell
<span class="c"># 如果没有，我们需要将 git-shell 添加到 /etc/shells 中</span>
<span class="nb">echo</span> <span class="si">$(</span>which git-shell<span class="si">)</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/shells
</code></pre></div></div> <p>接下来，我们可以通过以下命令将 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">shell</code> 设置为 <code class="language-plaintext highlighter-rouge">git-shell</code>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>chsh <span class="nt">-s</span> <span class="si">$(</span>which git-shell<span class="si">)</span> git
</code></pre></div></div> <p>设置完成后，<code class="language-plaintext highlighter-rouge">git</code> 用户将不能登录到服务器，只能通过 <code class="language-plaintext highlighter-rouge">git</code> 命令来操作仓库。</p> <h1 id="禁止转发">禁止转发</h1> <p>即使 <code class="language-plaintext highlighter-rouge">git</code> 用户目前不能登录，但是其依然可以执行一些端口转发的操作，我们可以通过在 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 对想要禁止的公钥添加 <code class="language-plaintext highlighter-rouge">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty</code> 来禁止转发。</p> <p>例如，对第一行的公钥进行禁止转发：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在第一行的前面添加后，内容可能如下：</span>
no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAAAA...
</code></pre></div></div> <h1 id="配置快速连接">配置快速连接</h1> <p>通常租用的服务器只有一个 <code class="language-plaintext highlighter-rouge">ip</code> 地址，没有相应的域名解析，不过我们可以通过 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件来配置 快速连接。</p> <p>以之前的例子为例，我们需要在本地的 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中添加以下内容：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host gitserver
  HostName 1.1.1.1
  User git
  Port 123
</code></pre></div></div> <p>这样操作后，我们的 <code class="language-plaintext highlighter-rouge">clone</code> 命令可以简化为：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 这个命令会获取 /home/git/a.git 仓库，因为 ssh 连接时默认路径为 ~</span>
git clone gitserver:a.git
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server">Git on the Server - Setting Up the Server</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="git"/><summary type="html"><![CDATA[本篇文章将会介绍如何在服务器上创建一个 git 中央服务器并且配置 ssh 连接。 必要工具 git ssh 创建 git 用户 我们一般不会使用 root 用户来管理 git 仓库，所以我们可以创建一个用户专门用来管理 git 仓库，通常 这个用户的名字叫 git。可以通过以下命令创建一个 git 用户： # -m 用于创建用户的家目录：/home/git useradd -m git 创建成功后， 我们需要为 git 用户设置密码： # 第一次可能需要输入 `sudo` 的密码，然后输入两次新密码 sudo passwd git 创建仓库 仓库的创建非常简单，我们首先通过以下命令切换到 git 用户： # 需要输入 `git` 用户的密码，或者可以使用 `sudo su git` 切换，此时需要输入 `sudo` 的密码 su git 然后我们可以通过以下命令创建一个仓库 a： # 将仓库放置在 /home/git/a.git 目录下 git init --bare /home/git/a.git 设置远程 ssh 我们需要为 git 用户设置 ssh，这样我们才能通过 ssh 连接到 git 服务器。 我们只需要通过以下命令创建相应的目录即可： # 切换到 git 用户，以保证目录的权限正确 su git # ~/.ssh 目录的权限必须是 700，~/.ssh/authorized_keys 的权限必须是 600 cd ~ mkdir .ssh &amp;&amp; chmod 700 .ssh touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys 上传公钥 我们需要将我们的公钥上传到 git 服务器，这样我们才能通过 ssh 连接到 git 服务器。 公钥的创建这里不多介绍。我们只需要将本地的公钥内容全部追加到 git 用户的 ~/.ssh/authorized_keys 文件中即可。 克隆仓库 如果一切正常，假定服务器域名为 1.1.1.1，端口为 123 的情况下，用户为 git，仓库路径为 ~/a.git， 我们可以通过以下命令克隆仓库： # 会在当前目录下创建一个 a 目录 git clone ssh://git@1.1.1.1:123/~/a.git 通过克隆命令获取的仓库，我们可以通过 git remote -v 查看远程仓库的地址。 如果想要手动添加远程仓库，可以通过以下命令： # 添加一个名为 origin 的远程仓库 git remote add origin ssh://git@1.1.1.1:123/~/a.git 配置 git-shell 如果我们不希望 git 用户能够登录到服务器，我们可以将 git 用户的 shell 设置为 git-shell，这样 git 用户只能通过 git 命令来操作仓库。 首先查看 /etc/shells 中是否有 git-shell，如果没有，我们需要将 git-shell 添加到 /etc/shells 中： # 查看 /etc/shells 中是否有 git-shell cat /etc/shells | grep git-shell # 如果没有，我们需要将 git-shell 添加到 /etc/shells 中 echo $(which git-shell) | sudo tee -a /etc/shells 接下来，我们可以通过以下命令将 git 用户的 shell 设置为 git-shell： sudo chsh -s $(which git-shell) git 设置完成后，git 用户将不能登录到服务器，只能通过 git 命令来操作仓库。 禁止转发 即使 git 用户目前不能登录，但是其依然可以执行一些端口转发的操作，我们可以通过在 ~/.ssh/authorized_keys 对想要禁止的公钥添加 no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty 来禁止转发。 例如，对第一行的公钥进行禁止转发： # 在第一行的前面添加后，内容可能如下： no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAAAA... 配置快速连接 通常租用的服务器只有一个 ip 地址，没有相应的域名解析，不过我们可以通过 ~/.ssh/config 文件来配置 快速连接。 以之前的例子为例，我们需要在本地的 ~/.ssh/config 中添加以下内容： Host gitserver HostName 1.1.1.1 User git Port 123 这样操作后，我们的 clone 命令可以简化为： # 这个命令会获取 /home/git/a.git 仓库，因为 ssh 连接时默认路径为 ~ git clone gitserver:a.git 巨人的肩膀 Git on the Server - Setting Up the Server]]></summary></entry><entry><title type="html">Spring Boot Test 自定义测试类顺序</title><link href="https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order/" rel="alternate" type="text/html" title="Spring Boot Test 自定义测试类顺序"/><published>2024-09-20T07:31:53+00:00</published><updated>2024-09-20T07:31:53+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order/"><![CDATA[<h1 id="起因">起因</h1> <p>在开发一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目的过程中，我编写了三个测试类：<code class="language-plaintext highlighter-rouge">AuthenticationControllerTest</code>, <code class="language-plaintext highlighter-rouge">UserControllerTest</code> 以及 <code class="language-plaintext highlighter-rouge">RepositoryControllerTest</code>。我希望在我执行 <code class="language-plaintext highlighter-rouge">mvn test</code> 的时候能够控制这三个 测试类的执行顺序：</p> <ol> <li><code class="language-plaintext highlighter-rouge">AuthenticationControllerTest</code> 先执行以便获取后续操作的 <code class="language-plaintext highlighter-rouge">token</code></li> <li>接着执行 <code class="language-plaintext highlighter-rouge">RepositoryControllerTest</code> 进行创建仓库的测试以便后续的查询的仓库列表不为空</li> <li>最后执行 <code class="language-plaintext highlighter-rouge">UserControllerTest</code> 进行用户相关的测试</li> </ol> <p>我在网上查找了很多资料，发现大部分都是介绍的如何指定一个测试类中的测试方法的执行顺序，但是没有找到 如何指定多个测试类的执行顺序的资料。</p> <p>这里简单介绍一下如何指定同一个类中的 <code class="language-plaintext highlighter-rouge">@Test</code> 修饰的方法的执行顺序：</p> <ul> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</code> 并在测试方法上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 注解可以实现按照 <code class="language-plaintext highlighter-rouge">@Order</code> 中的值从小到大的顺序执行测试方法。</li> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.Random.class)</code> 可以实现随机执行测试方法。</li> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.DisplayName.class)</code> 可以实现按照测试方法的名称的 字典序执行测试方法。</li> </ul> <h1 id="蓦然回首">蓦然回首</h1> <p>找了很多网上的资料都没有找到解决方案，于是我决定去 <code class="language-plaintext highlighter-rouge">Junit5</code> 翻阅一下官方文档，我便在官方文档中找到了 这样一段话：</p> <blockquote> <p>To configure test class execution order globally for the entire test suite, use the <code class="language-plaintext highlighter-rouge">junit.jupiter.testclass.order.default</code> configuration parameter to specify the fully qualified class name of the ClassOrderer you would like to use. The supplied class must implement the <code class="language-plaintext highlighter-rouge">ClassOrderer</code> interface.</p> </blockquote> <p>随即在后文又提到了如何配置这个变量：</p> <blockquote> <p>For example, for the <code class="language-plaintext highlighter-rouge">@Order</code> annotation to be honored on test classes, you should configure the <code class="language-plaintext highlighter-rouge">ClassOrderer.OrderAnnotation</code> class orderer using the configuration parameter with the corresponding fully qualified class name (e.g., in <code class="language-plaintext highlighter-rouge">src/test/resources/junit-platform.properties</code>).</p> </blockquote> <p>也就是说如果在 <code class="language-plaintext highlighter-rouge">src/test/resources/junit-platform.properties</code> 中添加如下内容：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">junit.jupiter.testclass.order.default</span><span class="p">=</span><span class="s">org.junit.jupiter.api.ClassOrderer$OrderAnnotation</span>
</code></pre></div></div> <p>便可以通过在测试类上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 的方式控制测试类的执行顺序。</p> <p>这样一来这个问题也就解决了。但是我想每次都需要在测试类上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 也是很麻烦的，于是我自定义了 一个 <code class="language-plaintext highlighter-rouge">SpringBootTestClassOrderer</code> 类，只需要按照顺序在 <code class="language-plaintext highlighter-rouge">classOrder</code> 中添加测试类即可以按照顺序执行：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringBootTestClassOrderer</span> <span class="kd">implements</span> <span class="nc">ClassOrderer</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classOrder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span>
        <span class="nc">AuthenticationControllerTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="nc">RepositoryControllerTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="nc">UserControllerTest</span><span class="o">.</span><span class="na">class</span>
    <span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">orderClasses</span><span class="o">(</span><span class="nc">ClassOrdererContext</span> <span class="n">classOrdererContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">classOrdererContext</span><span class="o">.</span><span class="na">getClassDescriptors</span><span class="o">().</span><span class="na">sort</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="nl">SpringBootTestClassOrderer:</span><span class="o">:</span><span class="n">getOrder</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nc">ClassDescriptor</span> <span class="n">classDescriptor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classOrder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">classDescriptor</span><span class="o">.</span><span class="na">getTestClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">classOrder</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>最后我的 <code class="language-plaintext highlighter-rouge">junit-platform.properties</code> 文件如下：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">junit.jupiter.testclass.order.default</span><span class="p">=</span><span class="s">edu.cmipt.gcs.SpringBootTestClassOrderer</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes">Junit 5 Class Order</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot Test"/><category term="Junit"/><summary type="html"><![CDATA[起因 在开发一个 Spring Boot 项目的过程中，我编写了三个测试类：AuthenticationControllerTest, UserControllerTest 以及 RepositoryControllerTest。我希望在我执行 mvn test 的时候能够控制这三个 测试类的执行顺序： AuthenticationControllerTest 先执行以便获取后续操作的 token 接着执行 RepositoryControllerTest 进行创建仓库的测试以便后续的查询的仓库列表不为空 最后执行 UserControllerTest 进行用户相关的测试 我在网上查找了很多资料，发现大部分都是介绍的如何指定一个测试类中的测试方法的执行顺序，但是没有找到 如何指定多个测试类的执行顺序的资料。 这里简单介绍一下如何指定同一个类中的 @Test 修饰的方法的执行顺序： 在测试类上添加 @TestMethodOrder(MethodOrderer.OrderAnnotation.class) 并在测试方法上添加 @Order 注解可以实现按照 @Order 中的值从小到大的顺序执行测试方法。 在测试类上添加 @TestMethodOrder(MethodOrderer.Random.class) 可以实现随机执行测试方法。 在测试类上添加 @TestMethodOrder(MethodOrderer.DisplayName.class) 可以实现按照测试方法的名称的 字典序执行测试方法。 蓦然回首 找了很多网上的资料都没有找到解决方案，于是我决定去 Junit5 翻阅一下官方文档，我便在官方文档中找到了 这样一段话： To configure test class execution order globally for the entire test suite, use the junit.jupiter.testclass.order.default configuration parameter to specify the fully qualified class name of the ClassOrderer you would like to use. The supplied class must implement the ClassOrderer interface. 随即在后文又提到了如何配置这个变量： For example, for the @Order annotation to be honored on test classes, you should configure the ClassOrderer.OrderAnnotation class orderer using the configuration parameter with the corresponding fully qualified class name (e.g., in src/test/resources/junit-platform.properties). 也就是说如果在 src/test/resources/junit-platform.properties 中添加如下内容： junit.jupiter.testclass.order.default=org.junit.jupiter.api.ClassOrderer$OrderAnnotation 便可以通过在测试类上添加 @Order 的方式控制测试类的执行顺序。 这样一来这个问题也就解决了。但是我想每次都需要在测试类上添加 @Order 也是很麻烦的，于是我自定义了 一个 SpringBootTestClassOrderer 类，只需要按照顺序在 classOrder 中添加测试类即可以按照顺序执行： public class SpringBootTestClassOrderer implements ClassOrderer { private static final Class&lt;?&gt;[] classOrder=new Class[] { AuthenticationControllerTest.class, RepositoryControllerTest.class, UserControllerTest.class }; @Override public void orderClasses(ClassOrdererContext classOrdererContext) { classOrdererContext.getClassDescriptors().sort(Comparator.comparingInt(SpringBootTestClassOrderer::getOrder)); } private static int getOrder(ClassDescriptor classDescriptor) { for (int i=0; i &lt; classOrder.length; i++) { if (classDescriptor.getTestClass().equals(classOrder[i])) { return i; } } return Integer.MAX_VALUE; } } 最后我的 junit-platform.properties 文件如下： junit.jupiter.testclass.order.default=edu.cmipt.gcs.SpringBootTestClassOrderer 巨人的肩膀 Junit 5 Class Order]]></summary></entry><entry><title type="html">Spring 多次读取请求体</title><link href="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/" rel="alternate" type="text/html" title="Spring 多次读取请求体"/><published>2024-09-19T02:47:47+00:00</published><updated>2024-09-19T02:47:47+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/"><![CDATA[<h1 id="起因">起因</h1> <p>在某次项目中，我需要在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">request</code> 的 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容以检验数据是否符合要求。 但当我在 <code class="language-plaintext highlighter-rouge">Filter</code> 添加通过 <code class="language-plaintext highlighter-rouge">request.getReader()</code> 获取 <code class="language-plaintext highlighter-rouge">body</code> 的代码后，进行测试时，抛出了异常，异常 信息显式 <code class="language-plaintext highlighter-rouge">getReader() has already been called for this request stack</code>。</p> <h1 id="问题分析">问题分析</h1> <p>对于一个流而言，其通常只能被读取一次，当我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行第一次读取后，后续到 <code class="language-plaintext highlighter-rouge">Controller</code> 部分 时，由于有 <code class="language-plaintext highlighter-rouge">@RequestBody</code> 注释的对象，此时会再次读取 <code class="language-plaintext highlighter-rouge">body</code> 部分，这时就会抛出异常。</p> <h1 id="解决方案">解决方案</h1> <p>解决方案也很简单，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletReqeust</code> 继承 <code class="language-plaintext highlighter-rouge">HttpServletRequestWrapper</code>， 在其中缓存 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容，然后在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">body</code> 时，直接从缓存中获取即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyHttpServletRequest</span> <span class="kd">extends</span> <span class="nc">HttpServletRequestWrapper</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyServletInputStream</span> <span class="kd">extends</span> <span class="nc">ServletInputStream</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">InputStream</span> <span class="n">cacheBodyInputStream</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cacheBodyInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">cacheBody</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFinished</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isReady</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setReadListener</span><span class="o">(</span><span class="nc">ReadListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="nc">InputStream</span> <span class="n">requestInputStream</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span> <span class="o">=</span> <span class="nc">StreamUtils</span><span class="o">.</span><span class="na">copyToByteArray</span><span class="o">(</span><span class="n">requestInputStream</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">ServletInputStream</span> <span class="nf">getInputStream</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BufferedReader</span> <span class="nf">getReader</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BufferedReader</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行处理的时候需要创建一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletRequest</code> 对象，然后将其传递给 <code class="language-plaintext highlighter-rouge">FilterChain</code> 的 <code class="language-plaintext highlighter-rouge">doFilter</code> 方法即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span>
        <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">CachedBodyHttpServletRequest</span> <span class="n">cachedRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="c1">// do something</span>
    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">cachedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://dev.to/cynavi/reading-request-body-multiple-times-in-javaspring-boot-1j53">Reading Request Body Multiple Times in Java/Spring Boot</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><summary type="html"><![CDATA[起因 在某次项目中，我需要在 Filter 中获取 request 的 body 部分的内容以检验数据是否符合要求。 但当我在 Filter 添加通过 request.getReader() 获取 body 的代码后，进行测试时，抛出了异常，异常 信息显式 getReader() has already been called for this request stack。 问题分析 对于一个流而言，其通常只能被读取一次，当我们在 Filter 中进行第一次读取后，后续到 Controller 部分 时，由于有 @RequestBody 注释的对象，此时会再次读取 body 部分，这时就会抛出异常。 解决方案 解决方案也很简单，我们只需要自定义一个 CachedBodyHttpServletReqeust 继承 HttpServletRequestWrapper， 在其中缓存 body 部分的内容，然后在 Filter 中获取 body 时，直接从缓存中获取即可： private class CachedBodyHttpServletRequest extends HttpServletRequestWrapper { private class CachedBodyServletInputStream extends ServletInputStream { private final InputStream cacheBodyInputStream; public CachedBodyServletInputStream(byte[] cacheBody) { this.cacheBodyInputStream = new ByteArrayInputStream(cacheBody); } @Override public boolean isFinished() { try { return cacheBodyInputStream.available() == 0; } catch (IOException e) { return true; } } @Override public boolean isReady() { return true; } @Override public void setReadListener(ReadListener listener) { throw new UnsupportedOperationException(); } @Override public int read() throws IOException { return cacheBodyInputStream.read(); } } private final byte[] cacheBody; public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException { super(request); InputStream requestInputStream=request.getInputStream(); this.cacheBody = StreamUtils.copyToByteArray(requestInputStream); } @Override public ServletInputStream getInputStream() { return new CachedBodyServletInputStream(this.cacheBody); } @Override public BufferedReader getReader() { return new BufferedReader( new InputStreamReader(new ByteArrayInputStream(this.cacheBody))); } } 这样我们在 Filter 中进行处理的时候需要创建一个 CachedBodyHttpServletRequest 对象，然后将其传递给 FilterChain 的 doFilter 方法即可： @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CachedBodyHttpServletRequest cachedRequest=new CachedBodyHttpServletRequest(request); // do something filterChain.doFilter(cachedRequest, response); } 巨人的肩膀 Reading Request Body Multiple Times in Java/Spring Boot]]></summary></entry><entry><title type="html">Long 在 Swagger 中精度丢失</title><link href="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/" rel="alternate" type="text/html" title="Long 在 Swagger 中精度丢失"/><published>2024-09-19T02:06:08+00:00</published><updated>2024-09-19T02:06:08+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/"><![CDATA[<h1 id="起因">起因</h1> <p>某次通过 <code class="language-plaintext highlighter-rouge">Swagger</code> 在项目中进行测试的时候，发现响应体中返回的 <code class="language-plaintext highlighter-rouge">id</code> (<code class="language-plaintext highlighter-rouge">Long</code> 类型，由雪花算法生成) 与 数据库中存储的 <code class="language-plaintext highlighter-rouge">id</code> 始终差那么一点点。</p> <h1 id="排查">排查</h1> <p>起先我认为是后端传得数据本身就有问题，于是我在 <code class="language-plaintext highlighter-rouge">Controller</code> 中进行返回数据的时候，将 <code class="language-plaintext highlighter-rouge">id</code> 的值 打印出来，发现 <code class="language-plaintext highlighter-rouge">id</code> 的值是正确的。于是我又在终端中单独执行了 <code class="language-plaintext highlighter-rouge">curl</code> 命令去获取数据，发现 <code class="language-plaintext highlighter-rouge">id</code> 的 值也是正确的。这时候我就很疑惑了，为什么在 <code class="language-plaintext highlighter-rouge">Swagger</code> 中获取的数据会有问题呢？</p> <p>接着我猜测是出现了精度丢失的问题，我猜想 <code class="language-plaintext highlighter-rouge">Long</code> 类型可能不能完全在 <code class="language-plaintext highlighter-rouge">js</code> 中表示，于是 <code class="language-plaintext highlighter-rouge">Swagger</code> 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 <code class="language-plaintext highlighter-rouge">Long 精度丢失</code> 便找到了相关的内容：</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">JavaScript</code> 的 <code class="language-plaintext highlighter-rouge">Number</code> 类型是基于 <code class="language-plaintext highlighter-rouge">IEEE 754</code> 标准的双精度浮点数格式，只能安全地表示 <code class="language-plaintext highlighter-rouge">53</code> 位 二进制数字，也就是 <code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code> 的值 <code class="language-plaintext highlighter-rouge">9007199254740991</code>。</p> </blockquote> <h1 id="解决方法">解决方法</h1> <p>网上的解决方法有很多，例如可以通过在类中 <code class="language-plaintext highlighter-rouge">Long</code> 字段上添加 <code class="language-plaintext highlighter-rouge">@JsonsSerialize(using = ToStringSerializer.class)</code> 注解，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。</p> <p>我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象和发送给前端的 <code class="language-plaintext highlighter-rouge">VO</code> 对象中的 <code class="language-plaintext highlighter-rouge">id</code> 字段更改成 <code class="language-plaintext highlighter-rouge">String</code> 类型，然后在从 <code class="language-plaintext highlighter-rouge">DTO</code> 类型构造 <code class="language-plaintext highlighter-rouge">PO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">String</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">Long</code> 类型，在从 <code class="language-plaintext highlighter-rouge">PO</code> 对象构造 <code class="language-plaintext highlighter-rouge">VO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。这样的好处在于，对于前端而言，<code class="language-plaintext highlighter-rouge">id</code> 确确 实实是一个 <code class="language-plaintext highlighter-rouge">String</code> 类型的字段，前端并不会知道 <code class="language-plaintext highlighter-rouge">id</code> 实际上是以 <code class="language-plaintext highlighter-rouge">Long</code> 类型进行存储的。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通过 UserPO 构造 UserVO</span>
<span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 通过 UserDTO 构造 UserPO</span>
<span class="kd">public</span> <span class="nf">UserPO</span><span class="o">(</span><span class="nc">UserDTO</span> <span class="n">userDTO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">userDTO</span><span class="o">.</span><span class="na">id</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://cloud.tencent.com/developer/article/2445079">长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring-Doc"/><category term="OpenAPI"/><summary type="html"><![CDATA[起因 某次通过 Swagger 在项目中进行测试的时候，发现响应体中返回的 id (Long 类型，由雪花算法生成) 与 数据库中存储的 id 始终差那么一点点。 排查 起先我认为是后端传得数据本身就有问题，于是我在 Controller 中进行返回数据的时候，将 id 的值 打印出来，发现 id 的值是正确的。于是我又在终端中单独执行了 curl 命令去获取数据，发现 id 的 值也是正确的。这时候我就很疑惑了，为什么在 Swagger 中获取的数据会有问题呢？ 接着我猜测是出现了精度丢失的问题，我猜想 Long 类型可能不能完全在 js 中表示，于是 Swagger 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 Long 精度丢失 便找到了相关的内容： JavaScript 的 Number 类型是基于 IEEE 754 标准的双精度浮点数格式，只能安全地表示 53 位 二进制数字，也就是 Number.MAX_SAFE_INTEGER 的值 9007199254740991。 解决方法 网上的解决方法有很多，例如可以通过在类中 Long 字段上添加 @JsonsSerialize(using = ToStringSerializer.class) 注解，将 Long 类型转换为 String 类型。 我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 DTO 对象和发送给前端的 VO 对象中的 id 字段更改成 String 类型，然后在从 DTO 类型构造 PO 对象的时候，将 String 类型的 id 字段转换为 Long 类型，在从 PO 对象构造 VO 对象的时候，将 Long 类型的 id 字段转换为 String 类型。这样的好处在于，对于前端而言，id 确确 实实是一个 String 类型的字段，前端并不会知道 id 实际上是以 Long 类型进行存储的。 // 通过 UserPO 构造 UserVO public UserVO(UserPO userPO) { this(userPO.getId().toString()); } // 通过 UserDTO 构造 UserPO public UserPO(UserDTO userDTO) { try { this.id = Long.valueOf(userDTO.id()); } catch (NumberFormatException e) { this.id = null; } } 巨人的肩膀 长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅]]></summary></entry><entry><title type="html">Spring Validation 路径变量与请求参数校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/" rel="alternate" type="text/html" title="Spring Validation 路径变量与请求参数校验"/><published>2024-09-18T12:43:30+00:00</published><updated>2024-09-18T12:43:30+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 从请求路径中 获取或者通过 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 从请求参数中获取。本文将介绍如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@ReqeustParam</code> 获取的基本类型参数进行校验。</p> <h1 id="validated"><code class="language-plaintext highlighter-rouge">@Validated</code></h1> <p>要对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 获取的参数进行校验，我们必须要在控制器类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。该注解由 <code class="language-plaintext highlighter-rouge">Spring</code> 提供以实现比 <code class="language-plaintext highlighter-rouge">JSR-303</code> 更加灵活的功能。</p> <p>在 <code class="language-plaintext highlighter-rouge">@Validated</code> 官方的文档中，有这样一句话：</p> <blockquote> <p>Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with.</p> </blockquote> <p>简单来说就是当 <code class="language-plaintext highlighter-rouge">@Validated</code> 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。</p> <p>完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Validated</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_CHECK_EMAIL_VALIDITY_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkEmailValidity</span><span class="o">(</span>
            <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
            <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
            <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"email"</span><span class="o">)</span>
            <span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"email"</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">EMAIL_ALREADY_EXISTS</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样操作后，当请求到达 <code class="language-plaintext highlighter-rouge">checkEmailValidity</code> 方法时，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动对 <code class="language-plaintext highlighter-rouge">email</code> 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 <code class="language-plaintext highlighter-rouge">ConstraintViolationException</code> 而不是 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code>。我们可以通过以下的方式进行全局异常处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">ConstraintViolationException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleConstraintViolationException</span><span class="o">(</span>
            <span class="nc">ConstraintViolationException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// do something</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://reflectoring.io/bean-validation-with-spring-boot/#validating-path-variables-and-request-parameters">Validation with Spring Boot - the Complete Guide</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring Validation 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 @PathVariable 从请求路径中 获取或者通过 @RequestParam 从请求参数中获取。本文将介绍如何使用 Spring Validation 对通过 @PathVariable 和 @ReqeustParam 获取的基本类型参数进行校验。 @Validated 要对通过 @PathVariable 和 @RequestParam 获取的参数进行校验，我们必须要在控制器类上添加 @Validated 注解。该注解由 Spring 提供以实现比 JSR-303 更加灵活的功能。 在 @Validated 官方的文档中，有这样一句话： Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with. 简单来说就是当 @Validated 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 @Validated 注解。 完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如： @Validated @RestController public class UserController { @Autowired private UserService userService; @GetMapping(ApiPathConstant.USER_CHECK_EMAIL_VALIDITY_API_PATH) public void checkEmailValidity( @Email(message = "USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank(message = "USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") @RequestParam("email") String email) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("email", email); if (userService.exists(wrapper)) { throw new GenericException(ErrorCodeEnum.EMAIL_ALREADY_EXISTS, email); } } } 这样操作后，当请求到达 checkEmailValidity 方法时，Spring 会自动对 email 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 ConstraintViolationException 而不是 MethodArgumentNotValidException。我们可以通过以下的方式进行全局异常处理： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ConstraintViolationException.class) public ResponseEntity&lt;ErrorVO&gt; handleConstraintViolationException( ConstraintViolationException e, HttpServletRequest request) { // do something } } 巨人的肩膀 Validation with Spring Boot - the Complete Guide]]></summary></entry><entry><title type="html">Linux 大杂烩</title><link href="https://kaiser-yang.github.io/blog/2024/linux-potpourri/" rel="alternate" type="text/html" title="Linux 大杂烩"/><published>2024-09-10T12:30:06+00:00</published><updated>2024-09-10T12:30:06+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/linux-potpourri</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/linux-potpourri/"><![CDATA[<h1 id="wildcards-in-linux">Wildcards in Linux</h1> <p>这里的 <code class="language-plaintext highlighter-rouge">wildcards</code> 指的是能够被 <code class="language-plaintext highlighter-rouge">shell</code> 扩展的符号。如果在执行的命令中出现这些符号，<code class="language-plaintext highlighter-rouge">shell</code> 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 <code class="language-plaintext highlighter-rouge">shell</code> 支持，这些 <code class="language-plaintext highlighter-rouge">wildcards</code> 是可以在任意 命令中使用的。</p> <p>常见的 <code class="language-plaintext highlighter-rouge">wildcards</code> 有以下几种：</p> <ul> <li><code class="language-plaintext highlighter-rouge">*</code>：匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">**</code>：递归匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">?</code>：匹配单个任意字符</li> <li><code class="language-plaintext highlighter-rouge">[]</code>：匹配出现在中括号中的某个符号，在中括号中可以使用 <code class="language-plaintext highlighter-rouge">-</code> 来表示范围，也可以使用 <code class="language-plaintext highlighter-rouge">!</code> 来表示取反， 例如 <code class="language-plaintext highlighter-rouge">[!0-9]</code> 表示匹配不是数字的字符，<code class="language-plaintext highlighter-rouge">[!ab]</code> 表示不是 <code class="language-plaintext highlighter-rouge">a</code> 也不是 <code class="language-plaintext highlighter-rouge">b</code> 的字符</li> </ul> <p>上面的通配符并不是所有的 <code class="language-plaintext highlighter-rouge">shell</code> 都支持的，但是在 <code class="language-plaintext highlighter-rouge">bash</code> 中是支持的。例如在 <code class="language-plaintext highlighter-rouge">fish shell</code> 中，只有 <code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">**</code> 以及 <code class="language-plaintext highlighter-rouge">?</code> 是支持的，其中 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 不会匹配 <code class="language-plaintext highlighter-rouge">/</code>，而 <code class="language-plaintext highlighter-rouge">**</code> 会匹配 <code class="language-plaintext highlighter-rouge">/</code> ，也就是说 <code class="language-plaintext highlighter-rouge">**</code> 是 递归匹配。</p> <p><strong>注意</strong>：在正则表达式的语法中，<code class="language-plaintext highlighter-rouge">*</code> 表示匹配前面的字符 0 次或者多次，<code class="language-plaintext highlighter-rouge">?</code> 表示匹配前面的字符 0 次或者 1 次， <code class="language-plaintext highlighter-rouge">[]</code> 表示匹配中括号中的任意一个字符，<code class="language-plaintext highlighter-rouge">-</code> 表示范围，<code class="language-plaintext highlighter-rouge">^</code> 表示取反。</p> <h1 id="常用命令-cheat-sheet">常用命令 <code class="language-plaintext highlighter-rouge">Cheat Sheet</code></h1> <h2 id="cat"><code class="language-plaintext highlighter-rouge">cat</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>显示非空行的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>合并多个空行为一个空行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">^</code> 和 <code class="language-plaintext highlighter-rouge">M-</code> 显示不可打印字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>在每行的结尾显示 <code class="language-plaintext highlighter-rouge">$</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-T</code></td> <td>将制表符显示为 <code class="language-plaintext highlighter-rouge">^I</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-</code></td> <td>从标准输入读取内容</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">cat</code> 可以直接创建带有内容的文件或者追加内容到文件中，例如 <code class="language-plaintext highlighter-rouge">cat &gt; file</code> 会等待输入，当输入完成 后，使用 <code class="language-plaintext highlighter-rouge">^D</code> (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 <code class="language-plaintext highlighter-rouge">cat &gt;&gt; file</code>。</p> <p><code class="language-plaintext highlighter-rouge">-</code> 可以出现在多个文件的任意位置，例如 <code class="language-plaintext highlighter-rouge">cat file1 - file2</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，而 <code class="language-plaintext highlighter-rouge">cat file1 - file2 - file3</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，<code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，然后输入第二次，再次使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，第一次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容 之间，第二次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间。</p> <p>补充：<code class="language-plaintext highlighter-rouge">tac</code> 可以将文件内容逆序输出 (优先输出最后一行)，<code class="language-plaintext highlighter-rouge">tac</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">cat</code> 的逆序。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">cat</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">concatenate</code>，即连接的意思，其可以将多个文件的内容拼接在一起。</p> <h2 id="grep"><code class="language-plaintext highlighter-rouge">grep</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归搜索目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--include "*.py"</code></td> <td>搜索指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude "test*"</code></td> <td>排除指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude-dir "test*"</code></td> <td>排除指定目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--color=auto,always,never</code></td> <td>何时进行高亮</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号。这里的行号指的是文件中的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>只显示文件名。当对多个文件中的内容进行匹配时，使用 <code class="language-plaintext highlighter-rouge">-l</code> 会在匹配成功时只显示文件名，而不是文件中具体的位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>只显示不含有任何匹配的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>反向匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>显示匹配次数。使用 <code class="language-plaintext highlighter-rouge">-v</code> 时，显示反向匹配的数量</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>只显示匹配的部分</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>指定匹配的次数。例如 <code class="language-plaintext highlighter-rouge">-m 1</code> 表示当有多个匹配的时候只显示第一个匹配。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>从文件中读取模式。文件中每行一个模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>指定模式。可以指定多个模式，例如 <code class="language-plaintext highlighter-rouge">grep -e pattern1 -e pattern2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>只匹配整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A 2</code></td> <td>显示匹配行的后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-B 2</code></td> <td>显示匹配行的前两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C 2</code></td> <td>显示匹配行的前两行和后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>使用扩展正则表达式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>显示文件名。默认情况下，当只有一个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 不会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-H</code> 可以强制显示文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>不显示文件名。默认情况下，当有多个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-h</code> 可以强制不显示文件名</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-m 1</code> 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">grep</code> 的正则表达式是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的基本正则表达式，而 <code class="language-plaintext highlighter-rouge">egrep</code> 和 <code class="language-plaintext highlighter-rouge">grep -E</code> 是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的扩展正则表达式。<code class="language-plaintext highlighter-rouge">grep</code> 和 <code class="language-plaintext highlighter-rouge">egrep</code> 的区别在于 <code class="language-plaintext highlighter-rouge">egrep</code> 默认使用扩展正则表达式，而 <code class="language-plaintext highlighter-rouge">grep</code> 默认使用基本 正则表达式。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">grep</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">g/re/p</code>，其中 <code class="language-plaintext highlighter-rouge">g</code> 表示 <code class="language-plaintext highlighter-rouge">global</code>，<code class="language-plaintext highlighter-rouge">re</code> 表示 <code class="language-plaintext highlighter-rouge">regular expression</code>，<code class="language-plaintext highlighter-rouge">p</code> 表示 <code class="language-plaintext highlighter-rouge">print</code>，直译即全局正则表达式打印。</p> <h2 id="sort"><code class="language-plaintext highlighter-rouge">sort</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>逆序排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>按照数字排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>按照某一列排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>去重</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>忽略大小写。默认情况下，大写会在所有小写的前面，而使用 <code class="language-plaintext highlighter-rouge">-f</code> 可以让大小写混合在一起排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>人类可读的排序。例如 <code class="language-plaintext highlighter-rouge">1K</code> 会被排序到 <code class="language-plaintext highlighter-rouge">512</code> 的前面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-M</code></td> <td>按照月份排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=-</code></td> <td>从标准输入读取以 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=filename</code></td> <td>从某个文件中读取 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查文件是否已经排序</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-k</code> 可以指定多个列，例如 <code class="language-plaintext highlighter-rouge">-k2,2 -k1,1</code> 表示先按照第二列排序，然后再按照第一列排序。<code class="language-plaintext highlighter-rouge">-k</code> 也 按照某列的部分进行排序，例如 <code class="language-plaintext highlighter-rouge">-k2.2,2.3</code> 表示按照第二列的第二个字符到第三个字符进行排序。<code class="language-plaintext highlighter-rouge">-k</code> 还可以 指定列的类型，例如 <code class="language-plaintext highlighter-rouge">-k2n,2</code> 表示按照第二列的数字进行排序。<code class="language-plaintext highlighter-rouge">-r</code> 选项也可以指定到 <code class="language-plaintext highlighter-rouge">-k</code> 选项中，例如 <code class="language-plaintext highlighter-rouge">-k2r,2</code> 表示按照第二列逆序排序。</p> <h2 id="awk"><code class="language-plaintext highlighter-rouge">awk</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>指定输入的分隔符。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">awk</code> 脚本文件。</td> </tr> </tbody> </table> <h3 id="打印列">打印列</h3> <ul> <li><code class="language-plaintext highlighter-rouge">$0</code>: 整行</li> <li><code class="language-plaintext highlighter-rouge">$1</code>: 第一列</li> <li><code class="language-plaintext highlighter-rouge">...</code></li> <li><code class="language-plaintext highlighter-rouge">$NF</code>: 最后一列</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}'</code> 打印出每行的第一列、第二列和最后一列。</p> <h3 id="分隔符">分隔符</h3> <p>可以通过 <code class="language-plaintext highlighter-rouge">OFS=</code> (Output Field Separator) 来指定输出的分隔符，例如 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}' OFS=","</code> 表示使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。也可以在 <code class="language-plaintext highlighter-rouge">BEGIN</code> 模式串中指定 <code class="language-plaintext highlighter-rouge">OFS</code>，例如 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {OFS=","} {print $1,$2,$NF}'</code>。</p> <p>除了 <code class="language-plaintext highlighter-rouge">OFS</code> 以外，还有 <code class="language-plaintext highlighter-rouge">FS</code> 用于指定输入文件的分隔符。</p> <h3 id="预定义变量">预定义变量</h3> <p>除了之前提到的 <code class="language-plaintext highlighter-rouge">OFS</code>, <code class="language-plaintext highlighter-rouge">FS</code> 之外，还有一些预定义变量：</p> <ul> <li><code class="language-plaintext highlighter-rouge">NR</code>: 当前行的行号</li> <li><code class="language-plaintext highlighter-rouge">NF</code>: 当前行的列数</li> <li><code class="language-plaintext highlighter-rouge">RS</code>：记录分隔符，默认是换行符，也就是每一行作为一条记录</li> <li><code class="language-plaintext highlighter-rouge">ORS</code>：输出的记录分隔符，默认是换行符</li> <li><code class="language-plaintext highlighter-rouge">FILENAME</code>：当前文件的文件名</li> <li><code class="language-plaintext highlighter-rouge">FNR</code>：当前文件的行号，当时用多个文件的时候，<code class="language-plaintext highlighter-rouge">NR</code> 记录的是当前的总行号，而 <code class="language-plaintext highlighter-rouge">FNR</code> 记录的是当前文件的行号</li> </ul> <p>我们可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1'</code> 从第二行开始打印，也可以使用 <code class="language-plaintext highlighter-rouge">awk 'NF &gt; 0'</code> 打印列数大于 <code class="language-plaintext highlighter-rouge">0</code> 的行 (也就是移除空行)。</p> <p>如果要打印第一行到第四行，我们可以通过 <code class="language-plaintext highlighter-rouge">awk 'NR == 1, NR == 4'</code> 来实现。其中的 <code class="language-plaintext highlighter-rouge">,</code> 表示范围，<code class="language-plaintext highlighter-rouge">NR == 1</code> 表示第一行，<code class="language-plaintext highlighter-rouge">NR == 4</code> 表示第四行。我们还可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 &amp;&amp; NR &lt; 5'</code> 来实现。</p> <h3 id="模式">模式</h3> <p><code class="language-plaintext highlighter-rouge">BEGIN</code> 和 <code class="language-plaintext highlighter-rouge">END</code> 模式串：</p> <ul> <li><code class="language-plaintext highlighter-rouge">BEGIN</code>: 在处理输入之前执行</li> <li><code class="language-plaintext highlighter-rouge">END</code>: 在处理输入之后执行</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}'</code> 来在处理输入之前和之后 打印出 <code class="language-plaintext highlighter-rouge">Start</code> 和 <code class="language-plaintext highlighter-rouge">End</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中可以使用模式来过滤行，例如 <code class="language-plaintext highlighter-rouge">awk '$1 &gt; 10'</code> 表示只打印第一列大于 <code class="language-plaintext highlighter-rouge">10</code> 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern/'</code> 表示只打印包含 <code class="language-plaintext highlighter-rouge">pattern</code> 的行，搜索 模式支持正则表达式。</p> <p><code class="language-plaintext highlighter-rouge">,</code> 也可以和搜索模式一起使用，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern1/,/pattern2/'</code> 表示打印找到的 <code class="language-plaintext highlighter-rouge">pattern1</code> 到 <code class="language-plaintext highlighter-rouge">pattern2</code> 的行。</p> <p><code class="language-plaintext highlighter-rouge">~</code> 可以用来表示是否与搜索模式匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 ~ /pattern/'</code> 表示第一列是否包含 <code class="language-plaintext highlighter-rouge">pattern</code>。<code class="language-plaintext highlighter-rouge">!~</code> 可以 用来表示是否不匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 !~ /pattern/'</code> 表示第一列是否不包含 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h3 id="awk-脚本"><code class="language-plaintext highlighter-rouge">awk</code> 脚本</h3> <p>我们也可以书写 <code class="language-plaintext highlighter-rouge">awk</code> 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#! /usr/bin/awk -f</span>

<span class="kr">BEGIN</span> <span class="p">{</span>
    <span class="c1"># 设置输入和输出的分隔符</span>
    <span class="kc">FS</span><span class="o">=</span><span class="s2">":"</span>
    <span class="kc">OFS</span><span class="o">=</span><span class="s2">" "</span>
    <span class="nx">tot_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="kc">NF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">words</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="o">++</span>
        <span class="nx">tot_count</span><span class="o">++</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">END</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s2">"Total words:"</span><span class="p">,</span> <span class="nx">tot_count</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">word</span> <span class="o">in</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="nx">word</span><span class="p">,</span> <span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：由于在 <code class="language-plaintext highlighter-rouge">awk file</code> 的意思是对某个文件的内容进行处理，所以要用 <code class="language-plaintext highlighter-rouge">awk -f file</code> 来表示将文件作为 脚本执行。</p> <h3 id="内置函数">内置函数</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中还有一些内置函数，例如 <code class="language-plaintext highlighter-rouge">length</code> 函数可以返回字符串的长度，<code class="language-plaintext highlighter-rouge">substr</code> 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中，<code class="language-plaintext highlighter-rouge">print</code> 会在输出的字符串后面自动添加换行符，而 <code class="language-plaintext highlighter-rouge">printf</code> 可以进行格式化输出，上面的例子中 我们通过 <code class="language-plaintext highlighter-rouge">printf</code> 来输出不带换行符的字符串。在 <code class="language-plaintext highlighter-rouge">awk</code> 中字符串是可以直接拼接的，例如 <code class="language-plaintext highlighter-rouge">printf "%s", $NF"+"</code> 表示将最后一列的值和 <code class="language-plaintext highlighter-rouge">+</code> 拼接在一起。</p> <p><code class="language-plaintext highlighter-rouge">printf</code> 的格式化方法与 <code class="language-plaintext highlighter-rouge">C/C++</code> 中的类似，这里不再进行详细介绍。</p> <p>当然要实现同样的功能有更简单的命令：<code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { sum+=$NF } END { print sum }'</code> 或者 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""</code>。</p> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">awk</code> 中，下标是从 <code class="language-plaintext highlighter-rouge">1</code> 开始的，而不是从 <code class="language-plaintext highlighter-rouge">0</code> 开始的，且区间是闭区间。</p> <p>这里再列出一些常用的内置函数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tolower</code>：将字符串转换为小写</li> <li><code class="language-plaintext highlighter-rouge">toupper</code>：将字符串转换为大写</li> <li><code class="language-plaintext highlighter-rouge">split</code>：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 <code class="language-plaintext highlighter-rouge">split($0, words, /:+/)</code> 表示 将当前行按照 <code class="language-plaintext highlighter-rouge">:</code> (或者多个连续的 <code class="language-plaintext highlighter-rouge">:</code>) 分割为数组。</li> <li><code class="language-plaintext highlighter-rouge">gsub</code>：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 <code class="language-plaintext highlighter-rouge">gsub(/pattern/, "replace", $0)</code> 表示将当前行中的 <code class="language-plaintext highlighter-rouge">pattern</code> 替换为 <code class="language-plaintext highlighter-rouge">replace</code>。</li> <li><code class="language-plaintext highlighter-rouge">system</code>：执行系统命令，例如 <code class="language-plaintext highlighter-rouge">system("ls")</code> 会执行 <code class="language-plaintext highlighter-rouge">ls</code> 命令并将结果输出到标准输出。</li> </ul> <h3 id="改变分隔符">改变分隔符</h3> <p>前面介绍到 <code class="language-plaintext highlighter-rouge">FS</code> 和 <code class="language-plaintext highlighter-rouge">OFS</code> 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 <code class="language-plaintext highlighter-rouge">awk '{print}' FS=':' OFS=' '</code> 这样的命令，试图将 <code class="language-plaintext highlighter-rouge">:</code> 改成空格。但是这样并不能正确工作，在 <code class="language-plaintext highlighter-rouge">awk</code> 中 只有当列被修改后 (或者在 <code class="language-plaintext highlighter-rouge">print</code> 中打印多个 <code class="language-plaintext highlighter-rouge">fields</code> 的时候) 才会使用新的输出分隔符，所以我们可以通过 <code class="language-plaintext highlighter-rouge">awk '($1=$1) || 1' FS=':' OFS=' '</code> 来实现 (这里省略了动作，因此会打印一整行)。</p> <p>这里的 <code class="language-plaintext highlighter-rouge">($1=$1) || 1</code> 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 <code class="language-plaintext highlighter-rouge">awk</code> 中被当作 <code class="language-plaintext highlighter-rouge">false</code>，所以我们需要通过 <code class="language-plaintext highlighter-rouge">|| 1</code> 来保证输出。这里的括号是必须的，如果没有括号， <code class="language-plaintext highlighter-rouge">$1=$1 || 1</code> 会被解释为 <code class="language-plaintext highlighter-rouge">$1=($1 || 1)</code>，这样会将 <code class="language-plaintext highlighter-rouge">$1</code> 赋值为 <code class="language-plaintext highlighter-rouge">1</code>，而不是保留原来的值。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">awk</code> 的名字来源于三个创始人的名字 <code class="language-plaintext highlighter-rouge">Alfred Aho</code>、<code class="language-plaintext highlighter-rouge">Peter Weinberger</code> 和 <code class="language-plaintext highlighter-rouge">Brian Kernighan</code> 的 首字母。</p> <h3 id="posix-字符类"><code class="language-plaintext highlighter-rouge">POSIX</code> 字符类</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中支持 <code class="language-plaintext highlighter-rouge">POSIX</code> 字符类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">[:alnum:]</code>：字母和数字</li> <li><code class="language-plaintext highlighter-rouge">[:alpha:]</code>：字母</li> <li><code class="language-plaintext highlighter-rouge">[:blank:]</code>：空格和制表符</li> <li><code class="language-plaintext highlighter-rouge">[:cntrl:]</code>：控制字符</li> <li><code class="language-plaintext highlighter-rouge">[:digit:]</code>：数字</li> <li><code class="language-plaintext highlighter-rouge">[:graph:]</code>：可打印字符，不包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:lower:]</code>：小写字母</li> <li><code class="language-plaintext highlighter-rouge">[:print:]</code>：可打印字符，包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:punct:]</code>：标点符号</li> <li><code class="language-plaintext highlighter-rouge">[:space:]</code>：空白字符</li> <li><code class="language-plaintext highlighter-rouge">[:upper:]</code>：大写字母</li> <li><code class="language-plaintext highlighter-rouge">[:xdigit:]</code>：十六进制数字</li> </ul> <p>例如，我们可以使用 <code class="language-plaintext highlighter-rouge">awk '/[[:digit:]]/'</code> 来匹配包含数字的行。当然也可以写成 <code class="language-plaintext highlighter-rouge">awk '/[0-9]/'</code>。</p> <h2 id="find"><code class="language-plaintext highlighter-rouge">find</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-type</code></td> <td>指定文件类型。<code class="language-plaintext highlighter-rouge">f</code> 表示普通文件，<code class="language-plaintext highlighter-rouge">d</code> 表示目录，<code class="language-plaintext highlighter-rouge">l</code> 表示符号链接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-readable</code></td> <td>查找可读文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-writable</code></td> <td>查找可写文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-executable</code></td> <td>查找可执行文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-name</code></td> <td>指定文件名。可以使用 <code class="language-plaintext highlighter-rouge">wildcads</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-path</code></td> <td>指定路径。可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iname</code></td> <td>忽略大小写的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ipath</code></td> <td>忽略大小写的路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-empty</code></td> <td>查找空文件或者空目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-perm</code></td> <td>指定权限。例如 <code class="language-plaintext highlighter-rouge">-perm 644</code> 表示查找权限为 <code class="language-plaintext highlighter-rouge">644</code> 的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mtime</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mtime +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-atime</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-atime +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ctime</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-ctime +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mmin</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mmin +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-amin</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-amin +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-cmin</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-cmin +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-user</code></td> <td>指定拥有者</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-group</code></td> <td>指定所属组</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-delete</code></td> <td>删除查找到的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-maxdepth</code></td> <td>指定查找的最大深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mindepth</code></td> <td>指定查找的最小深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-and</code></td> <td>逻辑与。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-or</code></td> <td>逻辑或。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-not</code></td> <td>逻辑非。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>不跟踪符号链接。默认行为。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>跟踪符号链接。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>只对命令行参数进行跟踪。例如 <code class="language-plaintext highlighter-rouge">find -H /path/to/file -name filename</code> 只对 <code class="language-plaintext highlighter-rouge">/path/to/file</code> 进行跟踪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-print0</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-regex</code></td> <td>使用正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iregex</code></td> <td>使用忽略大小写的正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-samefile</code></td> <td>指定文件的硬链接。例如 <code class="language-plaintext highlighter-rouge">find . -samefile file</code> 表示查找和 <code class="language-plaintext highlighter-rouge">file</code> 硬链接的文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-links</code></td> <td>指定文件的硬链接数。例如 <code class="language-plaintext highlighter-rouge">find . -links 2</code> 表示查找硬链接数为 <code class="language-plaintext highlighter-rouge">2</code> 的文件，<code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 可以用来表示大于和小于</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">-type</code> 还可以以下类型有：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块设备文件</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字符设备文件</li> <li><code class="language-plaintext highlighter-rouge">p</code>：管道文件</li> <li><code class="language-plaintext highlighter-rouge">s</code>：套接字文件</li> </ul> <p><strong>注意</strong>：使用正则表达式匹配含有某个字符的文件名时，需要使用 <code class="language-plaintext highlighter-rouge">.*</code> 来表示任意数量的字符，例如 <code class="language-plaintext highlighter-rouge">find . -regex ".*pattern.*"</code>，而不能直接使用 <code class="language-plaintext highlighter-rouge">find . -regex "pattern"</code>。</p> <p><strong>注意</strong>：如果要使用复杂的逻辑表达式，需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来分组，例如 <code class="language-plaintext highlighter-rouge">find . \( -name "*.txt" -or -name "*.md" \)</code> 表示查找所有 <code class="language-plaintext highlighter-rouge">txt</code> 或者 <code class="language-plaintext highlighter-rouge">md</code> 文件，其中的括号需要进行转义。</p> <h3 id="指定文件大小">指定文件大小</h3> <p><code class="language-plaintext highlighter-rouge">-size</code> 参数有以下几种单位：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块，取决于文件系统，默认是 <code class="language-plaintext highlighter-rouge">512</code> 字节</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字节</li> <li><code class="language-plaintext highlighter-rouge">k</code>：千字节 (1024 字节)</li> <li><code class="language-plaintext highlighter-rouge">M</code>：兆字节 (1024 千字节)</li> <li><code class="language-plaintext highlighter-rouge">G</code>：吉字节 (1024 兆字节)</li> </ul> <p>知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 <code class="language-plaintext highlighter-rouge">find . -size 1M</code> 表示查找大小为 <code class="language-plaintext highlighter-rouge">1</code> 兆字节的文件。</p> <p>但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 来表示大于和小于，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件，<code class="language-plaintext highlighter-rouge">find . -size -1M</code> 表示查找小于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件。 这两者也可以结合使用，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M -size -2M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 且小于 <code class="language-plaintext highlighter-rouge">2MB</code> 的文件。</p> <h3 id="对查找到的文件执行操作">对查找到的文件执行操作</h3> <p><code class="language-plaintext highlighter-rouge">-exec</code> 可以对查找到的文件执行操作，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec cat {} \;</code> 表示查找当前目录下的 所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并将其内容输出到标准输出。<code class="language-plaintext highlighter-rouge">{}</code> 会被替换为查找到的文件名，<code class="language-plaintext highlighter-rouge">\;</code> 表示结束。</p> <p>也可以使用 <code class="language-plaintext highlighter-rouge">grep</code> 命令过滤查找到的文件，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec grep "pattern" {} \;</code> 表示查找 当前目录下的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并在其中查找 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h2 id="tar"><code class="language-plaintext highlighter-rouge">tar</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>创建文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-z</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">gzip</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-j</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">bzip2</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-J</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">xz</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>提取文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>指定提取的目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>查看文档内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--wildcards</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 匹配文件。例如 <code class="language-plaintext highlighter-rouge">tar -xf a.tar --wildcards '*.txt'</code> 可以提取 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--delete</code></td> <td>删除文档中的文件。例如 <code class="language-plaintext highlighter-rouge">tar -f a.tar --delete '*.txt'</code> 可以删除 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude=</code></td> <td>排除文件。例如 <code class="language-plaintext highlighter-rouge">tar -cf a.tar --exclude=*.txt .</code> 可以创建 <code class="language-plaintext highlighter-rouge">a.tar</code> 时排除所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>向文档中追加文件。例如 <code class="language-plaintext highlighter-rouge">tar -rf a.tar b.txt</code> 可以将 <code class="language-plaintext highlighter-rouge">b.txt</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>向文档中追加另一个文档。例如 <code class="language-plaintext highlighter-rouge">tar -Af a.tar b.tar</code> 可以将 <code class="language-plaintext highlighter-rouge">b.tar</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-W</code></td> <td>检验文档。例如 <code class="language-plaintext highlighter-rouge">tar -Wf a.tar</code> 可以检验 <code class="language-plaintext highlighter-rouge">a.tar</code> 的完整性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>更新文档。例如 <code class="language-plaintext highlighter-rouge">tar -uf a.tar b.txt</code> 可以更新 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的 <code class="language-plaintext highlighter-rouge">b.txt</code> 文件</td> </tr> </tbody> </table> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">--exclude</code> 时必须使用 <code class="language-plaintext highlighter-rouge">=</code> 进行连接，且 <code class="language-plaintext highlighter-rouge">--exclude</code> 要出现在待打包文件之前。 <code class="language-plaintext highlighter-rouge">tar -cf a.tar . --exclude=*.txt</code> 是错误用法。</p> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">-u</code> 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 <code class="language-plaintext highlighter-rouge">tar</code> 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。</p> <h2 id="ln"><code class="language-plaintext highlighter-rouge">ln</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>创建软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>强制创建。如果软连接已经存在，会覆盖原有的软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定连接的目标目录。<code class="language-plaintext highlighter-rouge">ln -t dir target</code> 与 <code class="language-plaintext highlighter-rouge">ln target dir</code> 效果相同</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">ln target link_name</code> 创建的时候如果 <code class="language-plaintext highlighter-rouge">link_name</code> 是一个目录，那么会在目录下创建一个名为 <code class="language-plaintext highlighter-rouge">target</code> 的文件。</p> <p><code class="language-plaintext highlighter-rouge">ln</code> 默认创建硬连接。</p> <p>使用 <code class="language-plaintext highlighter-rouge">rm</code> 和 <code class="language-plaintext highlighter-rouge">unlink</code> 命令均可以删除软连接或者硬连接。但是 <code class="language-plaintext highlighter-rouge">unlink</code> 一次只能删除一个文件，而 <code class="language-plaintext highlighter-rouge">rm</code> 可以删除多个文件。</p> <h3 id="硬连接与软连接">硬连接与软连接</h3> <p><code class="language-plaintext highlighter-rouge">ln</code> 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 <code class="language-plaintext highlighter-rouge">inode</code>，而软连接是指一个文件指向 另一个文件。除此之外，硬连接和软连接还有以下区别：</p> <ul> <li>软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件</li> <li>软连接可以指向目录，而硬连接不能指向目录</li> <li>源文件被删除的时候，硬连接不会受到影响，而软连接会失效</li> </ul> <p>在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，可以通过 <code class="language-plaintext highlighter-rouge">ls -l</code> 命令查看文件的硬连接数 (第二列为硬连接数)，硬连接数为 <code class="language-plaintext highlighter-rouge">1</code> 表示只有一个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>，而硬连接数大于 <code class="language-plaintext highlighter-rouge">1</code> 表示有多个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>。</p> <h2 id="scp"><code class="language-plaintext highlighter-rouge">scp</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归复制。如果复制的是目录，需要使用 <code class="language-plaintext highlighter-rouge">-r</code> 选项</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>指定端口。默认端口是 <code class="language-plaintext highlighter-rouge">22</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>保留文件属性 (例如修改时间等)。默认情况下，<code class="language-plaintext highlighter-rouge">scp</code> 不会保留文件的属性，使用 <code class="language-plaintext highlighter-rouge">-p</code> 可以保留文件的属性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-q</code></td> <td>静默模式。不显示进度信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息。可以使用多个 <code class="language-plaintext highlighter-rouge">-v</code> 来显示更多的信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>压缩传输。使用 <code class="language-plaintext highlighter-rouge">-C</code> 可以压缩传输的数据</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>指定密钥文件。默认情况下，<code class="language-plaintext highlighter-rouge">scp</code> 使用 <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code> 作为密钥文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>限制带宽。单位是 <code class="language-plaintext highlighter-rouge">Kb/s</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-3</code></td> <td>通过本机在两个远端之间传输文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-4</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv4</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-6</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv6</code></td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">scp</code> 的时候，如果在 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中配置了主机信息，可以直接使用主机名进行传输，例如 <code class="language-plaintext highlighter-rouge">scp file host_name:/path/to/file</code>。</p> <p><code class="language-plaintext highlighter-rouge">scp</code> 可以一次拷贝多个文件，例如 <code class="language-plaintext highlighter-rouge">scp file1 file2 host_name:/path/to/</code>。</p> <h2 id="apropos"><code class="language-plaintext highlighter-rouge">apropos</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>逻辑与。可用于匹配多个关键字，例如 <code class="language-plaintext highlighter-rouge">apropos -a keyword1 keyword2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>精确匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>匹配带有 <code class="language-plaintext highlighter-rouge">Shell</code> 支持的通配符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>使用正则表达式匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>不依照终端宽度进行裁剪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">man</code> 手册的节。例如 <code class="language-plaintext highlighter-rouge">apropos -s 3 keyword</code> 表示查找第 <code class="language-plaintext highlighter-rouge">3</code> 节的手册</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">man</code> 手册的节有以下几个：</p> <ul> <li><code class="language-plaintext highlighter-rouge">1</code>：命令或程序</li> <li><code class="language-plaintext highlighter-rouge">2</code>：系统调用</li> <li><code class="language-plaintext highlighter-rouge">3</code>：库函数</li> <li><code class="language-plaintext highlighter-rouge">4</code>：特殊文件</li> <li><code class="language-plaintext highlighter-rouge">5</code>：文件格式和约定</li> <li><code class="language-plaintext highlighter-rouge">6</code>：游戏</li> <li><code class="language-plaintext highlighter-rouge">7</code>：杂项</li> <li><code class="language-plaintext highlighter-rouge">8</code>：系统管理命令</li> <li><code class="language-plaintext highlighter-rouge">9</code>：内核相关</li> </ul> <h2 id="tee"><code class="language-plaintext highlighter-rouge">tee</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>追加到文件。默认情况下，<code class="language-plaintext highlighter-rouge">tee</code> 会覆盖文件内容，使用 <code class="language-plaintext highlighter-rouge">-a</code> 可以追加到文件末尾</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略中断信号</td> </tr> </tbody> </table> <p>管道在进行传递的时候可能会遇到需要 <code class="language-plaintext highlighter-rouge">root</code> 权限的时候，这时候就需要使用 <code class="language-plaintext highlighter-rouge">sudo tee</code> 从管道中读取信息 并写入到文件中。例如 <code class="language-plaintext highlighter-rouge">echo "content" | sudo tee file</code>。</p> <h2 id="usermod"><code class="language-plaintext highlighter-rouge">usermod</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>修改用户名。例如 <code class="language-plaintext highlighter-rouge">usermod -l new_name old_name</code> 表示将 <code class="language-plaintext highlighter-rouge">old_name</code> 修改为 <code class="language-plaintext highlighter-rouge">new_name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>修改用户 <code class="language-plaintext highlighter-rouge">UID</code>。例如 <code class="language-plaintext highlighter-rouge">usermod -u 1000 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的 <code class="language-plaintext highlighter-rouge">UID</code> 修改为 <code class="language-plaintext highlighter-rouge">1000</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>允许重复的 <code class="language-plaintext highlighter-rouge">UID</code>。默认情况下，<code class="language-plaintext highlighter-rouge">usermod</code> 不允许重复的 <code class="language-plaintext highlighter-rouge">UID</code>，使用 <code class="language-plaintext highlighter-rouge">-o</code> 可以允许重复的 <code class="language-plaintext highlighter-rouge">UID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-g</code></td> <td>修改基本用户组。例如 <code class="language-plaintext highlighter-rouge">usermod -g group user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的基本用户组修改为 <code class="language-plaintext highlighter-rouge">group</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-G</code></td> <td>修改附加用户组。例如 <code class="language-plaintext highlighter-rouge">usermod -G group1,group2 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的附加用户组修改为 <code class="language-plaintext highlighter-rouge">group1</code> 和 <code class="language-plaintext highlighter-rouge">group2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>添加用户到附加用户组。默认情况下 <code class="language-plaintext highlighter-rouge">-G</code> 会覆盖用户的附加用户组，使用 <code class="language-plaintext highlighter-rouge">-a</code> 可以进行追加</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>修改用户描述</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-d</code></td> <td>修改用户主目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>移动用户主目录。默认情况下，<code class="language-plaintext highlighter-rouge">usermod -d dir</code> 不会移动用户主目录，使用 <code class="language-plaintext highlighter-rouge">-m</code> 可以移动用户主目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>修改用户登录 <code class="language-plaintext highlighter-rouge">shell</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>修改用户过期时间。例如 <code class="language-plaintext highlighter-rouge">usermod -e 2025-12-31 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的过期时间修改为 <code class="language-plaintext highlighter-rouge">2025-12-31</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>设置新的密码。注意新的密码应该是加密后的密码，可以使用 <code class="language-plaintext highlighter-rouge">openssl passwd</code> 来生成加密后的密码，更加推荐使用 <code class="language-plaintext highlighter-rouge">passwd</code> 命令进行密码修改</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>锁定用户。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-U</code></td> <td>解锁用户。</td> </tr> </tbody> </table> <p><strong>注意</strong>：创建出来的用户默认是不会过期的。如果设置了过期时间后，可以通过 <code class="language-plaintext highlighter-rouge">chmod -e ""</code> 来取消。</p> <h2 id="sudo"><code class="language-plaintext highlighter-rouge">sudo</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>列出用户可以执行的命令。可以使用 <code class="language-plaintext highlighter-rouge">sudo -l command</code> 来检查是否可以执行某个命令</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-U</code></td> <td>与 <code class="language-plaintext highlighter-rouge">-l</code> 一同使用，指定列出的用户而不是执行 <code class="language-plaintext highlighter-rouge">sudo</code> 的用户</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>指定用户执行命令。例如 <code class="language-plaintext highlighter-rouge">sudo -u user command</code> 表示以 <code class="language-plaintext highlighter-rouge">user</code> 用户的身份执行 <code class="language-plaintext highlighter-rouge">command</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-g</code></td> <td>指定用户组。例如 <code class="language-plaintext highlighter-rouge">sudo -g group command</code> 表示以 <code class="language-plaintext highlighter-rouge">group</code> 用户组的身份执行 <code class="language-plaintext highlighter-rouge">command</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">shell</code>。默认情况下，<code class="language-plaintext highlighter-rouge">sudo</code> 会使用 <code class="language-plaintext highlighter-rouge">root</code> 用户的 <code class="language-plaintext highlighter-rouge">shell</code>，使用 <code class="language-plaintext highlighter-rouge">-s</code> 可以指定其他的 <code class="language-plaintext highlighter-rouge">shell</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>使 <code class="language-plaintext highlighter-rouge">sudo</code> 忘记密码。默认情况下，<code class="language-plaintext highlighter-rouge">sudo</code> 会记住密码一段时间，使用 <code class="language-plaintext highlighter-rouge">-k</code> 可以使 <code class="language-plaintext highlighter-rouge">sudo</code> 忘记密码</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>更新记住密码时间的时间戳为当前时刻</td> </tr> </tbody> </table> <h3 id="etcsudoers"><code class="language-plaintext highlighter-rouge">/etc/sudoers</code></h3> <p><code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件用于配置 <code class="language-plaintext highlighter-rouge">sudo</code> 的权限，只有拥有 <code class="language-plaintext highlighter-rouge">root</code> 权限的用户可以修改这个文件。 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件的格式如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 配置某个用户
user host=(runas[:runasgroup]) [NOPASSWD:] command
# 配置某个组下的所有用户
%group host=(runas[:runasgroup]) [NOPASSWD:] command
# 引入目录中的所有文件
@includedir dirname
</code></pre></div></div> <p>对于上述的规则，方括号中代表可选项，这里给出几个实例：</p> <ul> <li><code class="language-plaintext highlighter-rouge">user ALL=(ALL) ALL</code>：允许 <code class="language-plaintext highlighter-rouge">user</code> 用户在任何主机上以任何用户的身份执行任何命令</li> <li><code class="language-plaintext highlighter-rouge">%group ALL=(ALL) NOPASSWD: ALL</code>：允许 <code class="language-plaintext highlighter-rouge">group</code> 组下的所有用户在任何主机上以任何用户的身份执行任何 命令，且不需要输入密码</li> <li><code class="language-plaintext highlighter-rouge">@includedir /etc/sudoers.d</code> 表示引入 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> 目录下的所有文件，这是默认添加的配置，这 意味着我们对于其他用户的配置可以放在 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> 目录下，并以用户名命名文件方便管理。</li> </ul> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">@includedir</code> 目录下的文件不能以 <code class="language-plaintext highlighter-rouge">~</code> 结尾并且不能含有 <code class="language-plaintext highlighter-rouge">.</code>。这是在 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d/README</code> 中明确指出的：</p> <blockquote> <p>This will cause <code class="language-plaintext highlighter-rouge">sudo</code> to read and parse any files in the <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> directory that do not end in <code class="language-plaintext highlighter-rouge">~</code> or contain a <code class="language-plaintext highlighter-rouge">.</code> character.</p> </blockquote> <p><strong>注意</strong>：如果要配置多条命令应该使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。</p> <h2 id="visudo"><code class="language-plaintext highlighter-rouge">visudo</code></h2> <p>推荐使用 <code class="language-plaintext highlighter-rouge">visudo</code> 对 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件进行修改 (即通过命令 <code class="language-plaintext highlighter-rouge">sudo visudo</code>)，<code class="language-plaintext highlighter-rouge">visudo</code> 会检查语法 错误并在保存之前进行检查。</p> <p><code class="language-plaintext highlighter-rouge">visudo</code> 还有一些选项：</p> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查语法错误。例如 <code class="language-plaintext highlighter-rouge">sudo visudo -c</code> 表示检查 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件的语法错误</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件。例如 <code class="language-plaintext highlighter-rouge">sudo visudo -f /path/to/file</code> 表示编辑 <code class="language-plaintext highlighter-rouge">/path/to/file</code> 文件</td> </tr> </tbody> </table> <h2 id="mount"><code class="language-plaintext highlighter-rouge">mount</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>挂载所有在 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 中配置的文件系统</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定文件系统类型。例如 <code class="language-plaintext highlighter-rouge">mount -t ext4 /dev/sda1 /mnt</code> 表示将 <code class="language-plaintext highlighter-rouge">/dev/sda1</code> 挂载到 <code class="language-plaintext highlighter-rouge">/mnt</code> 目录上，并且文件系统类型是 <code class="language-plaintext highlighter-rouge">ext4</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>指定挂载选项。例如 <code class="language-plaintext highlighter-rouge">mount -o ro /dev/sda1 /mnt</code> 表示将 <code class="language-plaintext highlighter-rouge">/dev/sda1</code> 以只读模式挂载到 <code class="language-plaintext highlighter-rouge">/mnt</code> 目录上</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>以只读模式挂载。等价于 <code class="language-plaintext highlighter-rouge">-o ro</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>以读写模式挂载。等价于 <code class="language-plaintext highlighter-rouge">-o rw</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--move</code></td> <td>移动挂载点。例如 <code class="language-plaintext highlighter-rouge">mount --move /mnt /mnt2</code> 表示将 <code class="language-plaintext highlighter-rouge">/mnt</code> 移动到 <code class="language-plaintext highlighter-rouge">/mnt2</code> 上</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--fake</code></td> <td>模拟挂载。例如 <code class="language-plaintext highlighter-rouge">mount --fake /mnt</code> 表示模拟挂载 <code class="language-plaintext highlighter-rouge">/mnt</code> 目录上的文件系统，但是不会真正挂载</td> </tr> </tbody> </table> <p>常见的文件系统类型：</p> <ul> <li><code class="language-plaintext highlighter-rouge">ext4</code>：<code class="language-plaintext highlighter-rouge">Linux</code> 文件系统</li> <li><code class="language-plaintext highlighter-rouge">ntfs</code>：<code class="language-plaintext highlighter-rouge">Windows</code> 文件系统, 使用 <code class="language-plaintext highlighter-rouge">mount -t ntfs-3g</code> 进行挂载</li> <li><code class="language-plaintext highlighter-rouge">FAT32</code>：<code class="language-plaintext highlighter-rouge">FAT32</code> 文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t vfat</code> 进行挂载</li> <li><code class="language-plaintext highlighter-rouge">exFAT</code>：需要安装 <code class="language-plaintext highlighter-rouge">exfat-fuse</code> 和 <code class="language-plaintext highlighter-rouge">exfat-utils</code> 包，使用 <code class="language-plaintext highlighter-rouge">mount -t exfat</code> 进行挂载</li> <li><code class="language-plaintext highlighter-rouge">ISO</code>：<code class="language-plaintext highlighter-rouge">ISO</code> 文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t iso9660</code> 进行挂载</li> <li><code class="language-plaintext highlighter-rouge">nfs</code>：网络文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t nfs -o vers=num</code> 可以指定版本</li> </ul> <p><strong>注意</strong>：直接使用 <code class="language-plaintext highlighter-rouge">mount</code> 可以列出所有已经挂载的文件系统。也可以使用 <code class="language-plaintext highlighter-rouge">mount -t type</code> 来列出指定类型 的文件系统。</p> <h3 id="获取设备的文件系统类型及-uuid">获取设备的文件系统类型及 <code class="language-plaintext highlighter-rouge">UUID</code></h3> <p>可以使用 <code class="language-plaintext highlighter-rouge">blkid</code> 命令来获取设备的文件系统类型及 <code class="language-plaintext highlighter-rouge">UUID</code>，例如 <code class="language-plaintext highlighter-rouge">blkid /dev/sda1</code>。</p> <h3 id="fstab"><code class="language-plaintext highlighter-rouge">fstab</code></h3> <p>直接通过 <code class="language-plaintext highlighter-rouge">mount</code> 命令挂载的文件系统在系统重启后会失效，为了让文件系统在系统重启后自动挂载，我们可以 将文件系统的信息写入 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件中。<code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件的格式如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># device &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;     &lt;dump&gt;  &lt;pass&gt;
/dev/sda1       /mnt        ext4    defaults       0       2
</code></pre></div></div> <p>其中各个字段的含义如下：</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;device&gt;</code>：设备文件</li> <li><code class="language-plaintext highlighter-rouge">&lt;mount point&gt;</code>：挂载点</li> <li><code class="language-plaintext highlighter-rouge">&lt;type&gt;</code>：文件系统类型</li> <li><code class="language-plaintext highlighter-rouge">&lt;options&gt;</code>：挂载选项，多个选项通过 <code class="language-plaintext highlighter-rouge">,</code> 进行分隔</li> <li><code class="language-plaintext highlighter-rouge">&lt;dump&gt;</code>：备份标志。<code class="language-plaintext highlighter-rouge">0</code> 表示不备份，<code class="language-plaintext highlighter-rouge">1</code> 表示备份 (需要 <code class="language-plaintext highlighter-rouge">dump</code> 工具，通常设置为 <code class="language-plaintext highlighter-rouge">0</code>)</li> <li><code class="language-plaintext highlighter-rouge">&lt;pass&gt;</code>：文件系统检查顺序。<code class="language-plaintext highlighter-rouge">0</code> 表示不检查，<code class="language-plaintext highlighter-rouge">1</code> 表示第一个检查，<code class="language-plaintext highlighter-rouge">2</code> 表示第二个检查 (根文件系统通常 设置为 <code class="language-plaintext highlighter-rouge">1</code>，其他文件系统设置为 <code class="language-plaintext highlighter-rouge">2</code>)</li> </ul> <h2 id="umount"><code class="language-plaintext highlighter-rouge">umount</code></h2> <p><code class="language-plaintext highlighter-rouge">umount</code> 用于卸载文件系统，使用方式为 <code class="language-plaintext highlighter-rouge">umount &lt;mount point&gt;</code>，例如 <code class="language-plaintext highlighter-rouge">umount /mnt</code>。</p> <p><strong>注意</strong>：卸载文件系统的时候，如果文件系统正在被使用，会提示 <code class="language-plaintext highlighter-rouge">device is busy</code>，这时候可以使用 <code class="language-plaintext highlighter-rouge">lsof &lt;mount point&gt;</code> 来查看哪些进程在使用这个文件系统，然后选择是否通过 <code class="language-plaintext highlighter-rouge">kill</code> 命令杀死这些进程。也 可以使用 <code class="language-plaintext highlighter-rouge">umount -l &lt;mount point&gt;</code> 在空闲时自动卸载。</p> <h1 id="git"><code class="language-plaintext highlighter-rouge">git</code></h1> <h2 id="gitignore"><code class="language-plaintext highlighter-rouge">.gitignore</code></h2> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件用于指定不需要被 <code class="language-plaintext highlighter-rouge">git</code> 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 来指定不需要被追踪的文件或目录。</p> <h3 id="wildcards"><code class="language-plaintext highlighter-rouge">wildcards</code></h3> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 中的 <code class="language-plaintext highlighter-rouge">wildcards</code> 与 <code class="language-plaintext highlighter-rouge">bash</code> 中基本一致，可以查看 <a href="#wildcards-in-linux">Wildcards in Linux</a> 来 了解更多关于 <code class="language-plaintext highlighter-rouge">wildcards</code> 的内容。</p> <h3 id="基本用法">基本用法</h3> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只对 当前目录生效。例如 <code class="language-plaintext highlighter-rouge">/foo</code> 表示只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示忽略所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或 目录。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只匹配 目录。例如 <code class="language-plaintext highlighter-rouge">foo/</code> 表示只匹配目录 <code class="language-plaintext highlighter-rouge">foo</code>，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示匹配所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录。你可能会有疑惑： 在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 <code class="language-plaintext highlighter-rouge">build/</code> 和 <code class="language-plaintext highlighter-rouge">build</code> 表示的意义是不同的，前者表示忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 目录，而后者表示 忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 文件或目录。前者可以保留某个子目录下面的名为 <code class="language-plaintext highlighter-rouge">build</code> 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 <code class="language-plaintext highlighter-rouge">/build/</code> 只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">build</code> 目录。</p> <h3 id="全局忽略">全局忽略</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中可以配置全局忽略文件，通常使用 <code class="language-plaintext highlighter-rouge">.git</code> 管理的仓库不需要追踪一些特定的文件，例如 <code class="language-plaintext highlighter-rouge">*.pyc</code>、 <code class="language-plaintext highlighter-rouge">*.o</code> 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 <code class="language-plaintext highlighter-rouge">~/.config/git/ignore</code>。</p> <h3 id="忽略文件优先级">忽略文件优先级</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中任何一个目录下都可以有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会覆盖父目录下的文件。也就是说，<code class="language-plaintext highlighter-rouge">.gitignore</code> 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。</p> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://www.tecmint.com/use-wildcards-to-match-filenames-in-linux/">10 Practical Examples Using Wildcards to Match Filenames in Linux</a></li> <li><a href="https://fishshell.com/docs/current/fish_for_bash_users.html#wildcards-globs">fish shell wildcards</a></li> <li><a href="https://ryanstutorials.net/linuxtutorial/cheatsheetgrep.php">Linux Tutorial - Cheat Sheet - grep</a></li> <li><a href="https://www.golinuxcloud.com/grep-command-in-linux/">20 grep command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://linuxhandbook.com/sort-command/">Linux Handbook: sort Command Examples</a></li> <li><a href="https://www.golinuxcloud.com/linux-sort-files/#1_Sort_by_name">15+ Tips to PROPERLY sort files in Linux [Cheat Sheet]</a></li> <li><a href="https://shapeshed.com/unix-sort/">Linux and Unix sort command tutorial with examples</a></li> <li><a href="https://www.baeldung.com/linux/sort-command">Linux sort Command</a></li> <li><a href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/">How to Use the awk Command on Linux</a></li> <li><a href="https://www.golinuxcloud.com/awk-examples-with-command-tutorial-unix-linux/">30+ awk examples for beginners / awk command tutorial in Linux/Unix</a></li> <li><a href="https://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/">8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR</a></li> <li><a href="https://linuxhandbook.com/awk-command-tutorial/">Getting Started With AWK Command [Beginner’s Guide]</a></li> <li><a href="https://www.golinuxcloud.com/find-command-in-linux/">25+ most used find commands in Linux [Cheat Sheet]</a></li> <li><a href="https://onecompiler.com/cheatsheets/find">find Linux Command Cheatsheet</a></li> <li><a href="https://linuxtutorials.org/linux-find-cheatsheet/">Linux Find Cheatsheet</a></li> <li><a href="https://opensource.com/article/21/9/linux-find-command">Find files and directories on Linux with the find command</a></li> <li><a href="https://www.redhat.com/sysadmin/linux-find-command">10 ways to use the Linux find command</a></li> <li><a href="https://quickref.me/find">Find cheatsheet</a></li> <li><a href="https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files">Ignoring files</a></li> <li><a href="https://www.golinuxcloud.com/cat-command-examples/">cat command examples for beginners [cheatsheet]</a></li> <li><a href="https://linux-audit.com/cheat-sheets/tar/">Linux Audit: tar cheat sheet</a></li> <li><a href="https://www.golinuxcloud.com/tar-command-in-linux/">15+ tar command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://www.golinuxcloud.com/create-symbolic-link-linux/">10+ practical examples to create symbolic link in Linux</a></li> <li><a href="https://www.golinuxcloud.com/scp-command-in-linux/">15+ scp command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://phoenixnap.com/kb/apropos-linux">apropos Linux Command Explained</a></li> <li><a href="https://www.golinuxcloud.com/tee-command-in-linux/">10 tee command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://raspberrytips.com/sudo-linux-command/">How To Use ‘sudo’: The Complete Linux Command Guide</a></li> <li><a href="https://www.computerhope.com/unix/visudo.htm">Linux visudo command</a></li> <li><a href="https://www.golinuxcloud.com/usermod-command-in-linux/">15 usermod command examples in Linux [Cheat Sheet]</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Linux"/><category term="CLI"/><summary type="html"><![CDATA[Wildcards in Linux 这里的 wildcards 指的是能够被 shell 扩展的符号。如果在执行的命令中出现这些符号，shell 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 shell 支持，这些 wildcards 是可以在任意 命令中使用的。 常见的 wildcards 有以下几种： *：匹配任意数量( 包含 0 个 )的字符 **：递归匹配任意数量( 包含 0 个 )的字符 ?：匹配单个任意字符 []：匹配出现在中括号中的某个符号，在中括号中可以使用 - 来表示范围，也可以使用 ! 来表示取反， 例如 [!0-9] 表示匹配不是数字的字符，[!ab] 表示不是 a 也不是 b 的字符 上面的通配符并不是所有的 shell 都支持的，但是在 bash 中是支持的。例如在 fish shell 中，只有 *、** 以及 ? 是支持的，其中 * 和 ? 不会匹配 /，而 ** 会匹配 / ，也就是说 ** 是 递归匹配。 注意：在正则表达式的语法中，* 表示匹配前面的字符 0 次或者多次，? 表示匹配前面的字符 0 次或者 1 次， [] 表示匹配中括号中的任意一个字符，- 表示范围，^ 表示取反。 常用命令 Cheat Sheet cat 选项 说明 -n 显示行号 -b 显示非空行的行号 -s 合并多个空行为一个空行 -v 使用 ^ 和 M- 显示不可打印字符 -E 在每行的结尾显示 $ -T 将制表符显示为 ^I -A 等价于 -v -E -T -e 等价于 -v -E -t 等价于 -v -T - 从标准输入读取内容 使用 cat 可以直接创建带有内容的文件或者追加内容到文件中，例如 cat &gt; file 会等待输入，当输入完成 后，使用 ^D (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 cat &gt;&gt; file。 - 可以出现在多个文件的任意位置，例如 cat file1 - file2 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，而 cat file1 - file2 - file3 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，file2 和 file3 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 ^D 结束，然后输入第二次，再次使用 ^D 结束，第一次输入的内容会放置在 file1 和 file2 的内容 之间，第二次输入的内容会放置在 file2 和 file3 的内容之间。 补充：tac 可以将文件内容逆序输出 (优先输出最后一行)，tac 的名字来源于 cat 的逆序。 题外话：cat 的名字来源于 concatenate，即连接的意思，其可以将多个文件的内容拼接在一起。 grep 选项 说明 -r 递归搜索目录 --include "*.py" 搜索指定文件 --exclude "test*" 排除指定文件 --exclude-dir "test*" 排除指定目录 --color=auto,always,never 何时进行高亮 -n 显示行号。这里的行号指的是文件中的行号 -l 只显示文件名。当对多个文件中的内容进行匹配时，使用 -l 会在匹配成功时只显示文件名，而不是文件中具体的位置 -L 只显示不含有任何匹配的文件名 -i 忽略大小写 -v 反向匹配 -c 显示匹配次数。使用 -v 时，显示反向匹配的数量 -o 只显示匹配的部分 -m 指定匹配的次数。例如 -m 1 表示当有多个匹配的时候只显示第一个匹配。 -f 从文件中读取模式。文件中每行一个模式 -e 指定模式。可以指定多个模式，例如 grep -e pattern1 -e pattern2 -w 只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。 -x 只匹配整行 -A 2 显示匹配行的后两行 -B 2 显示匹配行的前两行 -C 2 显示匹配行的前两行和后两行 -E 使用扩展正则表达式 -F 使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待 -H 显示文件名。默认情况下，当只有一个文件时，grep 不会显示文件名，而使用 -H 可以强制显示文件名 -h 不显示文件名。默认情况下，当有多个文件时，grep 会显示文件名，而使用 -h 可以强制不显示文件名 注意：-m 1 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。 注意：grep 的正则表达式是基于 POSIX 的基本正则表达式，而 egrep 和 grep -E 是基于 POSIX 的扩展正则表达式。grep 和 egrep 的区别在于 egrep 默认使用扩展正则表达式，而 grep 默认使用基本 正则表达式。 题外话：grep 的名字来源于 g/re/p，其中 g 表示 global，re 表示 regular expression，p 表示 print，直译即全局正则表达式打印。 sort 选项 说明 -r 逆序排序 -n 按照数字排序 -k 按照某一列排序 -u 去重 -t 指定分隔符 -f 忽略大小写。默认情况下，大写会在所有小写的前面，而使用 -f 可以让大小写混合在一起排序 -h 人类可读的排序。例如 1K 会被排序到 512 的前面 -M 按照月份排序 --files0-form=- 从标准输入读取以 NUL 作为文件名分隔符的多个文件内容 --files0-form=filename 从某个文件中读取 NUL 作为文件名分隔符的多个文件内容 -c 检查文件是否已经排序 注意：-k 可以指定多个列，例如 -k2,2 -k1,1 表示先按照第二列排序，然后再按照第一列排序。-k 也 按照某列的部分进行排序，例如 -k2.2,2.3 表示按照第二列的第二个字符到第三个字符进行排序。-k 还可以 指定列的类型，例如 -k2n,2 表示按照第二列的数字进行排序。-r 选项也可以指定到 -k 选项中，例如 -k2r,2 表示按照第二列逆序排序。 awk 选项 说明 -F 指定输入的分隔符。 -f 指定 awk 脚本文件。 打印列 $0: 整行 $1: 第一列 ... $NF: 最后一列 例如可以使用 awk '{print $1,$2,$NF}' 打印出每行的第一列、第二列和最后一列。 分隔符 可以通过 OFS=(Output Field Separator) 来指定输出的分隔符，例如 awk '{print $1,$2,$NF}' OFS="," 表示使用 , 作为分隔符。也可以在 BEGIN 模式串中指定 OFS，例如 awk 'BEGIN {OFS=","} {print $1,$2,$NF}'。 除了 OFS 以外，还有 FS 用于指定输入文件的分隔符。 预定义变量 除了之前提到的 OFS, FS 之外，还有一些预定义变量： NR: 当前行的行号 NF: 当前行的列数 RS：记录分隔符，默认是换行符，也就是每一行作为一条记录 ORS：输出的记录分隔符，默认是换行符 FILENAME：当前文件的文件名 FNR：当前文件的行号，当时用多个文件的时候，NR 记录的是当前的总行号，而 FNR 记录的是当前文件的行号 我们可以使用 awk 'NR &gt; 1' 从第二行开始打印，也可以使用 awk 'NF &gt; 0' 打印列数大于 0 的行 (也就是移除空行)。 如果要打印第一行到第四行，我们可以通过 awk 'NR == 1, NR== 4' 来实现。其中的 , 表示范围，NR == 1 表示第一行，NR == 4 表示第四行。我们还可以使用 awk 'NR &gt; 1 &amp;&amp; NR &lt; 5' 来实现。 模式 BEGIN 和 END 模式串： BEGIN: 在处理输入之前执行 END: 在处理输入之后执行 例如可以使用 awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}' 来在处理输入之前和之后 打印出 Start 和 End。 在 awk 中可以使用模式来过滤行，例如 awk '$1 &gt; 10' 表示只打印第一列大于 10 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 awk '/pattern/' 表示只打印包含 pattern 的行，搜索 模式支持正则表达式。 , 也可以和搜索模式一起使用，例如 awk '/pattern1/,/pattern2/' 表示打印找到的 pattern1 到 pattern2 的行。 ~ 可以用来表示是否与搜索模式匹配，例如 awk '$1 ~ /pattern/' 表示第一列是否包含 pattern。!~ 可以 用来表示是否不匹配，例如 awk '$1 !~ /pattern/' 表示第一列是否不包含 pattern。 awk 脚本 我们也可以书写 awk 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数： #! /usr/bin/awk -f BEGIN { # 设置输入和输出的分隔符 FS=":" OFS=" " tot_count=0 } { for (i = 1; i &lt;= NF; i++) { words[$i]++ tot_count++ } } END { print "Total words:", tot_count for (word in words) { print word, words[word] } } 注意：由于在 awk file 的意思是对某个文件的内容进行处理，所以要用 awk -f file 来表示将文件作为 脚本执行。 内置函数 awk 中还有一些内置函数，例如 length 函数可以返回字符串的长度，substr 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc。 在 awk 中，print 会在输出的字符串后面自动添加换行符，而 printf 可以进行格式化输出，上面的例子中 我们通过 printf 来输出不带换行符的字符串。在 awk 中字符串是可以直接拼接的，例如 printf "%s", $NF"+" 表示将最后一列的值和 + 拼接在一起。 printf 的格式化方法与 C/C++ 中的类似，这里不再进行详细介绍。 当然要实现同样的功能有更简单的命令：awk 'NR &gt; 1 { sum+=$NF } END { print sum }' 或者 awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""。 注意：在 awk 中，下标是从 1 开始的，而不是从 0 开始的，且区间是闭区间。 这里再列出一些常用的内置函数： tolower：将字符串转换为小写 toupper：将字符串转换为大写 split：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 split($0, words, /:+/) 表示 将当前行按照 : (或者多个连续的 :) 分割为数组。 gsub：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 gsub(/pattern/, "replace", $0) 表示将当前行中的 pattern 替换为 replace。 system：执行系统命令，例如 system("ls") 会执行 ls 命令并将结果输出到标准输出。 改变分隔符 前面介绍到 FS 和 OFS 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 awk '{print}' FS=':' OFS=' ' 这样的命令，试图将 : 改成空格。但是这样并不能正确工作，在 awk 中 只有当列被修改后 (或者在 print 中打印多个 fields 的时候) 才会使用新的输出分隔符，所以我们可以通过 awk '($1=$1) || 1' FS=':' OFS=' ' 来实现 (这里省略了动作，因此会打印一整行)。 这里的 ($1=$1) || 1 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 awk 中被当作 false，所以我们需要通过 || 1 来保证输出。这里的括号是必须的，如果没有括号， $1=$1 || 1 会被解释为 $1=($1 || 1)，这样会将 $1 赋值为 1，而不是保留原来的值。 题外话：awk 的名字来源于三个创始人的名字 Alfred Aho、Peter Weinberger 和 Brian Kernighan 的 首字母。 POSIX 字符类 awk 中支持 POSIX 字符类： [:alnum:]：字母和数字 [:alpha:]：字母 [:blank:]：空格和制表符 [:cntrl:]：控制字符 [:digit:]：数字 [:graph:]：可打印字符，不包括空格 [:lower:]：小写字母 [:print:]：可打印字符，包括空格 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制数字 例如，我们可以使用 awk '/[[:digit:]]/' 来匹配包含数字的行。当然也可以写成 awk '/[0-9]/'。 find 选项 说明 -type 指定文件类型。f 表示普通文件，d 表示目录，l 表示符号链接 -readable 查找可读文件或目录 -writable 查找可写文件或目录 -executable 查找可执行文件或目录 -name 指定文件名。可以使用 wildcads -path 指定路径。可以使用 wildcards -iname 忽略大小写的文件名 -ipath 忽略大小写的路径 -empty 查找空文件或者空目录 -perm 指定权限。例如 -perm 644 表示查找权限为 644 的文件或目录 -mtime 指定修改时间。例如 -mtime +1 表示查找修改时间在 1 天前的文件或目录 -atime 指定访问时间。例如 -atime +1 表示查找访问时间在 1 天前的文件或目录 -ctime 指定创建时间。例如 -ctime +1 表示查找创建时间在 1 天前的文件或目录 -mmin 指定修改时间。例如 -mmin +1 表示查找修改时间在 1 分钟前的文件或目录 -amin 指定访问时间。例如 -amin +1 表示查找访问时间在 1 分钟前的文件或目录 -cmin 指定创建时间。例如 -cmin +1 表示查找创建时间在 1 分钟前的文件或目录 -user 指定拥有者 -group 指定所属组 -delete 删除查找到的文件或目录 -maxdepth 指定查找的最大深度 -mindepth 指定查找的最小深度 -and 逻辑与。 -or 逻辑或。 -not 逻辑非。 -P 不跟踪符号链接。默认行为。 -L 跟踪符号链接。 -H 只对命令行参数进行跟踪。例如 find -H /path/to/file -name filename 只对 /path/to/file 进行跟踪 -print0 使用 NUL 作为文件名分隔符 -regex 使用正则表达式匹配文件名 -iregex 使用忽略大小写的正则表达式匹配文件名 -samefile 指定文件的硬链接。例如 find . -samefile file 表示查找和 file 硬链接的文件 -links 指定文件的硬链接数。例如 find . -links 2 表示查找硬链接数为 2 的文件，+ 和 - 可以用来表示大于和小于 -type 还可以以下类型有： b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 注意：使用正则表达式匹配含有某个字符的文件名时，需要使用 .* 来表示任意数量的字符，例如 find . -regex ".*pattern.*"，而不能直接使用 find . -regex "pattern"。 注意：如果要使用复杂的逻辑表达式，需要使用 () 来分组，例如 find . \( -name "*.txt" -or -name "*.md" \) 表示查找所有 txt 或者 md 文件，其中的括号需要进行转义。 指定文件大小 -size 参数有以下几种单位： b：块，取决于文件系统，默认是 512 字节 c：字节 k：千字节 (1024 字节) M：兆字节 (1024 千字节) G：吉字节 (1024 兆字节) 知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 find . -size 1M 表示查找大小为 1 兆字节的文件。 但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 + 和 - 来表示大于和小于，例如 find . -size +1M 表示查找大于 1MB 的文件，find . -size -1M 表示查找小于 1MB 的文件。 这两者也可以结合使用，例如 find . -size +1M -size -2M 表示查找大于 1MB 且小于 2MB 的文件。 对查找到的文件执行操作 -exec 可以对查找到的文件执行操作，例如 find . -name "*.txt" -exec cat {} \; 表示查找当前目录下的 所有 txt 文件并将其内容输出到标准输出。{} 会被替换为查找到的文件名，\; 表示结束。 也可以使用 grep 命令过滤查找到的文件，例如 find . -name "*.txt" -exec grep "pattern" {} \; 表示查找 当前目录下的所有 txt 文件并在其中查找 pattern。 tar 选项 说明 -c 创建文档 -f 指定文件名 -v 显示详细信息 -z 使用 gzip 压缩或解压 -j 使用 bzip2 压缩或解压 -J 使用 xz 压缩或解压 -x 提取文档 -C 指定提取的目录 -t 查看文档内容 --wildcards 使用 wildcards 匹配文件。例如 tar -xf a.tar --wildcards '*.txt' 可以提取 a.tar 中的所有 txt 文件 --delete 删除文档中的文件。例如 tar -f a.tar --delete '*.txt' 可以删除 a.tar 中的所有 txt 文件 --exclude= 排除文件。例如 tar -cf a.tar --exclude=*.txt . 可以创建 a.tar 时排除所有 txt 文件 -r 向文档中追加文件。例如 tar -rf a.tar b.txt 可以将 b.txt 追加到 a.tar 中 -A 向文档中追加另一个文档。例如 tar -Af a.tar b.tar 可以将 b.tar 追加到 a.tar 中 -W 检验文档。例如 tar -Wf a.tar 可以检验 a.tar 的完整性 -u 更新文档。例如 tar -uf a.tar b.txt 可以更新 a.tar 中的 b.txt 文件 注意：在使用 --exclude 时必须使用 = 进行连接，且 --exclude 要出现在待打包文件之前。 tar -cf a.tar . --exclude=*.txt 是错误用法。 注意：在使用 -u 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 tar 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。 ln 选项 说明 -s 创建软连接 -f 强制创建。如果软连接已经存在，会覆盖原有的软连接 -t 指定连接的目标目录。ln -t dir target 与 ln target dir 效果相同 使用 ln target link_name 创建的时候如果 link_name 是一个目录，那么会在目录下创建一个名为 target 的文件。 ln 默认创建硬连接。 使用 rm 和 unlink 命令均可以删除软连接或者硬连接。但是 unlink 一次只能删除一个文件，而 rm 可以删除多个文件。 硬连接与软连接 ln 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 inode，而软连接是指一个文件指向 另一个文件。除此之外，硬连接和软连接还有以下区别： 软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件 软连接可以指向目录，而硬连接不能指向目录 源文件被删除的时候，硬连接不会受到影响，而软连接会失效 在 Linux 中，可以通过 ls -l 命令查看文件的硬连接数 (第二列为硬连接数)，硬连接数为 1 表示只有一个文件指向该 inode，而硬连接数大于 1 表示有多个文件指向该 inode。 scp 选项 说明 -r 递归复制。如果复制的是目录，需要使用 -r 选项 -P 指定端口。默认端口是 22 -p 保留文件属性 (例如修改时间等)。默认情况下，scp 不会保留文件的属性，使用 -p 可以保留文件的属性 -q 静默模式。不显示进度信息 -v 显示详细信息。可以使用多个 -v 来显示更多的信息 -C 压缩传输。使用 -C 可以压缩传输的数据 -i 指定密钥文件。默认情况下，scp 使用 ~/.ssh/id_rsa 作为密钥文件 -l 限制带宽。单位是 Kb/s -3 通过本机在两个远端之间传输文件 -4 强制使用 IPv4 -6 强制使用 IPv6 使用 scp 的时候，如果在 ~/.ssh/config 中配置了主机信息，可以直接使用主机名进行传输，例如 scp file host_name:/path/to/file。 scp 可以一次拷贝多个文件，例如 scp file1 file2 host_name:/path/to/。 apropos 选项 说明 -a 逻辑与。可用于匹配多个关键字，例如 apropos -a keyword1 keyword2 -e 精确匹配 -w 匹配带有 Shell 支持的通配符 -r 使用正则表达式匹配 -l 不依照终端宽度进行裁剪 -s 指定 man 手册的节。例如 apropos -s 3 keyword 表示查找第 3 节的手册 man 手册的节有以下几个： 1：命令或程序 2：系统调用 3：库函数 4：特殊文件 5：文件格式和约定 6：游戏 7：杂项 8：系统管理命令 9：内核相关 tee 选项 说明 -a 追加到文件。默认情况下，tee 会覆盖文件内容，使用 -a 可以追加到文件末尾 -i 忽略中断信号 管道在进行传递的时候可能会遇到需要 root 权限的时候，这时候就需要使用 sudo tee 从管道中读取信息 并写入到文件中。例如 echo "content" | sudo tee file。 usermod 选项 说明 -l 修改用户名。例如 usermod -l new_name old_name 表示将 old_name 修改为 new_name -u 修改用户 UID。例如 usermod -u 1000 user 表示将 user 的 UID 修改为 1000 -o 允许重复的 UID。默认情况下，usermod 不允许重复的 UID，使用 -o 可以允许重复的 UID -g 修改基本用户组。例如 usermod -g group user 表示将 user 的基本用户组修改为 group -G 修改附加用户组。例如 usermod -G group1,group2 user 表示将 user 的附加用户组修改为 group1 和 group2 -a 添加用户到附加用户组。默认情况下 -G 会覆盖用户的附加用户组，使用 -a 可以进行追加 -c 修改用户描述 -d 修改用户主目录 -m 移动用户主目录。默认情况下，usermod -d dir 不会移动用户主目录，使用 -m 可以移动用户主目录 -s 修改用户登录 shell -e 修改用户过期时间。例如 usermod -e 2025-12-31 user 表示将 user 的过期时间修改为 2025-12-31 -p 设置新的密码。注意新的密码应该是加密后的密码，可以使用 openssl passwd 来生成加密后的密码，更加推荐使用 passwd 命令进行密码修改 -L 锁定用户。 -U 解锁用户。 注意：创建出来的用户默认是不会过期的。如果设置了过期时间后，可以通过 chmod -e "" 来取消。 sudo 选项 说明 -l 列出用户可以执行的命令。可以使用 sudo -l command 来检查是否可以执行某个命令 -U 与 -l 一同使用，指定列出的用户而不是执行 sudo 的用户 -u 指定用户执行命令。例如 sudo -u user command 表示以 user 用户的身份执行 command -g 指定用户组。例如 sudo -g group command 表示以 group 用户组的身份执行 command -s 指定 shell。默认情况下，sudo 会使用 root 用户的 shell，使用 -s 可以指定其他的 shell -k 使 sudo 忘记密码。默认情况下，sudo 会记住密码一段时间，使用 -k 可以使 sudo 忘记密码 -v 更新记住密码时间的时间戳为当前时刻 /etc/sudoers /etc/sudoers 文件用于配置 sudo 的权限，只有拥有 root 权限的用户可以修改这个文件。 /etc/sudoers 文件的格式如下： # 配置某个用户 user host=(runas[:runasgroup]) [NOPASSWD:] command # 配置某个组下的所有用户 %group host=(runas[:runasgroup]) [NOPASSWD:] command # 引入目录中的所有文件 @includedir dirname 对于上述的规则，方括号中代表可选项，这里给出几个实例： user ALL=(ALL) ALL：允许 user 用户在任何主机上以任何用户的身份执行任何命令 %group ALL=(ALL) NOPASSWD: ALL：允许 group 组下的所有用户在任何主机上以任何用户的身份执行任何 命令，且不需要输入密码 @includedir /etc/sudoers.d 表示引入 /etc/sudoers.d 目录下的所有文件，这是默认添加的配置，这 意味着我们对于其他用户的配置可以放在 /etc/sudoers.d 目录下，并以用户名命名文件方便管理。 注意：在 @includedir 目录下的文件不能以 ~ 结尾并且不能含有 .。这是在 /etc/sudoers.d/README 中明确指出的： This will cause sudo to read and parse any files in the /etc/sudoers.d directory that do not end in ~ or contain a . character. 注意：如果要配置多条命令应该使用 , 作为分隔符。 visudo 推荐使用 visudo 对 /etc/sudoers 文件进行修改 (即通过命令 sudo visudo)，visudo 会检查语法 错误并在保存之前进行检查。 visudo 还有一些选项： 选项 说明 -c 检查语法错误。例如 sudo visudo -c 表示检查 /etc/sudoers 文件的语法错误 -f 指定文件。例如 sudo visudo -f /path/to/file 表示编辑 /path/to/file 文件 mount 选项 说明 -a 挂载所有在 /etc/fstab 中配置的文件系统 -t 指定文件系统类型。例如 mount -t ext4 /dev/sda1 /mnt 表示将 /dev/sda1 挂载到 /mnt 目录上，并且文件系统类型是 ext4 -o 指定挂载选项。例如 mount -o ro /dev/sda1 /mnt 表示将 /dev/sda1 以只读模式挂载到 /mnt 目录上 -r 以只读模式挂载。等价于 -o ro -w 以读写模式挂载。等价于 -o rw --move 移动挂载点。例如 mount --move /mnt /mnt2 表示将 /mnt 移动到 /mnt2 上 --fake 模拟挂载。例如 mount --fake /mnt 表示模拟挂载 /mnt 目录上的文件系统，但是不会真正挂载 常见的文件系统类型： ext4：Linux 文件系统 ntfs：Windows 文件系统, 使用 mount -t ntfs-3g 进行挂载 FAT32：FAT32 文件系统，使用 mount -t vfat 进行挂载 exFAT：需要安装 exfat-fuse 和 exfat-utils 包，使用 mount -t exfat 进行挂载 ISO：ISO 文件系统，使用 mount -t iso9660 进行挂载 nfs：网络文件系统，使用 mount -t nfs -o vers=num 可以指定版本 注意：直接使用 mount 可以列出所有已经挂载的文件系统。也可以使用 mount -t type 来列出指定类型 的文件系统。 获取设备的文件系统类型及 UUID 可以使用 blkid 命令来获取设备的文件系统类型及 UUID，例如 blkid /dev/sda1。 fstab 直接通过 mount 命令挂载的文件系统在系统重启后会失效，为了让文件系统在系统重启后自动挂载，我们可以 将文件系统的信息写入 /etc/fstab 文件中。/etc/fstab 文件的格式如下： # device &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; /dev/sda1 /mnt ext4 defaults 0 2 其中各个字段的含义如下： &lt;device&gt;：设备文件 &lt;mount point&gt;：挂载点 &lt;type&gt;：文件系统类型 &lt;options&gt;：挂载选项，多个选项通过 , 进行分隔 &lt;dump&gt;：备份标志。0 表示不备份，1 表示备份 (需要 dump 工具，通常设置为 0) &lt;pass&gt;：文件系统检查顺序。0 表示不检查，1 表示第一个检查，2 表示第二个检查 (根文件系统通常 设置为 1，其他文件系统设置为 2) umount umount 用于卸载文件系统，使用方式为 umount &lt;mount point&gt;，例如 umount /mnt。 注意：卸载文件系统的时候，如果文件系统正在被使用，会提示 device is busy，这时候可以使用 lsof &lt;mount point&gt; 来查看哪些进程在使用这个文件系统，然后选择是否通过 kill 命令杀死这些进程。也 可以使用 umount -l &lt;mount point&gt; 在空闲时自动卸载。 git .gitignore .gitignore 文件用于指定不需要被 git 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 .gitignore 文件中可以使用 wildcards 来指定不需要被追踪的文件或目录。 wildcards .gitignore 中的 wildcards 与 bash 中基本一致，可以查看 Wildcards in Linux 来 了解更多关于 wildcards 的内容。 基本用法 默认情况下，.gitignore 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 / 表示只对 当前目录生效。例如 /foo 表示只忽略当前目录下的 foo 文件或目录，而 foo 表示忽略所有的 foo 文件或 目录。 默认情况下，.gitignore 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 / 表示只匹配 目录。例如 foo/ 表示只匹配目录 foo，而 foo 表示匹配所有的 foo 文件或目录。你可能会有疑惑： 在 Linux 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 build/ 和 build 表示的意义是不同的，前者表示忽略所有 build 目录，而后者表示 忽略所有 build 文件或目录。前者可以保留某个子目录下面的名为 build 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 /build/ 只忽略当前目录下的 build 目录。 全局忽略 在 git 中可以配置全局忽略文件，通常使用 .git 管理的仓库不需要追踪一些特定的文件，例如 *.pyc、 *.o 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 ~/.config/git/ignore。 忽略文件优先级 在 git 中任何一个目录下都可以有一个 .gitignore 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 .gitignore 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 .gitignore 文件，那么这个文件会覆盖父目录下的文件。也就是说，.gitignore 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。 巨人的肩膀 10 Practical Examples Using Wildcards to Match Filenames in Linux fish shell wildcards Linux Tutorial - Cheat Sheet - grep 20 grep command examples in Linux [Cheat Sheet] Linux Handbook: sort Command Examples 15+ Tips to PROPERLY sort files in Linux [Cheat Sheet] Linux and Unix sort command tutorial with examples Linux sort Command How to Use the awk Command on Linux 30+ awk examples for beginners / awk command tutorial in Linux/Unix 8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR Getting Started With AWK Command [Beginner’s Guide] 25+ most used find commands in Linux [Cheat Sheet] find Linux Command Cheatsheet Linux Find Cheatsheet Find files and directories on Linux with the find command 10 ways to use the Linux find command Find cheatsheet Ignoring files cat command examples for beginners [cheatsheet] Linux Audit: tar cheat sheet 15+ tar command examples in Linux [Cheat Sheet] 10+ practical examples to create symbolic link in Linux 15+ scp command examples in Linux [Cheat Sheet] apropos Linux Command Explained 10 tee command examples in Linux [Cheat Sheet] How To Use ‘sudo’: The Complete Linux Command Guide Linux visudo command 15 usermod command examples in Linux [Cheat Sheet]]]></summary></entry><entry><title type="html">Spring-Validation 自定义错误代码</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/" rel="alternate" type="text/html" title="Spring-Validation 自定义错误代码"/><published>2024-08-29T02:38:09+00:00</published><updated>2024-08-29T02:38:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 做了简单的介绍。但是只使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 就很难实现了，我们往往需要自定义代码的 实现逻辑。</p> <p>而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。</p> <p>而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。</p> <h1 id="返回信息">返回信息</h1> <p>我们的基本要求是对于错误信息返回如下的 <code class="language-plaintext highlighter-rouge">JSON</code> 数据：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User id must be null when creating a new user"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NOTNULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"4"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"5"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"6"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_EMAIL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"7"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"8"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"9"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"10"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"11"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERNAME_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"12"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EMAIL_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"13"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WRONG_SIGN_IN_INFORMATION"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"14"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INVALID_TOKEN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"15"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ACCESS_DENIED"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MESSAGE_CONVERSION_ERROR"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>对于这样的数据，前端开发者可以很容易将其定义成一个 <code class="language-plaintext highlighter-rouge">enum</code> 类型，这样就可以很方便的进行错误码的比较。</p> <h1 id="自定义校验逻辑">自定义校验逻辑</h1> <p>对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了如何设置全局异常处理器。</p> <h2 id="自定义错误码">自定义错误码</h2> <p>当然，我们首先需要有错误码的信息，我们可以定义如下的 <code class="language-plaintext highlighter-rouge">enum</code> 类型：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ErrorCodeEnum</span> <span class="o">{</span>
    <span class="c1">// This should be ignored, this is to make the ordinal of the enum start from 1</span>
    <span class="no">ZERO_PLACEHOLDER</span><span class="o">,</span>

    <span class="no">USERDTO_ID_NULL</span><span class="o">(</span><span class="s">"UserDTO.id.Null"</span><span class="o">),</span>
    <span class="no">USERDTO_ID_NOTNULL</span><span class="o">(</span><span class="s">"UserDTO.id.NotNull"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_SIZE</span><span class="o">(</span><span class="s">"UserDTO.username.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.email.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_EMAIL</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_SIZE</span><span class="o">(</span><span class="s">"UserDTO.userPassword.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERSIGNINDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERSIGNINDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERNAME_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"USERNAME_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">EMAIL_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"EMAIL_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">WRONG_SIGN_IN_INFORMATION</span><span class="o">(</span><span class="s">"WRONG_SIGN_IN_INFORMATION"</span><span class="o">),</span>

    <span class="no">INVALID_TOKEN</span><span class="o">(</span><span class="s">"INVALID_TOKEN"</span><span class="o">),</span>
    <span class="no">ACCESS_DENIED</span><span class="o">(</span><span class="s">"ACCESS_DENIED"</span><span class="o">),</span>

    <span class="no">MESSAGE_CONVERSION_ERROR</span><span class="o">(</span><span class="s">"MESSAGE_CONVERSION_ERROR"</span><span class="o">);</span>

    <span class="c1">// code means the error code in the message.properties</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">code</span><span class="o">;</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(){}</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">code</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通常 <code class="language-plaintext highlighter-rouge">0</code> 代表执行成功，所以我们在上面的 <code class="language-plaintext highlighter-rouge">enum</code> 类型中加入了一个 <code class="language-plaintext highlighter-rouge">ZERO_PLACEHOLDER</code>，这样我们的错误码 就可以从 <code class="language-plaintext highlighter-rouge">1</code> 开始了。</p> <p>为了能够让自己定义的错误也能使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国际化处理，我们通过在 <code class="language-plaintext highlighter-rouge">enum</code> 中定义 <code class="language-plaintext highlighter-rouge">code</code> 将其 与 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码进行对应。这样我们只需要在 <code class="language-plaintext highlighter-rouge">message.properties</code> 添加对应的错误码即可：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.id.Null</span><span class="p">=</span><span class="s">User id must be null when creating a new user</span>
<span class="py">UserDTO.id.NotNull</span><span class="p">=</span><span class="s">User id cannot be null</span>
<span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
<span class="py">UserDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="c"># UserSignInDTO validation messages
</span><span class="py">UserSignInDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserSignInDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="py">USERNAME_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Username already exists: {}</span>
<span class="py">EMAIL_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Email already exists: {}</span>
<span class="py">WRONG_SIGN_IN_INFORMATION</span><span class="p">=</span><span class="s">Wrong sign in information</span>

<span class="py">INVALID_TOKEN</span><span class="p">=</span><span class="s">Invalid token: {}</span>
<span class="py">ACCESS_DENIED</span><span class="p">=</span><span class="s">Operation without privileges</span>

<span class="py">MESSAGE_CONVERSION_ERROR</span><span class="p">=</span><span class="s">Error occurs while converting message</span>
</code></pre></div></div> <p>当然我们需要一个工具类来获取错误码的信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">args</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ignore</span>
        <span class="o">}</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>之前我们在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了 <code class="language-plaintext highlighter-rouge">{min}</code> 、<code class="language-plaintext highlighter-rouge">{max}</code> 等不能通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行替换的参数，所以在这个工具类中，我们先尝试通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 获取信息，如果获取失败，我们就通过正则表达式进行替换。</p> <p>最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然我们需要定义 <code class="language-plaintext highlighter-rouge">ErrorVO</code> 对象用于返回错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">errorCodeEnum</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">errorCodeEnum</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">GenericException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleGenericException</span><span class="o">(</span>
        <span class="nc">GenericException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error caused by {}:\n {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">INVALID_TOKEN:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">case</span> <span class="nl">ACCESS_DENIED:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="spring-validation">Spring Validation</h1> <p>在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> + <code class="language-plaintext highlighter-rouge">Spring Validation</code> 的时候，我们是通过 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "{UserDTO.username.NotBlank}")</code> 来获取 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码的， <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 的语法是由 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。</p> <p>众所周知，<code class="language-plaintext highlighter-rouge">enum</code> 对于的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法可以通过名称来创建对应的 <code class="language-plaintext highlighter-rouge">enum</code> 对象，例如 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK")</code> 与 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK</code> 是等价的， 而在 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 中只会对 <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 进行解析，而其他的部分将会保持不变，例如 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}")</code> 解析后获取到的 错误信息是 <code class="language-plaintext highlighter-rouge">USERDTO_USERNAME_NOTBLANK Username cannot be blank</code>。这也就意味着我们只需要在使用注解的 地方多增加一个 <code class="language-plaintext highlighter-rouge">enum</code> 的名称即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">UserDTO</span><span class="o">(</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NULL {UserDTO.id.Null}"</span><span class="o">)</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NOTNULL {UserDTO.id.NotNull}"</span><span class="o">)</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_SIZE {UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">username</span><span class="o">,</span>
    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">email</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">userPassword</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p>当然着还没完，我们需要在全局异常处理器中对这种错误进行处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span>
        <span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// we only handle one validation message</span>
    <span class="nc">String</span> <span class="n">codeAndMessage</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getFieldError</span><span class="o">().</span><span class="na">getDefaultMessage</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">firstSpaceIndex</span> <span class="o">=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
    <span class="c1">// There must be a space and not at the end of the message</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">var</span> <span class="n">exception</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericException</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">firstSpaceIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
    <span class="n">exception</span><span class="o">.</span><span class="na">setCode</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">firstSpaceIndex</span><span class="o">)));</span>
    <span class="k">return</span> <span class="nf">handleGenericException</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>再上面的处理中，我们提取到错误码后创建相应的 <code class="language-plaintext highlighter-rouge">GenericException</code> 对象，然后交给 <code class="language-plaintext highlighter-rouge">handleGenericException</code> 进行统一处理。</p> <p>通过上面的操作后，我们已经成功对自定义校验逻辑以及 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行了统一处理，而且我们还可以 通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。</p> <h1 id="返回错误码信息">返回错误码信息</h1> <p>我们只需要定义以下的 <code class="language-plaintext highlighter-rouge">controller</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="c1">// 标记只有在开发环境下才会被加载</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">DEV_PROFILE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errorCodeConstant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑</span>
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span> <span class="o">:</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">ZERO_PLACEHOLDER</span><span class="o">)</span> <span class="o">{</span> <span class="k">continue</span><span class="o">;</span> <span class="o">}</span>
            <span class="n">errorCodeConstant</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">code</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getErrorMessage</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">errorCodeConstant</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="最后">最后</h1> <p>上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring-Validation 做了简单的介绍。但是只使用 Spring-Validation 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 Spring-Validation 就很难实现了，我们往往需要自定义代码的 实现逻辑。 而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。 而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。 返回信息 我们的基本要求是对于错误信息返回如下的 JSON 数据： { "code": 1, "message": "User id must be null when creating a new user" } 除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式： { "1": "USERDTO_ID_NULL", "2": "USERDTO_ID_NOTNULL", "3": "USERDTO_USERNAME_SIZE", "4": "USERDTO_USERNAME_NOTBLANK", "5": "USERDTO_EMAIL_NOTBLANK", "6": "USERDTO_EMAIL_EMAIL", "7": "USERDTO_USERPASSWORD_SIZE", "8": "USERDTO_USERPASSWORD_NOTBLANK", "9": "USERSIGNINDTO_USERNAME_NOTBLANK", "10": "USERSIGNINDTO_USERPASSWORD_NOTBLANK", "11": "USERNAME_ALREADY_EXISTS", "12": "EMAIL_ALREADY_EXISTS", "13": "WRONG_SIGN_IN_INFORMATION", "14": "INVALID_TOKEN", "15": "ACCESS_DENIED", "16": "MESSAGE_CONVERSION_ERROR" } 对于这样的数据，前端开发者可以很容易将其定义成一个 enum 类型，这样就可以很方便的进行错误码的比较。 自定义校验逻辑 对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 使用 Spring-Validation 进行参数校验 中介绍了如何设置全局异常处理器。 自定义错误码 当然，我们首先需要有错误码的信息，我们可以定义如下的 enum 类型： public enum ErrorCodeEnum { // This should be ignored, this is to make the ordinal of the enum start from 1 ZERO_PLACEHOLDER, USERDTO_ID_NULL("UserDTO.id.Null"), USERDTO_ID_NOTNULL("UserDTO.id.NotNull"), USERDTO_USERNAME_SIZE("UserDTO.username.Size"), USERDTO_USERNAME_NOTBLANK("UserDTO.username.NotBlank"), USERDTO_EMAIL_NOTBLANK("UserDTO.email.NotBlank"), USERDTO_EMAIL_EMAIL("UserDTO.email.Email"), USERDTO_USERPASSWORD_SIZE("UserDTO.userPassword.Size"), USERDTO_USERPASSWORD_NOTBLANK("UserDTO.userPassword.NotBlank"), USERSIGNINDTO_USERNAME_NOTBLANK("UserSignInDTO.username.NotBlank"), USERSIGNINDTO_USERPASSWORD_NOTBLANK("UserSignInDTO.userPassword.NotBlank"), USERNAME_ALREADY_EXISTS("USERNAME_ALREADY_EXISTS"), EMAIL_ALREADY_EXISTS("EMAIL_ALREADY_EXISTS"), WRONG_SIGN_IN_INFORMATION("WRONG_SIGN_IN_INFORMATION"), INVALID_TOKEN("INVALID_TOKEN"), ACCESS_DENIED("ACCESS_DENIED"), MESSAGE_CONVERSION_ERROR("MESSAGE_CONVERSION_ERROR"); // code means the error code in the message.properties private String code; ErrorCodeEnum(){} ErrorCodeEnum(String code) { this.code = code; } public String getCode() { return code; } } 通常 0 代表执行成功，所以我们在上面的 enum 类型中加入了一个 ZERO_PLACEHOLDER，这样我们的错误码 就可以从 1 开始了。 为了能够让自己定义的错误也能使用 MessageSource 进行国际化处理，我们通过在 enum 中定义 code 将其 与 message.properties 中的错误码进行对应。这样我们只需要在 message.properties 添加对应的错误码即可： # UserDTO validation messages UserDTO.id.Null=User id must be null when creating a new user UserDTO.id.NotNull=User id cannot be null UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.username.NotBlank=Username cannot be blank UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters UserDTO.userPassword.NotBlank=Password cannot be blank # UserSignInDTO validation messages UserSignInDTO.username.NotBlank=Username cannot be blank UserSignInDTO.userPassword.NotBlank=Password cannot be blank USERNAME_ALREADY_EXISTS=Username already exists: {} EMAIL_ALREADY_EXISTS=Email already exists: {} WRONG_SIGN_IN_INFORMATION=Wrong sign in information INVALID_TOKEN=Invalid token: {} ACCESS_DENIED=Operation without privileges MESSAGE_CONVERSION_ERROR=Error occurs while converting message 当然我们需要一个工具类来获取错误码的信息： // 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入 @Component public class MessageSourceUtil { private static MessageSource messageSource; MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(ErrorCodeEnum code, Object... args) { try { return messageSource.getMessage(code.getCode(), args, LocaleContextHolder.getLocale()); } catch (Exception e) { // ignore } String message=messageSource.getMessage(code.getCode(), null, LocaleContextHolder.getLocale()); Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 之前我们在 使用 Spring-Validation 进行参数校验 中介绍了 {min} 、{max} 等不能通过 MessageSource 进行替换的参数，所以在这个工具类中，我们先尝试通过 MessageSource 获取信息，如果获取失败，我们就通过正则表达式进行替换。 最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理： @Getter @Setter public class GenericException extends RuntimeException { private ErrorCodeEnum code; public GenericException(String message) { super(message); } public GenericException(ErrorCodeEnum code, Object... args) { super(MessageSourceUtil.getMessage(code, args)); this.code = code; } } 当然我们需要定义 ErrorVO 对象用于返回错误信息： public record ErrorVO(Integer code, String message) { public ErrorVO(ErrorCodeEnum errorCodeEnum, String message) { this(errorCodeEnum.ordinal(), message); } } 经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了： @ExceptionHandler(GenericException.class) public ResponseEntity&lt;ErrorVO&gt; handleGenericException( GenericException e, HttpServletRequest request) { logger.error("Error caused by {}:\n {}", request.getRemoteAddr(), e.getMessage()); switch (e.getCode()) { case INVALID_TOKEN: return ResponseEntity.status(HttpStatus.UNAUTHORIZED) .body(new ErrorVO(e.getCode(), e.getMessage())); case ACCESS_DENIED: return ResponseEntity.status(HttpStatus.FORBIDDEN) .body(new ErrorVO(e.getCode(), e.getMessage())); default: return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(new ErrorVO(e.getCode(), e.getMessage())); } } Spring Validation 在使用 MessageSource + Spring Validation 的时候，我们是通过 @NotBlank(message = "{UserDTO.username.NotBlank}") 来获取 message.properties 中的错误码的， {xxx.xxx.xxx} 的语法是由 Spring Validation 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。 众所周知，enum 对于的 valueOf 方法可以通过名称来创建对应的 enum 对象，例如 ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK") 与 ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK 是等价的， 而在 Spring Validation 中只会对 {xxx.xxx.xxx} 进行解析，而其他的部分将会保持不变，例如 @NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") 解析后获取到的 错误信息是 USERDTO_USERNAME_NOTBLANK Username cannot be blank。这也就意味着我们只需要在使用注解的 地方多增加一个 enum 的名称即可： public record UserDTO( @Null(groups = CreateGroup.class, message="USERDTO_ID_NULL {UserDTO.id.Null}") @NotNull(groups = UpdateGroup.class, message="USERDTO_ID_NOTNULL {UserDTO.id.NotNull}") Long id, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_USERNAME_LENGTH, max=ValidationConstant.MAX_USERNAME_LENGTH, message="USERDTO_USERNAME_SIZE {UserDTO.username.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") String username, @Email( groups={CreateGroup.class}, message="USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") String email, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_PASSWORD_LENGTH, max=ValidationConstant.MAX_PASSWORD_LENGTH, message="USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}") String userPassword) {} 当然着还没完，我们需要在全局异常处理器中对这种错误进行处理： @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity&lt;ErrorVO&gt; handleMethodArgumentNotValidException( MethodArgumentNotValidException e, HttpServletRequest request) { // we only handle one validation message String codeAndMessage=e.getFieldError().getDefaultMessage(); int firstSpaceIndex=codeAndMessage.indexOf(" "); // There must be a space and not at the end of the message assert firstSpaceIndex != -1; assert firstSpaceIndex != codeAndMessage.length() - 1; var exception=new GenericException(codeAndMessage.substring(firstSpaceIndex + 1)); exception.setCode(ErrorCodeEnum.valueOf(codeAndMessage.substring(0, firstSpaceIndex))); return handleGenericException(exception, request); } 再上面的处理中，我们提取到错误码后创建相应的 GenericException 对象，然后交给 handleGenericException 进行统一处理。 通过上面的操作后，我们已经成功对自定义校验逻辑以及 Spring Validation 进行了统一处理，而且我们还可以 通过 MessageSource 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。 返回错误码信息 我们只需要定义以下的 controller 即可： @RestController // 标记只有在开发环境下才会被加载 @Profile(ApplicationConstant.DEV_PROFILE) public class DevelopmentController { private Map&lt;Integer, String&gt; errorCodeConstant=new HashMap&lt;&gt;(); // 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑 @PostConstruct public void init() { for (ErrorCodeEnum code : ErrorCodeEnum.values()) { if (code == ErrorCodeEnum.ZERO_PLACEHOLDER) { continue; } errorCodeConstant.put(code.ordinal(), code.name()); } } @GetMapping(ApiPathConstant.DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH) public Map&lt;Integer, String&gt; getErrorMessage() { return errorCodeConstant; } } 最后 上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。]]></summary></entry><entry><title type="html">JJWT + Spring Filter 实现 Token 验证</title><link href="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/" rel="alternate" type="text/html" title="JJWT + Spring Filter 实现 Token 验证"/><published>2024-08-27T12:21:37+00:00</published><updated>2024-08-27T12:21:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/"><![CDATA[<p>在实际上开发中我们可能会需要涉及到用户的认证和授权功能，<code class="language-plaintext highlighter-rouge">Spring Security</code> 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 <code class="language-plaintext highlighter-rouge">JJWT</code> 就能实现。</p> <h1 id="需求">需求</h1> <p>考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 <code class="language-plaintext highlighter-rouge">token</code> 来进行访问，<code class="language-plaintext highlighter-rouge">token</code> 一定时间内有效，过期后需要重新登录。</p> <p>对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 <code class="language-plaintext highlighter-rouge">token</code> 进行 解析，获取用户信息，然后进行比对。</p> <h2 id="双-token-模式">双 <code class="language-plaintext highlighter-rouge">token</code> 模式</h2> <p>对于 <code class="language-plaintext highlighter-rouge">token</code> 的设计，我们可以采用双 <code class="language-plaintext highlighter-rouge">token</code> 模式，即一个 <code class="language-plaintext highlighter-rouge">access token</code> 和一个 <code class="language-plaintext highlighter-rouge">refresh token</code>，<code class="language-plaintext highlighter-rouge">access token</code> 用于访问，<code class="language-plaintext highlighter-rouge">refresh token</code> 用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>。</p> <p>这样的设计可以有效的保证安全性，因为 <code class="language-plaintext highlighter-rouge">access token</code> 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 <code class="language-plaintext highlighter-rouge">refresh token</code> 通常有效时间较长，但是只能用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>，不能用于访问，且 <code class="language-plaintext highlighter-rouge">refresh token</code> 只有在每次 <code class="language-plaintext highlighter-rouge">access token</code> 过期后才会被传递，这样 <code class="language-plaintext highlighter-rouge">refresh token</code> 暴露的风险较小。</p> <h1 id="实现">实现</h1> <h2 id="jwtutil"><code class="language-plaintext highlighter-rouge">JwtUtil</code></h2> <p>我们首先需要自定义一个工具类，该工具类可以生成和解析 <code class="language-plaintext highlighter-rouge">token</code>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">TOKEN_TYPE_CLAIM</span> <span class="o">=</span> <span class="s">"tokenType"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ID_CLAIM</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">SecretKey</span> <span class="no">SECRET_KEY</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">SIG</span><span class="o">.</span><span class="na">HS256</span><span class="o">.</span><span class="na">key</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">issuedAt</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">())</span>
                <span class="o">.</span><span class="na">expiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span>
                    <span class="o">(</span><span class="n">tokenType</span> <span class="o">==</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span> <span class="o">?</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">ACCESS_TOKEN_EXPIRATION</span> <span class="o">:</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">REFRESH_TOKEN_EXPIRATION</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="n">tokenType</span><span class="o">.</span><span class="na">name</span><span class="o">())</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">id</span><span class="o">),</span> <span class="n">tokenType</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getID</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TokenTypeEnum</span> <span class="nf">getTokenType</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="filter"><code class="language-plaintext highlighter-rouge">Filter</code></h2> <p>要实现认证和授权，我们可以通过 <code class="language-plaintext highlighter-rouge">Filter</code> 拦截所有的非登录和注册的业务请求，然后进行 <code class="language-plaintext highlighter-rouge">token</code> 的解析和验证：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">LOWEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ignorePath</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_UP_API_PATH</span><span class="o">,</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">,</span>
    <span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
        <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">authorize</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getTokenType</span><span class="o">(</span><span class="n">token</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">ACCESS_TOKEN:</span>
                <span class="c1">// ACCESS_TOKEN can not be used for refresh</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">String</span> <span class="n">idInToken</span> <span class="o">=</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
                <span class="k">switch</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethod</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">case</span> <span class="s">"GET"</span><span class="o">:</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">case</span> <span class="s">"POST"</span><span class="o">:</span>
                        <span class="c1">// User can not update other user's information</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_API_PREFIX</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">idInToken</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getFromRequestBody</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="s">"id"</span><span class="o">)))</span> <span class="o">{</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">default</span><span class="o">:</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">REFRESH_TOKEN:</span>
                <span class="c1">// REFRESH_TOKEN can only be used for refresh</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">getFromRequestBody</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getReader</span><span class="o">();</span>
            <span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="o">=</span> <span class="nc">JsonParserFactory</span><span class="o">.</span><span class="na">getJsonParser</span><span class="o">().</span><span class="na">parseMap</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// unlikely to happen</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="signin"><code class="language-plaintext highlighter-rouge">SignIn</code></h2> <p>对于登录接口，我们只需要返回额外 <code class="language-plaintext highlighter-rouge">access token</code> 和 <code class="language-plaintext highlighter-rouge">refresh token</code>，对于刷新服务我们直接返回新的 <code class="language-plaintext highlighter-rouge">access token</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 我们在 UserVO 中保存 token</span>
<span class="kd">public</span> <span class="n">record</span> <span class="nf">UserVO</span><span class="o">(</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">accessToken</span><span class="o">,</span> <span class="nc">String</span> <span class="n">refreshToken</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">REFRESH_TOKEN</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticationController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">signIn</span><span class="o">(</span><span class="nd">@Validated</span> <span class="nd">@RequestBody</span> <span class="nc">UserSignInDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">username</span><span class="o">());</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"user_password"</span><span class="o">,</span> <span class="nc">MD5Converter</span><span class="o">.</span><span class="na">convertToMD5</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">userPassword</span><span class="o">()));</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">WRONG_SIGN_IN_INFORMATION</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="k">new</span> <span class="nc">UserVO</span><span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">getOne</span><span class="o">(</span><span class="n">wrapper</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">refreshToken</span><span class="o">(</span><span class="nd">@RequestHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="问题">问题</h1> <h2 id="如何让-token-在用户修改密码后失效">如何让 <code class="language-plaintext highlighter-rouge">token</code> 在用户修改密码后失效</h2> <p>一个情况是当用户发现自己的 <code class="language-plaintext highlighter-rouge">token</code> 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <p>这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 <code class="language-plaintext highlighter-rouge">id</code> 和密码修改的时间，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时，我们 需要验证 <code class="language-plaintext highlighter-rouge">token</code> 的发布时间是否在密码修改时间之前，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <h2 id="如何在用户进行登出操作后使-token-失效">如何在用户进行登出操作后使 <code class="language-plaintext highlighter-rouge">token</code> 失效</h2> <p>对于主动让一个 <code class="language-plaintext highlighter-rouge">token</code> 失效，我们可以采用黑名单机制，即将失效的 <code class="language-plaintext highlighter-rouge">token</code> 加入黑名单，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时， 我们需要验证 <code class="language-plaintext highlighter-rouge">token</code> 是否在黑名单中，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><category term="Token"/><summary type="html"><![CDATA[在实际上开发中我们可能会需要涉及到用户的认证和授权功能，Spring Security 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 JJWT 就能实现。 需求 考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 token 来进行访问，token 一定时间内有效，过期后需要重新登录。 对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 token 进行 解析，获取用户信息，然后进行比对。 双 token 模式 对于 token 的设计，我们可以采用双 token 模式，即一个 access token 和一个 refresh token，access token 用于访问，refresh token 用于刷新 access token。 这样的设计可以有效的保证安全性，因为 access token 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 refresh token 通常有效时间较长，但是只能用于刷新 access token，不能用于访问，且 refresh token 只有在每次 access token 过期后才会被传递，这样 refresh token 暴露的风险较小。 实现 JwtUtil 我们首先需要自定义一个工具类，该工具类可以生成和解析 token： public class JwtUtil { private static final String TOKEN_TYPE_CLAIM="tokenType"; private static final String ID_CLAIM="id"; private static final SecretKey SECRET_KEY=Jwts.SIG.HS256.key().build(); public static String generateToken(long id, TokenTypeEnum tokenType) { return Jwts.builder().issuedAt(new Date()) .expiration(new Date(System.currentTimeMillis() + (tokenType == TokenTypeEnum.ACCESS_TOKEN ? ApplicationConstant.ACCESS_TOKEN_EXPIRATION : ApplicationConstant.REFRESH_TOKEN_EXPIRATION))) .claim(ID_CLAIM, id) .claim(TOKEN_TYPE_CLAIM, tokenType.name()) .signWith(SECRET_KEY) .compact(); } public static String generateToken(String id, TokenTypeEnum tokenType) { return generateToken(Long.valueOf(id), tokenType); } public static String getID(String token) { return String.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(ID_CLAIM, Long.class)); } public static TokenTypeEnum getTokenType(String token) { return TokenTypeEnum.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(TOKEN_TYPE_CLAIM, String.class)); } } Filter 要实现认证和授权，我们可以通过 Filter 拦截所有的非登录和注册的业务请求，然后进行 token 的解析和验证： @Component @Order(Ordered.LOWEST_PRECEDENCE) public class JwtFilter extends OncePerRequestFilter { private Set&lt;String&gt; ignorePath=Set.of( ApiPathConstant.AUTHENTICATION_SIGN_UP_API_PATH, ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH, ); @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } private void authorize(HttpServletRequest request, String token) { switch (JwtUtil.getTokenType(token)) { case ACCESS_TOKEN: // ACCESS_TOKEN can not be used for refresh if (request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } String idInToken=JwtUtil.getID(token); switch (request.getMethod()) { case "GET": break; case "POST": // User can not update other user's information if (request.getRequestURI().startsWith(ApiPathConstant.USER_API_PREFIX) &amp;&amp; !idInToken.equals(getFromRequestBody(request, "id"))) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; case REFRESH_TOKEN: // REFRESH_TOKEN can only be used for refresh if (!request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } } private String getFromRequestBody(HttpServletRequest request, String key) { try { BufferedReader reader=request.getReader(); StringBuilder builder=new StringBuilder(); String line=reader.readLine(); while (line != null) { builder.append(line); line=reader.readLine(); } reader.close(); var json=JsonParserFactory.getJsonParser().parseMap(builder.toString()); return json.get(key).toString(); } catch (Exception e) { // unlikely to happen return null; } } } SignIn 对于登录接口，我们只需要返回额外 access token 和 refresh token，对于刷新服务我们直接返回新的 access token 即可： // 我们在 UserVO 中保存 token public record UserVO( Long id, String username, String email, String accessToken, String refreshToken) { public UserVO(UserPO userPO) { this(userPO.getId(), userPO.getUsername(), userPO.getEmail(), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.ACCESS_TOKEN), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.REFRESH_TOKEN)); } } @RestController public class AuthenticationController { @Autowired private UserService userService; @PostMapping(ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH) public ResponseEntity&lt;?&gt; signIn(@Validated @RequestBody UserSignInDTO user) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("username", user.username()); wrapper.eq("user_password", MD5Converter.convertToMD5(user.userPassword())); if (!userService.exists(wrapper)) { throw new IllegalArgumentException(ErrorMessageConstant.WRONG_SIGN_IN_INFORMATION); } return ResponseEntity.ok(new UserVO(userService.getOne(wrapper))); } @GetMapping(ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH) public String refreshToken(@RequestHeader("Token") String token) { return JwtUtil.generateToken(JwtUtil.getID(token), TokenTypeEnum.ACCESS_TOKEN); } } 问题 如何让 token 在用户修改密码后失效 一个情况是当用户发现自己的 token 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 token 失效。 这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 id 和密码修改的时间，每次验证 token 时，我们 需要验证 token 的发布时间是否在密码修改时间之前，如果是则说明 token 失效。 如何在用户进行登出操作后使 token 失效 对于主动让一个 token 失效，我们可以采用黑名单机制，即将失效的 token 加入黑名单，每次验证 token 时， 我们需要验证 token 是否在黑名单中，如果是则说明 token 失效。]]></summary></entry><entry><title type="html">Spring Filter 全局异常处理器</title><link href="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/" rel="alternate" type="text/html" title="Spring Filter 全局异常处理器"/><published>2024-08-27T12:21:09+00:00</published><updated>2024-08-27T12:21:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/exception-handler-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/"><![CDATA[<p>在之前的 <a href="/blog/2024/spring-validation-intro">Spring-Validation</a> 中简单介绍了如何通过 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解来处理全局异常，但是这种方式只能 处理 <code class="language-plaintext highlighter-rouge">Controller</code> 层抛出的异常。</p> <p>这篇文章介绍如何处理自定义 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常。</p> <h1 id="自定义-filter">自定义 <code class="language-plaintext highlighter-rouge">Filter</code></h1> <p>例如我们可能需要一个 <code class="language-plaintext highlighter-rouge">Filter</code> 来检验 <code class="language-plaintext highlighter-rouge">Token</code> 是否合法，而检查的过程中发现 <code class="language-plaintext highlighter-rouge">Token</code> 不合法，则抛出异常。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebFilter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：通过 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 注释的 <code class="language-plaintext highlighter-rouge">Filter</code> 需要在 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 启动类中添加 <code class="language-plaintext highlighter-rouge">@ServletComponentScan("xxx.xxx.xx")</code> 注解指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的查找路径。</p> <p>上面过程中抛出的异常不会被 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 捕获。</p> <h1 id="handlerexceptionresolver"><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code></h1> <p>实际上 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的异常处理是通过 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 来实现的。<code class="language-plaintext highlighter-rouge">Spring Boot</code> 中已经存在 两个默认的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，我们可以通过 <code class="language-plaintext highlighter-rouge">@Qualifier("HandlerExceptionResolver")</code> 配合 <code class="language-plaintext highlighter-rouge">@Autowired</code> 获取到负责处理异常的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，然后显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 方法来处理异常。</p> <h1 id="解决方案">解决方案</h1> <p>要实现这些，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">Filter</code> 并让其第一个执行，对捕获到的异常显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 进行处理就可以触发全局定义的异常处理器：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">HIGHEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExceptionHandlerFiter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"handlerExceptionResolver"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">HandlerExceptionResolver</span> <span class="n">resolver</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="na">resolveException</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：<code class="language-plaintext highlighter-rouge">@WebFilter</code> 不能指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序 (实际上是可以的，通过指定 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 中的 <code class="language-plaintext highlighter-rouge">filterName</code>，执行顺序是按照该字段的字典序)，要指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序，我们可以通 <code class="language-plaintext highlighter-rouge">@Order</code> 和 <code class="language-plaintext highlighter-rouge">@Component</code> 来实现，<code class="language-plaintext highlighter-rouge">@Order</code> 的值越小，执行顺序越靠前，上述例子的 <code class="language-plaintext highlighter-rouge">Ordered.HIGHEST_PRECEDENCE</code> 实际上是 <code class="language-plaintext highlighter-rouge">Integer.MIN_VALUE</code>。</p> <p><code class="language-plaintext highlighter-rouge">resolveException</code> 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">JwtException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ErrorVO</span> <span class="nf">handleJwtException</span><span class="o">(</span><span class="nc">JwtException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Invalid Token from {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">INVALID_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><summary type="html"><![CDATA[在之前的 Spring-Validation 中简单介绍了如何通过 @RestControllerAdvice 或者 @ControllerAdvice 注解来处理全局异常，但是这种方式只能 处理 Controller 层抛出的异常。 这篇文章介绍如何处理自定义 Filter 抛出的异常。 自定义 Filter 例如我们可能需要一个 Filter 来检验 Token 是否合法，而检查的过程中发现 Token 不合法，则抛出异常。 @WebFilter public class JwtFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } } 注意：通过 @WebFilter 注释的 Filter 需要在 @SpringBootApplication 启动类中添加 @ServletComponentScan("xxx.xxx.xx") 注解指定 Filter 的查找路径。 上面过程中抛出的异常不会被 @RestControllerAdvice 或者 @ControllerAdvice 捕获。 HandlerExceptionResolver 实际上 Spring Boot 的异常处理是通过 HandlerExceptionResolver 来实现的。Spring Boot 中已经存在 两个默认的 HandlerExceptionResolver，我们可以通过 @Qualifier("HandlerExceptionResolver") 配合 @Autowired 获取到负责处理异常的 HandlerExceptionResolver，然后显式调用 resolveException 方法来处理异常。 解决方案 要实现这些，我们只需要自定义一个 Filter 并让其第一个执行，对捕获到的异常显式调用 resolveException 进行处理就可以触发全局定义的异常处理器： @Component @Order(Ordered.HIGHEST_PRECEDENCE) public class ExceptionHandlerFiter extends OncePerRequestFilter { @Autowired @Qualifier("handlerExceptionResolver") private HandlerExceptionResolver resolver; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { filterChain.doFilter(request, response); } catch (Exception e) { resolver.resolveException(request, response, null, e); } } } 注意：@WebFilter 不能指定 Filter 的执行顺序 (实际上是可以的，通过指定 @WebFilter 中的 filterName，执行顺序是按照该字段的字典序)，要指定 Filter 的执行顺序，我们可以通 @Order 和 @Component 来实现，@Order 的值越小，执行顺序越靠前，上述例子的 Ordered.HIGHEST_PRECEDENCE 实际上是 Integer.MIN_VALUE。 resolveException 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 Filter 抛出的异常了： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(JwtException.class) public ErrorVO handleJwtException(JwtException e, HttpServletRequest request) { logger.error("Invalid Token from {}", request.getRemoteAddr()); return new ErrorVO(ErrorMessageConstant.INVALID_TOKEN); } }]]></summary></entry><entry><title type="html">使用 Spring-Validation 进行数据校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/" rel="alternate" type="text/html" title="使用 Spring-Validation 进行数据校验"/><published>2024-08-23T02:24:05+00:00</published><updated>2024-08-23T02:24:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/"><![CDATA[<p>在开发 <code class="language-plaintext highlighter-rouge">web</code> 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 <code class="language-plaintext highlighter-rouge">if else</code> 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 来进行数据 校验。</p> <h1 id="使用-jsr-303-注解">使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 注解</h1> <p><code class="language-plaintext highlighter-rouge">Spring-Validation</code> 提供了对于 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解的支持，我们可以使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解来对数据进行校验。</p> <p>简单来讲，对于一个 <code class="language-plaintext highlighter-rouge">DTO</code> 对象，我们可以在其属性上添加 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解，然后在 <code class="language-plaintext highlighter-rouge">Controller</code> 中对 参数使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解来对数据进行校验。</p> <p>例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 <code class="language-plaintext highlighter-rouge">DTO</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过上面的操作后，如果前端传入的数据不符合要求，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会抛出一个 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code> 异常，这个异常的默认处理方式是返回一个 <code class="language-plaintext highlighter-rouge">400</code> 的状态码和一个 <code class="language-plaintext highlighter-rouge">JSON</code> 格式的错误信息。我们可以自己定义异常处理器。</p> <h1 id="自定义异常处理器">自定义异常处理器</h1> <p>异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 <code class="language-plaintext highlighter-rouge">Controller</code> 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。</p> <h2 id="全局异常处理器">全局异常处理器</h2> <p>要定义一个全局异常处理器，我们可以创建一个类并且添加 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">e</span><span class="o">.</span><span class="na">getBindingResult</span><span class="o">().</span><span class="na">getFieldErrors</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">error</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">fieldName</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getField</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">errorMessage</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getDefaultMessage</span><span class="o">();</span>
            <span class="n">errors</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">errorMessage</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">errors</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 <code class="language-plaintext highlighter-rouge">Map</code> 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Username length must be between 1 and 20 characters"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="局部异常处理器">局部异常处理器</h2> <p>局部异常处理器的定义只需要将异常处理器定义在某个 <code class="language-plaintext highlighter-rouge">Controller</code> 中即可。</p> <h1 id="分组校验">分组校验</h1> <p>现在我们为上面的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象添加一个 <code class="language-plaintext highlighter-rouge">id</code> 字段，在创建用户的时候，不需要指定 <code class="language-plaintext highlighter-rouge">id</code> 字段，但是在更新 用户的时候，<code class="language-plaintext highlighter-rouge">id</code> 字段是必须的。这时候我们可以使用分组校验来解决这个问题。</p> <p>首先我们需要在 <code class="language-plaintext highlighter-rouge">DTO</code> 对象中定义一个分组：(这里使用内部类进行演示)</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Update</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Create</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>然后我们在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">@Validated</code> (此时不能使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 注解) 注解来指定分组：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PatchMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">updateUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="常用注解">常用注解</h1> <p><code class="language-plaintext highlighter-rouge">JSR 303</code> 中定义了很多注解，这里列出一些常用的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Null</code></td> <td>验证对象是否为 <code class="language-plaintext highlighter-rouge">null</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotNull</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>，无法查检长度为 <code class="language-plaintext highlighter-rouge">0</code>的字符串</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotBlank</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>、长度是否大于 <code class="language-plaintext highlighter-rouge">0</code>、是否包含至少一个非空白字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertFalse</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertTrue</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Min</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Max</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMin</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMax</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Digits</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是指定范围内的数字</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Past</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之前</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Future</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之后</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Size</code></td> <td>验证对象（<code class="language-plaintext highlighter-rouge">Array</code>、<code class="language-plaintext highlighter-rouge">Collection</code>、<code class="language-plaintext highlighter-rouge">Map</code>、<code class="language-plaintext highlighter-rouge">String</code>）长度是否在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Pattern</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否符合正则表达式的规则</td> </tr> </tbody> </table> <p>下面的注解是 <code class="language-plaintext highlighter-rouge">Hibernate Validator</code> 中定义的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Email</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是一个合法的电子邮件地址</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Length</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotEmpty</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code> 或者 <code class="language-plaintext highlighter-rouge">""</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Range</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否在给定的范围之内</td> </tr> </tbody> </table> <h1 id="messagesource-管理错误信息"><code class="language-plaintext highlighter-rouge">MessageSource</code> 管理错误信息</h1> <p>在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。</p> <p>为了解决这个问题，我们可以使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 来管理错误信息。</p> <p>首先我们在 <code class="language-plaintext highlighter-rouge">application.yml</code> ( 或者 <code class="language-plaintext highlighter-rouge">application.properties</code> ) 中添加如下配置：</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">messages</span><span class="pi">:</span>
    <span class="na">basename</span><span class="pi">:</span> <span class="s">message/message</span>
    <span class="na">encoding</span><span class="pi">:</span> <span class="s">UTF-8</span>
</code></pre></div></div> <p>标识我们的错误信息文件在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下的 <code class="language-plaintext highlighter-rouge">message</code> 目录中，文件名为 <code class="language-plaintext highlighter-rouge">message.properties</code> ( 只能 使用 <code class="language-plaintext highlighter-rouge">properties</code> 文件 )。</p> <p>接下来，我们在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下创建一个 <code class="language-plaintext highlighter-rouge">message</code> 目录，并且在其中创建一个 <code class="language-plaintext highlighter-rouge">message.properties</code> 文件， 在文件中添加如下内容：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
</code></pre></div></div> <p>然后我们可以直接在注解中的 <code class="language-plaintext highlighter-rouge">message</code> 部分使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的 <code class="language-plaintext highlighter-rouge">key</code> 来引用错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面通过 <code class="language-plaintext highlighter-rouge">message = "{xxx.xxx.xxx}"</code> 的方式获取变量是 <code class="language-plaintext highlighter-rouge">Hibernate</code> 提供的支持。而我们编写的字符串中 的 <code class="language-plaintext highlighter-rouge">{min}</code> 和 <code class="language-plaintext highlighter-rouge">{max}</code> 会被替换成注解中的 <code class="language-plaintext highlighter-rouge">min</code> 和 <code class="language-plaintext highlighter-rouge">max</code> 的值。</p> <p>但是我们在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="c1">// 通过构造器注入 MessageSource</span>
    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们可以在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">MessageSourceUtil</code> 来获取错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserControllerTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCreateUserInvalid</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span>
                <span class="sh">"""
                {
                    "name": "test",
                    "email": "invalid email address",
                    "userPassword": ""
                }
                """</span><span class="o">;</span>
        <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>
                        <span class="nc">MockMvcRequestBuilders</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">user</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpectAll</span><span class="o">(</span>
                        <span class="n">status</span><span class="o">().</span><span class="na">isBadRequest</span><span class="o">(),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.email"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">))),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.userPassword"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span>
                                        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span>
                                                <span class="s">"UserDTO.userPassword.Size"</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span>
                                                <span class="o">))),</span>
                        <span class="n">content</span><span class="o">().</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div> <p>在上面的代码中，我们同样将密码长度等常量信息放在了 <code class="language-plaintext highlighter-rouge">ConstantProperty</code> 类中，这样我们可以在测试中直接 引用这些常量。</p> <h2 id="国际化">国际化</h2> <p>实际上，<code class="language-plaintext highlighter-rouge">MessageSource</code> 是用来支持国际化的。在上面的例子中，我们只是使用了一个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 实际上我们可以使用多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件来支持多种语言。</p> <p>我们只需要在 <code class="language-plaintext highlighter-rouge">resources/message</code> (取决于我们指定的 <code class="language-plaintext highlighter-rouge">basename</code> ) 目录下创建多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 例如 <code class="language-plaintext highlighter-rouge">message.properties</code>、<code class="language-plaintext highlighter-rouge">message_en.properties</code>、<code class="language-plaintext highlighter-rouge">message_zh.properties</code> 等等。这样在发送请求的 时候，我们可以在请求头中添加 <code class="language-plaintext highlighter-rouge">Accept-Language</code> 来指定语言，<code class="language-plaintext highlighter-rouge">Spring</code> 会根据请求头中的语言来选择对应的 <code class="language-plaintext highlighter-rouge">properties</code> 文件中的信息。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在开发 web 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 if else 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 Spring-Validation 来进行数据 校验。 使用 JSR 303 注解 Spring-Validation 提供了对于 JSR 303 中的注解的支持，我们可以使用 JSR 303 中的注解来对数据进行校验。 简单来讲，对于一个 DTO 对象，我们可以在其属性上添加 JSR 303 中的注解，然后在 Controller 中对 参数使用 @Valid 或者 @Validated 注解来对数据进行校验。 例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 DTO 类： @Data public class UserDTO { @Size(min = 1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(message = "Email format is incorrect") @NotBlank(message = "Email cannot be blank") private String email; @Size(min = 6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; } 上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 @Valid 或者 @Validated 注解即可： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Valid @RequestBody UserDTO user) {} } 通过上面的操作后，如果前端传入的数据不符合要求，那么 Spring 会抛出一个 MethodArgumentNotValidException 异常，这个异常的默认处理方式是返回一个 400 的状态码和一个 JSON 格式的错误信息。我们可以自己定义异常处理器。 自定义异常处理器 异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 Controller 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。 全局异常处理器 要定义一个全局异常处理器，我们可以创建一个类并且添加 @RestControllerAdvice 或 @ControllerAdvice 注解： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public Map&lt;String, String&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException e) { Map&lt;String, String&gt; errors=new HashMap&lt;&gt;(); e.getBindingResult().getFieldErrors().forEach((error) -&gt; { String fieldName=error.getField(); String errorMessage=error.getDefaultMessage(); errors.put(fieldName, errorMessage); }); return errors; } } 在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 Map 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到： { "username": "Username length must be between 1 and 20 characters" } 局部异常处理器 局部异常处理器的定义只需要将异常处理器定义在某个 Controller 中即可。 分组校验 现在我们为上面的 DTO 对象添加一个 id 字段，在创建用户的时候，不需要指定 id 字段，但是在更新 用户的时候，id 字段是必须的。这时候我们可以使用分组校验来解决这个问题。 首先我们需要在 DTO 对象中定义一个分组：(这里使用内部类进行演示) @Data public class UserDTO { @NotNull(groups = Update.class) @Null(groups = Create.class) private Long id; @Size( groups={Update.class, Create.class}, min=1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(groups = {Update.class, Create.class}, message="Email format is incorrect") @NotBlank(groups = {Update.class, Create.class}, message="Email cannot be blank") private String email; @Size( groups={Update.class, Create.class}, min=6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; public interface Update {} public interface Create {} } 然后我们在 Controller 中使用 @Validated (此时不能使用 @Valid 注解) 注解来指定分组： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Validated(UserDTO.Create.class) @RequestBody UserDTO user) { return null; } @PatchMapping public ResponseEntity&lt;Void&gt; updateUser(@Validated(UserDTO.Update.class) @RequestBody UserDTO user) { return null; } } 常用注解 JSR 303 中定义了很多注解，这里列出一些常用的注解： 注解 说明 @Null 验证对象是否为 null @NotNull 验证对象是否不为 null，无法查检长度为 0的字符串 @NotBlank 验证 String 对象是否不为 null、长度是否大于 0、是否包含至少一个非空白字符 @AssertFalse 验证 Boolean 对象是否为 false @AssertTrue 验证 Boolean 对象是否为 true @Min 验证 Number 对象是否大于等于指定的值 @Max 验证 Number 对象是否小于等于指定的值 @DecimalMin 验证 Number 和 String 对象是否大于等于指定的值 @DecimalMax 验证 Number 和 String 对象是否小于等于指定的值 @Digits 验证 Number 和 String 对象是否是指定范围内的数字 @Past 验证 Date 对象是否是在当前时间之前 @Future 验证 Date 对象是否是在当前时间之后 @Size 验证对象（Array、Collection、Map、String）长度是否在给定的范围之内 @Pattern 验证 String 对象是否符合正则表达式的规则 下面的注解是 Hibernate Validator 中定义的注解： 注解 说明 @Email 验证 String 对象是否是一个合法的电子邮件地址 @Length 验证 String 对象是否是在给定的范围之内 @NotEmpty 验证对象是否不为 null 或者 "" @Range 验证 Number 对象是否在给定的范围之内 MessageSource 管理错误信息 在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。 为了解决这个问题，我们可以使用 MessageSource 来管理错误信息。 首先我们在 application.yml ( 或者 application.properties ) 中添加如下配置： spring: messages: basename: message/message encoding: UTF-8 标识我们的错误信息文件在 resources 目录下的 message 目录中，文件名为 message.properties ( 只能 使用 properties 文件 )。 接下来，我们在 resources 目录下创建一个 message 目录，并且在其中创建一个 message.properties 文件， 在文件中添加如下内容： # UserDTO validation messages UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters 然后我们可以直接在注解中的 message 部分使用 MessageSource 的 key 来引用错误信息： @Data public class UserDTO { @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_USERNAME_LENGTH, max=ConstantProperty.MAX_USERNAME_LENGTH, message="{UserDTO.username.Size}") private String username; @Email( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.Email}") @NotBlank( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.NotBlank}") private String email; @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_PASSWORD_LENGTH, max=ConstantProperty.MAX_PASSWORD_LENGTH, message="{UserDTO.userPassword.Size}") private String userPassword; } 上面通过 message="{xxx.xxx.xxx}" 的方式获取变量是 Hibernate 提供的支持。而我们编写的字符串中 的 {min} 和 {max} 会被替换成注解中的 min 和 max 的值。 但是我们在使用 MessageSource 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量： @Component public class MessageSourceUtil { private static MessageSource messageSource; // 通过构造器注入 MessageSource MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(String code, Object[] args) { String message=messageSource.getMessage(code, null, null); // 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值 Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 这样我们可以在 Controller 中使用 MessageSourceUtil 来获取错误信息： @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mvc; @Test public void testCreateUserInvalid() throws Exception { String user=""" { "name": "test", "email": "invalid email address", "userPassword": "" } """; mvc.perform( MockMvcRequestBuilders.post("/user") .contentType(MediaType.APPLICATION_JSON) .content(user)) .andExpectAll( status().isBadRequest(), jsonPath( "$.email", equalTo(MessageSourceUtil.getMessage("UserDTO.email.Email"))), jsonPath( "$.userPassword", equalTo( MessageSourceUtil.getMessage( "UserDTO.userPassword.Size", ConstantProperty.MIN_PASSWORD_LENGTH, ConstantProperty.MAX_PASSWORD_LENGTH ))), content().contentType(MediaType.APPLICATION_JSON)); } 在上面的代码中，我们同样将密码长度等常量信息放在了 ConstantProperty 类中，这样我们可以在测试中直接 引用这些常量。 国际化 实际上，MessageSource 是用来支持国际化的。在上面的例子中，我们只是使用了一个 properties 文件， 实际上我们可以使用多个 properties 文件来支持多种语言。 我们只需要在 resources/message (取决于我们指定的 basename ) 目录下创建多个 properties 文件， 例如 message.properties、message_en.properties、message_zh.properties 等等。这样在发送请求的 时候，我们可以在请求头中添加 Accept-Language 来指定语言，Spring 会根据请求头中的语言来选择对应的 properties 文件中的信息。]]></summary></entry></feed>