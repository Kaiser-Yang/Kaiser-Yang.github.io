<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2026-01-31T13:16:02+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>Sharing everything I know. </subtitle><entry><title type="html">奇怪的知识增加了</title><link href="https://kaiser-yang.github.io/blog/2026/uncommon-knowledge/" rel="alternate" type="text/html" title="奇怪的知识增加了"/><published>2026-01-25T05:39:41+00:00</published><updated>2026-01-25T05:39:41+00:00</updated><id>https://kaiser-yang.github.io/blog/2026/uncommon-knowledge</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2026/uncommon-knowledge/"><![CDATA[<h2 id="汉语字词">汉语字词</h2> <p>氤氲（yīn yūn）</p> <p>释义：</p> <ul> <li>原指烟云、雾气等弥漫融合、混沌不清的样子（侧重“气”的流动与交织）；</li> <li>引申为气氛、气息等浓郁而弥漫的状态（如“诗意氤氲”“茶香氤氲”）。</li> </ul> <p>例句：</p> <ul> <li>清晨的西湖被薄雾氤氲着，远处的雷峰塔只露出半截塔尖，像浸在牛奶里的墨痕。</li> </ul> <hr/> <p>罹患（lí huàn）</p> <p>释义：</p> <ul> <li>书面语，指患病（多指患上比较严重或特定的疾病）。</li> </ul> <p>例句：</p> <ul> <li>这位老人晚年罹患阿尔茨海默症，记忆逐渐模糊，却始终记得年轻时教书的校园。</li> </ul> <hr/> <p>英亩（yīng mǔ）</p> <p>释义：</p> <ul> <li>英制面积单位，1英亩约等于4046.86平方米（或约6.07市亩），常用于计量土地面积。</li> </ul> <p>例句：</p> <ul> <li>这片家族农场拥有80英亩的麦田，每到丰收季便是一片金黄的海洋。</li> </ul> <hr/> <p>英里（yīng lǐ）</p> <p>释义：</p> <ul> <li>英制长度单位，1英里约等于1609.344米（或约1.609公里），常用于英美等国计量距离。</li> </ul> <p>例句：</p> <ul> <li>从伦敦市中心到希思罗机场的直线距离约为15英里，开车通常需要40分钟左右。</li> </ul> <hr/> <p>英尺（yīng chǐ）</p> <p>释义：</p> <ul> <li>英制长度单位，1英尺约等于0.3048米（或30.48厘米），常用于英美等国计量身高、家具尺寸等。</li> </ul> <p>例句：</p> <ul> <li>他的身高约为6英尺，换算成公制大约是183厘米。</li> </ul> <hr/> <p>英寸（yīng cùn）</p> <p>释义：</p> <ul> <li>英制长度单位，1英寸等于2.54厘米（常用于屏幕尺寸、管材直径）。</li> </ul> <p>例句：</p> <ul> <li>这款平板电脑屏幕为11英寸，便携性与视觉体验兼顾。</li> </ul> <hr/> <p>念兹在兹（niàn zī zài zī）</p> <p>释义：</p> <ul> <li>指念念不忘某件事，形容时刻牵挂于心（出自《尚书·大禹谟》“念兹在兹，释兹在兹”）。</li> </ul> <p>例句：</p> <ul> <li>海外游子念兹在兹的，始终是故乡老屋前那棵年年开花的桂树。</li> </ul> <hr/> <p>付梓（fù zǐ）</p> <p>释义：</p> <ul> <li>书面语，指把稿件交付印刷（“梓”原指印刷用的木版）。</li> </ul> <p>例句：</p> <ul> <li>这部凝聚作者十年心血的学术专著终于付梓，即将与读者见面。</li> </ul> <hr/> <p>迩来（ěr lái）</p> <p>释义：</p> <ul> <li>书面语，指近来、最近（“迩”意为近）。</li> </ul> <p>例句：</p> <ul> <li>迩来天气反常，昨日还暖阳高照，今日便飘起了小雪。</li> </ul> <hr/> <p>顾盼自雄（gù pàn zì xióng）</p> <p>释义：</p> <ul> <li>形容得意忘形、自以为了不起的样子（“顾盼”指左右张望）。</li> </ul> <p>例句：</p> <ul> <li>他刚升任部门主管便顾盼自雄，对老同事也呼来喝去，渐渐失了人心。</li> </ul> <hr/> <p>毋宁（wú nìng）</p> <p>释义：</p> <ul> <li>连词，表示选择关系，相当于“宁可、不如”。</li> </ul> <p>例句：</p> <ul> <li>与其在无效社交中消耗精力，毋宁独处读书充实自己。</li> </ul> <hr/> <p>巨细靡遗（jù xì mí yí）</p> <p>释义：</p> <ul> <li>指大小事情都详尽无遗，没有遗漏（“靡遗”即无遗漏）。</li> </ul> <p>例句：</p> <ul> <li>这份调查报告巨细靡遗，连现场每片落叶的位置都标注清晰。</li> </ul> <hr/> <p>稔（rěn）</p> <p>释义：</p> <ul> <li>庄稼成熟；</li> <li>熟悉（如“稔知”“素稔”）；</li> <li>年（如“丰稔”“三稔”）。</li> </ul> <p>例句：</p> <ul> <li>这片土地肥沃，稻子每年都能稔收，养活了村里几代人。（义项①）</li> <li>他在此地生活半生，对乡间小路稔熟得如同掌纹。（义项②）</li> </ul> <hr/> <p>囹圄（líng yǔ）</p> <p>释义：</p> <ul> <li>书面语，指监狱。</li> </ul> <p>例句：</p> <ul> <li>他曾因冤案身陷囹圄，平反后更珍惜自由的可贵。</li> </ul> <hr/> <p>商榷（shāng què）</p> <p>释义：</p> <ul> <li>书面语，指商量、讨论（多用于正式场合）。</li> </ul> <p>例句：</p> <ul> <li>这个方案涉及多方利益，还需进一步商榷细节。</li> </ul> <hr/> <p>戒荤茹素（jiè hūn rú sù）</p> <p>释义：</p> <ul> <li>戒除荤腥食物，改吃素食（多为健康、宗教或养生目的）。</li> </ul> <p>例句：</p> <ul> <li>为调理肠胃，他决定戒荤茹素三个月，只吃五谷蔬果。</li> </ul> <hr/> <p>不落窠臼（bù luò kē jiù）</p> <p>释义：</p> <ul> <li>比喻文章、艺术等有独创风格，不落俗套（“窠臼”指现成的格式、套路）。</li> </ul> <p>例句：</p> <ul> <li>这部话剧的叙事手法不落窠臼，用倒叙穿插时空，观众耳目一新。</li> </ul> <hr/> <p>潺湲（chán yuán）</p> <p>释义：</p> <ul> <li>水缓慢流动的样子（侧重动态舒缓）；</li> <li>书面语，形容流泪不止（表悲伤/思念）；</li> </ul> <p>例句：</p> <ul> <li>山涧溪水潺湲，如鸣佩环，洗去旅人一身疲惫。</li> <li>故园遥望隔重云，别后离情泪潺湲。</li> </ul> <hr/> <p>凛冽（lǐn liè）</p> <p>释义：</p> <ul> <li>寒冷刺骨（多形容风、气温）。</li> </ul> <p>例句：</p> <ul> <li>北风凛冽的冬夜，街灯在雪幕里晕开昏黄的光圈。</li> </ul> <hr/> <p>冷冽（lěng liè）</p> <p>释义：</p> <ul> <li>寒冷刺骨（同“凛冽”，多形容空气、水等）。</li> </ul> <p>例句：</p> <ul> <li>冷冽的山泉从石缝涌出，捧一口顿觉神清气爽。</li> </ul> <hr/> <p>泠洌（líng liè）</p> <p>释义：</p> <ul> <li>同“冷冽”，形容清凉、寒冷（书面语色彩更浓）。</li> </ul> <p>例句：</p> <ul> <li>深山古寺的井水泠洌甘甜，僧人晨起必饮一瓢。</li> </ul> <hr/> <p>掴（guó）</p> <p>释义：</p> <ul> <li>动词，用手掌打（口语中常说“掴耳光”）。</li> </ul> <p>例句：</p> <ul> <li>他被这突如其来的真相震惊得忘了反驳，只觉脸上重重一掴。</li> </ul> <hr/> <p>舌灿莲花（shé càn lián huā）</p> <p>释义：</p> <ul> <li>形容人口才好，言辞生动精彩。</li> </ul> <p>例句：</p> <ul> <li>辩论赛上，她舌灿莲花，引经据典驳得对方哑口无言。</li> </ul> <hr/> <p>不分轩轾（bù fēn xuān zhì）</p> <p>释义：</p> <ul> <li>不分高下、优劣（“轩轾”指车前高后低为轩，前低后高为轾，喻高低）。</li> </ul> <p>例句：</p> <ul> <li>两位画家的作品风格迥异，艺术价值却不分轩轾。</li> </ul> <hr/> <p>杪（miǎo）</p> <p>释义：</p> <ul> <li>末端，末尾。</li> </ul> <p>例句：</p> <ul> <li>夏杪的荷塘褪去繁华，只剩残叶在风中诉说秋意。</li> </ul> <hr/> <p>丘阜（qiū fù）</p> <p>释义：</p> <ul> <li>低矮的小土山（“阜”指土山）。</li> </ul> <p>例句：</p> <ul> <li>丘陵地带散布着零星丘阜，登高可眺望整片稻田。</li> </ul> <hr/> <p>隈隩（wēi yù）</p> <p>释义：</p> <ul> <li>书面语，指山水弯曲隐蔽之处（“隈”：角落；“隩”：水岸内曲处）。</li> </ul> <p>例句：</p> <ul> <li>渔舟泊于隈隩，船娘哼着吴歌，惊起几只白鹭。</li> </ul> <hr/> <p>踽踽独行（jǔ jǔ dú xíng）</p> <p>释义：</p> <ul> <li>形容独自走路孤零零的样子（“踽踽”：孤独的样子）。</li> </ul> <p>例句：</p> <ul> <li>暮色中，老人踽踽独行在老街上，背影被夕阳拉得很长。</li> </ul> <hr/> <p>薄馔（bó zhuàn）</p> <p>释义：</p> <ul> <li>书面语，指简单粗陋的饭食（“馔”：饭食）。</li> </ul> <p>例句：</p> <ul> <li>山寺僧人以薄馔相待，一碗青菜豆腐汤却暖透客心。</li> </ul> <hr/> <p>大书特书（dà shū tè shū）</p> <p>释义：</p> <ul> <li>指对重要的事情着重书写或宣扬。</li> </ul> <p>例句：</p> <ul> <li>抗疫英雄的逆行壮举，值得历史大书特书。</li> </ul> <hr/> <p>形而上（xíng ér shàng）</p> <p>释义：</p> <ul> <li>出自《易经·系辞》”形而上者谓之道，形而下者谓之器”，指超越有形事物的本体性存在。</li> </ul> <p>例句：</p> <ul> <li>他对宇宙起源的思考偏向形而上学，试图探寻存在的终极意义。</li> </ul> <hr/> <p>箭镞（jiàn zú）</p> <p>释义：</p> <ul> <li>箭头（金属或骨质制成的尖锐部分）。</li> </ul> <p>例句：</p> <ul> <li>考古队在遗址中发现数枚青铜箭镞，印证了古战场的存在。</li> </ul> <hr/> <p>岿然不动（kuī rán bù dòng）</p> <p>释义：</p> <ul> <li>形容高大稳固，毫不动摇（“岿然”：高峻独立的样子）。</li> </ul> <p>例句：</p> <ul> <li>面对狂风暴雨，那座千年古塔依然岿然不动。</li> </ul> <hr/> <p>筚路蓝缕，以启山林（bì lù lán lǚ yǐ qǐ shān lín）</p> <p>释义：</p> <ul> <li>筚路：柴车；蓝缕：破衣服。驾着简陋的车，穿着破烂的衣服去开辟山林。形容创业的艰苦。</li> </ul> <hr/> <p>淅沥（xī lì）</p> <p>释义：</p> <ul> <li>象声词，形容轻微的风雨声（如小雨、落叶声）。</li> </ul> <p>例句：</p> <ul> <li>窗外细雨淅沥，屋内茶香袅袅，正是读书好时节。</li> </ul> <hr/> <p>阙如（quē rú）</p> <p>释义：</p> <ul> <li>“阙”本义指皇宫门前两边供瞭望的楼，后引申为空缺、欠缺。该词出自《论语·子路篇第十三》“君子于其所不知，盖阙如也”，指对未知事物应存疑不书；后《后汉书·孝和皇帝纪》“礼仪制度阙如也”用以描述制度缺失状态。</li> </ul> <hr/> <p>波谲云诡（bō jué yún guǐ）</p> <p>释义：</p> <ul> <li>形容事态变化多端，难以预料（“波谲”“云诡”均指变幻莫测）。</li> </ul> <p>例句：</p> <ul> <li>国际局势波谲云诡，外交官需时刻保持敏锐判断。</li> </ul> <hr/> <p>扬基人（yáng jī rén）</p> <p>释义：</p> <ul> <li>对美国人的俗称（“扬基”音译自英语“Yankee”）。</li> </ul> <p>例句：</p> <ul> <li>这位扬基人画家痴迷中国水墨，作品融合了东西方技法。</li> </ul> <hr/> <p>不无裨益（bù wú bì yì）</p> <p>释义：</p> <ul> <li>指有一定的益处，并非毫无好处（“不无”表示“不是没有”，“裨益”指益处）。</li> </ul> <p>例句：</p> <ul> <li>每天坚持晨读半小时，对培养语感和积累词汇不无裨益。</li> </ul> <h2 id="哲学">哲学</h2> <p>超验主义</p> <p>超验主义可以归纳为如下三个假设：</p> <ol> <li>词语是自然现象的表征； <ul> <li>这句话否定了语言的任意性，认为词语不是人为创造的符号，而是对自然现象的直接映射。超验主义者相信，语言的根源在自然之中，一个词语的意义，源于它所对应的自然事物的特质，比如“流水”一词，不只是指代水的流动形态，更承载着自然本身的动态属性。</li> </ul> </li> <li>特定的自然现象是特定的灵性现象的表征； <ul> <li>这是超验主义的核心逻辑，自然现象并非孤立的物质存在，而是灵性力量的外在显现。特定的自然事物对应特定的精神内涵，比如“橡树”的苍劲挺拔，是坚韧、不朽的灵性特质的具象化；“落日”的余晖，是生命圆满、归宿感的灵性象征，人可以通过观察自然现象，感知到背后的精神意义。</li> </ul> </li> <li>自然本身是灵性的表征。 <ul> <li>这是前两个假设的升华，将自然整体与终极灵性挂钩。超验主义眼中的自然不是零散事物的集合，而是终极灵性（可理解为“超灵” Oversoul）的载体和外在表现，整个自然世界就是一部灵性的“大书”，万物同源、同归于超灵，人融入自然，就是与终极灵性的连通。</li> </ul> </li> </ol> <p>超验主义这三个假设层层递进，构建了自然—语言—灵性三者的表征关联体系，核心是打破物质与精神的二元对立，强调万物背后共通的灵性本质。</p> <p>简单来说，这三句话的逻辑链条是：语言反映自然，自然反映灵性，自然整体就是灵性的化身，最终指向人可以通过自然与自身的灵性对话，实现精神的超越。</p> <hr/> <p>本体论</p> <p>本体论（Ontology）是哲学的核心分支之一，也是形而上学的核心内容，其词源来自希腊语“ὄν”（on，存在）和“λόγος”（logos，研究、言说），直白理解为“对存在本身的研究”。它的核心使命是追问世界的根本实在：探究什么是“真正的存在”、存在的本质与基本特征、存在者的分类及相互关系，以及“存在”与“表象”的区别，是哲学中最基础、最根本的“第一哲学”问题。</p> <h2 id="建筑风格">建筑风格</h2> <p>哥特式</p> <p>哥特式（Gothic）是一种起源于11世纪下半叶的文化艺术风格，内涵丰富，充斥神秘、恐怖、浪漫、阴郁等元素，常见于建筑、文学、音乐等不同领域 。以下是关于它的详细介绍 ：</p> <ul> <li>名称由来：原指代哥特人，是西欧日耳曼部族。文艺复兴时期，意大利理论家瓦萨里在其著作《名人传》中首次用“哥特”一词抨击尖拱式建筑风格，意为“野蛮、粗暴”。</li> <li>建筑风格：11世纪下半叶起源于法国，13-15世纪流行于欧洲。其基本构件是尖拱和肋架拱顶，整体风格高耸削瘦，常通过巨大的穹顶和支柱、精美的绘画、花窗和雕刻来营造神秘浓厚的宗教氛围。代表建筑有巴黎圣母院、科隆大教堂等。</li> <li>文学风格：1764年，贺拉斯·瓦尔浦尔的小说《奥特朗托城堡》标志着哥特小说的诞生。其内容大多充斥着诡异、神秘以及怪诞色彩，标志性元素包括恐怖、超自然、死亡、巫术、古堡等，偏爱黑暗凄凉的场景。代表作品有玛丽·雪莱的《弗兰肯斯坦》、爱伦·坡的《厄舍府的倒塌》等。</li> <li>音乐风格：20世纪80年代初，英国开启哥特文化运动，带动了哥特式音乐的发展。此类音乐从哥特式文学中的抒情诗、死亡主题等吸取灵感，通过舒缓而强劲的音效营造出不祥与悲伤之感，表现出人性中黑暗、阴沉等倾向。代表乐队有包豪斯乐队、Marilyn Manson乐队等。</li> <li>其他领域：在绘画、雕塑、影视、服饰等领域也有体现。哥特式绘画多为彩色玻璃镶嵌画等；哥特式服饰通常以黑色为主，搭配惨白的妆容和特色饰品，常见元素有十字架、骷髅等。</li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="中文文章"/><summary type="html"><![CDATA[一些不太常用的知识。]]></summary></entry><entry><title type="html">文学摘抄</title><link href="https://kaiser-yang.github.io/blog/2025/literature/" rel="alternate" type="text/html" title="文学摘抄"/><published>2025-12-11T06:18:12+00:00</published><updated>2025-12-11T06:18:12+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/literature</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/literature/"><![CDATA[<h2 id="诗词歌赋">诗词歌赋</h2> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">洛阳春</span> <span class="lit-author">岑参</span> </figcaption> <blockquote> <p>人到洛阳花似锦，偏我来时不逢春。</p> <p>谁道三冬无春色，冰山高处万里银。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">离思五首·其四</span> <span class="lit-author">元稹</span> </figcaption> <blockquote> <p>曾经沧海难为水，除却巫山不是云。</p> <p>取次花丛懒回顾，半缘修道半缘君。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">金缕衣</span> <span class="lit-author">佚名</span> </figcaption> <blockquote> <p>劝君莫惜金缕衣，劝君惜取少年时。</p> <p>花开堪折直须折，莫待无花空折枝。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">梅岭三章·其一</span> <span class="lit-author">陈毅</span> </figcaption> <blockquote> <p>断头今日意如何？创业艰难百战多。</p> <p>此去泉台招旧部，旌旗十万斩阎罗。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">观书有感二首·其一</span> <span class="lit-author">朱熹</span> </figcaption> <blockquote> <p>半亩方塘一鉴开��天光云影共徘徊。</p> <p>问渠那得清如许？为有源头活水来。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">观书有感二首·其二</span> <span class="lit-author">朱熹</span> </figcaption> <blockquote> <p>昨夜江边春水生，艨艟巨舰一毛轻。</p> <p>向来枉费推移力，此日中流自在行。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">竹枝词九首·其二</span> <span class="lit-author">刘禹锡</span> </figcaption> <blockquote> <p>山桃红花满上头，蜀江春水拍山流。</p> <p>花红易衰似郎意，水流无限似侬愁。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">南乡子·登京口北固亭有怀</span> <span class="lit-author">辛弃疾</span> </figcaption> <blockquote> <p>何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。</p> <p>年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">满江红·和郭沫若同志</span> <span class="lit-author">毛泽东</span> </figcaption> <blockquote> <p>小小寰球，有几个苍蝇碰壁。嗡嗡叫，几声凄厉，几声抽泣。蚂蚁缘槐夸大国，蚍蜉撼树谈何易。正西风落叶下长安，飞鸣镝。</p> <p>多少事，从来急；天地转，光阴迫。一万年太久，只争朝夕。四海翻腾云水怒，五洲震荡风雷激。要扫除一切害人虫，全无敌。</p> </blockquote> </figure> <figure class="lit lit-poem"> <figcaption> <span class="lit-title">清平乐·六盘山</span> <span class="lit-author">毛泽东</span> </figcaption> <blockquote> <p>天高云淡，望断南飞雁。不到长城非好汉，屈指行程二万。</p> <p>六盘山上高峰，红旗漫卷西风。今日长缨在手，何时缚住苍龙？</p> </blockquote> </figure> <h2 id="古话">古话</h2> <figure class="lit lit-quote"> <blockquote> <p>忠言逆耳利于行，毒药苦口利于病。</p> </blockquote> <figcaption>——《史记》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>智者千虑，必有一失；愚者千虑，必有一得。</p> </blockquote> <figcaption>——《史记》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>举大事不细谨，盛德不辞让，而公不为若更言。</p> </blockquote> <figcaption>——《史记》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>朝闻道，夕死可矣。</p> </blockquote> <figcaption>——《论语》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>王子比干者，亦纣之亲戚也。见箕子谏不听而为奴，则曰：“君有过而不以死争，则百姓何辜！”乃直言谏纣。纣怒曰：“吾闻圣人之心有七窍，信有诸乎？”乃遂杀王子比干，刳视其心。</p> </blockquote> <figcaption>——《史记》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>纣作炮烙之刑。王子比干曰：“主暴不谏，非忠也；畏死不言，非勇也。见过即谏，不用即死，忠之至也。”遂谏，三日不去��，纣囚杀之。诗曰：“昊天大怃，予慎无辜！”</p> </blockquote> <figcaption>——《韩诗外传》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>季康子问政于孔子曰：“如杀无道以就有道，何如？”</p> <p>孔子对曰：“子为政，焉用杀？子欲善而民善矣。君子之德风，小人之德草，草上之风必偃。”</p> </blockquote> <figcaption>——《论语》</figcaption> </figure> <figure class="lit lit-quote"> <blockquote> <p>丘也闻有国有家者，不患寡而患不均，不患贫而患不安。盖均无贫，和无寡，安无倾。夫如是，故远人不服，则修文德以来之。既来之，则安之。</p> </blockquote> <figcaption>——《论语》</figcaption> </figure> <h2 id="文学">文学</h2> <figure class="lit lit-quote"> <blockquote> <p>侯非侯，王非王，千乘万骑归邙山！狡兔死，良弓藏；我之后，君复伤！一曲《广陵散》，再奏待芸娘。</p> </blockquote> <figcaption>——《大明王朝1566》</figcaption> </figure> <h2 id="台词">台词</h2> <figure class="lit lit-quote lit-dialogue"> <blockquote> <p>在一个严寒的冬天，三百多名共青团员到博亚尔卡修一条窄轨铁路，为的是给基辅的人民运取暖的木材。那个时候我们想：“我们所做的，是最有意义的，伟大的工作。”所以，我们能够战胜一切艰难困苦，把铁路修成了。可是昨天，报纸上登着：“有几千名共青团员，要把古老的第聂伯河拦腰斩断，用河水转动发电站，一百万千瓦的涡轮。”那是多么雄伟的工程啊，同志们！我们当年做的，就显得微不足道了。</p> <p>在今天这个时代，我们每一个共青团员，要用什么样的态度对待生活？是贪图享受，还是继续战斗？当年我们的父兄浴血奋斗，是为了美好的今天。那么，在今天，青年一代的形象应该是：团结奋斗，手挽手，一往无前，任何困难都吓不倒我们！</p> </blockquote> <figcaption>——《钢铁是怎样炼成的》（电视剧）</figcaption> </figure>]]></content><author><name></name></author><category term="Potpourri"/><category term="中文文章"/><category term="Literature"/><summary type="html"><![CDATA[本文收集了一些我喜欢的文学作品中的摘抄。]]></summary></entry><entry><title type="html">Go 学习笔记</title><link href="https://kaiser-yang.github.io/blog/2025/go-learning/" rel="alternate" type="text/html" title="Go 学习笔记"/><published>2025-12-09T11:44:38+00:00</published><updated>2025-12-09T11:44:38+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/go-learning</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/go-learning/"><![CDATA[<p>使用 <code class="language-plaintext highlighter-rouge">fmt.Printf</code> 时可能涉及到相关的格式化动词，以下是一些常用的格式化动词及其含义：</p> <table> <thead> <tr> <th>动词</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td>%v</td> <td>默认格式</td> </tr> <tr> <td>%+v</td> <td>带字段名的结构体格式</td> </tr> <tr> <td>%#v</td> <td>Go 语法表示的值</td> </tr> <tr> <td>%T</td> <td>类型信息</td> </tr> <tr> <td>%t</td> <td>布尔值</td> </tr> <tr> <td>%c</td> <td>对应的 Unicode 字符</td> </tr> <tr> <td>%U</td> <td>Unicode 格式的字符</td> </tr> <tr> <td>%%</td> <td>字符 ‘%’</td> </tr> <tr> <td>%s</td> <td>字符串</td> </tr> <tr> <td>%q</td> <td>带双引号的字符串</td> </tr> <tr> <td>%p</td> <td>指针地址</td> </tr> <tr> <td>%b</td> <td>二进制</td> </tr> <tr> <td>%o/%O</td> <td>八进制（是否带 <code class="language-plaintext highlighter-rouge">0o</code> 前缀）</td> </tr> <tr> <td>%x/%X</td> <td>十六进制（大小写）</td> </tr> <tr> <td>%d/%i</td> <td>十进制整数</td> </tr> <tr> <td>%f</td> <td>十进制浮点数</td> </tr> <tr> <td>%g</td> <td>最简洁的十进制或科学计数法</td> </tr> <tr> <td>%e/%E</td> <td>科学计数法（大小写）</td> </tr> <tr> <td>%w</td> <td>用于错误包装</td> </tr> </tbody> </table> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 中的语句后面通常都不需要使用 <code class="language-plaintext highlighter-rouge">;</code> 来结尾， 并且在条件分支和循环分支中也不需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来包裹条件表达式。 除此之外，在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的条件分支中可以添加一条初始化语句，这条语句会在条件判断之前执行， 并且其作用域仅限于该条件分支内。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">doSomething</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="c">// 处理错误</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c">// 正常处理</span>
<span class="p">}</span>
<span class="c">// err 在这里不可见</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">switch</code> 语句会自动在每个 <code class="language-plaintext highlighter-rouge">case</code> 分支后面添加一个隐式的 <code class="language-plaintext highlighter-rouge">break</code>， 因此不需要显式地使用 <code class="language-plaintext highlighter-rouge">break</code> 语句来终止分支。 如果想要在某个 <code class="language-plaintext highlighter-rouge">case</code> 分支中继续执行下一个分支，可以使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 关键字。</p> <p><code class="language-plaintext highlighter-rouge">fallthrough</code> 的作用是强制执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支的代码，而不进行条件判断。 如果想在执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 后继续执行下下个 <code class="language-plaintext highlighter-rouge">case</code>， 则需要在下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支中再次使用 <code class="language-plaintext highlighter-rouge">fallthrough</code>。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">type</code> 关键字来定义新类型或者给已有的类型取别名。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span>
  <span class="n">MyInt</span> <span class="kt">int</span>              <span class="c">// 定义新类型 MyInt，底层类型为 int</span>
  <span class="n">YourInt</span> <span class="o">=</span> <span class="kt">int</span>          <span class="c">// 给 int 类型取别名 YourInt</span>
<span class="p">)</span>
</code></pre></div></div> <p>别名类型和原类型是完全相同的类型，可以互相赋值和转换。 而新类型和原类型是不同的类型，往往需要进行显式的转换。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">var</code>、<code class="language-plaintext highlighter-rouge">const</code>、<code class="language-plaintext highlighter-rouge">type</code>、<code class="language-plaintext highlighter-rouge">import</code> 等关键字都可以使用块语法来声明多个变量、常量或类型。 块语法使用 <code class="language-plaintext highlighter-rouge">()</code> 将多个声明包裹在一起。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
  <span class="n">a</span> <span class="kt">int</span>
  <span class="n">b</span> <span class="kt">string</span>
  <span class="n">c</span> <span class="kt">bool</span>
<span class="p">)</span>
</code></pre></div></div> <p>这种方式可以使代码更加整洁，尤其是在需要声明多个相关变量时。</p> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中，后续的变量会重复使用前一个变量的表达式，除非显式地为其赋值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="m">1</span>
  <span class="n">B</span>        <span class="c">// B 的值为 1</span>
  <span class="n">C</span> <span class="o">=</span> <span class="m">2</span>
  <span class="n">D</span>        <span class="c">// D 的值为 2</span>
<span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中可以使用 <code class="language-plaintext highlighter-rouge">iota</code>，它的值是当前变量所在的偏移位置（从0开始计算）。 每当遇到一个新的 <code class="language-plaintext highlighter-rouge">const</code> 块时，<code class="language-plaintext highlighter-rouge">iota</code> 会被重置为0，并且在每一行中递增1。 也可以在 <code class="language-plaintext highlighter-rouge">const</code> 块中使用 <code class="language-plaintext highlighter-rouge">_</code> 来忽略某些值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="no">iota</span>           <span class="c">// A 的值为 0</span>
  <span class="n">B</span>                  <span class="c">// B 的值为 1</span>
  <span class="n">_</span>                  <span class="c">// 忽略该值，iota 递增到 2</span>
  <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="no">iota</span><span class="p">,</span> <span class="no">iota</span>  <span class="c">// C 和 D 的值均为 3</span>
<span class="p">)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以定义 <code class="language-plaintext highlighter-rouge">label</code>，<code class="language-plaintext highlighter-rouge">label</code> 可以用来进行 <code class="language-plaintext highlighter-rouge">continue</code> 或者 <code class="language-plaintext highlighter-rouge">break</code> 操作， 从而跳出多层循环或者指定跳出某个循环。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OuterLoop</span><span class="o">:</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="n">OuterLoop</span> <span class="c">// 跳出当前内层循环，进入下一次外层循环</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">2</span> <span class="p">{</span>
      <span class="k">break</span> <span class="n">OuterLoop</span> <span class="c">// 跳出外层循环</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i=%d, j=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用有显示名称的返回值， 这样只需要在函数体中对这些返回值进行赋值而不需要显式地使用 <code class="language-plaintext highlighter-rouge">return</code> 语句返回它们。 这样的写法在需要根据条件分支返回多个值时非常有用。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 使用有显示名称的返回值</span>
<span class="k">func</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">quotient</span> <span class="kt">int</span><span class="p">,</span> <span class="n">remainder</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">quotient</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
  <span class="k">return</span> <span class="c">// 直接返回命名的返回值，这里的 return 不能省略</span>
<span class="p">}</span>

<span class="c">// 使用无名称的返回值</span>
<span class="k">func</span> <span class="n">divide2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用变长参数来接收不定数量的参数。 变长参数使用 <code class="language-plaintext highlighter-rouge">t ...T</code> 语法来定义，表示可以传入任意数量的该类型参数。 在函数体内，变长参数会被视为一个切片。 变长参数可以匹配多个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数或者一个类型为 <code class="language-plaintext highlighter-rouge">[]T</code> 的参数，但是不能同时匹配两种形式：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">total</span> <span class="o">:=</span> <span class="m">0</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">result1</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>       <span class="c">// 传入多个 int 参数</span>
  <span class="n">result2</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">}</span><span class="o">...</span><span class="p">)</span> <span class="c">// 传入一个 []int 参数，注意要加上 ...</span>
  <span class="c">// result3 := sum(1, 2, []int{3, 4}...) // 错误，不能同时传入多种形式的参数</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span> <span class="c">// 输出: 10</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span> <span class="c">// 输出: 18</span>
<span class="p">}</span>
</code></pre></div></div> <p>不过上面的规则有个例外：在使用 <code class="language-plaintext highlighter-rouge">append</code> 将一个 <code class="language-plaintext highlighter-rouge">string</code> 变量追加到 <code class="language-plaintext highlighter-rouge">[]byte</code> 切片中的时候是可行的， 编译器会自动将 <code class="language-plaintext highlighter-rouge">string</code> 转换为 <code class="language-plaintext highlighter-rouge">[]byte</code>，然后再进行追加操作：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">"hello"</span><span class="o">...</span><span class="p">)</span> <span class="c">// OK</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">import</code> 进行包的导入，导入时可以给导入的包取别名， 也可以使用 <code class="language-plaintext highlighter-rouge">.</code> 来导入包中的所有标识符。</p> <p>通常而言，在 <code class="language-plaintext highlighter-rouge">Go</code> 导入的包必须要被使用，否则会导致编译错误。 但是可以给包取别名为 <code class="language-plaintext highlighter-rouge">_</code>，这种方式仅执行包的 <code class="language-plaintext highlighter-rouge">init</code> 函数。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
  <span class="n">fmt</span> <span class="s">"fmt"</span>      <span class="c">// 给包取别名 fmt</span>
  <span class="o">.</span> <span class="s">"math"</span>       <span class="c">// 导入包中的所有标识符</span>
  <span class="n">_</span> <span class="s">"net/http"</span>   <span class="c">// 给包取别名 _，仅执行其 init 函数</span>
<span class="p">)</span>
</code></pre></div></div> <p>当两个同名的包（通常指路径中的最后一段相同）导入时就需要使用别名来区分它们。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中有各种字面量可以使用，同时对于数字字面量还支持使用下划线 <code class="language-plaintext highlighter-rouge">_</code> 来分隔数字以提高可读性。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">53</span><span class="n">_700</span>        <span class="c">// 十进制</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">0</span><span class="n">_700</span>         <span class="c">// 0前缀表示八进制</span>
<span class="n">c1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">x_aa_bb_cc</span>
<span class="n">c2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">X_dd_ee_ff</span>  <span class="c">// 0x或0X前缀表示十六进制</span>
<span class="n">d1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">b_1000_0001</span>
<span class="n">d2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">B_1000_0001</span> <span class="c">// 0b或0B前缀表示二进制</span>
<span class="n">e</span> <span class="o">:=</span> <span class="m">.15</span>           <span class="c">// 浮点数，可以省略整数部分的0</span>
<span class="n">f</span> <span class="o">:=</span> <span class="m">82.</span>           <span class="c">// 浮点数，可以省略小数部分的0</span>
<span class="n">g1</span> <span class="o">:=</span> <span class="m">1.5e2</span>        <span class="c">// 科学计数法表示</span>
<span class="n">g2</span> <span class="o">:=</span> <span class="m">1.5E3</span>        <span class="c">// 科学计数法表示</span>
<span class="n">h1</span> <span class="o">:=</span> <span class="m">0x2</span><span class="o">.</span><span class="n">p10</span>      <span class="c">// 十六进制浮点数</span>
<span class="n">h2</span> <span class="o">:=</span> <span class="m">0X1</span><span class="o">.</span><span class="n">Fp0</span>      <span class="c">// 十六进制浮点数</span>

<span class="n">ch1</span> <span class="o">:=</span> <span class="sc">'\u4e2d'</span>     <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch2</span> <span class="o">:=</span> <span class="sc">'\U00004e2d'</span> <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch3</span> <span class="o">:=</span> <span class="sc">'\x27'</span>       <span class="c">// 字符字面量，表示单引号字符 `'`</span>
<span class="n">ch4</span> <span class="o">:=</span> <span class="sc">'\047'</span>       <span class="c">// 字符字面量，八进制表示的字符 `'`</span>

<span class="n">s1</span> <span class="o">:=</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span>                <span class="c">// 字符串字面量，包含转义字符</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\u4e2d\u6587</span><span class="s">"</span>         <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\U00004e2d\U00006587</span><span class="s">"</span> <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s4</span> <span class="o">:=</span> <span class="s">`This is a raw string.
This is the second line.
This is the third line.
\n will not be interpreted.`</span> <span class="c">// 原始字符串字面量</span>

<span class="n">arr1</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr2</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">5</span><span class="o">:</span> <span class="m">5</span> <span class="p">}</span> <span class="c">// 数组字面量，长度均为 6</span>

<span class="n">sp1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// 切片字面量</span>

<span class="n">mp1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="s">"a"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"b"</span><span class="o">:</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// map 字面量</span>
</code></pre></div></div> <p>在使用十六进制的科学计数法进行表示的时候，<code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">P</code> 表示幂运算的底数是 <code class="language-plaintext highlighter-rouge">2</code>。 需要注意的是有效数字的整数部分和小数部分用十六进制来表示，而指数部分用十进制来表示。</p> <p>如果想要在 <code class="language-plaintext highlighter-rouge">raw string</code> 中包含反引号，则可以使用 <code class="language-plaintext highlighter-rouge">+</code> 进行字符串的拼接来实现。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">len</code> 来获取字符串、数组、切片、<code class="language-plaintext highlighter-rouge">map</code> 和通道的长度。</p> <ul> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取字符串的长度时，返回的是字符串的字节数而不是字符数；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取数组时，返回的是数组的元素个数；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取切片时，返回的是切片的长度；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取 <code class="language-plaintext highlighter-rouge">map</code> 时，返回的是 <code class="language-plaintext highlighter-rouge">map</code> 中键值对的数量；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取无缓冲通道时，返回的是 <code class="language-plaintext highlighter-rouge">0</code>；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取有缓冲通道时，返回的是通道中当前存储的元素个数。</li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">array[low:high:max]</code> 来基于一个已经存在的数组创建一个切片。 当省略 <code class="language-plaintext highlighter-rouge">max</code> 时，默认 <code class="language-plaintext highlighter-rouge">max</code> 的值为数组的长度。 这个切片的长度是 <code class="language-plaintext highlighter-rouge">high - low</code>，容量是 <code class="language-plaintext highlighter-rouge">max - low</code>。 这也表明 <code class="language-plaintext highlighter-rouge">[low, high)</code> 和 <code class="language-plaintext highlighter-rouge">[low, max)</code> 都是左闭右开区间。</p> <p>需要注意的是基于数组创建的切片的底层是原数组，所以对切片的修改往往会直接影响原数组。 不过在切片发生扩容的时候会创建一个新的底层数组，此时对切片的修改就不会影响原数组了。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
<span class="n">s1</span> <span class="o">:=</span> <span class="n">arr</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>              <span class="c">// 创建切片 s1，包含 arr[1], arr[2], arr[3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>               <span class="c">// 输出: [1 2 3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// 输出: 3 4</span>
<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>                    <span class="c">// 修改切片 s1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>              <span class="c">// 输出: [0 10 2 3 4]，arr 也被修改了</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span>      <span class="c">// 切片 s1 发生扩容，创建了新的底层数组</span>
<span class="n">s2</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">30</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// 输出: [0 10 2 3 4]，arr 不受影响</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// 输出: [30 2 3 20 30]</span>
</code></pre></div></div> <p>可以使用 <code class="language-plaintext highlighter-rouge">len</code> 和 <code class="language-plaintext highlighter-rouge">cap</code> 函数来获取切片的长度和容量。 但是对于 <code class="language-plaintext highlighter-rouge">map</code> 而言则只能使用 <code class="language-plaintext highlighter-rouge">len</code> 函数来获取其长度。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中通过下标运算符去获取一个 <code class="language-plaintext highlighter-rouge">map</code> 中不存在的键时会返回该类型的零值。 为了区分一个键是不存在还是其值就是类型的零值，可以使用双赋值的形式来获取键对应的值和一个布尔值， 该布尔值表示该键是否存在于 <code class="language-plaintext highlighter-rouge">map</code> 中。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s">"key"</span><span class="p">]</span> <span class="c">// 如果 "key" 不存在，v 为 0，ok 为 false</span>
<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
<span class="c">// 处理键不存在的情况</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c">// 使用 v 进行后续操作</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">map</code> 是基于 <code class="language-plaintext highlighter-rouge">hash</code> 的，对其进行遍历时的顺序是随机的。 <code class="language-plaintext highlighter-rouge">Go</code> 为了让开发者不依赖于 <code class="language-plaintext highlighter-rouge">map</code> 的遍历顺序，特意设计成每次遍历的顺序都有可能不一样。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串、字节切片、<code class="language-plaintext highlighter-rouge">rune</code> 切片之间可以方便地进行相互转换。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为字节切片</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[]</span><span class="kt">rune</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为 rune 切片</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>          <span class="c">// 字节切片转换为字符串</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>          <span class="c">// rune 切片转换为字符串</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串是通过 <code class="language-plaintext highlighter-rouge">UTF-8</code> 编码进行存储的，因此可以直接存储和处理多字节的 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">len</code> 获取的字符串的字节数而不是字符数，如果要获取字符数可以使用 <code class="language-plaintext highlighter-rouge">utf8.RuneCountInString</code> 函数。同理通过下标访问字符串时获取的是字节而不是字符。 不过 <code class="language-plaintext highlighter-rouge">for range</code> 遍历时获取的是字符。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="n">lengthInBytes</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                    <span class="c">// 获取字符串的字节数</span>
<span class="n">lengthInRunes</span> <span class="o">:=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 获取字符串的字符数</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>                      <span class="c">// 遍历字符串中的字符</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Character %d: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
  <span class="c">// i 是字符的起始字节索引，r 是对应的 rune 值</span>
  <span class="c">// Character 5: 世</span>
  <span class="c">// Character 8: 界</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Byte %d: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>      <span class="c">// 访问字符串中的字节</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的结构体中可以使用嵌入字段来实现类似于继承的效果。 嵌入字段是指在结构体中直接包含另一个结构体类型，而不需要为其指定字段名。 这样可以直接访问嵌入结构体的字段和方法。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Person</span>  <span class="c">// 嵌入 Person 结构体</span>
  <span class="n">ID</span>      <span class="kt">string</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">emp</span> <span class="n">Employee</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"Alice"</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="m">30</span>  <span class="c">// 直接访问嵌入结构体的字段</span>
</code></pre></div></div> <p>嵌入按照嵌入类型可以分为以下几种：</p> <ul> <li>接口中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> <li>结构体中嵌入结构体（可以是 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code>）</li> <li>结构体中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> </ul> <p>这里重点介绍一下在一个结构体中嵌入接口的情况。 在结构体中嵌入接口后，这个结构体类型就实现了该接口。 但是我们必须在使用接口中的方法前，为嵌入的接口字段赋值，否则会导致运行时错误：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M1</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">S</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M2</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M2 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I</span> <span class="c">// T 中嵌入接口 I</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span> <span class="c">// 为嵌入的接口字段赋值，否则会导致运行时错误</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们也可以自己在 <code class="language-plaintext highlighter-rouge">T</code> 中实现接口 <code class="language-plaintext highlighter-rouge">I</code> 的方法，当接口变量被赋值且 <code class="language-plaintext highlighter-rouge">T</code> 实现了接口的方法时， <code class="language-plaintext highlighter-rouge">T</code> 实现的方法会优先被调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"T's M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span> <span class="c">// 调用 T 实现的 M1 方法</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span> <span class="c">// 调用 S 实现的 M2 方法</span>
<span class="p">}</span>
</code></pre></div></div> <p>在结构体内嵌入多个接口时，如果这些接口中有同名的方法：</p> <ul> <li>若同名方法的签名不同，则编译时会报错，提示方法冲突。</li> <li>若同名方法的签名相同，则必须在结构体中实现该方法，否则调用时编译器会报错。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I1</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M1</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">I2</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I1</span>
  <span class="n">I2</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="p">(</span><span class="s">"T.M"</span><span class="p">)</span> <span class="p">}</span> <span class="c">// 必须实现 M 方法，否则 t.M() 会导致编译错误</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不可以在结构类型 <code class="language-plaintext highlighter-rouge">T</code> 中定义类型为 <code class="language-plaintext highlighter-rouge">T</code> 的字段，也不可以递归定义， 但是可以包含<code class="language-plaintext highlighter-rouge">*T</code>、<code class="language-plaintext highlighter-rouge">[]T</code>、<code class="language-plaintext highlighter-rouge">map[type]T</code> 等类型的字段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// F T         // 错误，不能包含类型为 T 的字段</span>
  <span class="n">F</span> <span class="o">*</span><span class="n">T</span>           <span class="c">// 正确，可以包含类型为 *T 的字段</span>
  <span class="n">G</span> <span class="p">[]</span><span class="n">T</span>          <span class="c">// 正确，可以包含类型为 []T 的字段</span>
  <span class="n">H</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">T</span> <span class="c">// 正确，可以包含类型为 map[type]T 的字段</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T1</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t2</span> <span class="n">T2</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T2</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t1</span> <span class="n">T1</span>  <span class="c">// 错误，不能递归定义</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中主要有多种方法可以对自定义类型进行初始化。以下面的自定义类型为例。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Book</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Title</span>  <span class="kt">string</span>
  <span class="n">Author</span> <span class="n">Person</span>
<span class="p">}</span>
</code></pre></div></div> <p>一是可以按照顺序对结构体的字段进行赋值，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b1</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>但是这样的弊端也很明显：如果结构体的字段顺序发生变化，那么初始化的代码也需要进行相应的修改。 且当结构体的字段较多时，代码的可读性也会变差。这就引出了第二种初始化的方式：使用字段名进行赋值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p2</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b2</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="n">Title</span><span class="o">:</span> <span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Author</span><span class="o">:</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>除此之外还可以自定义方法来根据传入的参数进行初始化，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="n">age</span><span class="p">}</span>
<span class="p">}</span>
<span class="c">// or</span>
<span class="c">// func NewPerson(name string, age int) Person {</span>
<span class="c">//   return Person{Name: name, Age: age}</span>
<span class="c">// }</span>

<span class="n">p3</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// p3 在这里是 *Person 类型</span>
</code></pre></div></div> <p>不过官方推荐使用一种名为 <code class="language-plaintext highlighter-rouge">WithOption</code> 的设计模式来进行复杂类型的初始化， 这种方式可以通过传入不同的选项函数来灵活地配置初始化参数。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">PersonOption</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">Person</span><span class="p">)</span>
<span class="k">func</span> <span class="n">WithName</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="n">name</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">WithAge</span><span class="p">(</span><span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="n">age</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">opts</span> <span class="o">...</span><span class="n">PersonOption</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span>
    <span class="n">Name</span><span class="o">:</span> <span class="s">"Unknown"</span><span class="p">,</span>
    <span class="n">Age</span><span class="o">:</span>  <span class="m">0</span><span class="p">,</span> <span class="c">// 默认值</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">opts</span> <span class="p">{</span>
    <span class="n">opt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>
<span class="n">p4</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">WithName</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">),</span> <span class="n">WithAge</span><span class="p">(</span><span class="m">30</span><span class="p">))</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言可以对底层类型相同的元素进行隐式转换，编译器会保证这种转换的安全。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">var</span> <span class="n">a</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="m">10</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">10</span>
<span class="n">c</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="c">// 隐式转换，MyInt 和 int 可以进行运算</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不能给接口或者指针类型定义方法：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="o">*</span><span class="kt">int</span>
<span class="c">// CE: invalid receiver type MyInt (MyInt is a pointer type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyInt</span><span class="p">)</span> <span class="n">IsNil</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">MyReader</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span>
<span class="c">// CE: invalid receiver type MyReader (MyReader is an interface type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyReader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言对接口的实现是通过 <code class="language-plaintext highlighter-rouge">iface</code> 和 <code class="language-plaintext highlighter-rouge">eface</code> 两种内部数据结构来实现的。 <code class="language-plaintext highlighter-rouge">iface</code> 用于存储非空接口类型的变量，而 <code class="language-plaintext highlighter-rouge">eface</code> 用于存储空接口类型的变量。</p> <p>空接口是指接口中没有任何方法的接口类型，表示可以存储任意类型的值。 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">any</code> 类型实际上就是空接口类型的别名。 非空接口是指除了空接口之外的所有接口类型。</p> <p>在 <code class="language-plaintext highlighter-rouge">eface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">_type</code>：表示具体的类型信息。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>而在 <code class="language-plaintext highlighter-rouge">iface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tab</code>：表示类型信息和方法集合的表。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>接口的比较是基于这两个字段的。</p> <p>不管是空接口还是非空接口只有当其两个字段均为 <code class="language-plaintext highlighter-rouge">nil</code> 时才表示接口变量为 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a1</span> <span class="n">any</span>
<span class="k">var</span> <span class="n">a2</span> <span class="n">any</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">e1</span> <span class="kt">error</span>
<span class="k">var</span> <span class="n">e2</span> <span class="kt">error</span> <span class="o">=</span> <span class="no">nil</span>
</code></pre></div></div> <p>上面的四个变量和 <code class="language-plaintext highlighter-rouge">nil</code> 进行比较时均为 <code class="language-plaintext highlighter-rouge">true</code>。 因为上面的四个变量都为 <code class="language-plaintext highlighter-rouge">nil</code> 所以他们在通过 <code class="language-plaintext highlighter-rouge">==</code> 互相比较时都会返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>一旦两个字段中的任意一个不为 <code class="language-plaintext highlighter-rouge">nil</code>，那么接口变量就不再等于 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">i</span> <span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">m</span> <span class="o">*</span><span class="n">MyError</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">a</span> <span class="n">any</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">var</span> <span class="n">e</span> <span class="kt">error</span> <span class="o">=</span> <span class="n">m</span>
</code></pre></div></div> <p>上面例子中的 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">e</code> 都不等于 <code class="language-plaintext highlighter-rouge">nil</code>，因为他们的 <code class="language-plaintext highlighter-rouge">data</code> 字段虽然为 <code class="language-plaintext highlighter-rouge">nil</code>， 但是 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code> ）字段不为 <code class="language-plaintext highlighter-rouge">nil</code>。</p> <p>在接口变量之间进行比较时：</p> <ul> <li>当比较的两个接口变量是空接口（<code class="language-plaintext highlighter-rouge">eface</code>）或两个接口变量是非空接口时， 当且仅当其 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code>）字段相等、<code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> <li>当比较的两个接口变量一个是空接口（<code class="language-plaintext highlighter-rouge">eface</code>），另一个是非空接口（<code class="language-plaintext highlighter-rouge">iface</code>）时， 当且仅当空接口的 <code class="language-plaintext highlighter-rouge">_type</code> 字段等于非空接口的 <code class="language-plaintext highlighter-rouge">tab</code> 字段中的 <code class="language-plaintext highlighter-rouge">_type</code>字段、 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> </ul> <p>这里的 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致指的是：</p> <ul> <li>如果接口与指针类型绑定，那么比较的是指针的值是否相等。</li> <li>如果接口与非指针类型绑定，那么比较的是值的内容是否相等。</li> </ul> <p><strong>NOTE</strong>：<code class="language-plaintext highlighter-rouge">iface</code> 代表的是 <code class="language-plaintext highlighter-rouge">interface</code> 的意思，而 <code class="language-plaintext highlighter-rouge">eface</code> 代表的是 <code class="language-plaintext highlighter-rouge">empty interface</code> 的意思。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的方法集合是指某个类型所拥有的方法的集合。 其主要作用是用于判断一个类型是否实现了某个接口。 类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 的方法组成的集合。 类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code> 的方法组成的集合。 如果一个类型的方法集合是一个接口的超集，那么该类型就实现了该接口。</p> <p>这里解释一下为什么会是这样的定义。 关键在于 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的接口的实现方式。<code class="language-plaintext highlighter-rouge">Go</code> 语言的接口中保存了两部分内容：</p> <ul> <li>具体的类型信息</li> <li>对应的实例数据</li> </ul> <p>当一个非指针类型的变量被赋值给一个接口变量的时候，这个变量的实例数据是原对象的拷贝。 而将一个指针类型的变量赋值给一个接口变量的时候，接口变量数据部分保存的是该指针的值。 这也就意味着，如果真的可以通过一个非指针变量去调用接收者为指针的方法的话， 那么这个方法中对接收者的任何修改都不会反应到原对象上。为了禁止这样反直觉的行为， <code class="language-plaintext highlighter-rouge">Go</code> 语言就采用了上面所说的方法集合的定义。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Animal</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Grow</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Dog</span> <span class="k">struct</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Dog</span><span class="p">)</span> <span class="n">Grow</span><span class="p">()</span> <span class="p">{</span>
 <span class="c">// some code will change Dog instance</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="n">Animal</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="n">Dog</span><span class="p">{}</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">d</span>
  <span class="n">a</span><span class="o">.</span><span class="n">Grow</span><span class="p">()</span> <span class="c">// 假设这里可以通过编译，d 的状态也不会改变</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果理解了上述的规则我们不难得出嵌套类型的方法集合：</p> <ul> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">U</code> 的方法集合。</li> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">*U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> <li>不论嵌入类型是 <code class="language-plaintext highlighter-rouge">U</code> 还是 <code class="language-plaintext highlighter-rouge">*U</code>，类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合都包含了 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> </ul> <p>需要注意的是一个变量的类型对应的方法集合中没有的方法并不意味着该变量不能调用。 对于可寻址的对象，<code class="language-plaintext highlighter-rouge">Go</code> 语言会自动将其取地址从而调用接收者为指针的方法。 同样地，对于指针类型的变量，<code class="language-plaintext highlighter-rouge">Go</code> 语言也会自动解引用从而调用接收者为非指针的方法。</p> <p>当我们使用 <code class="language-plaintext highlighter-rouge">type</code> 给一个变量取别名或者基于已有的类型定义新的类型时，方法集合会根据原类型而有所不同。</p> <ul> <li>取别名不会改变原类型的方法集合；</li> <li>基于接口类型创建的新类型，其方法集合与原接口类型一致；</li> <li>而基于非接口类型创建的新类型，其方法集合为空。</li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中，<code class="language-plaintext highlighter-rouge">map</code> 存储的元素是不可寻址的，而切片中的元素确是可寻址的。 关于这样设计的原因主要有两个：</p> <ul> <li>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，其底层实现是基于哈希表的， 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么在 <code class="language-plaintext highlighter-rouge">map</code> 发生扩容或者重新哈希时， 这些寻址的指针就会变得无效，从而导致不可预期的行为，这里应该主要是考虑红黑树上节点变化的问题。</li> <li>对于切片而言，其底层实现是基于数组的，数组的元素在内存中是连续存储的， 因此允许对切片中的元素进行寻址是安全且高效的； 且即使切片在使用过程中发生了扩容，如果此时有指针指向原数组上的元素，原数组就不会被释放。</li> <li>在 <code class="language-plaintext highlighter-rouge">map</code> 中，如果一个值不存在，那么通过下标运算符获取该值时会返回该类型的零值。 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么对于不存在的键，其对应的值将无法寻址， 这会导致代码变得复杂且容易出错。</li> </ul> <p>正因为 <code class="language-plaintext highlighter-rouge">map</code> 不可寻址，如果 <code class="language-plaintext highlighter-rouge">map</code> 存储的 <code class="language-plaintext highlighter-rouge">value</code> 部分是非指针，我们是不能调用接收者为指针的方法的。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以通过类型断言来获取一个接口变量的具体类型和值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">10</span>
<span class="k">var</span> <span class="n">x</span> <span class="n">any</span> <span class="o">=</span> <span class="n">a</span>
<span class="c">// WARN:</span>
<span class="c">// 如果断言失败会引发 panic，所以推荐使用带 ok 变量的形式进行断言</span>
<span class="n">v1</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="n">v2</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c">// ok2 为 true，v2 的值为 10</span>
<span class="n">v3</span><span class="p">,</span> <span class="n">ok3</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="c">// ok3 为 false，v3 的值为 string 类型的零值 ""</span>
</code></pre></div></div> <p>需要注意的是，如果断言的类型是一个接口则语义变成了“变量是否实现了该接口”的判断。 如果断言成功，返回值的类型为实际类型而不是所实现的接口类型。</p> <hr/> <p>在对内置的函数进行 <code class="language-plaintext highlighter-rouge">defer</code> 操作的时候， <code class="language-plaintext highlighter-rouge">append</code>、<code class="language-plaintext highlighter-rouge">cap</code>、<code class="language-plaintext highlighter-rouge">len</code>、<code class="language-plaintext highlighter-rouge">make</code>、<code class="language-plaintext highlighter-rouge">new</code> 等并不能作为 <code class="language-plaintext highlighter-rouge">deferred</code> 函数调用。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中只能通过 <code class="language-plaintext highlighter-rouge">make</code> 来创建 <code class="language-plaintext highlighter-rouge">channel</code>，<code class="language-plaintext highlighter-rouge">make</code> 接收两个参数， 第一个是 <code class="language-plaintext highlighter-rouge">channel</code> 的类型，第二个是 <code class="language-plaintext highlighter-rouge">channel</code> 的缓冲区大小。 缓冲区大小默认为 <code class="language-plaintext highlighter-rouge">0</code>，表示无缓冲 <code class="language-plaintext highlighter-rouge">channel</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// 无缓冲 channel</span>
<span class="n">chBuf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c">// 有缓冲 channel，缓冲区大小为 5</span>
</code></pre></div></div> <p>在使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 的时候，发送方和接收方一定要放在两个不同的 <code class="language-plaintext highlighter-rouge">goroutine</code> 中， 这是因为如果放在同一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中，无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 在发送和接收时都会阻塞当前的 <code class="language-plaintext highlighter-rouge">goroutine</code>， 进而引发协程泄漏。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中使用 <code class="language-plaintext highlighter-rouge">channel</code> 的时候往往是由发送方来关闭， 这是因为接收主有安全的手段来检查 <code class="language-plaintext highlighter-rouge">channel</code> 是否已经关闭，而发送方并没有这样安全的手段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>     <span class="c">// 当 channel 关闭时，n 会被赋值为类型的零值</span>
<span class="n">m</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// ok 为 false 表示 channel 已经关闭</span>
<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="c">// 当 channel 关闭时，循环会自动结束</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">select</code> 原语，其可以一次监听多个 <code class="language-plaintext highlighter-rouge">channel</code> 的操作。 当其中某个 <code class="language-plaintext highlighter-rouge">channel</code> 准备好进行发送或接收操作时，<code class="language-plaintext highlighter-rouge">select</code> 会执行对应的 <code class="language-plaintext highlighter-rouge">case</code> 分支。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">msg1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Received message from ch1: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg1</span><span class="p">)</span>
<span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">msg2</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Sent message to ch2: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg2</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"No channel is ready"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>当没有使用 <code class="language-plaintext highlighter-rouge">default</code> 的时候，<code class="language-plaintext highlighter-rouge">select</code> 会一直阻塞直到某个 <code class="language-plaintext highlighter-rouge">case</code> 分支可以执行。</p> <p>下面三种是 <code class="language-plaintext highlighter-rouge">select</code> 原语常用的方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">default</code> 分支可以实现 <code class="language-plaintext highlighter-rouge">try</code> 语义。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包可以实现超时控制。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包的 <code class="language-plaintext highlighter-rouge">Ticker</code> 可以实现周期任务。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="n">TrySend</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">value</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">true</span> <span class="c">// 发送成功</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">false</span> <span class="c">// channel 未准备好，发送失败</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ReceiveWithTimeout</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="no">nil</span> <span class="c">// 成功接收数据</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"receive timeout"</span><span class="p">)</span> <span class="c">// 超时</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">PeriodicTask</span><span class="p">(</span><span class="n">interval</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">stopCh</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
  <span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">ticker</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">ticker</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="c">// 执行周期任务</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">stopCh</span><span class="o">:</span>
      <span class="k">return</span> <span class="c">// 停止任务</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>有一点需要注意的是，在实现超时控制的时候，如果使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 则可能出现协程泄漏的问题：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// do some work</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}</span>
<span class="p">}()</span>
<span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务完成！"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务超时!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，如果任务在 <code class="language-plaintext highlighter-rouge">2</code> 秒内没有完成， 那么超时分支会被执行，而任务协程仍然会继续运行并尝试向 <code class="language-plaintext highlighter-rouge">ch</code> 发送数据。 由于 <code class="language-plaintext highlighter-rouge">ch</code> 是一个无缓冲的 <code class="language-plaintext highlighter-rouge">channel</code>，如果没有其他协程在接收数据， 那么任务协程会一直阻塞在发送操作上，导致协程泄漏。 为了解决这个问题，可以使用有缓冲的 <code class="language-plaintext highlighter-rouge">channel</code> 或者使用 <code class="language-plaintext highlighter-rouge">context</code> 进行超时控制。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">type switch</code> 来方便的判断一个接口变量所属于的类型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="m">10</span>
<span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span> <span class="c">// 只能接口类型可以使用 type switch</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is int: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is of unknown type</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意 <code class="language-plaintext highlighter-rouge">case</code> 后面的类型必须是实现了该接口的类型，否则会导致编译错误。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的泛型不支持在类型里面内嵌泛型本身，也不支持在泛型方法中接着定义泛型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// T          // 错误，不能在泛型类型中内嵌泛型本身</span>
<span class="p">}</span>
<span class="c">// 错误，不能在泛型方法中接着定义泛型</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">MyMethod</span><span class="p">[</span><span class="n">U</span> <span class="n">any</span><span class="p">]()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的类型约束在有些情况下可以简写，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">a1</span><span class="p">[</span><span class="n">I</span> <span class="k">interface</span> <span class="p">{</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">}](</span><span class="n">param</span> <span class="n">I</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">func</span> <span class="n">a2</span><span class="p">[</span><span class="n">T</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span><span class="p">](</span><span class="n">param</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p><strong>注意</strong>：在类型约束中如果使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示只要底层类型是该类型即可， 而不使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示必须是该类型本身。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">panic</code> 表示程序发生了不可恢复的错误，通常会导致程序崩溃。 任意一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中发生的 <code class="language-plaintext highlighter-rouge">panic</code> 都会导致整个程序崩溃。 可以使用 <code class="language-plaintext highlighter-rouge">recover</code> 函数来捕获 <code class="language-plaintext highlighter-rouge">panic</code>，从而防止程序崩溃。 而 <code class="language-plaintext highlighter-rouge">recover</code> 函数只能在 <code class="language-plaintext highlighter-rouge">defer</code> 函数中调用。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">safeFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Recovered from panic:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c">// 可能引发 panic 的代码</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的包导入时可以在结尾增加版本信息，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"github.com/user/project/v2"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的包符合 <code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code> 版本规范，官方规定只有当 <code class="language-plaintext highlighter-rouge">Major</code> 变化时才会出现兼容性的问题。 在不书写版本号时，默认导入的是 <code class="language-plaintext highlighter-rouge">v0</code> 或 <code class="language-plaintext highlighter-rouge">v1</code> 版本的包。可以使用 <code class="language-plaintext highlighter-rouge">go list -m -versions &lt;package_name&gt;</code> 来查看某个包的所有可用版本。</p> <p>如果想要移除一个依赖，需要使用 <code class="language-plaintext highlighter-rouge">go get &lt;package_name&gt;</code> 的形式在版本部分添加 <code class="language-plaintext highlighter-rouge">@none</code>， 例如 <code class="language-plaintext highlighter-rouge">go get github.com/go-redis/redis/v8@none</code> 会移除已经添加的 <code class="language-plaintext highlighter-rouge">go-redis v8</code> 依赖。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中命名的一些规范：</p> <ul> <li>循环和条件变量多采用单个字母命名。</li> <li>函数/方法的参数和返回值以单个单词或字母为主。</li> <li>方法的命名以单个单词为主。</li> <li>函数/类型多以多个单词的复合形式命名。</li> <li>变量中不携带类型信息。</li> <li>包名往往由单个单词进行命名，且尽量与导入路径的最后一个路径分段一致。</li> <li><code class="language-plaintext highlighter-rouge">Go</code> 中如果接口类型只有一个方法，则接口往往命名为该方法名加上 <code class="language-plaintext highlighter-rouge">-er</code> 后缀。 比如 <code class="language-plaintext highlighter-rouge">Read</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Reader</code>，<code class="language-plaintext highlighter-rouge">Write</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Writer</code>。</li> </ul> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言中零值可用是非常重要的概念，比如对于一个指向 <code class="language-plaintext highlighter-rouge">net.TCPAddr</code> 的指针， 如果我们使用 <code class="language-plaintext highlighter-rouge">fmt.Print</code> 对其进行输出则会调用 <code class="language-plaintext highlighter-rouge">func (*TCPAddr) String() string</code> 方法， 在该方法中，其检查了调用的实例是不是一个空指针，并对于空指针直接返回了 <code class="language-plaintext highlighter-rouge">&lt;nil&gt;</code> 字符串。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的参数传递是值传递的，对于一个数组参数其在进行参数传递的时候会对整个数组进行拷贝。 而因为切片、字典等对象实际存储的是指针，所以其在作为参数进行传递时开销会小很多。 除此之外，<code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">for i, v := range x</code> 中的 <code class="language-plaintext highlighter-rouge">v</code> 变量也会有一次拷贝， 即使 <code class="language-plaintext highlighter-rouge">x</code> 的类型是切片这样的类型，修改 <code class="language-plaintext highlighter-rouge">v</code> 也不会作用在原切片上。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="c">// CE: declared and not used: v</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">r</span> <span class="p">{</span>
  <span class="n">v</span> <span class="o">=</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的例子中我们尝试通过修改 <code class="language-plaintext highlighter-rouge">v</code> 来实现修改 <code class="language-plaintext highlighter-rouge">r</code> 的目的，但是实际上是不可能的， 因为我们只是对 <code class="language-plaintext highlighter-rouge">v</code> 进行了赋值，<code class="language-plaintext highlighter-rouge">Go</code> 编译器认为我们没有使用 <code class="language-plaintext highlighter-rouge">v</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span> <span class="p">{</span>
<span class="c">// for i, v := range &amp;a {</span>
<span class="c">// for i, v := range a[:] {</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// 注意这里我们改的是还没有遍历到的数据</span>
    <span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="m">12</span>
    <span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="m">13</span>
    <span class="c">// 不管是使用哪种形式的 for range</span>
    <span class="c">// 对当前遍历对象的修改都不会作用到 v 上</span>
    <span class="c">// 因为 v 已经是 a[0] 的拷贝了</span>
    <span class="c">// a[0] = 10</span>
  <span class="p">}</span>
  <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"r = "</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c">// r = [1 2 3 4 5]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a = "</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c">// a = [1 12 13 4 5]</span>
</code></pre></div></div> <p>由于在调用 <code class="language-plaintext highlighter-rouge">range</code> 的时候会将 <code class="language-plaintext highlighter-rouge">a</code> 进行一次拷贝， 即使我们第一次进行循环的时候修改了 <code class="language-plaintext highlighter-rouge">a[1]</code> 和 <code class="language-plaintext highlighter-rouge">a[2]</code>， 我们也不能看到修改的值。</p> <p>而如果我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range &amp;a</code> 拷贝的就是指针，此时编译器会帮我们解引用而因为是同一个地址， 所以 <code class="language-plaintext highlighter-rouge">v</code> 可以看到这样的影响。</p> <p>同理，当我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range a[:]</code> 拷贝的就是切片，而切片的底层数组是同一个， 所以 <code class="language-plaintext highlighter-rouge">v</code> 也可以看到这样的影响。</p> <p>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，如果在 <code class="language-plaintext highlighter-rouge">for</code> 过程中添加或者删除键值，则循环的次数是不确定的。 而对于切片而言，其循环次数在一开始就已经确定了。</p> <p>对于 <code class="language-plaintext highlighter-rouge">channel</code> 而言，<code class="language-plaintext highlighter-rouge">for range</code> 只有在 <code class="language-plaintext highlighter-rouge">channel</code> 被关闭后才会结束循环。 如果 <code class="language-plaintext highlighter-rouge">channel</code> 的变量是 <code class="language-plaintext highlighter-rouge">nil</code> 则循环将会永远被阻塞。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 版本之前，<code class="language-plaintext highlighter-rouge">for</code> 循环中变量只会被创建一次， 这会导致一些奇怪的现象：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Customer</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">ID</span>      <span class="kt">string</span>
  <span class="n">Balance</span> <span class="kt">float64</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Customers</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Store</span><span class="p">)</span> <span class="n">storeCustomers</span><span class="p">(</span><span class="n">customers</span> <span class="p">[]</span><span class="n">Customer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">customer</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">customers</span> <span class="p">{</span>
    <span class="c">// 在 go 1.22 之前需要这样写以避免问题，保证每次创建一个新的 customer 变量</span>
    <span class="c">// customer := customer</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Customers</span><span class="p">[</span><span class="n">customer</span><span class="o">.</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">customer</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="n">Store</span><span class="p">{</span><span class="n">Customers</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span><span class="p">)}</span>
  <span class="n">s</span><span class="o">.</span><span class="n">storeCustomers</span><span class="p">([]</span><span class="n">Customer</span><span class="p">{</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"1"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="o">-</span><span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"3"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">0</span><span class="p">},</span>
  <span class="p">})</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span><span class="o">.</span><span class="n">Customers</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"id=%s,customer=%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 之前会输出：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id=1, customer=&amp;main.Customer{ID:"3", Balance:0}
id=2, customer=&amp;main.Customer{ID:"3", Balance:0}
id=3, customer=&amp;main.Customer{ID:"3", Balance:0}
</code></pre></div></div> <p>这是因为在 <code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">customer</code> 只会被创建一次， 所以三次赋值都指向了同一个地址，从而导致最后的结果都是相同的。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 及之后的版本中，<code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">v</code> 会在每次循环时创建新的变量， 从而避免了上述的问题。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中除了常见的方法调用方式外，还可以通过 <code class="language-plaintext highlighter-rouge">Method Expression</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">t</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="c">// or</span>
<span class="n">T</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</code></pre></div></div> <p>除了 <code class="language-plaintext highlighter-rouge">Method Expression</code> 以外，还可以使用 <code class="language-plaintext highlighter-rouge">Method Value</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">getFunc</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Get</span>
<span class="n">setFunc</span> <span class="o">:=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span>
<span class="n">getFunc</span><span class="p">()</span>   <span class="c">// 等价于 t.Get()</span>
<span class="n">setFunc</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c">// 等价于 t.Set(10)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">select</code> 的执行过程分为求值阶段和选择阶段。</p> <p>在求值阶段，<code class="language-plaintext highlighter-rouge">select</code> 会在进入后按照从上到下、从左到右进行求值：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">getAChannel</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="n">computeValue1</span><span class="p">()</span><span class="o">:</span>           <span class="c">// getAChannel() 和 computeValue1() 会被调用</span>
<span class="k">case</span> <span class="p">(</span><span class="n">getAStorageArray</span><span class="p">())[</span><span class="m">0</span><span class="p">]</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">getAChannel</span><span class="p">()</span><span class="o">:</span> <span class="c">// getAStorageArray() 不会被调用，getAChannel() 会被调用</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，会依次执行 <code class="language-plaintext highlighter-rouge">&lt;-</code> 左右两部分，但是在赋值语句中，赋值号左边的表达式不会被执行， 只有在其被选中时才会执行。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 从 <code class="language-plaintext highlighter-rouge">1.11</code> 开始会对一些简单的函数或者方法进行内联优化，这在调试过程中或者发生 <code class="language-plaintext highlighter-rouge">panic</code> 时会影响调用栈的展示。我们可以使用 <code class="language-plaintext highlighter-rouge">-gcflags="-l"</code> 来禁用内联优化，例如：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build <span class="nt">-gcflags</span><span class="o">=</span><span class="s2">"-l"</span> <span class="nt">-o</span> myapp main.go
go run <span class="nt">-gcflags</span><span class="o">=</span><span class="s2">"-l"</span> main.go
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中常用的测试方式有两种：</p> <ul> <li>包内测试；</li> <li>包外测试。</li> </ul> <p>无论是包内测试还是包外测试，测试文件通过都是以 <code class="language-plaintext highlighter-rouge">_test.go</code> 结尾命名的文件，且与被测试包相同的目录下。而包内测试的包名（也就是 <code class="language-plaintext highlighter-rouge">package</code> 关键字后面的名称）与被测试包相同，而包外测试的包名则是被测试包名加上 <code class="language-plaintext highlighter-rouge">_test</code> 后缀。</p> <p>由于包内测试的代码和被测的代码在同一个包中，所以包内测试可以访问被测试的包内所以符号，这也是为什么包内测试被叫做白盒测试。而包外测试由于和被测代码不在同一个包中，所以只能访问被测包导出的符号，这也是为什么包外测试被叫做黑盒测试。</p> <p>白盒测试的覆盖率通常会比墨盒测试高且白盒测试的灵活性比较高，这是因为其可以直接访问包内的非导出符号，从而进行更细粒度的测试。而黑盒测试则更接近于真实的使用场景，可以更好地模拟外部用户对包的使用方式。</p> <p>不过白盒测试有一个致命的缺陷，那就是包循环引用。比如在标准库的测试文件 <code class="language-plaintext highlighter-rouge">strings_test.go</code> 中会引用 <code class="language-plaintext highlighter-rouge">testing</code> 这个包，而 <code class="language-plaintext highlighter-rouge">testing.go</code> 文件中因为需要处理测试结果的输出，所以会引用 <code class="language-plaintext highlighter-rouge">strings</code> 包，如果这里使用包内测试就会导致包循环引用的问题，这是 <code class="language-plaintext highlighter-rouge">Go</code> 语言所不允许的。所以在标准库中使用了包外测试的方法来测试 <code class="language-plaintext highlighter-rouge">strings</code> 包。</p> <p>如果我们使用包外测试进行测试，可能会出现需要使用包内非导出符号的情况，对于这种情况，我们可以使用 <code class="language-plaintext highlighter-rouge">Go</code> 语言提供的 <code class="language-plaintext highlighter-rouge">export_test.go</code> 文件来解决。在测试一个包的过程中我们可以在包所在的目录下创建一个名为 <code class="language-plaintext highlighter-rouge">export_test.go</code> 的文件，该文件与被测试的包处在同一个包下，所有其可以访问包中未导出的符号，我们可以在该文件中将未导出的符号进行导出，该文件只有在测试阶段才会被编译，例如 <code class="language-plaintext highlighter-rouge">Go</code> 语言 <code class="language-plaintext highlighter-rouge">fmt</code> 包下的 <code class="language-plaintext highlighter-rouge">export_test.go</code> 中部分内容：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 标明和 fmt 包在同一个包下</span>
<span class="k">package</span> <span class="n">fmt</span>

<span class="k">var</span> <span class="n">IsSpace</span> <span class="o">=</span> <span class="n">isSpace</span>
<span class="k">var</span> <span class="n">Parsenum</span> <span class="o">=</span> <span class="n">parsenum</span>
</code></pre></div></div> <p>根据上面的对比我们可以发现，包外测试因为有 <code class="language-plaintext highlighter-rouge">export_test.go</code> 的支持，所以其解决了包内测试的硬伤，可以说包内测试可以完成的功能包外测试都可以完成，所以在实际开发中推荐使用包外测试的方式进行测试。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中我们可以使用 <code class="language-plaintext highlighter-rouge">go test -run=TestCompare -v .</code> 来指定只运行前缀为 <code class="language-plaintext highlighter-rouge">TestCompare</code> 的测试函数。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 在 <code class="language-plaintext highlighter-rouge">1.14</code> 之前如果我们要在测试的时候进行初始化和清理工作我们可以使用以下的方法：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">setup</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 初始化工作</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 清理工作</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestSomething</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">teardown</span> <span class="o">:=</span> <span class="n">setup</span><span class="p">()</span>
  <span class="k">defer</span> <span class="n">teardown</span><span class="p">()</span>
  <span class="c">// 测试代码</span>
<span class="p">}</span>
</code></pre></div></div> <p>从 <code class="language-plaintext highlighter-rouge">1.14</code> 开始我们可以使用 <code class="language-plaintext highlighter-rouge">testing.Cleanup</code> 方法来清理：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 初始化工作</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">cleanup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 清理工作</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestSomething</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 测试开始时调用</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">setup</span><span class="p">)</span>
  <span class="c">// 测试结束时调用</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Cleanup</span><span class="p">(</span><span class="n">cleanup</span><span class="p">)</span>
  <span class="c">// 测试代码</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言在 <code class="language-plaintext highlighter-rouge">1.4</code> 引入了 <code class="language-plaintext highlighter-rouge">TestMain</code> 函数来进行包级别的初始化和清理工作：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 其他的测试函数……</span>

<span class="k">func</span> <span class="n">pkgSetup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 包级别的初始化工作</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">pkgCleanup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 包级别的清理工作</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestMain</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">pkgSetup</span><span class="p">)</span>
  <span class="n">m</span><span class="o">.</span><span class="n">Cleanup</span><span class="p">(</span><span class="n">pkgCleanup</span><span class="p">)</span>
  <span class="c">// 初始化工作</span>
  <span class="n">code</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span> <span class="c">// 运行所有测试</span>
  <span class="c">// 清理工作</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中我们可以通过 <code class="language-plaintext highlighter-rouge">t.Run("", func)</code> 来给当前的测试用例添加子测试用例，最后测试用例之间将会以树形结构进行展示：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">testChild1</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 子测试用例 1 的代码</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">testChild2</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 子测试用例 2 的代码</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestParent</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"Child_1"</span><span class="p">,</span> <span class="n">testchild1</span><span class="p">)</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"Child_2"</span><span class="p">,</span> <span class="n">testchild2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Go"/><category term="中文文章"/><summary type="html"><![CDATA[本文记录了我在学习 Go 语言过程中的一些笔记和思考。]]></summary></entry><entry><title type="html">鞋带公式</title><link href="https://kaiser-yang.github.io/blog/2025/shoelace-formula/" rel="alternate" type="text/html" title="鞋带公式"/><published>2025-10-30T08:51:37+00:00</published><updated>2025-10-30T08:51:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/shoelace-formula</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/shoelace-formula/"><![CDATA[<p>简单多边形：如果一个多边形的任意两条边都不相交，则称该多边形为简单多边形。</p> <p>鞋带公式是用来求一个简单多边形面积的公式。</p> <p>鞋带公式要求按照顺时针或逆时针的顺序给出多边形的顶点坐标。</p> <p>这里我们定义 \(x_i, y_i\) 分别表示一个简单 \(n\) 边形的第 \(i\) 个顶点的横坐标和纵坐标， 这里选择下标从 \(0\) 开始编号。特别地，我们定义 \(x_n = x_0\)，\(y_n = y_0\)。</p> <p>鞋带公式的表达式为：</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \right|\] <h2 id="原理">原理</h2> <p>鞋带公式实际是通过计算多个梯形的代数面积来求解多边形的面积。 具体地，我们可以将多边形划分为多个梯形， 每个梯形的顶点分别是多边形的两个相邻顶点和 x 轴上的两个投影点。 通过计算每个梯形的面积并累加起来，我们可以得到整个多边形的面积。</p> <p>而上述的过程可以写成如下的方程:</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (y_i + y_{i+1}) (x_{i+1} - x_i) \right|\] <p>整理后就可以得到最开始给出的鞋带公式。</p> <h2 id="实现">实现</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="n">R</span> <span class="nf">polygon_area</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">R</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">R</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">area</span> <span class="o">-=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Shoelace Formula"/><summary type="html"><![CDATA[本文介绍鞋带公式的原理及其实现方式。]]></summary></entry><entry><title type="html">多重背包优化</title><link href="https://kaiser-yang.github.io/blog/2025/knapsack-problem/" rel="alternate" type="text/html" title="多重背包优化"/><published>2025-10-24T10:39:56+00:00</published><updated>2025-10-24T10:39:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/knapsack-problem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/knapsack-problem/"><![CDATA[<p>多重背包问题可以通过如下的转移方程来解决：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>其中，\(dp_{i,j}\) 表示前 \(i\) 种物品放入容量为 \(j\) 的背包所能获得的最大价值， \(w_i\) 和 \(v_i\) 分别表示第 \(i\) 种物品的重量和价值，\(c_i\) 表示第 \(i\) 种物品的数量。</p> <p>通过上面的方法进行转移时，时间复杂度为 \(O(N \cdot M \cdot C)\)， 其中 \(N\) 是物品种类数，\(M\) 是背包容量，\(C\) 是物品数量的最大值。 当 \(C\) 较大时，时间复杂度会变得非常高，这里介绍两种优化方法来降低时间复杂度。</p> <h2 id="二进制优化">二进制优化</h2> <p>对于第 \(i\) 件物品我们将其拆分成 \(1, 2, 4, \ldots, 2^k\) 件，使得 \(1 + 2 + 4 + \ldots + 2^k \leq c_i\)， 再加上剩余的 \(x := c_i - (1 + 2 + 4 + \ldots + 2^k)\) 件，其中的 \(k\) 满足 \(2^{k+1} &gt; c_i\)。</p> <p>经过上述的拆分后，我们可以将多重背包问题转化为 0-1 背包问题，从而将时间复杂度降低到 \(O(N \cdot M \cdot \log C)\)。</p> <p>转换的依据是 \(1, 2, 4, \ldots, 2^k\) 件物品可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1\) 件物品， 而加上剩余的 \(x\) 件物品后，可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1 + x = c_i\) 件物品。</p> <p>综上所述，这里使用 0-1 背包的方式进行转移依然可以覆盖所有的情况。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="单调栈优化">单调栈优化</h2> <p>我们回到最开始的转移方程：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>在上面的方程中我们可以发现 \(dp_{i, j}\) 只依赖于 \(dp_{i-1, j-k \cdot w_i}\)， 因此我们可以以 \(w_i\) 为步长将 \(j\) 分成若干组， 即 \(j \equiv r \text{mod} w_i\)，其中 \(0 \leq r &lt; w_i\)。</p> <p>对于每一组，我们可以将其转移方程改写为：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} + (k - k') \cdot v_i) \quad (0 \leq k - k' \leq c_i)\] <p>整理一下可以得到：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i) + k \cdot v_i \quad (0 \leq k - k' \leq c_i)\] <p>不难发现上面的 \(\max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i)\) 可以通过单调队列来进行优化， 从而将时间复杂度降低到 \(O(N \cdot M)\)。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ndp</span><span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            <span class="n">ndp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ndp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Knapsack Problem"/><summary type="html"><![CDATA[本文介绍多重背包问题的两种优化方法。]]></summary></entry><entry><title type="html">中国剩余定理及其扩展</title><link href="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/" rel="alternate" type="text/html" title="中国剩余定理及其扩展"/><published>2025-10-16T07:22:05+00:00</published><updated>2025-10-16T07:22:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/"><![CDATA[<h2 id="中国剩余定理">中国剩余定理</h2> <p>假如给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>其中 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>我们令 \(M = m_1 \cdot m_2 \cdots m_k\)，并且对于每个 \(i\)，定义 \(M_i = \frac{M}{m_i}\)。 由于 \(m_i\) 和 \(M_i\) 互质，可以知道 \(M_i\) 在模 \(m_i\) 意义下是有逆元的， 记为 \(M_i^{-1}\)。不难发现 \(M_i \cdot M_i^{-1} \equiv 1 \text{mod} m_i\) 和 \(M_i \cdot M_i^{-1} \equiv 0 \text{mod} m_j\)（\(j \neq i\)）都成立。 记 \(c_i = a_i \cdot M_i \cdot M_i^{-1}\)，则有：</p> \[\begin{cases} c_i \equiv a_i \text{mod} m_i \\ n_i \equiv 0 \text{mod} m_j \quad (j \neq i) \end{cases}\] <p>由同余的线性性质可知，\(x' = \sum_{i=1}^{k} c_i\) 即为一个特解。</p> <p>不难证明通解可以写成 \(x = x' + t \cdot M \quad (t \in \mathbb{Z})\)。</p> <p>注意在上述的过程中，我们要求解 \(M_i\) 在模 \(m_i\) 意义下的逆元， 只有在 \(m_i\) 两两互质的情况下才能保证每次求解的逆元存在。</p> <p>代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">l</span> <span class="o">*=</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span> <span class="o">*</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="扩展中国剩余定理">扩展中国剩余定理</h2> <p>扩展中国剩余定理是在中国剩余定理的基础上，放宽了对模数的互质要求。 假设给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>并不保证 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>不难发现，\(x = x' + t \cdot M \quad (t \in \mathbb{Z})\) 是同余方程 \(x \equiv x' \text{mod}{M}\) 的解。</p> <p>假设我们已经求出了前 \(i-1\) 个方程的解：</p> \[x = x_{i-1} + t \cdot M_{i-1} \quad (t \in \mathbb{Z}),\] <p>现在考虑如何求其与</p> \[x \equiv a_i \text{mod}{m_i}\] <p>的公共解。</p> <p>将当前的解代入上述方程，得到：</p> \[x_{i-1} + t \cdot M_{i-1} \equiv a_i \text{mod}{m_i},\] <p>即</p> \[t \cdot M_{i-1} \equiv a_i - x_{i-1} \text{mod}{m_i}.\] <p>设 \(d = \gcd(M_{i-1}, m_i)\)，则上式有解的<strong>充要条件</strong>是\(d \mid (a_i - x_{i-1})\)。</p> <p>如果有解，将上式两边同时除以 \(d\)，得到：</p> \[t \cdot \frac{M_{i-1}}{d} \equiv \frac{a_i - x_{i-1}}{d} \text{mod}{\frac{m_i}{d}}.\] <p>由于\(\frac{M_{i-1}}{d}\)和\(\frac{m_i}{d}\)互质， 可以用扩展欧几里得算法求该方程的一个特解 \(t_0\)，则通解可以表示为：</p> \[t = t_0 + k \cdot \frac{m_i}{d} \quad (k \in \mathbb{Z}).\] <p>将通解代入\(x = x_{i-1} + t \cdot M_{i-1}\)中，可以得到：</p> \[x = x_{i-1} + t_0 \cdot M_{i-1} + k \cdot \frac{m_i}{d} \cdot M_{i-1} \quad (k \in \mathbb{Z}).\] <p>因此，新的解可以表示为：</p> \[x = x_i + k \cdot M_i \quad (k \in \mathbb{Z}),\] <p>其中</p> \[\begin{cases} x_i = x_{i-1} + t_0 \cdot M_{i-1} \\ M_i = \frac{m_i}{d} \cdot M_{i-1} \end{cases}\] <p>特别地，我们可以增加一个方程 \(x \equiv 0 \text{mod} 1\) 作为初始条件， 此时 \(x_0 = 0\)，\(M_0 = 1\)。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ex_crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ex_gcd</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">%=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Chinese Remainder Theorem"/><summary type="html"><![CDATA[本文介绍中国剩余定理以及扩展中国剩余定理。]]></summary></entry><entry><title type="html">模逆元</title><link href="https://kaiser-yang.github.io/blog/2025/mod-inverse/" rel="alternate" type="text/html" title="模逆元"/><published>2025-10-15T13:34:31+00:00</published><updated>2025-10-15T13:34:31+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/mod-inverse</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/mod-inverse/"><![CDATA[<p>模逆元的定义如下：</p> <p>给定一个正整数 \(a\) 和一个正模数 \(p\) ，如果存在一个正整数 \(b\) 满足：</p> \[a \cdot b \equiv 1 \ (\text{mod} \ p), 1 \leq b \le p\] <p>则称 \(b\) 为 \(a\) 关于模数 \(p\) 的模逆元，记作 \(a^{-1} \ (\text{mod} \ p)\) 。</p> <h2 id="计算方法">计算方法</h2> <h3 id="单个数的模逆元">单个数的模逆元</h3> <p>对于模逆元的计算，其本质是在求解 \(ax + py = 1\) 这个不定方程的正整数解 \(x\)。</p> <p>由裴蜀定理可知，只有当 \(\gcd(a, p) = 1\) 时，方程才有整数解。</p> <p>所以我们可以使用扩展欧几里得算法来计算模逆元。</p> <p>这里给出计算代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">inverse_of</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ex_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>特别地，当 \(p\) 是质数时，由费马小定理可知：</p> \[a^{p-1} \equiv 1 \ (\text{mod} \ p)\] <p>因此，\(a^{p-2} \ (\text{mod} \ p)\) 即为 \(a\) 关于模数 \(p\) 的模逆元。</p> <h3 id="多个数的模逆元">多个数的模逆元</h3> <p>逆元存在一个重要的性质：对于 \(a\) 和 \(b\)，有</p> \[(a \cdot b)^{-1} \equiv a^{-1} \cdot b^{-1} (\text{mod} \ p)\] <p>有了这个性质，我们可以通过预处理前缀积来计算多个数的模逆元。</p> <p>具体地，我们用 \(prod_i\) 表示 \([1, i)\) 的前缀积取模后的结果，即：</p> \[prod_i = a_{i-1} \cdot prod_{i-1} \ (\text{mod} \ p)\] <p>那么就有 \(a^{-1}_i \equiv prod^{-1}_{i+1} \cdot prod_i \ (\text{mod} \ p)\)。</p> <p>我们只需要计算出 \(prod_n\) 的模逆元，然后从后往前依次计算出每个数的模逆元即可。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of each element in a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">prod</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">mod</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">inv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Modular Inverse"/><summary type="html"><![CDATA[本文介绍模逆元的定义及其计算方法。]]></summary></entry><entry><title type="html">扩展欧几里德算法</title><link href="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/" rel="alternate" type="text/html" title="扩展欧几里德算法"/><published>2025-10-14T10:42:49+00:00</published><updated>2025-10-14T10:42:49+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/"><![CDATA[<h2 id="前置知识">前置知识</h2> <p>裴蜀定理（Bézout’s Identity）： 对于任意两个整数 \(a\) 和 \(b\)，存在整数 \(x\) 和 \(y\) 使得 \(ax + by = \gcd(a, b)\) 成立。</p> <p>欧几里德算法：对于两个非负整数 \(a\) 和 \(b\)，其最大公约数可以通过以下递归关系计算：</p> \[gcd(a, b) = gcd(b, a \text{mod} b)\] <h2 id="线性丢番图方程">线性丢番图方程</h2> <p>线性丢番图方程是形如 \(ax + by = c\) 的不定方程， 其中 \(a\)、\(b\) 和 \(c\) 是已知整数，\(x\) 和 \(y\) 是未知整数。</p> <p>根据裴蜀定理，线性丢番图方程有整数解的充分必要条件是 \(\gcd(a, b)\) 整除 \(c\)。</p> <h2 id="扩展欧几里德算法">扩展欧几里德算法</h2> <p>扩展欧几里德算法是用来求解 \(ax + by = \gcd(a, b)\) 的一组特解。</p> <p>算法的基本思想是利用欧几里德算法的递归结构，同时在每一步记录下 \(x\) 和 \(y\) 的变化。</p> <p>考虑当我们已经知道 \(gcd(b, a \text{mod} b) = bx_1 + (a \text{mod} b)y_1\) 的解时， 如何求出 \(gcd(a, b) = ax + by\) 的解。</p> <p>我们记 \(a \text{mod} b = a - \lfloor \frac{a}{b} \rfloor \cdot b\)， 则有：</p> \[gcd(b, a \text{mod} b) = bx_1 + (a - \lfloor \frac{a}{b} \rfloor \cdot b)y_1\] <p>注意到 \(gcd(b, a \text{mod} b) = gcd(a, b)\)，我们可以将上式改写为：</p> \[gcd(a, b) = ay_1 + b(x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1) = ax + by\] <p>从而得到：</p> \[\left\{ \begin{array}{l} x = y_1 \\ y = x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1 \end{array} \right.\] <p>而不难发现当 \(b = 0\) 时，\(gcd(a, 0) = a\)，此时方程的解为 \((1, 0)\)。</p> <p>这样我们就可以通过递归的方式来求解 \(ax + by = \gcd(a, b)\)。</p> <p>对于 \(ax + by = c\) 的情况，我们只需要先求出 \(ax_0 + by_0 = \gcd(a, b)\) 的一组解， 此时 \(x = x_0 \cdot \frac{c}{\gcd(a, b)}\)，\(y = y_0 \cdot \frac{c}{\gcd(a, b)}\) 即为 \(ax + by = c\) 的一组特解。</p> <p>接下来我们考虑在知道一组解的情况下，如何求出通解。这里先给出结论：</p> <p>若 \((x_0, y_0)\) 是 \(ax + by = c\) 的一组解，则通解可以表示为：</p> \[\left\{ \begin{array}{l} x = x_0 + k \cdot \frac{b}{\gcd(a, b)} \\ y = y_0 - k \cdot \frac{a}{\gcd(a, b)} \end{array} \right.\] <p>容易证明上述形式的解都满足方程。我们接下来证明所有解都可以表示为上述形式。</p> <p>设 \((x_1, y_1)\) 也是方程的解，则有 \(a(x_1 - x_0) + b(y_1 - y_0) = 0\) 成立。</p> <p>由此可得</p> \[a(x_1 - x_0) = -b(y_1 - y_0)\] <p>两边同时除以 \(\gcd(a, b)\)，有</p> \[\frac{a}{\gcd(a, b)}(x_1 - x_0) = -\frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>可以知道</p> \[\frac{a}{\gcd(a, b)} \mid \frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>因为 \(\frac{a}{\gcd(a, b)}\) 和 \(\frac{b}{\gcd(a, b)}\) 互质，所以</p> \[\frac{a}{\gcd(a, b)} \mid y_1 - y_0\] <p>即存在整数 \(k\) 使得：</p> \[y_1 - y_0 = k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[y_1 = y_0 + k \cdot \frac{a}{\gcd(a, b)}\] <p>代入前面的等式，有：</p> \[a(x_1 - x_0) = -b \cdot k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[x_1 = x_0 - k \cdot \frac{b}{\gcd(a, b)}\] <p>综上所述，所有解可以表示为上述通解的形式。</p> <p>最后给出扩展欧几里德算法的代码实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the greatest common divisor of a and b,</span>
<span class="c1">// and find x and y such that ax + by = gcd(a, b)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">ex_gcd</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ex_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Extended Euclidean Algorithm"/><category term="gcd"/><summary type="html"><![CDATA[本文介绍扩展欧几里德算法的原理及应用。]]></summary></entry><entry><title type="html">Miller Rabin 素数测试</title><link href="https://kaiser-yang.github.io/blog/2025/miller-rabin/" rel="alternate" type="text/html" title="Miller Rabin 素数测试"/><published>2025-10-13T13:11:22+00:00</published><updated>2025-10-13T13:11:22+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/miller-rabin</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/miller-rabin/"><![CDATA[<h2 id="前置知识">前置知识</h2> <h3 id="费马小定理fermats-little-theorem">费马小定理（Fermat’s Little Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(a\) 不是 \(p\) 的倍数， 则 \(a^{p-1} \equiv 1 \text{mod} p\)。</p> <h3 id="二次探测定理quadratic-residue-theorem">二次探测定理（Quadratic Residue Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(x^2 \equiv 1 \text{mod} p\)， 则 \(x \equiv 1 \text{mod} p\) 或 \(x \equiv n - 1 \text{mod} p\)。</p> <h2 id="miller-rabin-素数测试原理">Miller Rabin 素数测试原理</h2> <p>我们可以发现，费马小定理和二次探测定理都给出了素数的必要条件， 但并不是充分条件。也就是说，如果一个数不满足这些条件， 那么它一定不是素数。</p> <p>Miller Rabin 素数测试是一种基于概率的素数测试算法， 它通过多次随机选择基数 \(a\) 来验证一个数是否为素数。</p> <p>对于一个奇数 \(n\) 而言其可以被写成 \(n - 1 = 2^s \cdot d\) 的形式， 其中 \(d\) 是奇数，\(s \geq 1\)。 根据费马小定理，如果 \(n\) 是素数， 则对于任意不是 \(p\) 倍数的 \(a\)，都有 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\)。 而由二次探测定理可知，我们可以对 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\) 执行开方的操作，其结果一定要是 \(1\) 或 \(n - 1\)。 同时当其结果为 \(1\) 时，则可以继续尝试开方操作，直到结果为 \(n - 1\) 或无法继续开方为止。 如果在某次开方的过程中，结果既不是 \(1\) 也不是 \(n - 1\)， 则 \(n\) 一定不是素数。</p> <p>根据上面的流程我们可以选择多个不同的 \(a\) 来进行测试， 如果所有的测试都通过了，则 \(n\) 很可能是素数。</p> <p>特别地，对于 64 位无符号整数，选择 \(2, 325, 9375, 28178, 450775, 9780504, 1795265022\) 可以保证不会出现误判。</p> <p>另外在实现的过程中，我们往往不会进行开方的操作，取而代之的是平方操作：</p> <ol> <li>将待测试的数 \(n\) 表示为 \(n - 1 = 2^s \cdot d\)，其中 \(d\) 是奇数，\(s \geq 1\)。</li> <li>选择一个基数 \(a\)。</li> <li>计算 \(x = a^d \text{mod} n\)。</li> <li>如果 \(x \equiv 1 \text{mod} n\) 或 \(x \equiv n - 1 \text{mod} n\)，此时进行平方的结果一定是 \(1\)， 所以可以直接认为通过本轮的测试。</li> <li>否则，重复以下步骤 \(s - 1\) 次： <ul> <li>计算 \(x \leftarrow x^2 \text{mod} n\)。</li> <li>如果 \(x \equiv n - 1 \text{mod} n\)，则通过本轮测试。</li> <li>如果在 \(s - 1\) 次操作中都没有出现 \(x \equiv n - 1 \text{mod} n\)，则本轮测试未通过。</li> </ul> </li> </ol> <p>在上述过程的5中，我们只检查了结果是否等于 \(n - 1\)，而没有检查结果是否等于 \(1\)。 这是因为如果当前的结果第一次等于 \(1\)，则说明在前一次平方操作中， 结果既不是 \(1\) 也不是 \(n - 1\)，这就违背了二次探测定理。</p> <p>最后给出Miller Rabin素数测试的代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">a</span> <span class="o">:</span> <span class="n">miller_rabin_test</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// calculate a^d % n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Miller Rabin"/><category term="Primality Test"/><summary type="html"><![CDATA[本文介绍 Miller Rabin 素数测试的原理及其实现方式。]]></summary></entry><entry><title type="html">gcs-front-end Development</title><link href="https://kaiser-yang.github.io/blog/2025/gcs-front-end-development/" rel="alternate" type="text/html" title="gcs-front-end Development"/><published>2025-06-05T01:26:27+00:00</published><updated>2025-06-05T01:26:27+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/gcs-front-end-development</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/gcs-front-end-development/"><![CDATA[<p>The main process of <code class="language-plaintext highlighter-rouge">gcs-front-end</code> development is as follows:</p> <ul> <li>Clone the <code class="language-plaintext highlighter-rouge">gcs-front-end</code> repository.</li> <li>Code and test.</li> <li>Commit the code to the repository.</li> <li>Open a pull request to the <code class="language-plaintext highlighter-rouge">gcs-front-end</code> repository.</li> <li>Wait for the code review and merge.</li> </ul> <h2 id="clone-the-repository">Clone the Repository</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HTTPS</span>
git clone https://github.com/CMIPT/gcs-front-end.git
<span class="c"># or with SSH</span>
git clone git@github.com:CMIPT/gcs-front-end.git
</code></pre></div></div> <h2 id="code-and-test">Code and Test</h2> <p>You may need to deploy the <code class="language-plaintext highlighter-rouge">gcs-back-end</code> first, so that you can request APIs from the front-end.</p> <p>We recommend you to use the <code class="language-plaintext highlighter-rouge">docker-compose</code> to deploy the <code class="language-plaintext highlighter-rouge">gcs-back-end</code>, those below are required:</p> <ul> <li><code class="language-plaintext highlighter-rouge">docker</code></li> <li><code class="language-plaintext highlighter-rouge">docker-compose</code></li> <li><code class="language-plaintext highlighter-rouge">openssl</code></li> </ul> <p>First, you should download the latest release from <a href="https://github.com/CMIPT/gcs-back-end/releases">gcs-back-end</a>.</p> <p>The downloaded file is a compressed file named <code class="language-plaintext highlighter-rouge">gcs-back-end.tar.gz</code>, which contains the compiled <code class="language-plaintext highlighter-rouge">jar</code> package, and related configuration files.</p> <p>The directory structure is as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── .env
├── 3rdparty
├── Dockerfile
├── database
├── docker-compose.yml
├── nginx
├── start.sh
├── target
</code></pre></div></div> <p>Then you need to do some configurations for the deployment environment. You mainly need to modify the <code class="language-plaintext highlighter-rouge">.env</code> file in the root directory of the project. Those below are the environment variables you need to set:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">GIT_SERVER_DOMAIN</span><span class="o">=</span>
<span class="nv">SPRING_MAIL_HOST</span><span class="o">=</span>
<span class="nv">SPRING_MAIL_PORT</span><span class="o">=</span>
<span class="nv">SPRING_MAIL_USERNAME</span><span class="o">=</span>
<span class="nv">SPRING_MAIL_PASSWORD</span><span class="o">=</span>
<span class="nv">SPRING_MAIL_PROTOCOL</span><span class="o">=</span>
<span class="nv">MD5_SALT</span><span class="o">=</span>
<span class="nv">JWT_SECRET</span><span class="o">=</span>
<span class="nv">GCS_SSH_MAPPING_PORT</span><span class="o">=</span>
</code></pre></div></div> <p>You can generate <code class="language-plaintext highlighter-rouge">JWT_SECRET</code> and <code class="language-plaintext highlighter-rouge">MD5_SALT</code> using the command <code class="language-plaintext highlighter-rouge">openssl rand -base64 32</code> (make sure they are different). <code class="language-plaintext highlighter-rouge">GCS_SSH_MAPPING_PORT</code> is the port you want to expose, which is used for <code class="language-plaintext highlighter-rouge">ssh</code> cloning repositories.</p> <p><strong>NOTE</strong>: <code class="language-plaintext highlighter-rouge">MD5_SALT</code> should not be changed after set.</p> <p>You can generate the <code class="language-plaintext highlighter-rouge">ssl</code> certificate by running the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-x509</span> <span class="nt">-nodes</span> <span class="nt">-days</span> 36500 <span class="nt">-newkey</span> rsa:2048 <span class="se">\</span>
  <span class="nt">-keyout</span> nginx/ssl/private.key <span class="nt">-out</span> nginx/ssl/certificate.crt
</code></pre></div></div> <p>Now you can use the command below to start the <code class="language-plaintext highlighter-rouge">gcs</code> service:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose build
docker-compose up <span class="nt">-d</span>
</code></pre></div></div> <p>After this, the <code class="language-plaintext highlighter-rouge">gcs</code> service is running in the background listening on port <code class="language-plaintext highlighter-rouge">8080</code>.</p> <p>Once the service is running (you can check the status by running <code class="language-plaintext highlighter-rouge">docker ps</code>), you can access the API documentation at:</p> <p><code class="language-plaintext highlighter-rouge">http://localhost:8080/swagger-ui/index.html</code></p> <p>Now it’s time for you to code and test.</p> <h2 id="commit-the-code">Commit the Code</h2> <p>After you finish your coding and testing, you can commit the code to the repository:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add <span class="nb">.</span>
git commit <span class="nt">-m</span> <span class="s2">"Your commit message"</span>
<span class="c"># Or you can use your own GUI to write the commit message</span>
</code></pre></div></div> <p>The commit message should be clear and concise, those below are some examples:</p> <pre><code class="language-Bash"># Example 1
fix(repository): empty repository name

In this commit, we use asynchronous request to check if the repository
name is not empty. This should close #1234.

# Example 2
ci(format): format ci pipeline

We add new github actions to format the code automatically when
a pull request is opened.
</code></pre> <p>The first line of the commit message should started with the type of the commit, which can be one of the following:</p> <ul> <li><code class="language-plaintext highlighter-rouge">feat</code>: a new feature</li> <li><code class="language-plaintext highlighter-rouge">fix</code>: a bug fix</li> <li><code class="language-plaintext highlighter-rouge">docs</code>: documentation only changes</li> <li><code class="language-plaintext highlighter-rouge">format</code> / <code class="language-plaintext highlighter-rouge">style</code>: formatting changes</li> <li><code class="language-plaintext highlighter-rouge">refactor</code>: a code change that neither fixes a bug nor adds a feature</li> <li><code class="language-plaintext highlighter-rouge">perf</code>: a code change that improves performance</li> <li><code class="language-plaintext highlighter-rouge">test</code>: adding missing or correcting existing tests</li> <li><code class="language-plaintext highlighter-rouge">ci</code>: changes to our CI configuration files and scripts</li> <li><code class="language-plaintext highlighter-rouge">build</code> / <code class="language-plaintext highlighter-rouge">deps</code>: changes that affect the build system or external dependencies</li> </ul> <p>Then you should add the affected modules in the parentheses, then a colon <code class="language-plaintext highlighter-rouge">:</code>, and a brief description of the change.</p> <p>After the first line, you should leave a blank line, then write a detailed description of the change. Every line of the description should not be greater than <code class="language-plaintext highlighter-rouge">72</code> characters.</p> <p>You should try to make sure the commits are atomic, meaning that each commit should only contain one logical change. And you should try to make every commit can be built and tested successfully.</p> <h2 id="open-a-pull-request">Open a Pull Request</h2> <p>Once you have committed the code, you can push the code to your forked repository, or if you are one of the collaborators, you can push the code to the <code class="language-plaintext highlighter-rouge">gcs-front-end</code> repository directly.</p> <p>Then open a pull request to the <code class="language-plaintext highlighter-rouge">master</code> branch of the <code class="language-plaintext highlighter-rouge">gcs-front-end</code> repository.</p> <p>The title and description of the pull request should be clear and concise, you can pick up the first line of your commit message as the title of the pull request.</p> <h2 id="wait-for-code-review-and-merge">Wait for Code Review and Merge</h2> <p>You can send a message to the <code class="language-plaintext highlighter-rouge">gcs-developers</code> team to notify them that you have opened a pull request.</p> <p>Once the pull request is opened, the team will review your code and give you feedback as soon as possible.</p> <p>During this process, you may be asked to make some changes to your code.</p> <p>Once the code is reviewed and approved, the team will merge your code to the <code class="language-plaintext highlighter-rouge">master</code> branch.</p>]]></content><author><name></name></author><category term="gcs"/><category term="English Posts"/><category term="Frontend"/><category term="Vue"/><summary type="html"><![CDATA[This post includes the main process of gcs-front-end development.]]></summary></entry></feed>