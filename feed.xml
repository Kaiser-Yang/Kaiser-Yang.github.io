<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2025-12-17T13:30:58+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>Sharing everything I know. </subtitle><entry><title type="html">文学摘抄</title><link href="https://kaiser-yang.github.io/blog/2025/literature/" rel="alternate" type="text/html" title="文学摘抄"/><published>2025-12-11T06:18:12+00:00</published><updated>2025-12-11T06:18:12+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/literature</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/literature/"><![CDATA[<h2 id="诗词歌赋">诗词歌赋</h2> <blockquote> <p>洛阳春<br/> 岑参<br/> 人到洛阳花似锦，偏我来时不逢春。<br/> 谁道三冬无春色，冰山高处万里银。<br/></p> </blockquote> <hr/> <blockquote> <p>离思五首·其四<br/> 元稹<br/> 曾经沧海难为水，除却巫山不是云。<br/> 取次花丛懒回顾，半缘修道半缘君。<br/></p> </blockquote> <hr/> <blockquote> <p>金缕衣<br/> 佚名<br/> 劝君莫惜金缕衣，劝君惜取少年时。<br/> 花开堪折直须折，莫待无花空折枝。<br/></p> </blockquote> <hr/> <blockquote> <p>梅岭三章·其一<br/> 陈毅<br/> 断头今日意如何？创业艰难百战多。<br/> 此去泉台招旧部，旌旗十万斩阎罗。<br/></p> </blockquote> <hr/> <blockquote> <p>观书有感二首·其一<br/> 朱熹<br/> 半亩方塘一鉴开，天光云影共徘徊。<br/> 问渠那得清如许？为有源头活水来。<br/></p> </blockquote>]]></content><author><name></name></author><category term="Potpourri"/><category term="Literature"/><summary type="html"><![CDATA[本文收集了一些我喜欢的文学作品中的摘抄。]]></summary></entry><entry><title type="html">Go 学习笔记</title><link href="https://kaiser-yang.github.io/blog/2025/go-learning/" rel="alternate" type="text/html" title="Go 学习笔记"/><published>2025-12-09T11:44:38+00:00</published><updated>2025-12-09T11:44:38+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/go-learning</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/go-learning/"><![CDATA[<p>使用 <code class="language-plaintext highlighter-rouge">fmt.Printf</code> 时可能涉及到相关的格式化动词，以下是一些常用的格式化动词及其含义：</p> <table> <thead> <tr> <th>动词</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td>%v</td> <td>默认格式</td> </tr> <tr> <td>%+v</td> <td>带字段名的结构体格式</td> </tr> <tr> <td>%#v</td> <td>Go 语法表示的值</td> </tr> <tr> <td>%T</td> <td>类型信息</td> </tr> <tr> <td>%t</td> <td>布尔值</td> </tr> <tr> <td>%c</td> <td>对应的 Unicode 字符</td> </tr> <tr> <td>%U</td> <td>Unicode 格式的字符</td> </tr> <tr> <td>%%</td> <td>字符 ‘%’</td> </tr> <tr> <td>%s</td> <td>字符串</td> </tr> <tr> <td>%q</td> <td>带双引号的字符串</td> </tr> <tr> <td>%p</td> <td>指针地址</td> </tr> <tr> <td>%b</td> <td>二进制</td> </tr> <tr> <td>%o/%O</td> <td>八进制（是否带 <code class="language-plaintext highlighter-rouge">0o</code> 前缀）</td> </tr> <tr> <td>%x/%X</td> <td>十六进制（大小写）</td> </tr> <tr> <td>%d/%i</td> <td>十进制整数</td> </tr> <tr> <td>%f</td> <td>十进制浮点数</td> </tr> <tr> <td>%g</td> <td>最简洁的十进制或科学计数法</td> </tr> <tr> <td>%e/%E</td> <td>科学计数法（大小写）</td> </tr> <tr> <td>%w</td> <td>用于错误包装</td> </tr> </tbody> </table> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 中所以的语句后面都不需要使用 <code class="language-plaintext highlighter-rouge">;</code> 来结尾， 并且在条件分支中也不需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来包裹条件表达式。 除此之外，在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的条件分支中可以添加一个初始化语句，这个初始化语句会在条件判断之前执行， 并且其作用域仅限于该条件分支内。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">doSomething</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="c">// 处理错误</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c">// 正常处理</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">switch</code> 语句会自动在每个 <code class="language-plaintext highlighter-rouge">case</code> 分支后面添加一个隐式的 <code class="language-plaintext highlighter-rouge">break</code>， 因此不需要显式地使用 <code class="language-plaintext highlighter-rouge">break</code> 语句来终止分支。 如果想要在某个 <code class="language-plaintext highlighter-rouge">case</code> 分支中继续执行下一个分支，可以使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 关键字。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">type</code> 关键字来定义新类型或者给已有的类型取别名。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span>
  <span class="n">MyInt</span> <span class="kt">int</span>               <span class="c">// 定义新类型 MyInt，底层类型为 int</span>
  <span class="n">YourInt</span> <span class="o">=</span> <span class="kt">int</span>          <span class="c">// 给 int 类型取别名 YourInt</span>
<span class="p">)</span>
</code></pre></div></div> <p>别名类型和原类型是完全相同的类型，可以互相赋值和转换。 而新类型和原类型是不同的类型，往往需要进行显式的转换。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">var</code>、<code class="language-plaintext highlighter-rouge">const</code>、<code class="language-plaintext highlighter-rouge">type</code>、<code class="language-plaintext highlighter-rouge">import</code> 等关键字都可以使用块语法来声明多个变量、常量或类型。 块语法使用大括号 <code class="language-plaintext highlighter-rouge">{}</code> 将多个声明包裹在一起。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
  <span class="n">a</span> <span class="kt">int</span>
  <span class="n">b</span> <span class="kt">string</span>
  <span class="n">c</span> <span class="kt">bool</span>
<span class="p">)</span>
</code></pre></div></div> <p>这种方式可以使代码更加整洁，尤其是在需要声明多个相关变量时。</p> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中，后续的变量会重复使用前一个变量的表达式，除非显式地为其赋值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="m">1</span>
  <span class="n">B</span>        <span class="c">// B 的值为 1</span>
  <span class="n">C</span> <span class="o">=</span> <span class="m">2</span>
  <span class="n">D</span>        <span class="c">// D 的值为 2</span>
<span class="p">)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中可以使用 <code class="language-plaintext highlighter-rouge">iota</code>，它的值是当前变量所在的偏移位置（从0开始计算）。 每当遇到一个新的 <code class="language-plaintext highlighter-rouge">const</code> 块时，<code class="language-plaintext highlighter-rouge">iota</code> 会被重置为0，并且在每一行中递增1。 也可以在 <code class="language-plaintext highlighter-rouge">const</code> 块中使用 <code class="language-plaintext highlighter-rouge">_</code> 来忽略某些值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="no">iota</span>           <span class="c">// A 的值为 0</span>
  <span class="n">B</span>                  <span class="c">// B 的值为 1</span>
  <span class="n">_</span>                  <span class="c">// 忽略该值，iota 递增到 2</span>
  <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="no">iota</span><span class="p">,</span> <span class="no">iota</span>  <span class="c">// C 和 D 的值均为 3</span>
<span class="p">)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以定义 <code class="language-plaintext highlighter-rouge">label</code>，<code class="language-plaintext highlighter-rouge">label</code> 可以用来进行 <code class="language-plaintext highlighter-rouge">continue</code> 或者 <code class="language-plaintext highlighter-rouge">break</code> 操作， 从而跳出多层循环或者指定跳出某个循环。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OuterLoop</span><span class="o">:</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="n">OuterLoop</span> <span class="c">// 跳出当前内层循环，进入下一次外层循环</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">2</span> <span class="p">{</span>
      <span class="k">break</span> <span class="n">OuterLoop</span> <span class="c">// 跳出外层循环</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i=%d, j=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用有显示名称的返回值， 这样只需要在函数体中对这些返回值进行赋值而不需要显式地使用 <code class="language-plaintext highlighter-rouge">return</code> 语句返回它们。 这样的写法在需要根据条件分支返回多个值时非常有用。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 使用有显示名称的返回值</span>
<span class="k">func</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">quotient</span> <span class="kt">int</span><span class="p">,</span> <span class="n">remainder</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">quotient</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
  <span class="k">return</span> <span class="c">// 直接返回命名的返回值，这里的 return 不能省略</span>
<span class="p">}</span>

<span class="c">// 使用无名称的返回值</span>
<span class="k">func</span> <span class="n">divide2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用变长参数来接收不定数量的参数。 变长参数使用 <code class="language-plaintext highlighter-rouge">...</code> 语法来定义，表示可以传入任意数量的该类型参数。 在函数体内，变长参数会被视为一个切片。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">total</span> <span class="o">:=</span> <span class="m">0</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total</span>
<span class="p">}</span>
<span class="n">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">result1</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c">// 传入多个参数</span>
<span class="n">result2</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="o">...</span><span class="p">)</span>          <span class="c">// 传入切片，使用 ... 展开切片</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">import</code> 进行包的导入，可以给导入的包取别名， 也可以使用 <code class="language-plaintext highlighter-rouge">.</code> 来导入包中的所有标识符。通常而言，在 <code class="language-plaintext highlighter-rouge">Go</code> 导入的包必须要被使用，否则会导致编译错误。 但是有一种特殊的导入方式是使用 <code class="language-plaintext highlighter-rouge">_</code>，这种方式仅导入包以执行其 <code class="language-plaintext highlighter-rouge">init</code> 函数， 而不会导入包中的其他标识符。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
  <span class="n">fmt</span> <span class="s">"fmt"</span>      <span class="c">// 给包取别名</span>
  <span class="o">.</span> <span class="s">"math"</span>       <span class="c">// 导入包中的所有标识符</span>
  <span class="n">_</span> <span class="s">"net/http"</span>  <span class="c">// 仅导入包以执行其 init 函数</span>
<span class="p">)</span>
</code></pre></div></div> <p>当两个同名的包导入时就需要使用别名来区分它们。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中有各种字面量可以使用，同时对于数字字面量还支持使用下划线 <code class="language-plaintext highlighter-rouge">_</code> 来分隔数字以提高可读性。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">53</span><span class="n">_700</span>        <span class="c">// 十进制</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">0</span><span class="n">_700</span>         <span class="c">// 0前缀表示八进制</span>
<span class="n">c1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">x_aa_bb_cc</span>
<span class="n">c2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">X_dd_ee_ff</span>  <span class="c">// 0x或0X前缀表示十六进制</span>
<span class="n">d1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">b_1000_0001</span>
<span class="n">d2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">B_1000_0001</span> <span class="c">// 0b或0B前缀表示二进制</span>
<span class="n">e</span> <span class="o">:=</span> <span class="m">.15</span>           <span class="c">// 浮点数，可以省略整数部分的0</span>
<span class="n">f</span> <span class="o">:=</span> <span class="m">82.</span>           <span class="c">// 浮点数，可以省略小数部分的0</span>
<span class="n">g1</span> <span class="o">:=</span> <span class="m">1.5e2</span>        <span class="c">// 科学计数法表示</span>
<span class="n">g2</span> <span class="o">:=</span> <span class="m">1.5E3</span>        <span class="c">// 科学计数法表示</span>
<span class="n">h1</span> <span class="o">:=</span> <span class="m">0x2</span><span class="o">.</span><span class="n">p10</span>      <span class="c">// 十六进制浮点数</span>
<span class="n">h2</span> <span class="o">:=</span> <span class="m">0X1</span><span class="o">.</span><span class="n">Fp0</span>      <span class="c">// 十六进制浮点数</span>

<span class="n">ch1</span> <span class="o">:=</span> <span class="sc">'\u4e2d'</span>              <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch2</span> <span class="o">:=</span> <span class="sc">'\U00004e2d'</span>          <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch3</span> <span class="o">:=</span> <span class="sc">'\x27'</span>                <span class="c">// 字符字面量，表示单引号字符 `'`</span>
<span class="n">ch4</span> <span class="o">:=</span> <span class="sc">'\047'</span>                <span class="c">// 字符字面量，八进制表示的字符 `'`</span>

<span class="n">s1</span> <span class="o">:=</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span>                <span class="c">// 字符串字面量，包含转义字符</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\u4e2d\u6587</span><span class="s">"</span>         <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\U00004e2d\U00006587</span><span class="s">"</span> <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s4</span> <span class="o">:=</span> <span class="s">`This is a raw string.
This is the second line.
This is the third line.
\n will not be interpreted.`</span> <span class="c">// 原始字符串字面量</span>

<span class="n">arr1</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr2</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">5</span><span class="o">:</span> <span class="m">5</span> <span class="p">}</span>   <span class="c">// 数组字面量，长度均为 6</span>

<span class="n">sp1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span>    <span class="c">// 切片字面量</span>

<span class="n">mp1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="s">"a"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"b"</span><span class="o">:</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// 映射字面量</span>
</code></pre></div></div> <p>在使用十六进制的科学计数法进行表示的时候，<code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">P</code> 表示幂运算的底数是 <code class="language-plaintext highlighter-rouge">2</code>。 需要注意的是整数部分和小数部分用十六进制来表示，而幂运算的指数部分仍然使用十进制来表示。</p> <p>如果想要在 <code class="language-plaintext highlighter-rouge">raw string</code> 中包含反引号，则可以使用 <code class="language-plaintext highlighter-rouge">+</code> 进行字符串的拼接来实现。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">array[low:high:max]</code> 来基于一个已经存在的数组创建一个切片。 当省略 <code class="language-plaintext highlighter-rouge">max</code> 时，默认 <code class="language-plaintext highlighter-rouge">max</code> 的值为数组的长度。 这个切片的长度是 <code class="language-plaintext highlighter-rouge">high - low</code>，容量是 <code class="language-plaintext highlighter-rouge">max - low</code>。 这也表明 <code class="language-plaintext highlighter-rouge">[low, high)</code> 和 <code class="language-plaintext highlighter-rouge">[low, max)</code> 都是左闭右开区间。</p> <p>需要注意的是基于数组创建的切片的底层是原数组，所以对切片的修改往往会直接影响原数组。 不过在切片发生扩容的时候会创建一个新的底层数组，此时对切片的修改就不会影响原数组了。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
<span class="n">s1</span> <span class="o">:=</span> <span class="n">arr</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>              <span class="c">// 创建切片 s1，包含 arr[1], arr[2], arr[3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>               <span class="c">// 输出: [1 2 3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// 输出: 3 4</span>
<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>                    <span class="c">// 修改切片 s1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>              <span class="c">// 输出: [0 10 2 3 4]，arr 也被修改了</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span>      <span class="c">// 切片 s1 发生扩容，创建了新的底层数组</span>
<span class="n">s2</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">30</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// 输出: [0 10 2 3 4]，arr 不受影响</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// 输出: [30 2 3 20 30]</span>
</code></pre></div></div> <p>可以使用 <code class="language-plaintext highlighter-rouge">len</code> 和 <code class="language-plaintext highlighter-rouge">cap</code> 函数来获取切片的长度和容量。 但是对于 <code class="language-plaintext highlighter-rouge">map</code> 而言则只能使用 <code class="language-plaintext highlighter-rouge">len</code> 函数来获取其长度。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中通过下标运算符去获取一个 <code class="language-plaintext highlighter-rouge">map</code> 中不存在的键时会返回该类型的零值。 为了区分一个键是不存在还是其值就是类型的零值，可以使用双赋值的形式来获取键对应的值和一个布尔值， 该布尔值表示该键是否存在于 <code class="language-plaintext highlighter-rouge">map</code> 中。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s">"key"</span><span class="p">]</span> <span class="c">// 如果 "key" 不存在，v 为 0，ok 为 false</span>
<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
<span class="c">// 处理键不存在的情况</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c">// 使用 v 进行后续操作</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">map</code> 是基于 <code class="language-plaintext highlighter-rouge">hash</code> 的，对其进行遍历时的顺序是随机的。 <code class="language-plaintext highlighter-rouge">Go</code> 为了让开发者不依赖于 <code class="language-plaintext highlighter-rouge">map</code> 的遍历顺序，特意设计成每次遍历的顺序都有可能不一样。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串、字节切片、<code class="language-plaintext highlighter-rouge">rune</code> 切片之间可以方便地进行相互转换。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c">// 字符串转换为字节切片</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[]</span><span class="kt">rune</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c">// 字符串转换为 rune 切片</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                <span class="c">// 字节切片转换为字符串</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>                <span class="c">// rune 切片转换为字符串</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串是通过 <code class="language-plaintext highlighter-rouge">UTF-8</code> 编码进行存储的，因此可以直接存储和处理多字节的 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">len</code> 获取的字符串的字节数而不是字符数，如果要获取字符数可以使用 <code class="language-plaintext highlighter-rouge">utf8.RuneCountInString</code> 函数。同理通过下标访问字符串时获取的是字节而不是字符。 不过如果是使用 <code class="language-plaintext highlighter-rouge">for range</code> 来遍历字符串时获取的是字符。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="n">lengthInBytes</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                      <span class="c">// 获取字符串的字节数</span>
<span class="n">lengthInRunes</span> <span class="o">:=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   <span class="c">// 获取字符串的字符数</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>                        <span class="c">// 遍历字符串中的字符</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Character %d: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
  <span class="c">// i 是字符的起始字节索引，r 是对应的 rune 值</span>
  <span class="c">// Character 5: 世</span>
  <span class="c">// Character 8: 界</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Byte %d: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>      <span class="c">// 访问字符串中的字节</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的结构体中可以使用嵌入字段来实现类似于继承的效果。 嵌入字段是指在结构体中直接包含另一个结构体类型，而不需要为其指定字段名。 这样可以直接访问嵌入结构体的字段和方法。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Person</span>  <span class="c">// 嵌入 Person 结构体</span>
  <span class="n">ID</span>      <span class="kt">string</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">emp</span> <span class="n">Employee</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"Alice"</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="m">30</span>  <span class="c">// 直接访问嵌入结构体的字段</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不可以在结构类型 <code class="language-plaintext highlighter-rouge">T</code> 中类型为 <code class="language-plaintext highlighter-rouge">T</code> 的字段，也不可以递归定义， 但是可以包含<code class="language-plaintext highlighter-rouge">*T</code>、<code class="language-plaintext highlighter-rouge">[]T</code>、<code class="language-plaintext highlighter-rouge">map[type]T</code> 等类型的字段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// F T         // 错误，不能包含类型为 T 的字段</span>
  <span class="n">F</span> <span class="o">*</span><span class="n">T</span>           <span class="c">// 正确，可以包含类型为 *T 的字段</span>
  <span class="n">G</span> <span class="p">[]</span><span class="n">T</span>          <span class="c">// 正确，可以包含类型为 []T 的字段</span>
  <span class="n">H</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">T</span> <span class="c">// 正确，可以包含类型为 map[type]T 的字段</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T1</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t2</span> <span class="n">T2</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T2</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t1</span> <span class="n">T1</span>  <span class="c">// 错误，不能递归定义</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中主要有三种方法可以对自定义类型进行初始化。以下面的自定义类型为例。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Book</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Title</span>  <span class="kt">string</span>
  <span class="n">Author</span> <span class="n">Person</span>
<span class="p">}</span>
</code></pre></div></div> <p>一是可以按照顺序对结构体的字段进行赋值，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b1</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>但是这样的弊端也很明显：如果结构体的字段顺序发生变化，那么初始化的代码也需要进行相应的修改。 且当结构体的字段较多时，代码的可读性也会变差。这就引出了第二种初始化的方式：使用字段名进行赋值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p2</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b2</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="n">Title</span><span class="o">:</span> <span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Author</span><span class="o">:</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>除此之外还可以自定义方法来根据传入的参数进行初始化，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="n">age</span><span class="p">}</span>
<span class="p">}</span>
<span class="c">// or</span>
<span class="c">// func NewPerson(name string, age int) Person {</span>
<span class="c">//   return Person{Name: name, Age: age}</span>
<span class="c">// }</span>

<span class="n">p3</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// p3 在这里是 *Person 类型</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言可以对底层类型相同的元素进行隐式转换，编译器会保证这种转换的安全。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">var</span> <span class="n">a</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="m">10</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">10</span>
<span class="n">c</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="c">// 隐式转换，MyInt 和 int 可以进行运算</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的方法集合是指某个类型所拥有的方法的集合。 方法集合会根据接收者的类型而有所不同。 如果接收者是值类型，那么方法集合中包含所有值接收者和指针接收者的方法。 如果接收者是指针类型，那么方法集合中只包含指针接收者的方法。 如果一个类型的方法集合是一接口的超集，那么该类型就实现了该接口。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以通过类型断言来获取一个接口变量的具体类型和值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">10</span>
<span class="k">var</span> <span class="n">x</span> <span class="n">any</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">v1</span><span class="p">,</span> <span class="n">ok1</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c">// ok1 为 true，v1 的值为 10</span>
<span class="n">v2</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="c">// ok2 为 false，v2 的值为 string 类型的零值 ""</span>
<span class="n">v3</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>     <span class="c">// 如果断言失败会引发 panic</span>
</code></pre></div></div> <p>需要注意的是，如果断言的类型是一个接口则语义变成了「变量是否实现了该接口」的判断。 如果断言成功，会返回变量的实际类型和值而不是返回接口类型和值。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">select</code> 原语，其可以一次监听多个 <code class="language-plaintext highlighter-rouge">channel</code> 的操作。 当其中某个 <code class="language-plaintext highlighter-rouge">channel</code> 准备好进行发送或接收操作时，<code class="language-plaintext highlighter-rouge">select</code> 会执行对应的 <code class="language-plaintext highlighter-rouge">case</code> 分支。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">msg1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Received message from ch1: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg1</span><span class="p">)</span>
<span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">msg2</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Sent message to ch2: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg2</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"No channel is ready"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>当没有使用 <code class="language-plaintext highlighter-rouge">default</code> 的时候，<code class="language-plaintext highlighter-rouge">select</code> 会一直阻塞直到某个 <code class="language-plaintext highlighter-rouge">case</code> 分支可以执行。</p> <p>下面三种是 <code class="language-plaintext highlighter-rouge">select</code> 原语常用的方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">default</code> 分支可以实现 <code class="language-plaintext highlighter-rouge">try</code> 语义。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包可以实现超时控制。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包的 <code class="language-plaintext highlighter-rouge">Ticker</code> 可以实现周期任务。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="n">TrySend</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">value</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">true</span> <span class="c">// 发送成功</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">false</span> <span class="c">// channel 未准备好，发送失败</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ReceiveWithTimeout</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="no">nil</span> <span class="c">// 成功接收数据</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"receive timeout"</span><span class="p">)</span> <span class="c">// 超时</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">PeriodicTask</span><span class="p">(</span><span class="n">interval</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">stopCh</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
  <span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">ticker</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">ticker</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="c">// 执行周期任务</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">stopCh</span><span class="o">:</span>
      <span class="k">return</span> <span class="c">// 停止任务</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">type switch</code> 来方便的判断一个接口变量所属于的类型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="m">10</span>
<span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span> <span class="c">// 只能接口类型可以使用 type switch</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is int: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is of unknown type</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意 <code class="language-plaintext highlighter-rouge">case</code> 后面的类型必须是实现了该接口的类型，否则会导致编译错误。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中只能通过 <code class="language-plaintext highlighter-rouge">make</code> 来创建 <code class="language-plaintext highlighter-rouge">channel</code>，<code class="language-plaintext highlighter-rouge">make</code> 接收两个参数， 第一个是 <code class="language-plaintext highlighter-rouge">channel</code> 的类型，第二个是 <code class="language-plaintext highlighter-rouge">channel</code> 的缓冲区大小。 缓冲区大小默认为 <code class="language-plaintext highlighter-rouge">0</code>，表示无缓冲 <code class="language-plaintext highlighter-rouge">channel</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// 无缓冲 channel</span>
<span class="n">chBuf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c">// 有缓冲 channel，缓冲区大小为 5</span>
</code></pre></div></div> <p>在使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 的时候，发送方和接收方一定要放在两个不同的 <code class="language-plaintext highlighter-rouge">goroutine</code> 中， 这是因为如果放在同一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中，无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 在发送和接收时都会阻塞当前的 <code class="language-plaintext highlighter-rouge">goroutine</code>。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中使用 <code class="language-plaintext highlighter-rouge">channel</code> 的时候往往是由发送方来关闭， 这是因为接收主有安全的手段来检查 <code class="language-plaintext highlighter-rouge">channel</code> 是否已经关闭，而发送方并没有这样安全的手段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>     <span class="c">// 当 channel 关闭时，n 会被赋值为类型的零值</span>
<span class="n">m</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// ok 为 false 表示 channel 已经关闭</span>
<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="c">// 当 channel 关闭时，循环会自动结束</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的泛型不支持在类型里面内嵌泛型本身，也不支持在泛型方法中接着定义泛型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// T          // 错误，不能在泛型类型中内嵌泛型本身</span>
<span class="p">}</span>
<span class="c">// 错误，不能在泛型方法中接着定义泛型</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">MyMethod</span><span class="p">[</span><span class="n">U</span> <span class="n">any</span><span class="p">]()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的类型约束在有些情况下可以简写，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">a1</span><span class="p">[</span><span class="n">I</span> <span class="k">interface</span> <span class="p">{</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">}](</span><span class="n">param</span> <span class="n">I</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">func</span> <span class="n">a2</span><span class="p">[</span><span class="n">T</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span><span class="p">](</span><span class="n">param</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p>不过要注意的是，如果是单独的指针类型则需要加上 <code class="language-plaintext highlighter-rouge">,</code> 来进行简写：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">b1</span><span class="p">[</span><span class="n">I</span> <span class="k">interface</span> <span class="p">{</span> <span class="o">*</span><span class="kt">int</span>  <span class="p">}](</span><span class="n">param</span> <span class="n">I</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">func</span> <span class="n">b2</span><span class="p">[</span><span class="n">T</span> <span class="o">*</span><span class="kt">int</span><span class="p">,](</span><span class="n">param</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span> <span class="c">// 需要加上逗号</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">panic</code> 表示程序发生了不可恢复的错误，通常会导致程序崩溃。 任意一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中发生的 <code class="language-plaintext highlighter-rouge">panic</code> 都会导致整个程序崩溃。 可以使用 <code class="language-plaintext highlighter-rouge">recover</code> 函数来捕获 <code class="language-plaintext highlighter-rouge">panic</code>，从而防止程序崩溃。 而 <code class="language-plaintext highlighter-rouge">recover</code> 函数只能在 <code class="language-plaintext highlighter-rouge">defer</code> 函数中调用。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">safeFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Recovered from panic:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c">// 可能引发 panic 的代码</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的包导入时可以在结尾增加版本信息，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"github.com/user/project/v2"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的包符合 <code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code> 版本规范，官方规定只有当 <code class="language-plaintext highlighter-rouge">Major</code> 变化时才会出现兼容性的问题。 在不书写版本号时，默认导入的是 <code class="language-plaintext highlighter-rouge">v0</code> 或 <code class="language-plaintext highlighter-rouge">v1</code> 版本的包。可以使用 <code class="language-plaintext highlighter-rouge">go list -m -versions &lt;package_name&gt;</code> 来查看某个包的所有可用版本。</p> <p>如果想要移除一个依赖，需要使用 <code class="language-plaintext highlighter-rouge">go get &lt;package_name&gt;</code> 的形式在版本部分添加 <code class="language-plaintext highlighter-rouge">@none</code>， 例如 <code class="language-plaintext highlighter-rouge">go get github.com/go-redis/redis/v8@none</code> 会移除已经添加的 <code class="language-plaintext highlighter-rouge">go-redis v8</code> 依赖。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中命名的一些规范：</p> <ul> <li>循环和条件变量多采用单个字母命名。</li> <li>函数/方法的参数和返回值以单个单词或字母为主。</li> <li>方法的命名以单个单词为主。</li> <li>函数/类型多以多个单词的复合形式命名。</li> <li>变量中不携带类型信息。</li> <li>包名往往由单个单词进行命名，且尽量与导入路径的最后一个路径分段一致。</li> <li><code class="language-plaintext highlighter-rouge">Go</code> 中如果接口类型只有一个方法，则接口往往命名为该方法名加上 <code class="language-plaintext highlighter-rouge">-er</code> 后缀。 比如 <code class="language-plaintext highlighter-rouge">Read</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Reader</code>，<code class="language-plaintext highlighter-rouge">Write</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Writer</code>。</li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Go"/><summary type="html"><![CDATA[本文记录了我在学习 Go 语言过程中的一些笔记和心得。]]></summary></entry><entry><title type="html">客制化 Neovim</title><link href="https://kaiser-yang.github.io/blog/2025/vim-nvim-customization/" rel="alternate" type="text/html" title="客制化 Neovim"/><published>2025-10-31T08:37:42+00:00</published><updated>2025-10-31T08:37:42+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/vim-nvim-customization</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/vim-nvim-customization/"><![CDATA[<h2 id="前言">前言</h2> <p>一些符号介绍：</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;CR&gt;</code>：回车键；</li> <li><code class="language-plaintext highlighter-rouge">&lt;C-&gt;</code>：表示按住<code class="language-plaintext highlighter-rouge">Control</code>然后点按另一个键；</li> <li><code class="language-plaintext highlighter-rouge">ab</code>：表示在规定的时间内依次按下<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>；</li> <li><code class="language-plaintext highlighter-rouge">&lt;leader&gt;</code>：前置键（前缀键）默认是<code class="language-plaintext highlighter-rouge">,</code>，可以自定义；</li> </ul> <p><strong>注意</strong>：一般以尖括号包围的是指某类特殊按键，而不是需要你输入尖括号。</p> <p><strong>注意</strong>：尖括号中的 <code class="language-plaintext highlighter-rouge">modifier</code> 是不区分大小写的， 也就是说 <code class="language-plaintext highlighter-rouge">&lt;C-O&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;c-O&gt;</code> 都表示按住 <code class="language-plaintext highlighter-rouge">Control</code> 键再点按 <code class="language-plaintext highlighter-rouge">O</code> 键。 <code class="language-plaintext highlighter-rouge">modifier</code> 为 <code class="language-plaintext highlighter-rouge">alt</code> (<code class="language-plaintext highlighter-rouge">&lt;m-&gt;</code> 或者 <code class="language-plaintext highlighter-rouge">&lt;M-&gt;</code>) 时，后面的字符是有大小写之分的。 <code class="language-plaintext highlighter-rouge">&lt;m-p&gt;</code> 表示按住 <code class="language-plaintext highlighter-rouge">Alt</code> 键再点按小写的 <code class="language-plaintext highlighter-rouge">p</code> 键， 而 <code class="language-plaintext highlighter-rouge">&lt;m-P&gt;</code> 则表示按住 <code class="language-plaintext highlighter-rouge">Alt</code> 键再点按大写的 <code class="language-plaintext highlighter-rouge">P</code> 键， 在大小写未锁定的情况下这个可以理解成按住 <code class="language-plaintext highlighter-rouge">Alt</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键再点按 <code class="language-plaintext highlighter-rouge">p</code> 键。</p> <p><strong>注意</strong>：如果不知道想要绑定的按键对应的序列可以在插入模式下先按下 <code class="language-plaintext highlighter-rouge">Ctrl-V</code>， 然后再按下想要绑定的按键，这样就会在文本中插入对应的按键序列。</p> <h2 id="为什么使用-neovim">为什么使用 <code class="language-plaintext highlighter-rouge">Neovim</code></h2> <h3 id="我和-vim">我和 <code class="language-plaintext highlighter-rouge">vim</code></h3> <p>和 <code class="language-plaintext highlighter-rouge">vim</code> 的结缘要说到高中时期，我在高中时期第一次接触到 <code class="language-plaintext highlighter-rouge">vim</code> ，当时我只是觉得这个工具非常的麻烦， 竟然不能够通过鼠标进行操作（当然可以设置开启鼠标功能，但我当时并不知道这一点）， 于是在我高中的时候我对 <code class="language-plaintext highlighter-rouge">vim</code> 的认识只是停留在通过 <code class="language-plaintext highlighter-rouge">h,j,k,l</code> 进行导航， 修改文件需要先按一次 <code class="language-plaintext highlighter-rouge">i</code> 键，输入完成后如果要保存需要按下 <code class="language-plaintext highlighter-rouge">&lt;esc&gt;</code>， 然后输入 <code class="language-plaintext highlighter-rouge">:w&lt;cr&gt;</code> 而且还必须是英文的冒号， 这就导致如果你输入中文之后忘记按 <code class="language-plaintext highlighter-rouge">&lt;shift&gt;</code>（或者没有关闭输入法），那么你的命令将不被<code class="language-plaintext highlighter-rouge">vim</code>所识别。 当时使用最多的操作应该是 <code class="language-plaintext highlighter-rouge">:wq&lt;CR&gt;</code> 保存退出和 <code class="language-plaintext highlighter-rouge">:q!&lt;CR&gt;</code> 退出不保存了吧。</p> <p>我相信很多知道 <code class="language-plaintext highlighter-rouge">vim</code>， 但是没有真正开始学习 <code class="language-plaintext highlighter-rouge">vim</code> 的人和我高中时期是很相像的——知道几条 <code class="language-plaintext highlighter-rouge">vim</code> 的基本指令。</p> <h3 id="烦人的鼠标操作">烦人的鼠标操作</h3> <p>在我高中时觉得 <code class="language-plaintext highlighter-rouge">vim</code> 最难用的就是不能使用鼠标， 而现在我转战 <code class="language-plaintext highlighter-rouge">vim</code> 也是因为我要完成的很多操作都需要使用鼠标，严重影响了我的操作的连贯性。 举一个例子，如果我要在 <code class="language-plaintext highlighter-rouge">markdown</code> 文件中插入一段代码， 那么我需要连续按下三次强调符号（和波浪线在一起符号，也被叫做反引号），然后输入我的代码语言， 接着按下回车键，这个时候有的编辑器例如 <code class="language-plaintext highlighter-rouge">typora</code> 会自动生成一个代码块，可以在里面写代码， 写完后需要通过鼠标或者方向键将光标移到后面的位置，如果你没有在 <code class="language-plaintext highlighter-rouge">markdown</code> 文件后面插入一些空行的习惯， 可能你还需要进入源代码模式进行操作，而如果使用一些没有自动生成代码块的编辑器， 你还需要在输入完代码后继续键入三次强调符号。 上面的过程实在是非常的麻烦，主要是因为鼠标和方向键以及强调符键都与主键盘区（字母集中区）较远， 难以操作，且强调符号键不独立容易按错，比如按到 <code class="language-plaintext highlighter-rouge">1</code> 或者是 <code class="language-plaintext highlighter-rouge">&lt;tab&gt;</code>。</p> <p>正是因为上述的原因我认识到：如果只是单纯的顺序浏览文件，那么使用鼠标是最方便的，我不需要到处跳转， 就算我需要进行一些链接的跳转，我也可以通过鼠标侧键进行返回，而对于需要浏览加编辑的文件， 只使用鼠标是近乎不可能完成的，而使用鼠标和键盘的形式同样不是最优解， 而 <code class="language-plaintext highlighter-rouge">vim</code> 可以只使用键盘完成浏览和编写的操作，如果使用 <code class="language-plaintext highlighter-rouge">vim</code> 编写纯英文的文件是更为方便的。 而作为一个程序员，平常的大部分需要编写的文件应该是满足纯英文条件的 （当然你可能需要写中文注释，或者写一些笔记，但是使用 <code class="language-plaintext highlighter-rouge">vim</code> 进行操作并不会太慢）。</p> <h3 id="the-missing-semester">the missing semester</h3> <p><code class="language-plaintext highlighter-rouge">MIT</code> 的 <code class="language-plaintext highlighter-rouge">the missing semester</code> 让我真正认识到了好的工具的重要性，在三位顶级学府的教授的推荐下， 以及看了他们的实操演示后，我被 <code class="language-plaintext highlighter-rouge">vim</code> 所吸引——使用 <code class="language-plaintext highlighter-rouge">vim</code> 不是单纯地操作鼠标键盘， 而是在大脑里进行一个类似编程的过程。</p> <p>这个过程需要你进一步分解每一个操作，然后完全通过键盘完成相关的操作。</p> <p>比如我要跳到某个函数的开始，那么我就有很多种方法：</p> <ul> <li>通过鼠标滚轮找到这个函数，通过点击鼠标放置鼠标指针；</li> <li>通过搜索函数名字并跳转到函数（当然得能大概记住函数的名字才行）；</li> <li>如果在当前的屏幕内看见函数，那么可以直接通过输入行号进行跳转；</li> <li>如果你刚好在函数的尾部括号处，那么你可以通过<code class="language-plaintext highlighter-rouge">%</code>进行跳转；</li> <li>……</li> </ul> <p>使用鼠标的话，会面临我之前提到的问题，而使用<code class="language-plaintext highlighter-rouge">vim</code>可以轻松的通过后面几种方式实现。</p> <h3 id="值不值">值不值</h3> <p>在我学习了 <code class="language-plaintext highlighter-rouge">vim</code> 并用 <code class="language-plaintext highlighter-rouge">vim</code> 写下一篇 <code class="language-plaintext highlighter-rouge">blog</code> 的时候， 我已经感受到一周 <code class="language-plaintext highlighter-rouge">vim</code> 带给我的速度与我写了几年 <code class="language-plaintext highlighter-rouge">VSCode</code> 的速度相当了 （当然也是因为我比较懒，不会去记忆太多<code class="language-plaintext highlighter-rouge">VSCode</code>的快捷键）。</p> <p>而学会 <code class="language-plaintext highlighter-rouge">vim</code> 可能需要很短的时间，但是你可能需要一生的时间去掌握这一个工具 （这是在<code class="language-plaintext highlighter-rouge">the missing semester</code>里面看到的）。 根据我目前的体验看下来，我是相信 <code class="language-plaintext highlighter-rouge">vim</code> 给我带来的效率提升远远超过我花费的时间， 也就是投入产出比非常小。</p> <h3 id="从-vim-到-neovim">从 <code class="language-plaintext highlighter-rouge">vim</code> 到 <code class="language-plaintext highlighter-rouge">neovim</code></h3> <p>最开始我自己进行了 <code class="language-plaintext highlighter-rouge">vim</code> 的学习并尝试根据自己的需求进行了相关的配置， 这个期间我参考了很多网上成熟的配置。期间主要的模式是通过 <code class="language-plaintext highlighter-rouge">vim-plug</code> 进行插件的管理。 最开始使用的 <code class="language-plaintext highlighter-rouge">YouCompleteMe</code> 等一些比较老牌的插件进行的补全，再在后面换成了 <code class="language-plaintext highlighter-rouge">coc</code>。</p> <p>后面在我持续使用的过程中，我了解到了 <code class="language-plaintext highlighter-rouge">neovim</code> 这个项目，其拥有更加活跃的社区以及更加灵活的配置方式 （当时使用 <code class="language-plaintext highlighter-rouge">vim script</code> 进行配置的时候还是感觉不是很方便，而 <code class="language-plaintext highlighter-rouge">neovim</code> 支持 <code class="language-plaintext highlighter-rouge">lua</code> 进行配置）， 于是我决定转战 <code class="language-plaintext highlighter-rouge">neovim</code>，并且在 <code class="language-plaintext highlighter-rouge">neovim</code> 上重新进行配置。在使用 <code class="language-plaintext highlighter-rouge">neovim</code> 的时候我使用的是 <code class="language-plaintext highlighter-rouge">lazy.nvim</code> 进行插件管理，这个插件管理器支持惰性加载插件，可以大幅度提升 <code class="language-plaintext highlighter-rouge">neovim</code> 的启动速度， 但是我当时不太了解懒加载，没有为其他的插件考虑应该在什么时候进行加载。补全最开始使用的是 <code class="language-plaintext highlighter-rouge">cmp</code>， 后面 <code class="language-plaintext highlighter-rouge">blink.nvim</code> 出现后我就切换到了 <code class="language-plaintext highlighter-rouge">blink.nvim</code>，体验下来确实补全会比 <code class="language-plaintext highlighter-rouge">cmp</code> 快， 自己也给 <code class="language-plaintext highlighter-rouge">blink.nvim</code> 提交过一些 <code class="language-plaintext highlighter-rouge">issues</code> 并写了几个自己平时会用到的 <code class="language-plaintext highlighter-rouge">sources</code>。</p> <h2 id="学习资料">学习资料</h2> <p>主要依靠以下几种方式进行学习:</p> <ul> <li><code class="language-plaintext highlighter-rouge">vimtutor</code>：<code class="language-plaintext highlighter-rouge">vim</code> 自带的教程，适合初学者入门，也是我最开始使用的教程；</li> <li>网上的各种 <code class="language-plaintext highlighter-rouge">vim</code> 配置的介绍：这类视频网上有很多，可以学习到很多实用的配置技巧， 也可以找到很多好用的插件；</li> <li><code class="language-plaintext highlighter-rouge">:help</code>：<code class="language-plaintext highlighter-rouge">vim</code> 自带的帮助文档，内容非常全面，适合有一定基础的用户。 可以使用 <code class="language-plaintext highlighter-rouge">:help &lt;topic&gt;</code> 来查找相关的帮助文档；</li> <li><code class="language-plaintext highlighter-rouge">Vim</code> 实用技巧：这本书介绍了很多 <code class="language-plaintext highlighter-rouge">vim</code> 的实用技巧，适合有一定基础的用户； 看了这本书，你会发现你之前可能并不太会用 <code class="language-plaintext highlighter-rouge">vim</code>；</li> <li>使用过程中优化：在使用 <code class="language-plaintext highlighter-rouge">vim</code> 的过程中，你可能会发现你会频繁的用到一些操作， 或者一些操作在现有的配置下需要多次按键才可以实现，那么在这个时候你就是尝试进行优化， 网上对这类问题往往是有相关讨论的。</li> </ul> <h2 id="配置的迁移">配置的迁移</h2> <p>当你切换电脑的时候，或者需要在多台电脑是进行配置同步的时候，你可能需要将你的配置进行迁移。</p> <p>我个人的做法是将配置文件放在 <code class="language-plaintext highlighter-rouge">GitHub</code> 上。 并实现了一个简单的脚本帮助我安装一些依赖以及将配置文件进行软链接到对应的位置。</p> <p>可以参考：<a href="https://github.com/Kaiser-Yang/dotfiles/blob/main/dotfiles.sh">dotfiles.sh</a>。</p> <p><strong>NOTE</strong>：可以直接把上面的代码扔给 <code class="language-plaintext highlighter-rouge">AI</code> 让 <code class="language-plaintext highlighter-rouge">AI</code> 来解释上面代码的功能。</p> <h2 id="lightboat">LightBoat</h2> <p>网上其实有很多好用的 <code class="language-plaintext highlighter-rouge">neovim</code> 配置。我自己在配置过程中还是发现很多插件对于大文件并不是很友好， 所以我自己就发布了一个 <code class="language-plaintext highlighter-rouge">neovim</code> 配置，叫做 <a href="https://github.com/kaiser-Yang/LightBoat">LightBoat</a>。 <code class="language-plaintext highlighter-rouge">LightBoat</code> 是根据我自己的使用习惯进行配置的，可以进行自定义，并且对于大文件有比较好的支持。</p>]]></content><author><name></name></author><category term="Potpourri"/><category term="Vim/Neovim"/><summary type="html"><![CDATA[本文介绍自己如何客制化 Neovim 以提升编程效率。]]></summary></entry><entry><title type="html">鞋带公式</title><link href="https://kaiser-yang.github.io/blog/2025/shoelace-formula/" rel="alternate" type="text/html" title="鞋带公式"/><published>2025-10-30T08:51:37+00:00</published><updated>2025-10-30T08:51:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/shoelace-formula</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/shoelace-formula/"><![CDATA[<p>简单多边形：如果一个多边形的任意两条边都不相交，则称该多边形为简单多边形。</p> <p>鞋带公式是用来求一个简单多边形面积的公式。</p> <p>鞋带公式要求按照顺时针或逆时针的顺序给出多边形的顶点坐标。</p> <p>这里我们定义 \(x_i, y_i\) 分别表示一个简单 \(n\) 边形的第 \(i\) 个顶点的横坐标和纵坐标， 这里选择下标从 \(0\) 开始编号。特别地，我们定义 \(x_n = x_0\)，\(y_n = y_0\)。</p> <p>鞋带公式的表达式为：</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \right|\] <h2 id="原理">原理</h2> <p>鞋带公式实际是通过计算多个梯形的代数面积来求解多边形的面积。 具体地，我们可以将多边形划分为多个梯形， 每个梯形的顶点分别是多边形的两个相邻顶点和 x 轴上的两个投影点。 通过计算每个梯形的面积并累加起来，我们可以得到整个多边形的面积。</p> <p>而上述的过程可以写成如下的方程:</p> \[\text{Area} = \frac{1}{2} \sum_{i=0}^{n-1} (y_i + y_{i+1}) (x_{i+1} - x_i)\] <p>整理后就可以得到最开始给出的鞋带公式。</p> <h2 id="实现">实现</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="n">R</span> <span class="nf">polygon_area</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">R</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">R</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">area</span> <span class="o">-=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Shoelace Formula"/><summary type="html"><![CDATA[本文介绍鞋带公式的原理及其实现方式。]]></summary></entry><entry><title type="html">背包问题</title><link href="https://kaiser-yang.github.io/blog/2025/knapsack-problem/" rel="alternate" type="text/html" title="背包问题"/><published>2025-10-24T10:39:56+00:00</published><updated>2025-10-24T10:39:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/knapsack-problem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/knapsack-problem/"><![CDATA[<p>多重背包问题可以通过如下的转移方程来解决：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>其中，\(dp_{i,j}\) 表示前 \(i\) 种物品放入容量为 \(j\) 的背包所能获得的最大价值， \(w_i\) 和 \(v_i\) 分别表示第 \(i\) 种物品的重量和价值，\(c_i\) 表示第 \(i\) 种物品的数量。</p> <p>通过上面的方法进行转移时，时间复杂度为 \(O(N \cdot M \cdot C)\)， 其中 \(N\) 是物品种类数，\(M\) 是背包容量，\(C\) 是物品数量的最大值。 当 \(C\) 较大时，时间复杂度会变得非常高，这里介绍两种优化方法来降低时间复杂度。</p> <h2 id="二进制优化">二进制优化</h2> <p>对于第 \(i\) 件物品我们将其拆分成 \(1, 2, 4, \ldots, 2^k\) 件，使得 \(1 + 2 + 4 + \ldots + 2^k \leq c_i\)， 再加上剩余的 \(x := c_i - (1 + 2 + 4 + \ldots + 2^k)\) 件，其中的 \(k\) 满足 \(2^{k+1} &gt; c_i\)。</p> <p>经过上述的拆分后，我们可以将多重背包问题转化为 0-1 背包问题，从而将时间复杂度降低到 \(O(N \cdot M \cdot \log C)\)。</p> <p>转换的依据是 \(1, 2, 4, \ldots, 2^k\) 件物品可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1\) 件物品， 而加上剩余的 \(x\) 件物品后，可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1 + x = c_i\) 件物品。</p> <p>综上所述，这里使用 0-1 背包的方式进行转移依然可以覆盖所有的情况。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="单调栈优化">单调栈优化</h2> <p>我们回到最开始的转移方程：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>在上面的方程中我们可以发现 \(dp_{i, j}\) 只依赖于 \(dp_{i-1, j-k \cdot w_i}\)， 因此我们可以以 \(w_i\) 为步长将 \(j\) 分成若干组， 即 \(j \equiv r \text{mod} w_i\)，其中 \(0 \leq r &lt; w_i\)。</p> <p>对于每一组，我们可以将其转移方程改写为：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} + (k - k') \cdot v_i) \quad (0 \leq k - k' \leq c_i)\] <p>整理一下可以得到：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i) + k \cdot v_i \quad (0 \leq k - k' \leq c_i)\] <p>不难发现上面的 \(\max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i)\) 可以通过单调队列来进行优化， 从而将时间复杂度降低到 \(O(N \cdot M)\)。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ndp</span><span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            <span class="n">ndp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ndp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Knapsack Problem"/><summary type="html"><![CDATA[本文介绍多重背包问题的两种优化方法。]]></summary></entry><entry><title type="html">中国剩余定理及其扩展</title><link href="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/" rel="alternate" type="text/html" title="中国剩余定理及其扩展"/><published>2025-10-16T07:22:05+00:00</published><updated>2025-10-16T07:22:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/"><![CDATA[<h2 id="中国剩余定理">中国剩余定理</h2> <p>假如给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>其中 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>我们令 \(M = m_1 \cdot m_2 \cdots m_k\)，并且对于每个 \(i\)，定义 \(M_i = \frac{M}{m_i}\)。 由于 \(m_i\) 和 \(M_i\) 互质，可以知道 \(M_i\) 在模 \(m_i\) 意义下是有逆元的， 记为 \(M_i^{-1}\)。不难发现 \(M_i \cdot M_i^{-1} \equiv 1 \text{mod} m_i\) 和 \(M_i \cdot M_i^{-1} \equiv 0 \text{mod} m_j\)（\(j \neq i\)）都成立。 记 \(c_i = a_i \cdot M_i \cdot M_i^{-1}\)，则有：</p> \[\begin{cases} c_i \equiv a_i \text{mod} m_i \\ n_i \equiv 0 \text{mod} m_j \quad (j \neq i) \end{cases}\] <p>由同余的线性性质可知，\(x' = \sum_{i=1}^{k} c_i\) 即为一个特解。</p> <p>不难证明通解可以写成 \(x = x' + t \cdot M \quad (t \in \mathbb{Z})\)。</p> <p>注意在上述的过程中，我们要求解 \(M_i\) 在模 \(m_i\) 意义下的逆元， 只有在 \(m_i\) 两两互质的情况下才能保证每次求解的逆元存在。</p> <p>代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">l</span> <span class="o">*=</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span> <span class="o">*</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="扩展中国剩余定理">扩展中国剩余定理</h2> <p>扩展中国剩余定理是在中国剩余定理的基础上，放宽了对模数的互质要求。 假设给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>并不保证 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>不难发现，\(x = x' + t \cdot M \quad (t \in \mathbb{Z})\) 是同余方程 \(x \equiv x' \text{mod}{M}\) 的解。</p> <p>假设我们已经求出了前 \(i-1\) 个方程的解：</p> \[x = x_{i-1} + t \cdot M_{i-1} \quad (t \in \mathbb{Z}),\] <p>现在考虑如何求其与</p> \[x \equiv a_i \text{mod}{m_i}\] <p>的公共解。</p> <p>将当前的解代入上述方程，得到：</p> \[x_{i-1} + t \cdot M_{i-1} \equiv a_i \text{mod}{m_i},\] <p>即</p> \[t \cdot M_{i-1} \equiv a_i - x_{i-1} \text{mod}{m_i}.\] <p>设 \(d = \gcd(M_{i-1}, m_i)\)，则上式有解的<strong>充要条件</strong>是\(d \mid (a_i - x_{i-1})\)。</p> <p>如果有解，将上式两边同时除以 \(d\)，得到：</p> \[t \cdot \frac{M_{i-1}}{d} \equiv \frac{a_i - x_{i-1}}{d} \text{mod}{\frac{m_i}{d}}.\] <p>由于\(\frac{M_{i-1}}{d}\)和\(\frac{m_i}{d}\)互质， 可以用扩展欧几里得算法求该方程的一个特解 \(t_0\)，则通解可以表示为：</p> \[t = t_0 + k \cdot \frac{m_i}{d} \quad (k \in \mathbb{Z}).\] <p>将通解代入\(x = x_{i-1} + t \cdot M_{i-1}\)中，可以得到：</p> \[x = x_{i-1} + t_0 \cdot M_{i-1} + k \cdot \frac{m_i}{d} \cdot M_{i-1} \quad (k \in \mathbb{Z}).\] <p>因此，新的解可以表示为：</p> \[x = x_i + k \cdot M_i \quad (k \in \mathbb{Z}),\] <p>其中</p> \[\begin{cases} x_i = x_{i-1} + t_0 \cdot M_{i-1} \\ M_i = \frac{m_i}{d} \cdot M_{i-1} \end{cases}\] <p>特别地，我们可以增加一个方程 \(x \equiv 0 \text{mod} 1\) 作为初始条件， 此时 \(x_0 = 0\)，\(M_0 = 1\)。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ex_crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ex_gcd</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">%=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Chinese Remainder Theorem"/><summary type="html"><![CDATA[本文介绍中国剩余定理以及扩展中国剩余定理。]]></summary></entry><entry><title type="html">模逆元</title><link href="https://kaiser-yang.github.io/blog/2025/mod-inverse/" rel="alternate" type="text/html" title="模逆元"/><published>2025-10-15T13:34:31+00:00</published><updated>2025-10-15T13:34:31+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/mod-inverse</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/mod-inverse/"><![CDATA[<p>模逆元的定义如下：</p> <p>给定一个正整数 \(a\) 和一个正模数 \(p\) ，如果存在一个正整数 \(b\) 满足：</p> \[a \cdot b \equiv 1 \ (\text{mod} \ p), 1 \leq b \le p\] <p>则称 \(b\) 为 \(a\) 关于模数 \(p\) 的模逆元，记作 \(a^{-1} \ (\text{mod} \ p)\) 。</p> <h2 id="计算方法">计算方法</h2> <h3 id="单个数的模逆元">单个数的模逆元</h3> <p>对于模逆元的计算，其本质是在求解 \(ax + py = 1\) 这个不定方程的正整数解 \(x\)。</p> <p>由裴蜀定理可知，只有当 \(\gcd(a, p) = 1\) 时，方程才有整数解。</p> <p>所以我们可以使用扩展欧几里得算法来计算模逆元。</p> <p>这里给出计算代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">inverse_of</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ex_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>特别地，当 \(p\) 是质数时，由费马小定理可知：</p> \[a^{p-1} \equiv 1 \ (\text{mod} \ p)\] <p>因此，\(a^{p-2} \ (\text{mod} \ p)\) 即为 \(a\) 关于模数 \(p\) 的模逆元。</p> <h3 id="多个数的模逆元">多个数的模逆元</h3> <p>逆元存在一个重要的性质：对于 \(a\) 和 \(b\)，有</p> \[(a \cdot b)^{-1} \equiv a^{-1} \cdot b^{-1} (\text{mod} \ p)\] <p>有了这个性质，我们可以通过预处理前缀积来计算多个数的模逆元。</p> <p>具体地，我们用 \(prod_i\) 表示 \([1, i)\) 的前缀积取模后的结果，即：</p> \[prod_i = a_{i-1} \cdot prod_{i-1} \ (\text{mod} \ p)\] <p>那么就有 \(a^{-1}_i \equiv prod^{-1}_{i+1} \cdot prod_i \ (\text{mod} \ p)\)。</p> <p>我们只需要计算出 \(prod_n\) 的模逆元，然后从后往前依次计算出每个数的模逆元即可。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of each element in a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">prod</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">mod</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">inv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Modular Inverse"/><summary type="html"><![CDATA[本文介绍模逆元的定义及其计算方法。]]></summary></entry><entry><title type="html">扩展欧几里德算法</title><link href="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/" rel="alternate" type="text/html" title="扩展欧几里德算法"/><published>2025-10-14T10:42:49+00:00</published><updated>2025-10-14T10:42:49+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/"><![CDATA[<h2 id="前置知识">前置知识</h2> <p>裴蜀定理（Bézout’s Identity）： 对于任意两个整数 \(a\) 和 \(b\)，存在整数 \(x\) 和 \(y\) 使得 \(ax + by = \gcd(a, b)\) 成立。</p> <p>欧几里德算法：对于两个非负整数 \(a\) 和 \(b\)，其最大公约数可以通过以下递归关系计算：</p> \[gcd(a, b) = gcd(b, a \text{mod} b)\] <h2 id="线性丢番图方程">线性丢番图方程</h2> <p>线性丢番图方程是形如 \(ax + by = c\) 的不定方程， 其中 \(a\)、\(b\) 和 \(c\) 是已知整数，\(x\) 和 \(y\) 是未知整数。</p> <p>根据裴蜀定理，线性丢番图方程有整数解的充分必要条件是 \(\gcd(a, b)\) 整除 \(c\)。</p> <h2 id="扩展欧几里德算法">扩展欧几里德算法</h2> <p>扩展欧几里德算法是用来求解 \(ax + by = \gcd(a, b)\) 的一组特解。</p> <p>算法的基本思想是利用欧几里德算法的递归结构，同时在每一步记录下 \(x\) 和 \(y\) 的变化。</p> <p>考虑当我们已经知道 \(gcd(b, a \text{mod} b) = bx_1 + (a \text{mod} b)y_1\) 的解时， 如何求出 \(gcd(a, b) = ax + by\) 的解。</p> <p>我们记 \(a \text{mod} b = a - \lfloor \frac{a}{b} \rfloor \cdot b\)， 则有：</p> \[gcd(b, a \text{mod} b) = bx_1 + (a - \lfloor \frac{a}{b} \rfloor \cdot b)y_1\] <p>注意到 \(gcd(b, a \text{mod} b) = gcd(a, b)\)，我们可以将上式改写为：</p> \[gcd(a, b) = ay_1 + b(x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1) = ax + by\] <p>从而得到：</p> \[\left\{ \begin{array}{l} x = y_1 \\ y = x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1 \end{array} \right.\] <p>而不难发现当 \(b = 0\) 时，\(gcd(a, 0) = a\)，此时方程的解为 \((1, 0)\)。</p> <p>这样我们就可以通过递归的方式来求解 \(ax + by = \gcd(a, b)\)。</p> <p>对于 \(ax + by = c\) 的情况，我们只需要先求出 \(ax_0 + by_0 = \gcd(a, b)\) 的一组解， 此时 \(x = x_0 \cdot \frac{c}{\gcd(a, b)}\)，\(y = y_0 \cdot \frac{c}{\gcd(a, b)}\) 即为 \(ax + by = c\) 的一组特解。</p> <p>接下来我们考虑在知道一组解的情况下，如何求出通解。这里先给出结论：</p> <p>若 \((x_0, y_0)\) 是 \(ax + by = c\) 的一组解，则通解可以表示为：</p> \[\left\{ \begin{array}{l} x = x_0 + k \cdot \frac{b}{\gcd(a, b)} \\ y = y_0 - k \cdot \frac{a}{\gcd(a, b)} \end{array} \right.\] <p>容易证明上述形式的解都满足方程。我们接下来证明所有解都可以表示为上述形式。</p> <p>设 \((x_1, y_1)\) 也是方程的解，则有 \(a(x_1 - x_0) + b(y_1 - y_0) = 0\) 成立。</p> <p>由此可得</p> \[a(x_1 - x_0) = -b(y_1 - y_0)\] <p>两边同时除以 \(\gcd(a, b)\)，有</p> \[\frac{a}{\gcd(a, b)}(x_1 - x_0) = -\frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>可以知道</p> \[\frac{a}{\gcd(a, b)} \mid \frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>因为 \(\frac{a}{\gcd(a, b)}\) 和 \(\frac{b}{\gcd(a, b)}\) 互质，所以</p> \[\frac{a}{\gcd(a, b)} \mid y_1 - y_0\] <p>即存在整数 \(k\) 使得：</p> \[y_1 - y_0 = k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[y_1 = y_0 + k \cdot \frac{a}{\gcd(a, b)}\] <p>代入前面的等式，有：</p> \[a(x_1 - x_0) = -b \cdot k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[x_1 = x_0 - k \cdot \frac{b}{\gcd(a, b)}\] <p>综上所述，所有解可以表示为上述通解的形式。</p> <p>最后给出扩展欧几里德算法的代码实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the greatest common divisor of a and b,</span>
<span class="c1">// and find x and y such that ax + by = gcd(a, b)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">ex_gcd</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ex_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Extended Euclidean Algorithm"/><category term="gcd"/><summary type="html"><![CDATA[本文介绍扩展欧几里德算法的原理及应用。]]></summary></entry><entry><title type="html">Miller Rabin 素数测试</title><link href="https://kaiser-yang.github.io/blog/2025/miller-rabin/" rel="alternate" type="text/html" title="Miller Rabin 素数测试"/><published>2025-10-13T13:11:22+00:00</published><updated>2025-10-13T13:11:22+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/miller-rabin</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/miller-rabin/"><![CDATA[<h2 id="前置知识">前置知识</h2> <h3 id="费马小定理fermats-little-theorem">费马小定理（Fermat’s Little Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(a\) 不是 \(p\) 的倍数， 则 \(a^{p-1} \equiv 1 \text{mod} p\)。</p> <h3 id="二次探测定理quadratic-residue-theorem">二次探测定理（Quadratic Residue Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(x^2 \equiv 1 \text{mod} p\)， 则 \(x \equiv 1 \text{mod} p\) 或 \(x \equiv n - 1 \text{mod} p\)。</p> <h2 id="miller-rabin-素数测试原理">Miller Rabin 素数测试原理</h2> <p>我们可以发现，费马小定理和二次探测定理都给出了素数的必要条件， 但并不是充分条件。也就是说，如果一个数不满足这些条件， 那么它一定不是素数。</p> <p>Miller Rabin 素数测试是一种基于概率的素数测试算法， 它通过多次随机选择基数 \(a\) 来验证一个数是否为素数。</p> <p>对于一个奇数 \(n\) 而言其可以被写成 \(n - 1 = 2^s \cdot d\) 的形式， 其中 \(d\) 是奇数，\(s \geq 1\)。 根据费马小定理，如果 \(n\) 是素数， 则对于任意不是 \(p\) 倍数的 \(a\)，都有 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\)。 而由二次探测定理可知，我们可以对 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\) 执行开方的操作，其结果一定要是 \(1\) 或 \(n - 1\)。 同时当其结果为 \(1\) 时，则可以继续尝试开方操作，直到结果为 \(n - 1\) 或无法继续开方为止。 如果在某次开方的过程中，结果既不是 \(1\) 也不是 \(n - 1\)， 则 \(n\) 一定不是素数。</p> <p>根据上面的流程我们可以选择多个不同的 \(a\) 来进行测试， 如果所有的测试都通过了，则 \(n\) 很可能是素数。</p> <p>特别地，对于 64 位无符号整数，选择 \(2, 325, 9375, 28178, 450775, 9780504, 1795265022\) 可以保证不会出现误判。</p> <p>另外在实现的过程中，我们往往不会进行开方的操作，取而代之的是平方操作：</p> <ol> <li>将待测试的数 \(n\) 表示为 \(n - 1 = 2^s \cdot d\)，其中 \(d\) 是奇数，\(s \geq 1\)。</li> <li>选择一个基数 \(a\)。</li> <li>计算 \(x = a^d \text{mod} n\)。</li> <li>如果 \(x \equiv 1 \text{mod} n\) 或 \(x \equiv n - 1 \text{mod} n\)，此时进行平方的结果一定是 \(1\)， 所以可以直接认为通过本轮的测试。</li> <li>否则，重复以下步骤 \(s - 1\) 次： <ul> <li>计算 \(x \leftarrow x^2 \text{mod} n\)。</li> <li>如果 \(x \equiv n - 1 \text{mod} n\)，则通过本轮测试。</li> <li>如果在 \(s - 1\) 次操作中都没有出现 \(x \equiv n - 1 \text{mod} n\)，则本轮测试未通过。</li> </ul> </li> </ol> <p>在上述过程的5中，我们只检查了结果是否等于 \(n - 1\)，而没有检查结果是否等于 \(1\)。 这是因为如果当前的结果第一次等于 \(1\)，则说明在前一次平方操作中， 结果既不是 \(1\) 也不是 \(n - 1\)，这就违背了二次探测定理。</p> <p>最后给出Miller Rabin素数测试的代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">a</span> <span class="o">:</span> <span class="n">miller_rabin_test</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// calculate a^d % n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Miller Rabin"/><category term="Primality Test"/><summary type="html"><![CDATA[本文介绍 Miller Rabin 素数测试的原理及其实现方式。]]></summary></entry><entry><title type="html">Cradle to Grave Devotion: Objective C Notes</title><link href="https://kaiser-yang.github.io/blog/2025/oc-notes/" rel="alternate" type="text/html" title="Cradle to Grave Devotion: Objective C Notes"/><published>2025-06-18T11:57:02+00:00</published><updated>2025-06-18T11:57:02+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/oc-notes</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/oc-notes/"><![CDATA[<h2 id="property"><code class="language-plaintext highlighter-rouge">@property</code></h2> <p>In Objective C, <code class="language-plaintext highlighter-rouge">@property</code> is used to declare properties in a class. It is a way to define instance variables (ivars) and their associated getter and setter methods. You can use <code class="language-plaintext highlighter-rouge">@property</code> to declare properties in the interface section of a class.</p> <p>Here is an example of how to declare a property:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">Person</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">age</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div> <p>You can also specify attributes for the property.</p> <p>Here are some common attributes for memory management. Note that you can only use one of these attributes at a time:</p> <ul> <li><code class="language-plaintext highlighter-rouge">strong</code> (default): This means that the property retains a strong reference to the object.</li> <li><code class="language-plaintext highlighter-rouge">weak</code>: This means that the property does not retain the object and allows it to be deallocated if there are no strong references to it.</li> <li><code class="language-plaintext highlighter-rouge">assign</code>: This means that the property does not retain the object and simply assigns it. This one is usually used for primitive types like <code class="language-plaintext highlighter-rouge">NSInteger</code>, <code class="language-plaintext highlighter-rouge">CGFloat</code>, etc.</li> <li><code class="language-plaintext highlighter-rouge">copy</code>: This means that the property creates a copy of the object when it is assigned.</li> <li><code class="language-plaintext highlighter-rouge">retain</code>: This is similar to <code class="language-plaintext highlighter-rouge">strong</code>, but it is used in manual reference counting (MRC) instead of automatic reference counting (ARC). Deprecated in ARC.</li> </ul> <p>Here are some common attributes for thread safety and access control. Note that you can only use one of these attributes at a time:</p> <ul> <li><code class="language-plaintext highlighter-rouge">atomic</code> (default): This means that the property is thread-safe and uses atomic access.</li> <li><code class="language-plaintext highlighter-rouge">nonatomic</code>: This means that the property is not thread-safe and does not use atomic access.</li> </ul> <p>Here are some common attributes for access control. Note that you can only use one of these attributes at a time:</p> <ul> <li><code class="language-plaintext highlighter-rouge">readwrite</code> (default): This means that the property can be both read and written to.</li> <li><code class="language-plaintext highlighter-rouge">readonly</code>: This means that the property can only be read and not written to.</li> </ul> <p>Other attributes you can use with <code class="language-plaintext highlighter-rouge">@property</code> include:</p> <ul> <li><code class="language-plaintext highlighter-rouge">getter=</code>: This allows you to specify a custom getter method name.</li> <li><code class="language-plaintext highlighter-rouge">setter=</code>: This allows you to specify a custom setter method name.</li> </ul> <p>These below are some attributes that just used for documentation and do not affect the behavior of the property unless you implement the methods yourself:</p> <ul> <li><code class="language-plaintext highlighter-rouge">nullable</code>: This indicates that the property can be <code class="language-plaintext highlighter-rouge">nil</code>.</li> <li><code class="language-plaintext highlighter-rouge">nonnull</code>: This indicates that the property cannot be <code class="language-plaintext highlighter-rouge">nil</code>.</li> <li><code class="language-plaintext highlighter-rouge">null_resettable</code>: This indicates that the property can be <code class="language-plaintext highlighter-rouge">nil</code> and will be reset to a default value when it is set to <code class="language-plaintext highlighter-rouge">nil</code>.</li> </ul> <p>For <code class="language-plaintext highlighter-rouge">@property</code>, you can access the property using dot notation and when you access the property with dot notation, the compiler will automatically call the getter or setter method for you.</p> <h2 id="categories-of-objective-c">Categories of Objective C</h2> <p>There is a very interesting syntax in Objective C: the category.</p> <p>A category is a way to add methods to an existing class without modifying the original class.</p> <p>To use a category, you first need to define it in a header file (<code class="language-plaintext highlighter-rouge">.h</code> file) and then implement it in an implementation file (<code class="language-plaintext highlighter-rouge">.m</code> file or <code class="language-plaintext highlighter-rouge">.mm</code> file).</p> <p>Here is an example of a category that extends the <code class="language-plaintext highlighter-rouge">NSString</code> class to add a method that reverses a string:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// NSString+Reverse.h</span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="k">@interface</span> <span class="nc">NSString</span> <span class="p">(</span><span class="nl">Reverse</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">reversedString</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// NSString+Reverse.m</span>
<span class="cp">#import "NSString+Reverse.h"
</span><span class="k">@implementation</span> <span class="nc">NSString</span> <span class="p">(</span><span class="nl">Reverse</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">reversedString</span> <span class="p">{</span>
    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">reversed</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nf">stringWithCapacity</span><span class="p">:[</span><span class="n">self</span> <span class="nf">length</span><span class="p">]];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">length</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">reversed</span> <span class="nf">appendFormat</span><span class="p">:</span><span class="s">@"%C"</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="nf">characterAtIndex</span><span class="p">:</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">reversed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>We usually name the files with the format <code class="language-plaintext highlighter-rouge">ClassName+CategoryName.h</code> and <code class="language-plaintext highlighter-rouge">ClassName+CategoryName.m</code>. With these files, now you can use the <code class="language-plaintext highlighter-rouge">reversedString</code> method on any <code class="language-plaintext highlighter-rouge">NSString</code> object:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// import the category header file</span>
<span class="cp">#import "NSString+Reverse.h"
</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">original</span> <span class="o">=</span> <span class="s">@"Hello, World!"</span><span class="p">;</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">reversed</span> <span class="o">=</span> <span class="p">[</span><span class="n">original</span> <span class="nf">reversedString</span><span class="p">];</span>
</code></pre></div></div> <p>Of course, you can also add class methods (<code class="language-plaintext highlighter-rouge">+</code> methods) to a category. But note that you cannot add new properties to a category, and you cannot access the ivars (instance variables) of the original class directly.</p> <p>You can define multiple categories for the same class, but be careful to avoid method name conflicts.</p> <p>You can also use the methods defined in a category in another category, and you just need to import the category header file in the implementation file of the other category.</p> <h2 id="class-extensions">Class Extensions</h2> <p>Class extensions are also called anonymous categories.</p> <p>Unlike normal categories, class extensions are defined and implemented in implementation files, and usually used to add private methods or properties to a class.</p> <p>Here is an example of a class extension:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Person.mm</span>
<span class="cp">#import "Person.h"
#import &lt;Foundation/Foundation.h&gt;
</span><span class="k">@interface</span> <span class="nc">Person</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">privateProperty</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">privateMethod</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">privateMethod</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"This is a private method."</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">privateProperty</code> and <code class="language-plaintext highlighter-rouge">privateMethod</code> are only accessible within the <code class="language-plaintext highlighter-rouge">Person</code> class.</p> <p>Actually, you can still access the private methods from outside the class using <code class="language-plaintext highlighter-rouge">performSelector</code>. For example:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
<span class="p">[</span><span class="n">person</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">privateMethod</span><span class="p">)];</span>
<span class="c1">// With parameters, but only support at most two parameters</span>
<span class="p">[</span><span class="n">person</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">privateMethod</span><span class="p">:</span><span class="n">withArg</span><span class="o">:</span><span class="p">)</span> <span class="n">withObject</span><span class="o">:</span><span class="s">@"arg1"</span> <span class="n">withObject</span><span class="o">:</span><span class="s">@"arg2"</span><span class="p">];</span>
</code></pre></div></div> <h2 id="protocols">Protocols</h2> <p>Protocols in Objective C are similar to interfaces in other languages. They define a set of methods that a class can implement.</p> <p>You can use <code class="language-plaintext highlighter-rouge">@protocol</code> to define a protocol, and then use <code class="language-plaintext highlighter-rouge">@optional</code> or <code class="language-plaintext highlighter-rouge">@required</code> to specify whether the methods are optional or required. The default is <code class="language-plaintext highlighter-rouge">@required</code>. And when you use <code class="language-plaintext highlighter-rouge">@optional</code> or <code class="language-plaintext highlighter-rouge">@required</code>, all the methods following it will be optional or required until the end of the protocol or the next <code class="language-plaintext highlighter-rouge">@optional</code> or <code class="language-plaintext highlighter-rouge">@required</code>.</p> <p>Here is an example of a protocol:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@protocol</span> <span class="nc">MyProtocol</span>
<span class="err">@required</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">requiredMethod</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">anotherRequiredMethod</span><span class="p">;</span>
<span class="k">@optional</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">optionalMethod</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">anotherOptionalMethod</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div> <p>To declare a class that conforms to a protocol, you can use the <code class="language-plaintext highlighter-rouge">&lt;ProtocolName&gt;</code> syntax in the class declaration. If the class implements more than one protocol, you can separate them with commas.</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">MyClass</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">MyProtocol</span><span class="p">,</span> <span class="n">AnotherProtocol</span><span class="o">&gt;</span>
<span class="k">@end</span>
</code></pre></div></div> <p>When a class conforms to a protocol, it must implement all the required methods of the protocol. If it does not implement all the required methods, the compiler will generate a warning or error.</p> <p>And you can specify that a property conforms to protocols, like this:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">MyClass</span>
<span class="c1">// We use 'id' for properties that conform to protocols</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">id</span><span class="o">&lt;</span><span class="n">MyProtocol</span><span class="o">&gt;</span> <span class="n">myProperty</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div> <p>For optional methods, you may want to check if the object responds to the method before calling it, using <code class="language-plaintext highlighter-rouge">respondsToSelector:</code>:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">([</span><span class="n">myObject</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">optionalMethod</span><span class="p">)])</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">myObject</span> <span class="nf">optionalMethod</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is possible to declare a protocol conforming to another protocol, like this:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@protocol</span> <span class="nc">MyProtocol</span> <span class="o">&lt;</span><span class="n">AnotherProtocol</span><span class="o">&gt;</span>
<span class="c1">// We just declare that 'MyProtocol' conforms to 'AnotherProtocol'</span>
<span class="c1">// and we don't need to implement any methods here.</span>
<span class="k">@end</span>
</code></pre></div></div> <p>When you declare a class that conforms to a protocol, you must implement all the required methods of the protocol. For example:</p> <div class="language-objective-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In the .h file</span>
<span class="k">@interface</span> <span class="nc">MyClass</span> <span class="o">&lt;</span><span class="n">MyProtocol</span><span class="o">&gt;</span>
<span class="k">@end</span>

<span class="c1">// In the .m file</span>
<span class="k">@implementation</span> <span class="nc">MyClass</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">requiredMethod</span> <span class="p">{</span>
    <span class="c1">// Implementation of the required method</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Potpourri"/><category term="Objective C"/><summary type="html"><![CDATA[This post includes some notes on Objective C.]]></summary></entry></feed>