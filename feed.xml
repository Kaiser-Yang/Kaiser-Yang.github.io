<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2024-09-15T13:01:29+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>This homepage is for sharing everything I know. </subtitle><entry><title type="html">Linux 大杂烩</title><link href="https://kaiser-yang.github.io/blog/2024/linux-potpourri/" rel="alternate" type="text/html" title="Linux 大杂烩"/><published>2024-09-10T12:30:06+00:00</published><updated>2024-09-10T12:30:06+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/linux-potpourri</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/linux-potpourri/"><![CDATA[<h1 id="wildcards-in-linux">Wildcards in Linux</h1> <p>这里的 <code class="language-plaintext highlighter-rouge">wildcards</code> 指的是能够被 <code class="language-plaintext highlighter-rouge">shell</code> 扩展的符号。如果在执行的命令中出现这些符号，<code class="language-plaintext highlighter-rouge">shell</code> 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 <code class="language-plaintext highlighter-rouge">shell</code> 支持，这些 <code class="language-plaintext highlighter-rouge">wildcards</code> 是可以在任意 命令中使用的。</p> <p>常见的 <code class="language-plaintext highlighter-rouge">wildcards</code> 有以下几种：</p> <ul> <li><code class="language-plaintext highlighter-rouge">*</code>：匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">**</code>：递归匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">?</code>：匹配单个任意字符</li> <li><code class="language-plaintext highlighter-rouge">[]</code>：匹配出现在中括号中的某个符号，在中括号中可以使用 <code class="language-plaintext highlighter-rouge">-</code> 来表示范围，也可以使用 <code class="language-plaintext highlighter-rouge">!</code> 来表示取反， 例如 <code class="language-plaintext highlighter-rouge">[!0-9]</code> 表示匹配不是数字的字符，<code class="language-plaintext highlighter-rouge">[!ab]</code> 表示不是 <code class="language-plaintext highlighter-rouge">a</code> 也不是 <code class="language-plaintext highlighter-rouge">b</code> 的字符</li> </ul> <p>上面的通配符并不是所有的 <code class="language-plaintext highlighter-rouge">shell</code> 都支持的，但是在 <code class="language-plaintext highlighter-rouge">bash</code> 中是支持的。例如在 <code class="language-plaintext highlighter-rouge">fish shell</code> 中，只有 <code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">**</code> 以及 <code class="language-plaintext highlighter-rouge">?</code> 是支持的，其中 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 不会匹配 <code class="language-plaintext highlighter-rouge">/</code>，而 <code class="language-plaintext highlighter-rouge">**</code> 会匹配 <code class="language-plaintext highlighter-rouge">/</code> ，也就是说 <code class="language-plaintext highlighter-rouge">**</code> 是 递归匹配。</p> <p><strong>注意</strong>：在正则表达式的语法中，<code class="language-plaintext highlighter-rouge">*</code> 表示匹配前面的字符 0 次或者多次，<code class="language-plaintext highlighter-rouge">?</code> 表示匹配前面的字符 0 次或者 1 次， <code class="language-plaintext highlighter-rouge">[]</code> 表示匹配中括号中的任意一个字符，<code class="language-plaintext highlighter-rouge">-</code> 表示范围，<code class="language-plaintext highlighter-rouge">^</code> 表示取反。</p> <h1 id="常用命令-cheat-sheet">常用命令 <code class="language-plaintext highlighter-rouge">Cheat Sheet</code></h1> <h2 id="cat"><code class="language-plaintext highlighter-rouge">cat</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>显示非空行的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>合并多个空行为一个空行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">^</code> 和 <code class="language-plaintext highlighter-rouge">M-</code> 显示不可打印字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>在每行的结尾显示 <code class="language-plaintext highlighter-rouge">$</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-T</code></td> <td>将制表符显示为 <code class="language-plaintext highlighter-rouge">^I</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-</code></td> <td>从标准输入读取内容</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">cat</code> 可以直接创建带有内容的文件或者追加内容到文件中，例如 <code class="language-plaintext highlighter-rouge">cat &gt; file</code> 会等待输入，当输入完成 后，使用 <code class="language-plaintext highlighter-rouge">^D</code> (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 <code class="language-plaintext highlighter-rouge">cat &gt;&gt; file</code>。</p> <p><code class="language-plaintext highlighter-rouge">-</code> 可以出现在多个文件的任意位置，例如 <code class="language-plaintext highlighter-rouge">cat file1 - file2</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，而 <code class="language-plaintext highlighter-rouge">cat file1 - file2 - file3</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，<code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，然后输入第二次，再次使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，第一次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容 之间，第二次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间。</p> <p>补充：<code class="language-plaintext highlighter-rouge">tac</code> 可以将文件内容逆序输出 (优先输出最后一行)，<code class="language-plaintext highlighter-rouge">tac</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">cat</code> 的逆序。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">cat</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">concatenate</code>，即连接的意思，其可以将多个文件的内容拼接在一起。</p> <h2 id="grep"><code class="language-plaintext highlighter-rouge">grep</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归搜索目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--include "*.py"</code></td> <td>搜索指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude "test*"</code></td> <td>排除指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude-dir "test*"</code></td> <td>排除指定目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--color=auto,always,never</code></td> <td>何时进行高亮</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号。这里的行号指的是文件中的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>只显示文件名。当对多个文件中的内容进行匹配时，使用 <code class="language-plaintext highlighter-rouge">-l</code> 会在匹配成功时只显示文件名，而不是文件中具体的位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>只显示不含有任何匹配的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>反向匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>显示匹配次数。使用 <code class="language-plaintext highlighter-rouge">-v</code> 时，显示反向匹配的数量</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>只显示匹配的部分</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>指定匹配的次数。例如 <code class="language-plaintext highlighter-rouge">-m 1</code> 表示当有多个匹配的时候只显示第一个匹配。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>从文件中读取模式。文件中每行一个模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>指定模式。可以指定多个模式，例如 <code class="language-plaintext highlighter-rouge">grep -e pattern1 -e pattern2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>只匹配整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A 2</code></td> <td>显示匹配行的后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-B 2</code></td> <td>显示匹配行的前两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C 2</code></td> <td>显示匹配行的前两行和后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>使用扩展正则表达式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>显示文件名。默认情况下，当只有一个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 不会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-H</code> 可以强制显示文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>不显示文件名。默认情况下，当有多个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-h</code> 可以强制不显示文件名</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-m 1</code> 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">grep</code> 的正则表达式是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的基本正则表达式，而 <code class="language-plaintext highlighter-rouge">egrep</code> 和 <code class="language-plaintext highlighter-rouge">grep -E</code> 是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的扩展正则表达式。<code class="language-plaintext highlighter-rouge">grep</code> 和 <code class="language-plaintext highlighter-rouge">egrep</code> 的区别在于 <code class="language-plaintext highlighter-rouge">egrep</code> 默认使用扩展正则表达式，而 <code class="language-plaintext highlighter-rouge">grep</code> 默认使用基本 正则表达式。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">grep</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">g/re/p</code>，其中 <code class="language-plaintext highlighter-rouge">g</code> 表示 <code class="language-plaintext highlighter-rouge">global</code>，<code class="language-plaintext highlighter-rouge">re</code> 表示 <code class="language-plaintext highlighter-rouge">regular expression</code>，<code class="language-plaintext highlighter-rouge">p</code> 表示 <code class="language-plaintext highlighter-rouge">print</code>，直译即全局正则表达式打印。</p> <h2 id="sort"><code class="language-plaintext highlighter-rouge">sort</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>逆序排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>按照数字排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>按照某一列排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>去重</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>忽略大小写。默认情况下，大写会在所有小写的前面，而使用 <code class="language-plaintext highlighter-rouge">-f</code> 可以让大小写混合在一起排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>人类可读的排序。例如 <code class="language-plaintext highlighter-rouge">1K</code> 会被排序到 <code class="language-plaintext highlighter-rouge">512</code> 的前面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-M</code></td> <td>按照月份排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=-</code></td> <td>从标准输入读取以 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=filename</code></td> <td>从某个文件中读取 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查文件是否已经排序</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-k</code> 可以指定多个列，例如 <code class="language-plaintext highlighter-rouge">-k2,2 -k1,1</code> 表示先按照第二列排序，然后再按照第一列排序。<code class="language-plaintext highlighter-rouge">-k</code> 也 按照某列的部分进行排序，例如 <code class="language-plaintext highlighter-rouge">-k2.2,2.3</code> 表示按照第二列的第二个字符到第三个字符进行排序。<code class="language-plaintext highlighter-rouge">-k</code> 还可以 指定列的类型，例如 <code class="language-plaintext highlighter-rouge">-k2n,2</code> 表示按照第二列的数字进行排序。<code class="language-plaintext highlighter-rouge">-r</code> 选项也可以指定到 <code class="language-plaintext highlighter-rouge">-k</code> 选项中，例如 <code class="language-plaintext highlighter-rouge">-k2r,2</code> 表示按照第二列逆序排序。</p> <h2 id="awk"><code class="language-plaintext highlighter-rouge">awk</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>指定输入的分隔符。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">awk</code> 脚本文件。</td> </tr> </tbody> </table> <h3 id="打印列">打印列</h3> <ul> <li><code class="language-plaintext highlighter-rouge">$0</code>: 整行</li> <li><code class="language-plaintext highlighter-rouge">$1</code>: 第一列</li> <li><code class="language-plaintext highlighter-rouge">...</code></li> <li><code class="language-plaintext highlighter-rouge">$NF</code>: 最后一列</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}'</code> 打印出每行的第一列、第二列和最后一列。</p> <h3 id="分隔符">分隔符</h3> <p>可以通过 <code class="language-plaintext highlighter-rouge">OFS=</code> (Output Field Separator) 来指定输出的分隔符，例如 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}' OFS=","</code> 表示使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。也可以在 <code class="language-plaintext highlighter-rouge">BEGIN</code> 模式串中指定 <code class="language-plaintext highlighter-rouge">OFS</code>，例如 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {OFS=","} {print $1,$2,$NF}'</code>。</p> <p>除了 <code class="language-plaintext highlighter-rouge">OFS</code> 以外，还有 <code class="language-plaintext highlighter-rouge">FS</code> 用于指定输入文件的分隔符。</p> <h3 id="预定义变量">预定义变量</h3> <p>除了之前提到的 <code class="language-plaintext highlighter-rouge">OFS</code>, <code class="language-plaintext highlighter-rouge">FS</code> 之外，还有一些预定义变量：</p> <ul> <li><code class="language-plaintext highlighter-rouge">NR</code>: 当前行的行号</li> <li><code class="language-plaintext highlighter-rouge">NF</code>: 当前行的列数</li> <li><code class="language-plaintext highlighter-rouge">RS</code>：记录分隔符，默认是换行符，也就是每一行作为一条记录</li> <li><code class="language-plaintext highlighter-rouge">ORS</code>：输出的记录分隔符，默认是换行符</li> <li><code class="language-plaintext highlighter-rouge">FILENAME</code>：当前文件的文件名</li> <li><code class="language-plaintext highlighter-rouge">FNR</code>：当前文件的行号，当时用多个文件的时候，<code class="language-plaintext highlighter-rouge">NR</code> 记录的是当前的总行号，而 <code class="language-plaintext highlighter-rouge">FNR</code> 记录的是当前文件的行号</li> </ul> <p>我们可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1'</code> 从第二行开始打印，也可以使用 <code class="language-plaintext highlighter-rouge">awk 'NF &gt; 0'</code> 打印列数大于 <code class="language-plaintext highlighter-rouge">0</code> 的行 (也就是移除空行)。</p> <p>如果要打印第一行到第四行，我们可以通过 <code class="language-plaintext highlighter-rouge">awk 'NR == 1, NR == 4'</code> 来实现。其中的 <code class="language-plaintext highlighter-rouge">,</code> 表示范围，<code class="language-plaintext highlighter-rouge">NR == 1</code> 表示第一行，<code class="language-plaintext highlighter-rouge">NR == 4</code> 表示第四行。我们还可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 &amp;&amp; NR &lt; 5'</code> 来实现。</p> <h3 id="模式">模式</h3> <p><code class="language-plaintext highlighter-rouge">BEGIN</code> 和 <code class="language-plaintext highlighter-rouge">END</code> 模式串：</p> <ul> <li><code class="language-plaintext highlighter-rouge">BEGIN</code>: 在处理输入之前执行</li> <li><code class="language-plaintext highlighter-rouge">END</code>: 在处理输入之后执行</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}'</code> 来在处理输入之前和之后 打印出 <code class="language-plaintext highlighter-rouge">Start</code> 和 <code class="language-plaintext highlighter-rouge">End</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中可以使用模式来过滤行，例如 <code class="language-plaintext highlighter-rouge">awk '$1 &gt; 10'</code> 表示只打印第一列大于 <code class="language-plaintext highlighter-rouge">10</code> 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern/'</code> 表示只打印包含 <code class="language-plaintext highlighter-rouge">pattern</code> 的行，搜索 模式支持正则表达式。</p> <p><code class="language-plaintext highlighter-rouge">,</code> 也可以和搜索模式一起使用，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern1/,/pattern2/'</code> 表示打印找到的 <code class="language-plaintext highlighter-rouge">pattern1</code> 到 <code class="language-plaintext highlighter-rouge">pattern2</code> 的行。</p> <p><code class="language-plaintext highlighter-rouge">~</code> 可以用来表示是否与搜索模式匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 ~ /pattern/'</code> 表示第一列是否包含 <code class="language-plaintext highlighter-rouge">pattern</code>。<code class="language-plaintext highlighter-rouge">!~</code> 可以 用来表示是否不匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 !~ /pattern/'</code> 表示第一列是否不包含 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h3 id="awk-脚本"><code class="language-plaintext highlighter-rouge">awk</code> 脚本</h3> <p>我们也可以书写 <code class="language-plaintext highlighter-rouge">awk</code> 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#! /usr/bin/awk -f</span>

<span class="kr">BEGIN</span> <span class="p">{</span>
    <span class="c1"># 设置输入和输出的分隔符</span>
    <span class="kc">FS</span><span class="o">=</span><span class="s2">":"</span>
    <span class="kc">OFS</span><span class="o">=</span><span class="s2">" "</span>
    <span class="nx">tot_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="kc">NF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">words</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="o">++</span>
        <span class="nx">tot_count</span><span class="o">++</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">END</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s2">"Total words:"</span><span class="p">,</span> <span class="nx">tot_count</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">word</span> <span class="o">in</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="nx">word</span><span class="p">,</span> <span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：由于在 <code class="language-plaintext highlighter-rouge">awk file</code> 的意思是对某个文件的内容进行处理，所以要用 <code class="language-plaintext highlighter-rouge">awk -f file</code> 来表示将文件作为 脚本执行。</p> <h3 id="内置函数">内置函数</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中还有一些内置函数，例如 <code class="language-plaintext highlighter-rouge">length</code> 函数可以返回字符串的长度，<code class="language-plaintext highlighter-rouge">substr</code> 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中，<code class="language-plaintext highlighter-rouge">print</code> 会在输出的字符串后面自动添加换行符，而 <code class="language-plaintext highlighter-rouge">printf</code> 可以进行格式化输出，上面的例子中 我们通过 <code class="language-plaintext highlighter-rouge">printf</code> 来输出不带换行符的字符串。在 <code class="language-plaintext highlighter-rouge">awk</code> 中字符串是可以直接拼接的，例如 <code class="language-plaintext highlighter-rouge">printf "%s", $NF"+"</code> 表示将最后一列的值和 <code class="language-plaintext highlighter-rouge">+</code> 拼接在一起。</p> <p><code class="language-plaintext highlighter-rouge">printf</code> 的格式化方法与 <code class="language-plaintext highlighter-rouge">C/C++</code> 中的类似，这里不再进行详细介绍。</p> <p>当然要实现同样的功能有更简单的命令：<code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { sum+=$NF } END { print sum }'</code> 或者 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""</code>。</p> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">awk</code> 中，下标是从 <code class="language-plaintext highlighter-rouge">1</code> 开始的，而不是从 <code class="language-plaintext highlighter-rouge">0</code> 开始的，且区间是闭区间。</p> <p>这里再列出一些常用的内置函数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tolower</code>：将字符串转换为小写</li> <li><code class="language-plaintext highlighter-rouge">toupper</code>：将字符串转换为大写</li> <li><code class="language-plaintext highlighter-rouge">split</code>：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 <code class="language-plaintext highlighter-rouge">split($0, words, /:+/)</code> 表示 将当前行按照 <code class="language-plaintext highlighter-rouge">:</code> (或者多个连续的 <code class="language-plaintext highlighter-rouge">:</code>) 分割为数组。</li> <li><code class="language-plaintext highlighter-rouge">gsub</code>：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 <code class="language-plaintext highlighter-rouge">gsub(/pattern/, "replace", $0)</code> 表示将当前行中的 <code class="language-plaintext highlighter-rouge">pattern</code> 替换为 <code class="language-plaintext highlighter-rouge">replace</code>。</li> <li><code class="language-plaintext highlighter-rouge">system</code>：执行系统命令，例如 <code class="language-plaintext highlighter-rouge">system("ls")</code> 会执行 <code class="language-plaintext highlighter-rouge">ls</code> 命令并将结果输出到标准输出。</li> </ul> <h3 id="改变分隔符">改变分隔符</h3> <p>前面介绍到 <code class="language-plaintext highlighter-rouge">FS</code> 和 <code class="language-plaintext highlighter-rouge">OFS</code> 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 <code class="language-plaintext highlighter-rouge">awk '{print}' FS=':' OFS=' '</code> 这样的命令，试图将 <code class="language-plaintext highlighter-rouge">:</code> 改成空格。但是这样并不能正确工作，在 <code class="language-plaintext highlighter-rouge">awk</code> 中 只有当列被修改后 (或者在 <code class="language-plaintext highlighter-rouge">print</code> 中打印多个 <code class="language-plaintext highlighter-rouge">fields</code> 的时候) 才会使用新的输出分隔符，所以我们可以通过 <code class="language-plaintext highlighter-rouge">awk '($1=$1) || 1' FS=':' OFS=' '</code> 来实现 (这里省略了动作，因此会打印一整行)。</p> <p>这里的 <code class="language-plaintext highlighter-rouge">($1=$1) || 1</code> 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 <code class="language-plaintext highlighter-rouge">awk</code> 中被当作 <code class="language-plaintext highlighter-rouge">false</code>，所以我们需要通过 <code class="language-plaintext highlighter-rouge">|| 1</code> 来保证输出。这里的括号是必须的，如果没有括号， <code class="language-plaintext highlighter-rouge">$1=$1 || 1</code> 会被解释为 <code class="language-plaintext highlighter-rouge">$1=($1 || 1)</code>，这样会将 <code class="language-plaintext highlighter-rouge">$1</code> 赋值为 <code class="language-plaintext highlighter-rouge">1</code>，而不是保留原来的值。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">awk</code> 的名字来源于三个创始人的名字 <code class="language-plaintext highlighter-rouge">Alfred Aho</code>、<code class="language-plaintext highlighter-rouge">Peter Weinberger</code> 和 <code class="language-plaintext highlighter-rouge">Brian Kernighan</code> 的 首字母。</p> <h3 id="posix-字符类"><code class="language-plaintext highlighter-rouge">POSIX</code> 字符类</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中支持 <code class="language-plaintext highlighter-rouge">POSIX</code> 字符类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">[:alnum:]</code>：字母和数字</li> <li><code class="language-plaintext highlighter-rouge">[:alpha:]</code>：字母</li> <li><code class="language-plaintext highlighter-rouge">[:blank:]</code>：空格和制表符</li> <li><code class="language-plaintext highlighter-rouge">[:cntrl:]</code>：控制字符</li> <li><code class="language-plaintext highlighter-rouge">[:digit:]</code>：数字</li> <li><code class="language-plaintext highlighter-rouge">[:graph:]</code>：可打印字符，不包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:lower:]</code>：小写字母</li> <li><code class="language-plaintext highlighter-rouge">[:print:]</code>：可打印字符，包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:punct:]</code>：标点符号</li> <li><code class="language-plaintext highlighter-rouge">[:space:]</code>：空白字符</li> <li><code class="language-plaintext highlighter-rouge">[:upper:]</code>：大写字母</li> <li><code class="language-plaintext highlighter-rouge">[:xdigit:]</code>：十六进制数字</li> </ul> <p>例如，我们可以使用 <code class="language-plaintext highlighter-rouge">awk '/[[:digit:]]/'</code> 来匹配包含数字的行。当然也可以写成 <code class="language-plaintext highlighter-rouge">awk '/[0-9]/'</code>。</p> <h2 id="find"><code class="language-plaintext highlighter-rouge">find</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-type</code></td> <td>指定文件类型。<code class="language-plaintext highlighter-rouge">f</code> 表示普通文件，<code class="language-plaintext highlighter-rouge">d</code> 表示目录，<code class="language-plaintext highlighter-rouge">l</code> 表示符号链接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-readable</code></td> <td>查找可读文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-writable</code></td> <td>查找可写文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-executable</code></td> <td>查找可执行文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-name</code></td> <td>指定文件名。可以使用 <code class="language-plaintext highlighter-rouge">wildcads</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-path</code></td> <td>指定路径。可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iname</code></td> <td>忽略大小写的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ipath</code></td> <td>忽略大小写的路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-empty</code></td> <td>查找空文件或者空目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-perm</code></td> <td>指定权限。例如 <code class="language-plaintext highlighter-rouge">-perm 644</code> 表示查找权限为 <code class="language-plaintext highlighter-rouge">644</code> 的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mtime</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mtime +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-atime</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-atime +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ctime</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-ctime +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mmin</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mmin +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-amin</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-amin +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-cmin</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-cmin +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-user</code></td> <td>指定拥有者</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-group</code></td> <td>指定所属组</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-delete</code></td> <td>删除查找到的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-maxdepth</code></td> <td>指定查找的最大深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mindepth</code></td> <td>指定查找的最小深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-and</code></td> <td>逻辑与。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-or</code></td> <td>逻辑或。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-not</code></td> <td>逻辑非。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>不跟踪符号链接。默认行为。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>跟踪符号链接。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>只对命令行参数进行跟踪。例如 <code class="language-plaintext highlighter-rouge">find -H /path/to/file -name filename</code> 只对 <code class="language-plaintext highlighter-rouge">/path/to/file</code> 进行跟踪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-print0</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-regex</code></td> <td>使用正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iregex</code></td> <td>使用忽略大小写的正则表达式匹配文件名</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">-type</code> 还可以以下类型有：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块设备文件</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字符设备文件</li> <li><code class="language-plaintext highlighter-rouge">p</code>：管道文件</li> <li><code class="language-plaintext highlighter-rouge">s</code>：套接字文件</li> </ul> <p><strong>注意</strong>：使用正则表达式匹配含有某个字符的文件名时，需要使用 <code class="language-plaintext highlighter-rouge">.*</code> 来表示任意数量的字符，例如 <code class="language-plaintext highlighter-rouge">find . -regex ".*pattern.*"</code>，而不能直接使用 <code class="language-plaintext highlighter-rouge">find . -regex "pattern"</code>。</p> <p><strong>注意</strong>：如果要使用复杂的逻辑表达式，需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来分组，例如 <code class="language-plaintext highlighter-rouge">find . \( -name "*.txt" -or -name "*.md" \)</code> 表示查找所有 <code class="language-plaintext highlighter-rouge">txt</code> 或者 <code class="language-plaintext highlighter-rouge">md</code> 文件，其中的括号需要进行转义。</p> <h3 id="指定文件大小">指定文件大小</h3> <p><code class="language-plaintext highlighter-rouge">-size</code> 参数有以下几种单位：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块，取决于文件系统，默认是 <code class="language-plaintext highlighter-rouge">512</code> 字节</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字节</li> <li><code class="language-plaintext highlighter-rouge">k</code>：千字节 (1024 字节)</li> <li><code class="language-plaintext highlighter-rouge">M</code>：兆字节 (1024 千字节)</li> <li><code class="language-plaintext highlighter-rouge">G</code>：吉字节 (1024 兆字节)</li> </ul> <p>知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 <code class="language-plaintext highlighter-rouge">find . -size 1M</code> 表示查找大小为 <code class="language-plaintext highlighter-rouge">1</code> 兆字节的文件。</p> <p>但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 来表示大于和小于，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件，<code class="language-plaintext highlighter-rouge">find . -size -1M</code> 表示查找小于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件。 这两者也可以结合使用，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M -size -2M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 且小于 <code class="language-plaintext highlighter-rouge">2MB</code> 的文件。</p> <h3 id="对查找到的文件执行操作">对查找到的文件执行操作</h3> <p><code class="language-plaintext highlighter-rouge">-exec</code> 可以对查找到的文件执行操作，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec cat {} \;</code> 表示查找当前目录下的 所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并将其内容输出到标准输出。<code class="language-plaintext highlighter-rouge">{}</code> 会被替换为查找到的文件名，<code class="language-plaintext highlighter-rouge">\;</code> 表示结束。</p> <p>也可以使用 <code class="language-plaintext highlighter-rouge">grep</code> 命令过滤查找到的文件，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec grep "pattern" {} \;</code> 表示查找 当前目录下的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并在其中查找 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h2 id="tar"><code class="language-plaintext highlighter-rouge">tar</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>创建文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-z</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">gzip</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-j</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">bzip2</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-J</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">xz</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>提取文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>指定提取的目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>查看文档内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--wildcards</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 匹配文件。例如 <code class="language-plaintext highlighter-rouge">tar -xf a.tar --wildcards '*.txt'</code> 可以提取 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--delete</code></td> <td>删除文档中的文件。例如 <code class="language-plaintext highlighter-rouge">tar -f a.tar --delete '*.txt'</code> 可以删除 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude=</code></td> <td>排除文件。例如 <code class="language-plaintext highlighter-rouge">tar -cf a.tar --exclude=*.txt .</code> 可以创建 <code class="language-plaintext highlighter-rouge">a.tar</code> 时排除所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>向文档中追加文件。例如 <code class="language-plaintext highlighter-rouge">tar -rf a.tar b.txt</code> 可以将 <code class="language-plaintext highlighter-rouge">b.txt</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>向文档中追加另一个文档。例如 <code class="language-plaintext highlighter-rouge">tar -Af a.tar b.tar</code> 可以将 <code class="language-plaintext highlighter-rouge">b.tar</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-W</code></td> <td>检验文档。例如 <code class="language-plaintext highlighter-rouge">tar -Wf a.tar</code> 可以检验 <code class="language-plaintext highlighter-rouge">a.tar</code> 的完整性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>更新文档。例如 <code class="language-plaintext highlighter-rouge">tar -uf a.tar b.txt</code> 可以更新 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的 <code class="language-plaintext highlighter-rouge">b.txt</code> 文件</td> </tr> </tbody> </table> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">--exclude</code> 时必须使用 <code class="language-plaintext highlighter-rouge">=</code> 进行连接，且 <code class="language-plaintext highlighter-rouge">--exclude</code> 要出现在待打包文件之前。 <code class="language-plaintext highlighter-rouge">tar -cf a.tar . --exclude=*.txt</code> 是错误用法。</p> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">-u</code> 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 <code class="language-plaintext highlighter-rouge">tar</code> 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。</p> <h1 id="git"><code class="language-plaintext highlighter-rouge">git</code></h1> <h2 id="gitignore"><code class="language-plaintext highlighter-rouge">.gitignore</code></h2> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件用于指定不需要被 <code class="language-plaintext highlighter-rouge">git</code> 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 来指定不需要被追踪的文件或目录。</p> <h3 id="wildcards"><code class="language-plaintext highlighter-rouge">wildcards</code></h3> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 中的 <code class="language-plaintext highlighter-rouge">wildcards</code> 与 <code class="language-plaintext highlighter-rouge">bash</code> 中基本一致，可以查看 <a href="#wildcards-in-linux">Wildcards in Linux</a> 来 了解更多关于 <code class="language-plaintext highlighter-rouge">wildcards</code> 的内容。</p> <h3 id="基本用法">基本用法</h3> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只对 当前目录生效。例如 <code class="language-plaintext highlighter-rouge">/foo</code> 表示只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示忽略所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或 目录。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只匹配 目录。例如 <code class="language-plaintext highlighter-rouge">foo/</code> 表示只匹配目录 <code class="language-plaintext highlighter-rouge">foo</code>，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示匹配所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录。你可能会有疑惑： 在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 <code class="language-plaintext highlighter-rouge">build/</code> 和 <code class="language-plaintext highlighter-rouge">build</code> 表示的意义是不同的，前者表示忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 目录，而后者表示 忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 文件或目录。前者可以保留某个子目录下面的名为 <code class="language-plaintext highlighter-rouge">build</code> 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 <code class="language-plaintext highlighter-rouge">/build/</code> 只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">build</code> 目录。</p> <h3 id="全局忽略">全局忽略</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中可以配置全局忽略文件，通常使用 <code class="language-plaintext highlighter-rouge">.git</code> 管理的仓库不需要追踪一些特定的文件，例如 <code class="language-plaintext highlighter-rouge">*.pyc</code>、 <code class="language-plaintext highlighter-rouge">*.o</code> 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 <code class="language-plaintext highlighter-rouge">~/.config/git/ignore</code>。</p> <h3 id="忽略文件优先级">忽略文件优先级</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中任何一个目录下都可以有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会覆盖父目录下的文件。也就是说，<code class="language-plaintext highlighter-rouge">.gitignore</code> 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。</p> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://www.tecmint.com/use-wildcards-to-match-filenames-in-linux/">10 Practical Examples Using Wildcards to Match Filenames in Linux</a></li> <li><a href="https://fishshell.com/docs/current/fish_for_bash_users.html#wildcards-globs">fish shell wildcards</a></li> <li><a href="https://ryanstutorials.net/linuxtutorial/cheatsheetgrep.php">Linux Tutorial - Cheat Sheet - grep</a></li> <li><a href="https://www.golinuxcloud.com/grep-command-in-linux/">20 grep command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://linuxhandbook.com/sort-command/">Linux Handbook: sort Command Examples</a></li> <li><a href="https://www.golinuxcloud.com/linux-sort-files/#1_Sort_by_name">15+ Tips to PROPERLY sort files in Linux [Cheat Sheet]</a></li> <li><a href="https://shapeshed.com/unix-sort/">Linux and Unix sort command tutorial with examples</a></li> <li><a href="https://www.baeldung.com/linux/sort-command">Linux sort Command</a></li> <li><a href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/">How to Use the awk Command on Linux</a></li> <li><a href="https://www.golinuxcloud.com/awk-examples-with-command-tutorial-unix-linux/">30+ awk examples for beginners / awk command tutorial in Linux/Unix</a></li> <li><a href="https://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/">8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR</a></li> <li><a href="https://linuxhandbook.com/awk-command-tutorial/">Getting Started With AWK Command [Beginner’s Guide]</a></li> <li><a href="https://www.golinuxcloud.com/find-command-in-linux/">25+ most used find commands in Linux [Cheat Sheet]</a></li> <li><a href="https://onecompiler.com/cheatsheets/find">find Linux Command Cheatsheet</a></li> <li><a href="https://linuxtutorials.org/linux-find-cheatsheet/">Linux Find Cheatsheet</a></li> <li><a href="https://opensource.com/article/21/9/linux-find-command">Find files and directories on Linux with the find command</a></li> <li><a href="https://www.redhat.com/sysadmin/linux-find-command">10 ways to use the Linux find command</a></li> <li><a href="https://quickref.me/find">Find cheatsheet</a></li> <li><a href="https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files">Ignoring files</a></li> <li><a href="https://www.golinuxcloud.com/cat-command-examples/">cat command examples for beginners [cheatsheet]</a></li> <li><a href="https://linux-audit.com/cheat-sheets/tar/">Linux Audit: tar cheat sheet</a></li> <li><a href="https://www.golinuxcloud.com/tar-command-in-linux/">15+ tar command examples in Linux [Cheat Sheet]</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Linux"/><category term="CLI"/><summary type="html"><![CDATA[Wildcards in Linux 这里的 wildcards 指的是能够被 shell 扩展的符号。如果在执行的命令中出现这些符号，shell 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 shell 支持，这些 wildcards 是可以在任意 命令中使用的。 常见的 wildcards 有以下几种： *：匹配任意数量( 包含 0 个 )的字符 **：递归匹配任意数量( 包含 0 个 )的字符 ?：匹配单个任意字符 []：匹配出现在中括号中的某个符号，在中括号中可以使用 - 来表示范围，也可以使用 ! 来表示取反， 例如 [!0-9] 表示匹配不是数字的字符，[!ab] 表示不是 a 也不是 b 的字符 上面的通配符并不是所有的 shell 都支持的，但是在 bash 中是支持的。例如在 fish shell 中，只有 *、** 以及 ? 是支持的，其中 * 和 ? 不会匹配 /，而 ** 会匹配 / ，也就是说 ** 是 递归匹配。 注意：在正则表达式的语法中，* 表示匹配前面的字符 0 次或者多次，? 表示匹配前面的字符 0 次或者 1 次， [] 表示匹配中括号中的任意一个字符，- 表示范围，^ 表示取反。 常用命令 Cheat Sheet cat 选项 说明 -n 显示行号 -b 显示非空行的行号 -s 合并多个空行为一个空行 -v 使用 ^ 和 M- 显示不可打印字符 -E 在每行的结尾显示 $ -T 将制表符显示为 ^I -A 等价于 -v -E -T -e 等价于 -v -E -t 等价于 -v -T - 从标准输入读取内容 使用 cat 可以直接创建带有内容的文件或者追加内容到文件中，例如 cat &gt; file 会等待输入，当输入完成 后，使用 ^D (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 cat &gt;&gt; file。 - 可以出现在多个文件的任意位置，例如 cat file1 - file2 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，而 cat file1 - file2 - file3 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，file2 和 file3 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 ^D 结束，然后输入第二次，再次使用 ^D 结束，第一次输入的内容会放置在 file1 和 file2 的内容 之间，第二次输入的内容会放置在 file2 和 file3 的内容之间。 补充：tac 可以将文件内容逆序输出 (优先输出最后一行)，tac 的名字来源于 cat 的逆序。 题外话：cat 的名字来源于 concatenate，即连接的意思，其可以将多个文件的内容拼接在一起。 grep 选项 说明 -r 递归搜索目录 --include "*.py" 搜索指定文件 --exclude "test*" 排除指定文件 --exclude-dir "test*" 排除指定目录 --color=auto,always,never 何时进行高亮 -n 显示行号。这里的行号指的是文件中的行号 -l 只显示文件名。当对多个文件中的内容进行匹配时，使用 -l 会在匹配成功时只显示文件名，而不是文件中具体的位置 -L 只显示不含有任何匹配的文件名 -i 忽略大小写 -v 反向匹配 -c 显示匹配次数。使用 -v 时，显示反向匹配的数量 -o 只显示匹配的部分 -m 指定匹配的次数。例如 -m 1 表示当有多个匹配的时候只显示第一个匹配。 -f 从文件中读取模式。文件中每行一个模式 -e 指定模式。可以指定多个模式，例如 grep -e pattern1 -e pattern2 -w 只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。 -x 只匹配整行 -A 2 显示匹配行的后两行 -B 2 显示匹配行的前两行 -C 2 显示匹配行的前两行和后两行 -E 使用扩展正则表达式 -F 使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待 -H 显示文件名。默认情况下，当只有一个文件时，grep 不会显示文件名，而使用 -H 可以强制显示文件名 -h 不显示文件名。默认情况下，当有多个文件时，grep 会显示文件名，而使用 -h 可以强制不显示文件名 注意：-m 1 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。 注意：grep 的正则表达式是基于 POSIX 的基本正则表达式，而 egrep 和 grep -E 是基于 POSIX 的扩展正则表达式。grep 和 egrep 的区别在于 egrep 默认使用扩展正则表达式，而 grep 默认使用基本 正则表达式。 题外话：grep 的名字来源于 g/re/p，其中 g 表示 global，re 表示 regular expression，p 表示 print，直译即全局正则表达式打印。 sort 选项 说明 -r 逆序排序 -n 按照数字排序 -k 按照某一列排序 -u 去重 -t 指定分隔符 -f 忽略大小写。默认情况下，大写会在所有小写的前面，而使用 -f 可以让大小写混合在一起排序 -h 人类可读的排序。例如 1K 会被排序到 512 的前面 -M 按照月份排序 --files0-form=- 从标准输入读取以 NUL 作为文件名分隔符的多个文件内容 --files0-form=filename 从某个文件中读取 NUL 作为文件名分隔符的多个文件内容 -c 检查文件是否已经排序 注意：-k 可以指定多个列，例如 -k2,2 -k1,1 表示先按照第二列排序，然后再按照第一列排序。-k 也 按照某列的部分进行排序，例如 -k2.2,2.3 表示按照第二列的第二个字符到第三个字符进行排序。-k 还可以 指定列的类型，例如 -k2n,2 表示按照第二列的数字进行排序。-r 选项也可以指定到 -k 选项中，例如 -k2r,2 表示按照第二列逆序排序。 awk 选项 说明 -F 指定输入的分隔符。 -f 指定 awk 脚本文件。 打印列 $0: 整行 $1: 第一列 ... $NF: 最后一列 例如可以使用 awk '{print $1,$2,$NF}' 打印出每行的第一列、第二列和最后一列。 分隔符 可以通过 OFS=(Output Field Separator) 来指定输出的分隔符，例如 awk '{print $1,$2,$NF}' OFS="," 表示使用 , 作为分隔符。也可以在 BEGIN 模式串中指定 OFS，例如 awk 'BEGIN {OFS=","} {print $1,$2,$NF}'。 除了 OFS 以外，还有 FS 用于指定输入文件的分隔符。 预定义变量 除了之前提到的 OFS, FS 之外，还有一些预定义变量： NR: 当前行的行号 NF: 当前行的列数 RS：记录分隔符，默认是换行符，也就是每一行作为一条记录 ORS：输出的记录分隔符，默认是换行符 FILENAME：当前文件的文件名 FNR：当前文件的行号，当时用多个文件的时候，NR 记录的是当前的总行号，而 FNR 记录的是当前文件的行号 我们可以使用 awk 'NR &gt; 1' 从第二行开始打印，也可以使用 awk 'NF &gt; 0' 打印列数大于 0 的行 (也就是移除空行)。 如果要打印第一行到第四行，我们可以通过 awk 'NR == 1, NR== 4' 来实现。其中的 , 表示范围，NR == 1 表示第一行，NR == 4 表示第四行。我们还可以使用 awk 'NR &gt; 1 &amp;&amp; NR &lt; 5' 来实现。 模式 BEGIN 和 END 模式串： BEGIN: 在处理输入之前执行 END: 在处理输入之后执行 例如可以使用 awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}' 来在处理输入之前和之后 打印出 Start 和 End。 在 awk 中可以使用模式来过滤行，例如 awk '$1 &gt; 10' 表示只打印第一列大于 10 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 awk '/pattern/' 表示只打印包含 pattern 的行，搜索 模式支持正则表达式。 , 也可以和搜索模式一起使用，例如 awk '/pattern1/,/pattern2/' 表示打印找到的 pattern1 到 pattern2 的行。 ~ 可以用来表示是否与搜索模式匹配，例如 awk '$1 ~ /pattern/' 表示第一列是否包含 pattern。!~ 可以 用来表示是否不匹配，例如 awk '$1 !~ /pattern/' 表示第一列是否不包含 pattern。 awk 脚本 我们也可以书写 awk 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数： #! /usr/bin/awk -f BEGIN { # 设置输入和输出的分隔符 FS=":" OFS=" " tot_count=0 } { for (i = 1; i &lt;= NF; i++) { words[$i]++ tot_count++ } } END { print "Total words:", tot_count for (word in words) { print word, words[word] } } 注意：由于在 awk file 的意思是对某个文件的内容进行处理，所以要用 awk -f file 来表示将文件作为 脚本执行。 内置函数 awk 中还有一些内置函数，例如 length 函数可以返回字符串的长度，substr 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc。 在 awk 中，print 会在输出的字符串后面自动添加换行符，而 printf 可以进行格式化输出，上面的例子中 我们通过 printf 来输出不带换行符的字符串。在 awk 中字符串是可以直接拼接的，例如 printf "%s", $NF"+" 表示将最后一列的值和 + 拼接在一起。 printf 的格式化方法与 C/C++ 中的类似，这里不再进行详细介绍。 当然要实现同样的功能有更简单的命令：awk 'NR &gt; 1 { sum+=$NF } END { print sum }' 或者 awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""。 注意：在 awk 中，下标是从 1 开始的，而不是从 0 开始的，且区间是闭区间。 这里再列出一些常用的内置函数： tolower：将字符串转换为小写 toupper：将字符串转换为大写 split：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 split($0, words, /:+/) 表示 将当前行按照 : (或者多个连续的 :) 分割为数组。 gsub：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 gsub(/pattern/, "replace", $0) 表示将当前行中的 pattern 替换为 replace。 system：执行系统命令，例如 system("ls") 会执行 ls 命令并将结果输出到标准输出。 改变分隔符 前面介绍到 FS 和 OFS 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 awk '{print}' FS=':' OFS=' ' 这样的命令，试图将 : 改成空格。但是这样并不能正确工作，在 awk 中 只有当列被修改后 (或者在 print 中打印多个 fields 的时候) 才会使用新的输出分隔符，所以我们可以通过 awk '($1=$1) || 1' FS=':' OFS=' ' 来实现 (这里省略了动作，因此会打印一整行)。 这里的 ($1=$1) || 1 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 awk 中被当作 false，所以我们需要通过 || 1 来保证输出。这里的括号是必须的，如果没有括号， $1=$1 || 1 会被解释为 $1=($1 || 1)，这样会将 $1 赋值为 1，而不是保留原来的值。 题外话：awk 的名字来源于三个创始人的名字 Alfred Aho、Peter Weinberger 和 Brian Kernighan 的 首字母。 POSIX 字符类 awk 中支持 POSIX 字符类： [:alnum:]：字母和数字 [:alpha:]：字母 [:blank:]：空格和制表符 [:cntrl:]：控制字符 [:digit:]：数字 [:graph:]：可打印字符，不包括空格 [:lower:]：小写字母 [:print:]：可打印字符，包括空格 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制数字 例如，我们可以使用 awk '/[[:digit:]]/' 来匹配包含数字的行。当然也可以写成 awk '/[0-9]/'。 find 选项 说明 -type 指定文件类型。f 表示普通文件，d 表示目录，l 表示符号链接 -readable 查找可读文件或目录 -writable 查找可写文件或目录 -executable 查找可执行文件或目录 -name 指定文件名。可以使用 wildcads -path 指定路径。可以使用 wildcards -iname 忽略大小写的文件名 -ipath 忽略大小写的路径 -empty 查找空文件或者空目录 -perm 指定权限。例如 -perm 644 表示查找权限为 644 的文件或目录 -mtime 指定修改时间。例如 -mtime +1 表示查找修改时间在 1 天前的文件或目录 -atime 指定访问时间。例如 -atime +1 表示查找访问时间在 1 天前的文件或目录 -ctime 指定创建时间。例如 -ctime +1 表示查找创建时间在 1 天前的文件或目录 -mmin 指定修改时间。例如 -mmin +1 表示查找修改时间在 1 分钟前的文件或目录 -amin 指定访问时间。例如 -amin +1 表示查找访问时间在 1 分钟前的文件或目录 -cmin 指定创建时间。例如 -cmin +1 表示查找创建时间在 1 分钟前的文件或目录 -user 指定拥有者 -group 指定所属组 -delete 删除查找到的文件或目录 -maxdepth 指定查找的最大深度 -mindepth 指定查找的最小深度 -and 逻辑与。 -or 逻辑或。 -not 逻辑非。 -P 不跟踪符号链接。默认行为。 -L 跟踪符号链接。 -H 只对命令行参数进行跟踪。例如 find -H /path/to/file -name filename 只对 /path/to/file 进行跟踪 -print0 使用 NUL 作为文件名分隔符 -regex 使用正则表达式匹配文件名 -iregex 使用忽略大小写的正则表达式匹配文件名 -type 还可以以下类型有： b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 注意：使用正则表达式匹配含有某个字符的文件名时，需要使用 .* 来表示任意数量的字符，例如 find . -regex ".*pattern.*"，而不能直接使用 find . -regex "pattern"。 注意：如果要使用复杂的逻辑表达式，需要使用 () 来分组，例如 find . \( -name "*.txt" -or -name "*.md" \) 表示查找所有 txt 或者 md 文件，其中的括号需要进行转义。 指定文件大小 -size 参数有以下几种单位： b：块，取决于文件系统，默认是 512 字节 c：字节 k：千字节 (1024 字节) M：兆字节 (1024 千字节) G：吉字节 (1024 兆字节) 知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 find . -size 1M 表示查找大小为 1 兆字节的文件。 但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 + 和 - 来表示大于和小于，例如 find . -size +1M 表示查找大于 1MB 的文件，find . -size -1M 表示查找小于 1MB 的文件。 这两者也可以结合使用，例如 find . -size +1M -size -2M 表示查找大于 1MB 且小于 2MB 的文件。 对查找到的文件执行操作 -exec 可以对查找到的文件执行操作，例如 find . -name "*.txt" -exec cat {} \; 表示查找当前目录下的 所有 txt 文件并将其内容输出到标准输出。{} 会被替换为查找到的文件名，\; 表示结束。 也可以使用 grep 命令过滤查找到的文件，例如 find . -name "*.txt" -exec grep "pattern" {} \; 表示查找 当前目录下的所有 txt 文件并在其中查找 pattern。 tar 选项 说明 -c 创建文档 -f 指定文件名 -v 显示详细信息 -z 使用 gzip 压缩或解压 -j 使用 bzip2 压缩或解压 -J 使用 xz 压缩或解压 -x 提取文档 -C 指定提取的目录 -t 查看文档内容 --wildcards 使用 wildcards 匹配文件。例如 tar -xf a.tar --wildcards '*.txt' 可以提取 a.tar 中的所有 txt 文件 --delete 删除文档中的文件。例如 tar -f a.tar --delete '*.txt' 可以删除 a.tar 中的所有 txt 文件 --exclude= 排除文件。例如 tar -cf a.tar --exclude=*.txt . 可以创建 a.tar 时排除所有 txt 文件 -r 向文档中追加文件。例如 tar -rf a.tar b.txt 可以将 b.txt 追加到 a.tar 中 -A 向文档中追加另一个文档。例如 tar -Af a.tar b.tar 可以将 b.tar 追加到 a.tar 中 -W 检验文档。例如 tar -Wf a.tar 可以检验 a.tar 的完整性 -u 更新文档。例如 tar -uf a.tar b.txt 可以更新 a.tar 中的 b.txt 文件 注意：在使用 --exclude 时必须使用 = 进行连接，且 --exclude 要出现在待打包文件之前。 tar -cf a.tar . --exclude=*.txt 是错误用法。 注意：在使用 -u 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 tar 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。 git .gitignore .gitignore 文件用于指定不需要被 git 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 .gitignore 文件中可以使用 wildcards 来指定不需要被追踪的文件或目录。 wildcards .gitignore 中的 wildcards 与 bash 中基本一致，可以查看 Wildcards in Linux 来 了解更多关于 wildcards 的内容。 基本用法 默认情况下，.gitignore 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 / 表示只对 当前目录生效。例如 /foo 表示只忽略当前目录下的 foo 文件或目录，而 foo 表示忽略所有的 foo 文件或 目录。 默认情况下，.gitignore 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 / 表示只匹配 目录。例如 foo/ 表示只匹配目录 foo，而 foo 表示匹配所有的 foo 文件或目录。你可能会有疑惑： 在 Linux 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 build/ 和 build 表示的意义是不同的，前者表示忽略所有 build 目录，而后者表示 忽略所有 build 文件或目录。前者可以保留某个子目录下面的名为 build 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 /build/ 只忽略当前目录下的 build 目录。 全局忽略 在 git 中可以配置全局忽略文件，通常使用 .git 管理的仓库不需要追踪一些特定的文件，例如 *.pyc、 *.o 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 ~/.config/git/ignore。 忽略文件优先级 在 git 中任何一个目录下都可以有一个 .gitignore 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 .gitignore 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 .gitignore 文件，那么这个文件会覆盖父目录下的文件。也就是说，.gitignore 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。 巨人的肩膀 10 Practical Examples Using Wildcards to Match Filenames in Linux fish shell wildcards Linux Tutorial - Cheat Sheet - grep 20 grep command examples in Linux [Cheat Sheet] Linux Handbook: sort Command Examples 15+ Tips to PROPERLY sort files in Linux [Cheat Sheet] Linux and Unix sort command tutorial with examples Linux sort Command How to Use the awk Command on Linux 30+ awk examples for beginners / awk command tutorial in Linux/Unix 8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR Getting Started With AWK Command [Beginner’s Guide] 25+ most used find commands in Linux [Cheat Sheet] find Linux Command Cheatsheet Linux Find Cheatsheet Find files and directories on Linux with the find command 10 ways to use the Linux find command Find cheatsheet Ignoring files cat command examples for beginners [cheatsheet] Linux Audit: tar cheat sheet 15+ tar command examples in Linux [Cheat Sheet]]]></summary></entry><entry><title type="html">Spring-Validation 自定义错误代码</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/" rel="alternate" type="text/html" title="Spring-Validation 自定义错误代码"/><published>2024-08-29T02:38:09+00:00</published><updated>2024-08-29T02:38:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 做了简单的介绍。但是只使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 就很难实现了，我们往往需要自定义代码的 实现逻辑。</p> <p>而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。</p> <p>而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。</p> <h1 id="返回信息">返回信息</h1> <p>我们的基本要求是对于错误信息返回如下的 <code class="language-plaintext highlighter-rouge">JSON</code> 数据：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User id must be null when creating a new user"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NOTNULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"4"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"5"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"6"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_EMAIL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"7"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"8"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"9"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"10"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"11"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERNAME_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"12"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EMAIL_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"13"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WRONG_SIGN_IN_INFORMATION"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"14"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INVALID_TOKEN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"15"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ACCESS_DENIED"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MESSAGE_CONVERSION_ERROR"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>对于这样的数据，前端开发者可以很容易将其定义成一个 <code class="language-plaintext highlighter-rouge">enum</code> 类型，这样就可以很方便的进行错误码的比较。</p> <h1 id="自定义校验逻辑">自定义校验逻辑</h1> <p>对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了如何设置全局异常处理器。</p> <h2 id="自定义错误码">自定义错误码</h2> <p>当然，我们首先需要有错误码的信息，我们可以定义如下的 <code class="language-plaintext highlighter-rouge">enum</code> 类型：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ErrorCodeEnum</span> <span class="o">{</span>
    <span class="c1">// This should be ignored, this is to make the ordinal of the enum start from 1</span>
    <span class="no">ZERO_PLACEHOLDER</span><span class="o">,</span>

    <span class="no">USERDTO_ID_NULL</span><span class="o">(</span><span class="s">"UserDTO.id.Null"</span><span class="o">),</span>
    <span class="no">USERDTO_ID_NOTNULL</span><span class="o">(</span><span class="s">"UserDTO.id.NotNull"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_SIZE</span><span class="o">(</span><span class="s">"UserDTO.username.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.email.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_EMAIL</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_SIZE</span><span class="o">(</span><span class="s">"UserDTO.userPassword.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERSIGNINDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERSIGNINDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERNAME_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"USERNAME_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">EMAIL_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"EMAIL_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">WRONG_SIGN_IN_INFORMATION</span><span class="o">(</span><span class="s">"WRONG_SIGN_IN_INFORMATION"</span><span class="o">),</span>

    <span class="no">INVALID_TOKEN</span><span class="o">(</span><span class="s">"INVALID_TOKEN"</span><span class="o">),</span>
    <span class="no">ACCESS_DENIED</span><span class="o">(</span><span class="s">"ACCESS_DENIED"</span><span class="o">),</span>

    <span class="no">MESSAGE_CONVERSION_ERROR</span><span class="o">(</span><span class="s">"MESSAGE_CONVERSION_ERROR"</span><span class="o">);</span>

    <span class="c1">// code means the error code in the message.properties</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">code</span><span class="o">;</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(){}</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">code</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通常 <code class="language-plaintext highlighter-rouge">0</code> 代表执行成功，所以我们在上面的 <code class="language-plaintext highlighter-rouge">enum</code> 类型中加入了一个 <code class="language-plaintext highlighter-rouge">ZERO_PLACEHOLDER</code>，这样我们的错误码 就可以从 <code class="language-plaintext highlighter-rouge">1</code> 开始了。</p> <p>为了能够让自己定义的错误也能使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国际化处理，我们通过在 <code class="language-plaintext highlighter-rouge">enum</code> 中定义 <code class="language-plaintext highlighter-rouge">code</code> 将其 与 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码进行对应。这样我们只需要在 <code class="language-plaintext highlighter-rouge">message.properties</code> 添加对应的错误码即可：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.id.Null</span><span class="p">=</span><span class="s">User id must be null when creating a new user</span>
<span class="py">UserDTO.id.NotNull</span><span class="p">=</span><span class="s">User id cannot be null</span>
<span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
<span class="py">UserDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="c"># UserSignInDTO validation messages
</span><span class="py">UserSignInDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserSignInDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="py">USERNAME_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Username already exists: {}</span>
<span class="py">EMAIL_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Email already exists: {}</span>
<span class="py">WRONG_SIGN_IN_INFORMATION</span><span class="p">=</span><span class="s">Wrong sign in information</span>

<span class="py">INVALID_TOKEN</span><span class="p">=</span><span class="s">Invalid token: {}</span>
<span class="py">ACCESS_DENIED</span><span class="p">=</span><span class="s">Operation without privileges</span>

<span class="py">MESSAGE_CONVERSION_ERROR</span><span class="p">=</span><span class="s">Error occurs while converting message</span>
</code></pre></div></div> <p>当然我们需要一个工具类来获取错误码的信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">args</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ignore</span>
        <span class="o">}</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>之前我们在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了 <code class="language-plaintext highlighter-rouge">{min}</code> 、<code class="language-plaintext highlighter-rouge">{max}</code> 等不能通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行替换的参数，所以在这个工具类中，我们先尝试通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 获取信息，如果获取失败，我们就通过正则表达式进行替换。</p> <p>最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然我们需要定义 <code class="language-plaintext highlighter-rouge">ErrorVO</code> 对象用于返回错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">errorCodeEnum</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">errorCodeEnum</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">GenericException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleGenericException</span><span class="o">(</span>
        <span class="nc">GenericException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error caused by {}:\n {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">INVALID_TOKEN:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">case</span> <span class="nl">ACCESS_DENIED:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="spring-validation">Spring Validation</h1> <p>在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> + <code class="language-plaintext highlighter-rouge">Spring Validation</code> 的时候，我们是通过 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "{UserDTO.username.NotBlank}")</code> 来获取 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码的， <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 的语法是由 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。</p> <p>众所周知，<code class="language-plaintext highlighter-rouge">enum</code> 对于的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法可以通过名称来创建对应的 <code class="language-plaintext highlighter-rouge">enum</code> 对象，例如 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK")</code> 与 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK</code> 是等价的， 而在 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 中只会对 <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 进行解析，而其他的部分将会保持不变，例如 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}")</code> 解析后获取到的 错误信息是 <code class="language-plaintext highlighter-rouge">USERDTO_USERNAME_NOTBLANK Username cannot be blank</code>。这也就意味着我们只需要在使用注解的 地方多增加一个 <code class="language-plaintext highlighter-rouge">enum</code> 的名称即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">UserDTO</span><span class="o">(</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NULL {UserDTO.id.Null}"</span><span class="o">)</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NOTNULL {UserDTO.id.NotNull}"</span><span class="o">)</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_SIZE {UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">username</span><span class="o">,</span>
    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">email</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">userPassword</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p>当然着还没完，我们需要在全局异常处理器中对这种错误进行处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span>
        <span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// we only handle one validation message</span>
    <span class="nc">String</span> <span class="n">codeAndMessage</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getFieldError</span><span class="o">().</span><span class="na">getDefaultMessage</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">firstSpaceIndex</span> <span class="o">=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
    <span class="c1">// There must be a space and not at the end of the message</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">var</span> <span class="n">exception</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericException</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">firstSpaceIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
    <span class="n">exception</span><span class="o">.</span><span class="na">setCode</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">firstSpaceIndex</span><span class="o">)));</span>
    <span class="k">return</span> <span class="nf">handleGenericException</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>再上面的处理中，我们提取到错误码后创建相应的 <code class="language-plaintext highlighter-rouge">GenericException</code> 对象，然后交给 <code class="language-plaintext highlighter-rouge">handleGenericException</code> 进行统一处理。</p> <p>通过上面的操作后，我们已经成功对自定义校验逻辑以及 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行了统一处理，而且我们还可以 通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。</p> <h1 id="返回错误码信息">返回错误码信息</h1> <p>我们只需要定义以下的 <code class="language-plaintext highlighter-rouge">controller</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="c1">// 标记只有在开发环境下才会被加载</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">DEV_PROFILE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errorCodeConstant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑</span>
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span> <span class="o">:</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">ZERO_PLACEHOLDER</span><span class="o">)</span> <span class="o">{</span> <span class="k">continue</span><span class="o">;</span> <span class="o">}</span>
            <span class="n">errorCodeConstant</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">code</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getErrorMessage</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">errorCodeConstant</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="最后">最后</h1> <p>上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring-Validation 做了简单的介绍。但是只使用 Spring-Validation 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 Spring-Validation 就很难实现了，我们往往需要自定义代码的 实现逻辑。 而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。 而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。 返回信息 我们的基本要求是对于错误信息返回如下的 JSON 数据： { "code": 1, "message": "User id must be null when creating a new user" } 除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式： { "1": "USERDTO_ID_NULL", "2": "USERDTO_ID_NOTNULL", "3": "USERDTO_USERNAME_SIZE", "4": "USERDTO_USERNAME_NOTBLANK", "5": "USERDTO_EMAIL_NOTBLANK", "6": "USERDTO_EMAIL_EMAIL", "7": "USERDTO_USERPASSWORD_SIZE", "8": "USERDTO_USERPASSWORD_NOTBLANK", "9": "USERSIGNINDTO_USERNAME_NOTBLANK", "10": "USERSIGNINDTO_USERPASSWORD_NOTBLANK", "11": "USERNAME_ALREADY_EXISTS", "12": "EMAIL_ALREADY_EXISTS", "13": "WRONG_SIGN_IN_INFORMATION", "14": "INVALID_TOKEN", "15": "ACCESS_DENIED", "16": "MESSAGE_CONVERSION_ERROR" } 对于这样的数据，前端开发者可以很容易将其定义成一个 enum 类型，这样就可以很方便的进行错误码的比较。 自定义校验逻辑 对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 使用 Spring-Validation 进行参数校验 中介绍了如何设置全局异常处理器。 自定义错误码 当然，我们首先需要有错误码的信息，我们可以定义如下的 enum 类型： public enum ErrorCodeEnum { // This should be ignored, this is to make the ordinal of the enum start from 1 ZERO_PLACEHOLDER, USERDTO_ID_NULL("UserDTO.id.Null"), USERDTO_ID_NOTNULL("UserDTO.id.NotNull"), USERDTO_USERNAME_SIZE("UserDTO.username.Size"), USERDTO_USERNAME_NOTBLANK("UserDTO.username.NotBlank"), USERDTO_EMAIL_NOTBLANK("UserDTO.email.NotBlank"), USERDTO_EMAIL_EMAIL("UserDTO.email.Email"), USERDTO_USERPASSWORD_SIZE("UserDTO.userPassword.Size"), USERDTO_USERPASSWORD_NOTBLANK("UserDTO.userPassword.NotBlank"), USERSIGNINDTO_USERNAME_NOTBLANK("UserSignInDTO.username.NotBlank"), USERSIGNINDTO_USERPASSWORD_NOTBLANK("UserSignInDTO.userPassword.NotBlank"), USERNAME_ALREADY_EXISTS("USERNAME_ALREADY_EXISTS"), EMAIL_ALREADY_EXISTS("EMAIL_ALREADY_EXISTS"), WRONG_SIGN_IN_INFORMATION("WRONG_SIGN_IN_INFORMATION"), INVALID_TOKEN("INVALID_TOKEN"), ACCESS_DENIED("ACCESS_DENIED"), MESSAGE_CONVERSION_ERROR("MESSAGE_CONVERSION_ERROR"); // code means the error code in the message.properties private String code; ErrorCodeEnum(){} ErrorCodeEnum(String code) { this.code = code; } public String getCode() { return code; } } 通常 0 代表执行成功，所以我们在上面的 enum 类型中加入了一个 ZERO_PLACEHOLDER，这样我们的错误码 就可以从 1 开始了。 为了能够让自己定义的错误也能使用 MessageSource 进行国际化处理，我们通过在 enum 中定义 code 将其 与 message.properties 中的错误码进行对应。这样我们只需要在 message.properties 添加对应的错误码即可： # UserDTO validation messages UserDTO.id.Null=User id must be null when creating a new user UserDTO.id.NotNull=User id cannot be null UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.username.NotBlank=Username cannot be blank UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters UserDTO.userPassword.NotBlank=Password cannot be blank # UserSignInDTO validation messages UserSignInDTO.username.NotBlank=Username cannot be blank UserSignInDTO.userPassword.NotBlank=Password cannot be blank USERNAME_ALREADY_EXISTS=Username already exists: {} EMAIL_ALREADY_EXISTS=Email already exists: {} WRONG_SIGN_IN_INFORMATION=Wrong sign in information INVALID_TOKEN=Invalid token: {} ACCESS_DENIED=Operation without privileges MESSAGE_CONVERSION_ERROR=Error occurs while converting message 当然我们需要一个工具类来获取错误码的信息： // 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入 @Component public class MessageSourceUtil { private static MessageSource messageSource; MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(ErrorCodeEnum code, Object... args) { try { return messageSource.getMessage(code.getCode(), args, LocaleContextHolder.getLocale()); } catch (Exception e) { // ignore } String message=messageSource.getMessage(code.getCode(), null, LocaleContextHolder.getLocale()); Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 之前我们在 使用 Spring-Validation 进行参数校验 中介绍了 {min} 、{max} 等不能通过 MessageSource 进行替换的参数，所以在这个工具类中，我们先尝试通过 MessageSource 获取信息，如果获取失败，我们就通过正则表达式进行替换。 最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理： @Getter @Setter public class GenericException extends RuntimeException { private ErrorCodeEnum code; public GenericException(String message) { super(message); } public GenericException(ErrorCodeEnum code, Object... args) { super(MessageSourceUtil.getMessage(code, args)); this.code = code; } } 当然我们需要定义 ErrorVO 对象用于返回错误信息： public record ErrorVO(Integer code, String message) { public ErrorVO(ErrorCodeEnum errorCodeEnum, String message) { this(errorCodeEnum.ordinal(), message); } } 经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了： @ExceptionHandler(GenericException.class) public ResponseEntity&lt;ErrorVO&gt; handleGenericException( GenericException e, HttpServletRequest request) { logger.error("Error caused by {}:\n {}", request.getRemoteAddr(), e.getMessage()); switch (e.getCode()) { case INVALID_TOKEN: return ResponseEntity.status(HttpStatus.UNAUTHORIZED) .body(new ErrorVO(e.getCode(), e.getMessage())); case ACCESS_DENIED: return ResponseEntity.status(HttpStatus.FORBIDDEN) .body(new ErrorVO(e.getCode(), e.getMessage())); default: return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(new ErrorVO(e.getCode(), e.getMessage())); } } Spring Validation 在使用 MessageSource + Spring Validation 的时候，我们是通过 @NotBlank(message = "{UserDTO.username.NotBlank}") 来获取 message.properties 中的错误码的， {xxx.xxx.xxx} 的语法是由 Spring Validation 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。 众所周知，enum 对于的 valueOf 方法可以通过名称来创建对应的 enum 对象，例如 ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK") 与 ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK 是等价的， 而在 Spring Validation 中只会对 {xxx.xxx.xxx} 进行解析，而其他的部分将会保持不变，例如 @NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") 解析后获取到的 错误信息是 USERDTO_USERNAME_NOTBLANK Username cannot be blank。这也就意味着我们只需要在使用注解的 地方多增加一个 enum 的名称即可： public record UserDTO( @Null(groups = CreateGroup.class, message="USERDTO_ID_NULL {UserDTO.id.Null}") @NotNull(groups = UpdateGroup.class, message="USERDTO_ID_NOTNULL {UserDTO.id.NotNull}") Long id, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_USERNAME_LENGTH, max=ValidationConstant.MAX_USERNAME_LENGTH, message="USERDTO_USERNAME_SIZE {UserDTO.username.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") String username, @Email( groups={CreateGroup.class}, message="USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") String email, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_PASSWORD_LENGTH, max=ValidationConstant.MAX_PASSWORD_LENGTH, message="USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}") String userPassword) {} 当然着还没完，我们需要在全局异常处理器中对这种错误进行处理： @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity&lt;ErrorVO&gt; handleMethodArgumentNotValidException( MethodArgumentNotValidException e, HttpServletRequest request) { // we only handle one validation message String codeAndMessage=e.getFieldError().getDefaultMessage(); int firstSpaceIndex=codeAndMessage.indexOf(" "); // There must be a space and not at the end of the message assert firstSpaceIndex != -1; assert firstSpaceIndex != codeAndMessage.length() - 1; var exception=new GenericException(codeAndMessage.substring(firstSpaceIndex + 1)); exception.setCode(ErrorCodeEnum.valueOf(codeAndMessage.substring(0, firstSpaceIndex))); return handleGenericException(exception, request); } 再上面的处理中，我们提取到错误码后创建相应的 GenericException 对象，然后交给 handleGenericException 进行统一处理。 通过上面的操作后，我们已经成功对自定义校验逻辑以及 Spring Validation 进行了统一处理，而且我们还可以 通过 MessageSource 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。 返回错误码信息 我们只需要定义以下的 controller 即可： @RestController // 标记只有在开发环境下才会被加载 @Profile(ApplicationConstant.DEV_PROFILE) public class DevelopmentController { private Map&lt;Integer, String&gt; errorCodeConstant=new HashMap&lt;&gt;(); // 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑 @PostConstruct public void init() { for (ErrorCodeEnum code : ErrorCodeEnum.values()) { if (code == ErrorCodeEnum.ZERO_PLACEHOLDER) { continue; } errorCodeConstant.put(code.ordinal(), code.name()); } } @GetMapping(ApiPathConstant.DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH) public Map&lt;Integer, String&gt; getErrorMessage() { return errorCodeConstant; } } 最后 上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。]]></summary></entry><entry><title type="html">JJWT + Spring Filter 实现 Token 验证</title><link href="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/" rel="alternate" type="text/html" title="JJWT + Spring Filter 实现 Token 验证"/><published>2024-08-27T12:21:37+00:00</published><updated>2024-08-27T12:21:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/"><![CDATA[<p>在实际上开发中我们可能会需要涉及到用户的认证和授权功能，<code class="language-plaintext highlighter-rouge">Spring Security</code> 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 <code class="language-plaintext highlighter-rouge">JJWT</code> 就能实现。</p> <h1 id="需求">需求</h1> <p>考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 <code class="language-plaintext highlighter-rouge">token</code> 来进行访问，<code class="language-plaintext highlighter-rouge">token</code> 一定时间内有效，过期后需要重新登录。</p> <p>对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 <code class="language-plaintext highlighter-rouge">token</code> 进行 解析，获取用户信息，然后进行比对。</p> <h2 id="双-token-模式">双 <code class="language-plaintext highlighter-rouge">token</code> 模式</h2> <p>对于 <code class="language-plaintext highlighter-rouge">token</code> 的设计，我们可以采用双 <code class="language-plaintext highlighter-rouge">token</code> 模式，即一个 <code class="language-plaintext highlighter-rouge">access token</code> 和一个 <code class="language-plaintext highlighter-rouge">refresh token</code>，<code class="language-plaintext highlighter-rouge">access token</code> 用于访问，<code class="language-plaintext highlighter-rouge">refresh token</code> 用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>。</p> <p>这样的设计可以有效的保证安全性，因为 <code class="language-plaintext highlighter-rouge">access token</code> 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 <code class="language-plaintext highlighter-rouge">refresh token</code> 通常有效时间较长，但是只能用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>，不能用于访问，且 <code class="language-plaintext highlighter-rouge">refresh token</code> 只有在每次 <code class="language-plaintext highlighter-rouge">access token</code> 过期后才会被传递，这样 <code class="language-plaintext highlighter-rouge">refresh token</code> 暴露的风险较小。</p> <h1 id="实现">实现</h1> <h2 id="jwtutil"><code class="language-plaintext highlighter-rouge">JwtUtil</code></h2> <p>我们首先需要自定义一个工具类，该工具类可以生成和解析 <code class="language-plaintext highlighter-rouge">token</code>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">TOKEN_TYPE_CLAIM</span> <span class="o">=</span> <span class="s">"tokenType"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ID_CLAIM</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">SecretKey</span> <span class="no">SECRET_KEY</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">SIG</span><span class="o">.</span><span class="na">HS256</span><span class="o">.</span><span class="na">key</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">issuedAt</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">())</span>
                <span class="o">.</span><span class="na">expiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span>
                    <span class="o">(</span><span class="n">tokenType</span> <span class="o">==</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span> <span class="o">?</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">ACCESS_TOKEN_EXPIRATION</span> <span class="o">:</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">REFRESH_TOKEN_EXPIRATION</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="n">tokenType</span><span class="o">.</span><span class="na">name</span><span class="o">())</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">id</span><span class="o">),</span> <span class="n">tokenType</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getID</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TokenTypeEnum</span> <span class="nf">getTokenType</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="filter"><code class="language-plaintext highlighter-rouge">Filter</code></h2> <p>要实现认证和授权，我们可以通过 <code class="language-plaintext highlighter-rouge">Filter</code> 拦截所有的非登录和注册的业务请求，然后进行 <code class="language-plaintext highlighter-rouge">token</code> 的解析和验证：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">LOWEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ignorePath</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_UP_API_PATH</span><span class="o">,</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">,</span>
    <span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
        <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">authorize</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getTokenType</span><span class="o">(</span><span class="n">token</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">ACCESS_TOKEN:</span>
                <span class="c1">// ACCESS_TOKEN can not be used for refresh</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">String</span> <span class="n">idInToken</span> <span class="o">=</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
                <span class="k">switch</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethod</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">case</span> <span class="s">"GET"</span><span class="o">:</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">case</span> <span class="s">"POST"</span><span class="o">:</span>
                        <span class="c1">// User can not update other user's information</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_API_PREFIX</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">idInToken</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getFromRequestBody</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="s">"id"</span><span class="o">)))</span> <span class="o">{</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">default</span><span class="o">:</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">REFRESH_TOKEN:</span>
                <span class="c1">// REFRESH_TOKEN can only be used for refresh</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">getFromRequestBody</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getReader</span><span class="o">();</span>
            <span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="o">=</span> <span class="nc">JsonParserFactory</span><span class="o">.</span><span class="na">getJsonParser</span><span class="o">().</span><span class="na">parseMap</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// unlikely to happen</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="signin"><code class="language-plaintext highlighter-rouge">SignIn</code></h2> <p>对于登录接口，我们只需要返回额外 <code class="language-plaintext highlighter-rouge">access token</code> 和 <code class="language-plaintext highlighter-rouge">refresh token</code>，对于刷新服务我们直接返回新的 <code class="language-plaintext highlighter-rouge">access token</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 我们在 UserVO 中保存 token</span>
<span class="kd">public</span> <span class="n">record</span> <span class="nf">UserVO</span><span class="o">(</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">accessToken</span><span class="o">,</span> <span class="nc">String</span> <span class="n">refreshToken</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">REFRESH_TOKEN</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticationController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">signIn</span><span class="o">(</span><span class="nd">@Validated</span> <span class="nd">@RequestBody</span> <span class="nc">UserSignInDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">username</span><span class="o">());</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"user_password"</span><span class="o">,</span> <span class="nc">MD5Converter</span><span class="o">.</span><span class="na">convertToMD5</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">userPassword</span><span class="o">()));</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">WRONG_SIGN_IN_INFORMATION</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="k">new</span> <span class="nc">UserVO</span><span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">getOne</span><span class="o">(</span><span class="n">wrapper</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">refreshToken</span><span class="o">(</span><span class="nd">@RequestHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="问题">问题</h1> <h2 id="如何让-token-在用户修改密码后失效">如何让 <code class="language-plaintext highlighter-rouge">token</code> 在用户修改密码后失效</h2> <p>一个情况是当用户发现自己的 <code class="language-plaintext highlighter-rouge">token</code> 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <p>这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 <code class="language-plaintext highlighter-rouge">id</code> 和密码修改的时间，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时，我们 需要验证 <code class="language-plaintext highlighter-rouge">token</code> 的发布时间是否在密码修改时间之前，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <h2 id="如何在用户进行登出操作后使-token-失效">如何在用户进行登出操作后使 <code class="language-plaintext highlighter-rouge">token</code> 失效</h2> <p>对于主动让一个 <code class="language-plaintext highlighter-rouge">token</code> 失效，我们可以采用黑名单机制，即将失效的 <code class="language-plaintext highlighter-rouge">token</code> 加入黑名单，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时， 我们需要验证 <code class="language-plaintext highlighter-rouge">token</code> 是否在黑名单中，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><category term="Token"/><summary type="html"><![CDATA[在实际上开发中我们可能会需要涉及到用户的认证和授权功能，Spring Security 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 JJWT 就能实现。 需求 考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 token 来进行访问，token 一定时间内有效，过期后需要重新登录。 对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 token 进行 解析，获取用户信息，然后进行比对。 双 token 模式 对于 token 的设计，我们可以采用双 token 模式，即一个 access token 和一个 refresh token，access token 用于访问，refresh token 用于刷新 access token。 这样的设计可以有效的保证安全性，因为 access token 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 refresh token 通常有效时间较长，但是只能用于刷新 access token，不能用于访问，且 refresh token 只有在每次 access token 过期后才会被传递，这样 refresh token 暴露的风险较小。 实现 JwtUtil 我们首先需要自定义一个工具类，该工具类可以生成和解析 token： public class JwtUtil { private static final String TOKEN_TYPE_CLAIM="tokenType"; private static final String ID_CLAIM="id"; private static final SecretKey SECRET_KEY=Jwts.SIG.HS256.key().build(); public static String generateToken(long id, TokenTypeEnum tokenType) { return Jwts.builder().issuedAt(new Date()) .expiration(new Date(System.currentTimeMillis() + (tokenType == TokenTypeEnum.ACCESS_TOKEN ? ApplicationConstant.ACCESS_TOKEN_EXPIRATION : ApplicationConstant.REFRESH_TOKEN_EXPIRATION))) .claim(ID_CLAIM, id) .claim(TOKEN_TYPE_CLAIM, tokenType.name()) .signWith(SECRET_KEY) .compact(); } public static String generateToken(String id, TokenTypeEnum tokenType) { return generateToken(Long.valueOf(id), tokenType); } public static String getID(String token) { return String.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(ID_CLAIM, Long.class)); } public static TokenTypeEnum getTokenType(String token) { return TokenTypeEnum.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(TOKEN_TYPE_CLAIM, String.class)); } } Filter 要实现认证和授权，我们可以通过 Filter 拦截所有的非登录和注册的业务请求，然后进行 token 的解析和验证： @Component @Order(Ordered.LOWEST_PRECEDENCE) public class JwtFilter extends OncePerRequestFilter { private Set&lt;String&gt; ignorePath=Set.of( ApiPathConstant.AUTHENTICATION_SIGN_UP_API_PATH, ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH, ); @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } private void authorize(HttpServletRequest request, String token) { switch (JwtUtil.getTokenType(token)) { case ACCESS_TOKEN: // ACCESS_TOKEN can not be used for refresh if (request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } String idInToken=JwtUtil.getID(token); switch (request.getMethod()) { case "GET": break; case "POST": // User can not update other user's information if (request.getRequestURI().startsWith(ApiPathConstant.USER_API_PREFIX) &amp;&amp; !idInToken.equals(getFromRequestBody(request, "id"))) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; case REFRESH_TOKEN: // REFRESH_TOKEN can only be used for refresh if (!request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } } private String getFromRequestBody(HttpServletRequest request, String key) { try { BufferedReader reader=request.getReader(); StringBuilder builder=new StringBuilder(); String line=reader.readLine(); while (line != null) { builder.append(line); line=reader.readLine(); } reader.close(); var json=JsonParserFactory.getJsonParser().parseMap(builder.toString()); return json.get(key).toString(); } catch (Exception e) { // unlikely to happen return null; } } } SignIn 对于登录接口，我们只需要返回额外 access token 和 refresh token，对于刷新服务我们直接返回新的 access token 即可： // 我们在 UserVO 中保存 token public record UserVO( Long id, String username, String email, String accessToken, String refreshToken) { public UserVO(UserPO userPO) { this(userPO.getId(), userPO.getUsername(), userPO.getEmail(), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.ACCESS_TOKEN), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.REFRESH_TOKEN)); } } @RestController public class AuthenticationController { @Autowired private UserService userService; @PostMapping(ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH) public ResponseEntity&lt;?&gt; signIn(@Validated @RequestBody UserSignInDTO user) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("username", user.username()); wrapper.eq("user_password", MD5Converter.convertToMD5(user.userPassword())); if (!userService.exists(wrapper)) { throw new IllegalArgumentException(ErrorMessageConstant.WRONG_SIGN_IN_INFORMATION); } return ResponseEntity.ok(new UserVO(userService.getOne(wrapper))); } @GetMapping(ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH) public String refreshToken(@RequestHeader("Token") String token) { return JwtUtil.generateToken(JwtUtil.getID(token), TokenTypeEnum.ACCESS_TOKEN); } } 问题 如何让 token 在用户修改密码后失效 一个情况是当用户发现自己的 token 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 token 失效。 这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 id 和密码修改的时间，每次验证 token 时，我们 需要验证 token 的发布时间是否在密码修改时间之前，如果是则说明 token 失效。 如何在用户进行登出操作后使 token 失效 对于主动让一个 token 失效，我们可以采用黑名单机制，即将失效的 token 加入黑名单，每次验证 token 时， 我们需要验证 token 是否在黑名单中，如果是则说明 token 失效。]]></summary></entry><entry><title type="html">Spring Filter 全局异常处理器</title><link href="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/" rel="alternate" type="text/html" title="Spring Filter 全局异常处理器"/><published>2024-08-27T12:21:09+00:00</published><updated>2024-08-27T12:21:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/exception-handler-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/"><![CDATA[<p>在之前的 <a href="/blog/2024/spring-validation-intro">Spring-Validation</a> 中简单介绍了如何通过 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解来处理全局异常，但是这种方式只能 处理 <code class="language-plaintext highlighter-rouge">Controller</code> 层抛出的异常。</p> <p>这篇文章介绍如何处理自定义 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常。</p> <h1 id="自定义-filter">自定义 <code class="language-plaintext highlighter-rouge">Filter</code></h1> <p>例如我们可能需要一个 <code class="language-plaintext highlighter-rouge">Filter</code> 来检验 <code class="language-plaintext highlighter-rouge">Token</code> 是否合法，而检查的过程中发现 <code class="language-plaintext highlighter-rouge">Token</code> 不合法，则抛出异常。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebFilter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：通过 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 注释的 <code class="language-plaintext highlighter-rouge">Filter</code> 需要在 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 启动类中添加 <code class="language-plaintext highlighter-rouge">@ServletComponentScan("xxx.xxx.xx")</code> 注解指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的查找路径。</p> <p>上面过程中抛出的异常不会被 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 捕获。</p> <h1 id="handlerexceptionresolver"><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code></h1> <p>实际上 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的异常处理是通过 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 来实现的。<code class="language-plaintext highlighter-rouge">Spring Boot</code> 中已经存在 两个默认的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，我们可以通过 <code class="language-plaintext highlighter-rouge">@Qualifier("HandlerExceptionResolver")</code> 配合 <code class="language-plaintext highlighter-rouge">@Autowired</code> 获取到负责处理异常的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，然后显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 方法来处理异常。</p> <h1 id="解决方案">解决方案</h1> <p>要实现这些，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">Filter</code> 并让其第一个执行，对捕获到的异常显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 进行处理就可以触发全局定义的异常处理器：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">HIGHEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExceptionHandlerFiter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"handlerExceptionResolver"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">HandlerExceptionResolver</span> <span class="n">resolver</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="na">resolveException</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：<code class="language-plaintext highlighter-rouge">@WebFilter</code> 不能指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序 (实际上是可以的，通过指定 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 中的 <code class="language-plaintext highlighter-rouge">filterName</code>，执行顺序是按照该字段的字典序)，要指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序，我们可以通 <code class="language-plaintext highlighter-rouge">@Order</code> 和 <code class="language-plaintext highlighter-rouge">@Component</code> 来实现，<code class="language-plaintext highlighter-rouge">@Order</code> 的值越小，执行顺序越靠前，上述例子的 <code class="language-plaintext highlighter-rouge">Ordered.HIGHEST_PRECEDENCE</code> 实际上是 <code class="language-plaintext highlighter-rouge">Integer.MIN_VALUE</code>。</p> <p><code class="language-plaintext highlighter-rouge">resolveException</code> 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">JwtException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ErrorVO</span> <span class="nf">handleJwtException</span><span class="o">(</span><span class="nc">JwtException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Invalid Token from {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">INVALID_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><summary type="html"><![CDATA[在之前的 Spring-Validation 中简单介绍了如何通过 @RestControllerAdvice 或者 @ControllerAdvice 注解来处理全局异常，但是这种方式只能 处理 Controller 层抛出的异常。 这篇文章介绍如何处理自定义 Filter 抛出的异常。 自定义 Filter 例如我们可能需要一个 Filter 来检验 Token 是否合法，而检查的过程中发现 Token 不合法，则抛出异常。 @WebFilter public class JwtFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } } 注意：通过 @WebFilter 注释的 Filter 需要在 @SpringBootApplication 启动类中添加 @ServletComponentScan("xxx.xxx.xx") 注解指定 Filter 的查找路径。 上面过程中抛出的异常不会被 @RestControllerAdvice 或者 @ControllerAdvice 捕获。 HandlerExceptionResolver 实际上 Spring Boot 的异常处理是通过 HandlerExceptionResolver 来实现的。Spring Boot 中已经存在 两个默认的 HandlerExceptionResolver，我们可以通过 @Qualifier("HandlerExceptionResolver") 配合 @Autowired 获取到负责处理异常的 HandlerExceptionResolver，然后显式调用 resolveException 方法来处理异常。 解决方案 要实现这些，我们只需要自定义一个 Filter 并让其第一个执行，对捕获到的异常显式调用 resolveException 进行处理就可以触发全局定义的异常处理器： @Component @Order(Ordered.HIGHEST_PRECEDENCE) public class ExceptionHandlerFiter extends OncePerRequestFilter { @Autowired @Qualifier("handlerExceptionResolver") private HandlerExceptionResolver resolver; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { filterChain.doFilter(request, response); } catch (Exception e) { resolver.resolveException(request, response, null, e); } } } 注意：@WebFilter 不能指定 Filter 的执行顺序 (实际上是可以的，通过指定 @WebFilter 中的 filterName，执行顺序是按照该字段的字典序)，要指定 Filter 的执行顺序，我们可以通 @Order 和 @Component 来实现，@Order 的值越小，执行顺序越靠前，上述例子的 Ordered.HIGHEST_PRECEDENCE 实际上是 Integer.MIN_VALUE。 resolveException 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 Filter 抛出的异常了： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(JwtException.class) public ErrorVO handleJwtException(JwtException e, HttpServletRequest request) { logger.error("Invalid Token from {}", request.getRemoteAddr()); return new ErrorVO(ErrorMessageConstant.INVALID_TOKEN); } }]]></summary></entry><entry><title type="html">使用 Spring-Validation 进行数据校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/" rel="alternate" type="text/html" title="使用 Spring-Validation 进行数据校验"/><published>2024-08-23T02:24:05+00:00</published><updated>2024-08-23T02:24:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/"><![CDATA[<p>在开发 <code class="language-plaintext highlighter-rouge">web</code> 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 <code class="language-plaintext highlighter-rouge">if else</code> 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 来进行数据 校验。</p> <h1 id="使用-jsr-303-注解">使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 注解</h1> <p><code class="language-plaintext highlighter-rouge">Spring-Validation</code> 提供了对于 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解的支持，我们可以使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解来对数据进行校验。</p> <p>简单来讲，对于一个 <code class="language-plaintext highlighter-rouge">DTO</code> 对象，我们可以在其属性上添加 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解，然后在 <code class="language-plaintext highlighter-rouge">Controller</code> 中对 参数使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解来对数据进行校验。</p> <p>例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 <code class="language-plaintext highlighter-rouge">DTO</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过上面的操作后，如果前端传入的数据不符合要求，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会抛出一个 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code> 异常，这个异常的默认处理方式是返回一个 <code class="language-plaintext highlighter-rouge">400</code> 的状态码和一个 <code class="language-plaintext highlighter-rouge">JSON</code> 格式的错误信息。我们可以自己定义异常处理器。</p> <h1 id="自定义异常处理器">自定义异常处理器</h1> <p>异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 <code class="language-plaintext highlighter-rouge">Controller</code> 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。</p> <h2 id="全局异常处理器">全局异常处理器</h2> <p>要定义一个全局异常处理器，我们可以创建一个类并且添加 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">e</span><span class="o">.</span><span class="na">getBindingResult</span><span class="o">().</span><span class="na">getFieldErrors</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">error</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">fieldName</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getField</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">errorMessage</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getDefaultMessage</span><span class="o">();</span>
            <span class="n">errors</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">errorMessage</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">errors</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 <code class="language-plaintext highlighter-rouge">Map</code> 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Username length must be between 1 and 20 characters"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="局部异常处理器">局部异常处理器</h2> <p>局部异常处理器的定义只需要将异常处理器定义在某个 <code class="language-plaintext highlighter-rouge">Controller</code> 中即可。</p> <h1 id="分组校验">分组校验</h1> <p>现在我们为上面的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象添加一个 <code class="language-plaintext highlighter-rouge">id</code> 字段，在创建用户的时候，不需要指定 <code class="language-plaintext highlighter-rouge">id</code> 字段，但是在更新 用户的时候，<code class="language-plaintext highlighter-rouge">id</code> 字段是必须的。这时候我们可以使用分组校验来解决这个问题。</p> <p>首先我们需要在 <code class="language-plaintext highlighter-rouge">DTO</code> 对象中定义一个分组：(这里使用内部类进行演示)</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Update</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Create</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>然后我们在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">@Validated</code> (此时不能使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 注解) 注解来指定分组：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PatchMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">updateUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="常用注解">常用注解</h1> <p><code class="language-plaintext highlighter-rouge">JSR 303</code> 中定义了很多注解，这里列出一些常用的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Null</code></td> <td>验证对象是否为 <code class="language-plaintext highlighter-rouge">null</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotNull</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>，无法查检长度为 <code class="language-plaintext highlighter-rouge">0</code>的字符串</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotBlank</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>、长度是否大于 <code class="language-plaintext highlighter-rouge">0</code>、是否包含至少一个非空白字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertFalse</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertTrue</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Min</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Max</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMin</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMax</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Digits</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是指定范围内的数字</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Past</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之前</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Future</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之后</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Size</code></td> <td>验证对象（<code class="language-plaintext highlighter-rouge">Array</code>、<code class="language-plaintext highlighter-rouge">Collection</code>、<code class="language-plaintext highlighter-rouge">Map</code>、<code class="language-plaintext highlighter-rouge">String</code>）长度是否在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Pattern</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否符合正则表达式的规则</td> </tr> </tbody> </table> <p>下面的注解是 <code class="language-plaintext highlighter-rouge">Hibernate Validator</code> 中定义的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Email</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是一个合法的电子邮件地址</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Length</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotEmpty</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code> 或者 <code class="language-plaintext highlighter-rouge">""</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Range</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否在给定的范围之内</td> </tr> </tbody> </table> <h1 id="messagesource-管理错误信息"><code class="language-plaintext highlighter-rouge">MessageSource</code> 管理错误信息</h1> <p>在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。</p> <p>为了解决这个问题，我们可以使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 来管理错误信息。</p> <p>首先我们在 <code class="language-plaintext highlighter-rouge">application.yml</code> ( 或者 <code class="language-plaintext highlighter-rouge">application.properties</code> ) 中添加如下配置：</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">messages</span><span class="pi">:</span>
    <span class="na">basename</span><span class="pi">:</span> <span class="s">message/message</span>
    <span class="na">encoding</span><span class="pi">:</span> <span class="s">UTF-8</span>
</code></pre></div></div> <p>标识我们的错误信息文件在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下的 <code class="language-plaintext highlighter-rouge">message</code> 目录中，文件名为 <code class="language-plaintext highlighter-rouge">message.properties</code> ( 只能 使用 <code class="language-plaintext highlighter-rouge">properties</code> 文件 )。</p> <p>接下来，我们在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下创建一个 <code class="language-plaintext highlighter-rouge">message</code> 目录，并且在其中创建一个 <code class="language-plaintext highlighter-rouge">message.properties</code> 文件， 在文件中添加如下内容：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
</code></pre></div></div> <p>然后我们可以直接在注解中的 <code class="language-plaintext highlighter-rouge">message</code> 部分使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的 <code class="language-plaintext highlighter-rouge">key</code> 来引用错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面通过 <code class="language-plaintext highlighter-rouge">message = "{xxx.xxx.xxx}"</code> 的方式获取变量是 <code class="language-plaintext highlighter-rouge">Hibernate</code> 提供的支持。而我们编写的字符串中 的 <code class="language-plaintext highlighter-rouge">{min}</code> 和 <code class="language-plaintext highlighter-rouge">{max}</code> 会被替换成注解中的 <code class="language-plaintext highlighter-rouge">min</code> 和 <code class="language-plaintext highlighter-rouge">max</code> 的值。</p> <p>但是我们在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="c1">// 通过构造器注入 MessageSource</span>
    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们可以在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">MessageSourceUtil</code> 来获取错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserControllerTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCreateUserInvalid</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span>
                <span class="sh">"""
                {
                    "name": "test",
                    "email": "invalid email address",
                    "userPassword": ""
                }
                """</span><span class="o">;</span>
        <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>
                        <span class="nc">MockMvcRequestBuilders</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">user</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpectAll</span><span class="o">(</span>
                        <span class="n">status</span><span class="o">().</span><span class="na">isBadRequest</span><span class="o">(),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.email"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">))),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.userPassword"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span>
                                        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span>
                                                <span class="s">"UserDTO.userPassword.Size"</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span>
                                                <span class="o">))),</span>
                        <span class="n">content</span><span class="o">().</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div> <p>在上面的代码中，我们同样将密码长度等常量信息放在了 <code class="language-plaintext highlighter-rouge">ConstantProperty</code> 类中，这样我们可以在测试中直接 引用这些常量。</p> <h2 id="国际化">国际化</h2> <p>实际上，<code class="language-plaintext highlighter-rouge">MessageSource</code> 是用来支持国际化的。在上面的例子中，我们只是使用了一个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 实际上我们可以使用多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件来支持多种语言。</p> <p>我们只需要在 <code class="language-plaintext highlighter-rouge">resources/message</code> (取决于我们指定的 <code class="language-plaintext highlighter-rouge">basename</code> ) 目录下创建多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 例如 <code class="language-plaintext highlighter-rouge">message.properties</code>、<code class="language-plaintext highlighter-rouge">message_en.properties</code>、<code class="language-plaintext highlighter-rouge">message_zh.properties</code> 等等。这样在发送请求的 时候，我们可以在请求头中添加 <code class="language-plaintext highlighter-rouge">Accept-Language</code> 来指定语言，<code class="language-plaintext highlighter-rouge">Spring</code> 会根据请求头中的语言来选择对应的 <code class="language-plaintext highlighter-rouge">properties</code> 文件中的信息。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在开发 web 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 if else 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 Spring-Validation 来进行数据 校验。 使用 JSR 303 注解 Spring-Validation 提供了对于 JSR 303 中的注解的支持，我们可以使用 JSR 303 中的注解来对数据进行校验。 简单来讲，对于一个 DTO 对象，我们可以在其属性上添加 JSR 303 中的注解，然后在 Controller 中对 参数使用 @Valid 或者 @Validated 注解来对数据进行校验。 例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 DTO 类： @Data public class UserDTO { @Size(min = 1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(message = "Email format is incorrect") @NotBlank(message = "Email cannot be blank") private String email; @Size(min = 6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; } 上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 @Valid 或者 @Validated 注解即可： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Valid @RequestBody UserDTO user) {} } 通过上面的操作后，如果前端传入的数据不符合要求，那么 Spring 会抛出一个 MethodArgumentNotValidException 异常，这个异常的默认处理方式是返回一个 400 的状态码和一个 JSON 格式的错误信息。我们可以自己定义异常处理器。 自定义异常处理器 异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 Controller 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。 全局异常处理器 要定义一个全局异常处理器，我们可以创建一个类并且添加 @RestControllerAdvice 或 @ControllerAdvice 注解： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public Map&lt;String, String&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException e) { Map&lt;String, String&gt; errors=new HashMap&lt;&gt;(); e.getBindingResult().getFieldErrors().forEach((error) -&gt; { String fieldName=error.getField(); String errorMessage=error.getDefaultMessage(); errors.put(fieldName, errorMessage); }); return errors; } } 在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 Map 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到： { "username": "Username length must be between 1 and 20 characters" } 局部异常处理器 局部异常处理器的定义只需要将异常处理器定义在某个 Controller 中即可。 分组校验 现在我们为上面的 DTO 对象添加一个 id 字段，在创建用户的时候，不需要指定 id 字段，但是在更新 用户的时候，id 字段是必须的。这时候我们可以使用分组校验来解决这个问题。 首先我们需要在 DTO 对象中定义一个分组：(这里使用内部类进行演示) @Data public class UserDTO { @NotNull(groups = Update.class) @Null(groups = Create.class) private Long id; @Size( groups={Update.class, Create.class}, min=1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(groups = {Update.class, Create.class}, message="Email format is incorrect") @NotBlank(groups = {Update.class, Create.class}, message="Email cannot be blank") private String email; @Size( groups={Update.class, Create.class}, min=6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; public interface Update {} public interface Create {} } 然后我们在 Controller 中使用 @Validated (此时不能使用 @Valid 注解) 注解来指定分组： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Validated(UserDTO.Create.class) @RequestBody UserDTO user) { return null; } @PatchMapping public ResponseEntity&lt;Void&gt; updateUser(@Validated(UserDTO.Update.class) @RequestBody UserDTO user) { return null; } } 常用注解 JSR 303 中定义了很多注解，这里列出一些常用的注解： 注解 说明 @Null 验证对象是否为 null @NotNull 验证对象是否不为 null，无法查检长度为 0的字符串 @NotBlank 验证 String 对象是否不为 null、长度是否大于 0、是否包含至少一个非空白字符 @AssertFalse 验证 Boolean 对象是否为 false @AssertTrue 验证 Boolean 对象是否为 true @Min 验证 Number 对象是否大于等于指定的值 @Max 验证 Number 对象是否小于等于指定的值 @DecimalMin 验证 Number 和 String 对象是否大于等于指定的值 @DecimalMax 验证 Number 和 String 对象是否小于等于指定的值 @Digits 验证 Number 和 String 对象是否是指定范围内的数字 @Past 验证 Date 对象是否是在当前时间之前 @Future 验证 Date 对象是否是在当前时间之后 @Size 验证对象（Array、Collection、Map、String）长度是否在给定的范围之内 @Pattern 验证 String 对象是否符合正则表达式的规则 下面的注解是 Hibernate Validator 中定义的注解： 注解 说明 @Email 验证 String 对象是否是一个合法的电子邮件地址 @Length 验证 String 对象是否是在给定的范围之内 @NotEmpty 验证对象是否不为 null 或者 "" @Range 验证 Number 对象是否在给定的范围之内 MessageSource 管理错误信息 在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。 为了解决这个问题，我们可以使用 MessageSource 来管理错误信息。 首先我们在 application.yml ( 或者 application.properties ) 中添加如下配置： spring: messages: basename: message/message encoding: UTF-8 标识我们的错误信息文件在 resources 目录下的 message 目录中，文件名为 message.properties ( 只能 使用 properties 文件 )。 接下来，我们在 resources 目录下创建一个 message 目录，并且在其中创建一个 message.properties 文件， 在文件中添加如下内容： # UserDTO validation messages UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters 然后我们可以直接在注解中的 message 部分使用 MessageSource 的 key 来引用错误信息： @Data public class UserDTO { @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_USERNAME_LENGTH, max=ConstantProperty.MAX_USERNAME_LENGTH, message="{UserDTO.username.Size}") private String username; @Email( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.Email}") @NotBlank( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.NotBlank}") private String email; @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_PASSWORD_LENGTH, max=ConstantProperty.MAX_PASSWORD_LENGTH, message="{UserDTO.userPassword.Size}") private String userPassword; } 上面通过 message="{xxx.xxx.xxx}" 的方式获取变量是 Hibernate 提供的支持。而我们编写的字符串中 的 {min} 和 {max} 会被替换成注解中的 min 和 max 的值。 但是我们在使用 MessageSource 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量： @Component public class MessageSourceUtil { private static MessageSource messageSource; // 通过构造器注入 MessageSource MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(String code, Object[] args) { String message=messageSource.getMessage(code, null, null); // 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值 Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 这样我们可以在 Controller 中使用 MessageSourceUtil 来获取错误信息： @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mvc; @Test public void testCreateUserInvalid() throws Exception { String user=""" { "name": "test", "email": "invalid email address", "userPassword": "" } """; mvc.perform( MockMvcRequestBuilders.post("/user") .contentType(MediaType.APPLICATION_JSON) .content(user)) .andExpectAll( status().isBadRequest(), jsonPath( "$.email", equalTo(MessageSourceUtil.getMessage("UserDTO.email.Email"))), jsonPath( "$.userPassword", equalTo( MessageSourceUtil.getMessage( "UserDTO.userPassword.Size", ConstantProperty.MIN_PASSWORD_LENGTH, ConstantProperty.MAX_PASSWORD_LENGTH ))), content().contentType(MediaType.APPLICATION_JSON)); } 在上面的代码中，我们同样将密码长度等常量信息放在了 ConstantProperty 类中，这样我们可以在测试中直接 引用这些常量。 国际化 实际上，MessageSource 是用来支持国际化的。在上面的例子中，我们只是使用了一个 properties 文件， 实际上我们可以使用多个 properties 文件来支持多种语言。 我们只需要在 resources/message (取决于我们指定的 basename ) 目录下创建多个 properties 文件， 例如 message.properties、message_en.properties、message_zh.properties 等等。这样在发送请求的 时候，我们可以在请求头中添加 Accept-Language 来指定语言，Spring 会根据请求头中的语言来选择对应的 properties 文件中的信息。]]></summary></entry><entry><title type="html">Python 高级技巧学习</title><link href="https://kaiser-yang.github.io/blog/2024/python-advanced-skills/" rel="alternate" type="text/html" title="Python 高级技巧学习"/><published>2024-08-22T12:34:45+00:00</published><updated>2024-08-22T12:34:45+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/python-advanced-skills</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/python-advanced-skills/"><![CDATA[<p>本文介绍一些 <code class="language-plaintext highlighter-rouge">Python</code> 高级技巧。</p> <h1 id="拆包">拆包</h1> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中，我们可以使用拆包的方式来将一个序列或者字典中的元素赋值给多个变量。下面是最简单的用法：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 1 2
</span></code></pre></div></div> <p>我们还可以使用 <code class="language-plaintext highlighter-rouge">*</code> 来拆包，<code class="language-plaintext highlighter-rouge">*</code> 会将多个元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 1 [2, 3]
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在中间位置，这样可以将中间的元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 1 [2, 3] 4
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在左边，这样可以将右边的元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># [1, 2] 3
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以直接用在列表变量中，这样可以将列表中的所有元素拆包为多个变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># [1, 2, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="c1"># 1 2 3
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在字典中，这样可以将字典中的所有键拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 'a' ['b', 'c']
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 可以用在函数的参数中，这样可以将参数拆包为多个参数：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1"># (1, 2, (3, 4, 5))
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">**</code> 可以用在函数的参数中，这样可以将参数记录成字典：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">g1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">g1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># (1, 2, {'x': 3, 'y': 4, 'z': 5})
</span></code></pre></div></div> <h1 id="fstring"><code class="language-plaintext highlighter-rouge">fstring</code></h1> <p><code class="language-plaintext highlighter-rouge">fstring</code> 是 <code class="language-plaintext highlighter-rouge">Python 3.6</code> 新增的字符串格式化方法，可以使用 <code class="language-plaintext highlighter-rouge">{}</code> 和 <code class="language-plaintext highlighter-rouge">f</code> 前缀来格式化字符串。</p> <h2 id="r-s-和-a"><code class="language-plaintext highlighter-rouge">!r</code>, <code class="language-plaintext highlighter-rouge">!s</code> 和 <code class="language-plaintext highlighter-rouge">!a</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">!r</code> 和 <code class="language-plaintext highlighter-rouge">!s</code> 分别表示调用对象的 <code class="language-plaintext highlighter-rouge">__repr__</code> 和 <code class="language-plaintext highlighter-rouge">__str__</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">!a</code> 则会调用 <code class="language-plaintext highlighter-rouge">ascii</code>，注意这里没有以 <code class="language-plaintext highlighter-rouge">__</code> 开头结尾，这是一个 <code class="language-plaintext highlighter-rouge">Python</code> 提供的方法，不是一个特殊方法。</p> <p>在默认情况下 <code class="language-plaintext highlighter-rouge">f'{number}</code> 会调用 <code class="language-plaintext highlighter-rouge">number.__str__</code> 方法，而 <code class="language-plaintext highlighter-rouge">f'{number!r}</code> 会调用 <code class="language-plaintext highlighter-rouge">number.__repr__</code> 方法。</p> <h2 id="f-e-e-g-和-"><code class="language-plaintext highlighter-rouge">:f</code>, <code class="language-plaintext highlighter-rouge">:e</code>, <code class="language-plaintext highlighter-rouge">:E</code>, <code class="language-plaintext highlighter-rouge">:g</code> 和 <code class="language-plaintext highlighter-rouge">:%</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:f</code>, <code class="language-plaintext highlighter-rouge">:e</code>, <code class="language-plaintext highlighter-rouge">:E</code>, <code class="language-plaintext highlighter-rouge">:g</code> 和 <code class="language-plaintext highlighter-rouge">:%</code> 分别表示浮点数、科学计数法、科学计数法大写、通用格式和百分比。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mf">123.456</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123.456000'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">e</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '1.234560e+02'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">E</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '1.234560E+02'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">g</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123.456'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">%</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '12345.600000%'
</span></code></pre></div></div> <h2 id="--和-"><code class="language-plaintext highlighter-rouge">:&gt;</code>, <code class="language-plaintext highlighter-rouge">:&lt;</code> 和 <code class="language-plaintext highlighter-rouge">:^</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:&gt;</code>, <code class="language-plaintext highlighter-rouge">:&lt;</code> 和 <code class="language-plaintext highlighter-rouge">:^</code> 分别表示右对齐、左对齐和居中对齐。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">123</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '     123'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">&lt;</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123     '
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">^</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '  123   '
</span></code></pre></div></div> <p>我们还可以指定填充字符，例如 <code class="language-plaintext highlighter-rouge">f'{number:0&gt;8}</code> 表示右对齐，不足 8 位的部分用 <code class="language-plaintext highlighter-rouge">0</code> 填充。</p> <h2 id="b-d-o-x-和-x"><code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code> 分别表示二进制、十进制、八进制、十六进制小写和十六进制大写。</p> <p>例如 <code class="language-plaintext highlighter-rouge">f'{number:b}</code> 表示将 <code class="language-plaintext highlighter-rouge">number</code> 转换为二进制字符串。还可以通过设置宽度和填充字符来格式化字符串，例如 <code class="language-plaintext highlighter-rouge">f'{number:08b}</code> 表示将 <code class="language-plaintext highlighter-rouge">number</code> 转换为 8 位的二进制字符串，不足 8 位的部分用 <code class="language-plaintext highlighter-rouge">0</code> 填充。</p> <h2 id="千分位分隔符">千分位分隔符</h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中可以使用 <code class="language-plaintext highlighter-rouge">,</code> 等来添加千分位分隔符。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">1234567890</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="p">,</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 1,234,567,890
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">_</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 123_456_7890
</span></code></pre></div></div> <h3 id="自定义-__format__-方法">自定义 <code class="language-plaintext highlighter-rouge">__format__</code> 方法</h3> <p>我们可以通过自定义 <code class="language-plaintext highlighter-rouge">__format__</code> 方法来实现自定义的格式化方法。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">b</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">o</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">x</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">X</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="p">)</span>

<span class="n">number</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">b</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00001010'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00000010'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">o</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00000012'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">x</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '0000000a'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">X</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '0000000A'
</span></code></pre></div></div> <p>上面的代码中，我们更改了 <code class="language-plaintext highlighter-rouge">Number</code> 类的 <code class="language-plaintext highlighter-rouge">__format__</code> 方法，使得 <code class="language-plaintext highlighter-rouge">Number</code> 类的 <code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code> 变成了 <code class="language-plaintext highlighter-rouge">8</code> 位的二进制、十进制、八进制、十六进制小写和十六进制大写。</p> <h1 id="matchcase-语句"><code class="language-plaintext highlighter-rouge">match/case</code> 语句</h1> <p><code class="language-plaintext highlighter-rouge">Python 3.10</code> 新增了 <code class="language-plaintext highlighter-rouge">match/case</code> 语句，这是一种新的模式匹配语法，可以替代 <code class="language-plaintext highlighter-rouge">if/elif/else</code> 语句。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Blue</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Red
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match</code> 语句会依次匹配 <code class="language-plaintext highlighter-rouge">case</code> 语句，如果匹配成功则执行对应的代码块，如果没有匹配成功则执行 <code class="language-plaintext highlighter-rouge">_</code> 代码块。</p> <p><code class="language-plaintext highlighter-rouge">match</code> 语句还可以使用 <code class="language-plaintext highlighter-rouge">|</code> 来匹配多个值：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Primary</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">magenta</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">yellow</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Secondary</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Primary
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match</code> 语句还可以使用 <code class="language-plaintext highlighter-rouge">if</code> 来添加条件：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="c1"># Light Red
</span></code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">case</code> 语句中，我们可以指定匹配模式：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="c1"># 也可以使用 *_ 来匹配任意项
</span>        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">([</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span> <span class="c1"># Light Red
</span><span class="nf">match_color</span><span class="p">([</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span> <span class="c1"># Dark Red
</span></code></pre></div></div> <p>还可以使用 <code class="language-plaintext highlighter-rouge">as</code> 来重新命名变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Light </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Dark </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Light </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Dark </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">([(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># Light ('red', True)
</span></code></pre></div></div> <p>需要注意的是，只有以下的类型支持对序列进行拆分的写法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">list</code></li> <li><code class="language-plaintext highlighter-rouge">memoryview</code></li> <li><code class="language-plaintext highlighter-rouge">array.array</code></li> <li><code class="language-plaintext highlighter-rouge">tuple</code></li> <li><code class="language-plaintext highlighter-rouge">range</code></li> <li><code class="language-plaintext highlighter-rouge">collections.deque</code></li> </ul> <p>需要注意的是在序列结构中使用 <code class="language-plaintext highlighter-rouge">str()</code> 等是标明匹配项必须是 <code class="language-plaintext highlighter-rouge">str</code> 类型，而不是进行字符串转换：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nf">bool</span><span class="p">(</span><span class="n">light</span><span class="p">)]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light </span><span class="sh">'</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> <span class="c1"># Unknown
</span><span class="nf">match_color</span><span class="p">((</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> <span class="c1"># Light red
</span></code></pre></div></div> <h1 id="特殊方法">特殊方法</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的特殊方法也叫魔术方法 (<code class="language-plaintext highlighter-rouge">Magic Method</code>)，这些方法以 <code class="language-plaintext highlighter-rouge">__</code> 开头和结尾，比如 <code class="language-plaintext highlighter-rouge">__init__</code>、 <code class="language-plaintext highlighter-rouge">__str__</code>、<code class="language-plaintext highlighter-rouge">__repr__</code> 等。这些方法是 <code class="language-plaintext highlighter-rouge">Python</code> 解释器调用的，我们可以重写这些方法，从而实现自定义的功能。</p> <p>这里给出常用的特殊方法的定义与调用方式。</p> <h2 id="类型转换">类型转换</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__bool__(self)</code></td> <td>布尔化</td> <td><code class="language-plaintext highlighter-rouge">bool(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__int__(self)</code></td> <td>整型化</td> <td><code class="language-plaintext highlighter-rouge">int(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__float__(self)</code></td> <td>浮点化</td> <td><code class="language-plaintext highlighter-rouge">float(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__complex__(self)</code></td> <td>复数化</td> <td><code class="language-plaintext highlighter-rouge">complex(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__bytes__(self)</code></td> <td>字节化</td> <td><code class="language-plaintext highlighter-rouge">bytes(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__str__(self)</code></td> <td>字符串化</td> <td><code class="language-plaintext highlighter-rouge">str(obj)</code></td> </tr> </tbody> </table> <h2 id="一元运算符">一元运算符</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__neg__(self)</code></td> <td>取负</td> <td><code class="language-plaintext highlighter-rouge">-obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__pos__(self)</code></td> <td>取正</td> <td><code class="language-plaintext highlighter-rouge">+obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__abs__(self)</code></td> <td>取绝对值</td> <td><code class="language-plaintext highlighter-rouge">abs(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__round__(self, ndigits)</code></td> <td>四舍五入</td> <td><code class="language-plaintext highlighter-rouge">round(obj, ndigits)</code></td> </tr> </tbody> </table> <h2 id="算数运算">算数运算</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__add__(self, other)</code></td> <td>加法</td> <td><code class="language-plaintext highlighter-rouge">obj + other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__sub__(self, other)</code></td> <td>减法</td> <td><code class="language-plaintext highlighter-rouge">obj - other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__mul__(self, other)</code></td> <td>乘法</td> <td><code class="language-plaintext highlighter-rouge">obj * other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__truediv__(self, other)</code></td> <td>除法</td> <td><code class="language-plaintext highlighter-rouge">obj / other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__floordiv__(self, other)</code></td> <td>整除</td> <td><code class="language-plaintext highlighter-rouge">obj // other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__mod__(self, other)</code></td> <td>取模</td> <td><code class="language-plaintext highlighter-rouge">obj % other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__pow__(self, other)</code></td> <td>幂运算</td> <td><code class="language-plaintext highlighter-rouge">obj ** other</code></td> </tr> </tbody> </table> <p>说明：上述的所有方法增加了 <code class="language-plaintext highlighter-rouge">r</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__radd__</code>、<code class="language-plaintext highlighter-rouge">__rsub__</code> 等，表示反向运算，即 <code class="language-plaintext highlighter-rouge">other + obj</code>。 增加了 <code class="language-plaintext highlighter-rouge">i</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__iadd__</code>、<code class="language-plaintext highlighter-rouge">__isub__</code> 等，表示增量运算，即 <code class="language-plaintext highlighter-rouge">obj += other</code>。</p> <h2 id="比较">比较</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__eq__(self, other)</code></td> <td>等于</td> <td><code class="language-plaintext highlighter-rouge">obj == other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__ne__(self, other)</code></td> <td>不等于</td> <td><code class="language-plaintext highlighter-rouge">obj != other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__lt__(self, other)</code></td> <td>小于</td> <td><code class="language-plaintext highlighter-rouge">obj &lt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__le__(self, other)</code></td> <td>小于等于</td> <td><code class="language-plaintext highlighter-rouge">obj &lt;= other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__gt__(self, other)</code></td> <td>大于</td> <td><code class="language-plaintext highlighter-rouge">obj &gt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__ge__(self, other)</code></td> <td>大于等于</td> <td><code class="language-plaintext highlighter-rouge">obj &gt;= other</code></td> </tr> </tbody> </table> <h2 id="迭代">迭代</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__len__(self)</code></td> <td>长度</td> <td><code class="language-plaintext highlighter-rouge">len(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__getitem__(self, pos)</code></td> <td>获取元素</td> <td><code class="language-plaintext highlighter-rouge">obj[pos]</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__setitem__(self, pos, value)</code></td> <td>设置元素</td> <td><code class="language-plaintext highlighter-rouge">obj[pos] = value</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__iter__(self)</code></td> <td>迭代器</td> <td><code class="language-plaintext highlighter-rouge">for i in obj:</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__contains__(self, value)</code></td> <td>是否包含</td> <td><code class="language-plaintext highlighter-rouge">value in obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__next__(self)</code></td> <td>下一个</td> <td><code class="language-plaintext highlighter-rouge">next(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__reversed__(self)</code></td> <td>反向迭代器</td> <td><code class="language-plaintext highlighter-rouge">reversed(obj)</code></td> </tr> </tbody> </table> <h2 id="位运算">位运算</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__and__(self, other)</code></td> <td>与运算</td> <td><code class="language-plaintext highlighter-rouge">obj &amp; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__or__(self, other)</code></td> <td>或运算</td> <td><code class="language-plaintext highlighter-rouge">obj | other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__xor__(self, other)</code></td> <td>异或运算</td> <td><code class="language-plaintext highlighter-rouge">obj ^ other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__lshift__(self, other)</code></td> <td>左移</td> <td><code class="language-plaintext highlighter-rouge">obj &lt;&lt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__rshift__(self, other)</code></td> <td>右移</td> <td><code class="language-plaintext highlighter-rouge">obj &gt;&gt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__invert__(self)</code></td> <td>取反</td> <td><code class="language-plaintext highlighter-rouge">~obj</code></td> </tr> </tbody> </table> <p>说明：上述的所有方法增加了 <code class="language-plaintext highlighter-rouge">r</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__rand__</code>、<code class="language-plaintext highlighter-rouge">__ror__</code> 等，表示反向运算，即 <code class="language-plaintext highlighter-rouge">other &amp; obj</code>。 增加了 <code class="language-plaintext highlighter-rouge">i</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__iand__</code>、<code class="language-plaintext highlighter-rouge">__ior__</code> 等，表示增量运算，即 <code class="language-plaintext highlighter-rouge">obj &amp;= other</code>。</p> <h2 id="构造与析构">构造与析构</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__init__(self, ...)</code></td> <td>构造方法</td> <td><code class="language-plaintext highlighter-rouge">obj = CalssName(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__new__(cls, ...)</code></td> <td>创建对象</td> <td><code class="language-plaintext highlighter-rouge">obj = ClassName(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__del__(self)</code></td> <td>析构方法</td> <td><code class="language-plaintext highlighter-rouge">del obj</code></td> </tr> </tbody> </table> <p>其中的 <code class="language-plaintext highlighter-rouge">__new__</code> 方法是一个类方法，用于创建对象，而 <code class="language-plaintext highlighter-rouge">__init__</code> 方法是一个实例方法，用于初始化对象。 <code class="language-plaintext highlighter-rouge">__new__</code> 方法需要返回一个对象，通常是调用父类的 <code class="language-plaintext highlighter-rouge">__new__</code> 方法，这个返回值会传递给 <code class="language-plaintext highlighter-rouge">__init__</code> 方法， 而 <code class="language-plaintext highlighter-rouge">__init__</code> 方法不需要返回值。</p> <h2 id="其他">其他</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__repr__(self)</code></td> <td>表示形式</td> <td><code class="language-plaintext highlighter-rouge">repr(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__format__(self, format_spec)</code></td> <td>格式化</td> <td><code class="language-plaintext highlighter-rouge">format(obj, format_spec)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__hash__(self)</code></td> <td>哈希值</td> <td><code class="language-plaintext highlighter-rouge">hash(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__index__</code></td> <td>索引值</td> <td><code class="language-plaintext highlighter-rouge">index(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__call__(self, ...)</code></td> <td>调用</td> <td><code class="language-plaintext highlighter-rouge">obj(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__delitem__(self, pos)</code></td> <td>删除元素</td> <td><code class="language-plaintext highlighter-rouge">del obj[pos]</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__getattr__(self, name)</code></td> <td>获取属性</td> <td><code class="language-plaintext highlighter-rouge">obj.name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__setattr__(self, name, value)</code></td> <td>设置属性</td> <td><code class="language-plaintext highlighter-rouge">obj.name = value</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__delattr__(self, name)</code></td> <td>删除属性</td> <td><code class="language-plaintext highlighter-rouge">del obj.name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__enter__(self)</code></td> <td>上下文管理器</td> <td><code class="language-plaintext highlighter-rouge">with obj as ...:</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__exit__(self, exc_type, exc_value, traceback)</code></td> <td>上下文管理器</td> <td><code class="language-plaintext highlighter-rouge">with obj as ...:</code></td> </tr> </tbody> </table> <p>注意：实现方法后的调用方式可能并不只有一种，比如 <code class="language-plaintext highlighter-rouge">__str__</code> 方法可以通过 <code class="language-plaintext highlighter-rouge">str(obj)</code> 或 <code class="language-plaintext highlighter-rouge">print(obj)</code> 来调用。 而如果实现了 <code class="language-plaintext highlighter-rouge">__bool__</code>，那么 <code class="language-plaintext highlighter-rouge">not</code>、<code class="language-plaintext highlighter-rouge">and</code> 和 <code class="language-plaintext highlighter-rouge">or</code> 也会调用这个方法。</p> <p>注意：<code class="language-plaintext highlighter-rouge">Python</code> 中的很多特殊方法即使不进行实现也能使用其支持的调用形式，例如对于一个只实现了 <code class="language-plaintext highlighter-rouge">__add__</code> 方法的类，也可以使用 <code class="language-plaintext highlighter-rouge">a += b</code> 这种形式，此时会被解释为 <code class="language-plaintext highlighter-rouge">a = a + b</code>，即先调用 <code class="language-plaintext highlighter-rouge">__add__</code> 方法，然后进行赋值。</p> <h1 id="海象运算符-">海象运算符 <code class="language-plaintext highlighter-rouge">:=</code></h1> <p>这个符号被称为海象运算符，仅仅是因为它的形状像海象。</p> <p><code class="language-plaintext highlighter-rouge">:=</code> 运算符是 <code class="language-plaintext highlighter-rouge">Python 3.8</code> 新增的，它可以在表达式中赋值，这样我们就可以在表达式中使用赋值的变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>一个更加常见的例子是在循环中使用 <code class="language-plaintext highlighter-rouge">:=</code> 运算符：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">while </span><span class="p">(</span><span class="n">line</span> <span class="p">:</span><span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">readline</span><span class="p">()):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">())</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="nb">file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">())</span>
</code></pre></div></div> <p>我们还可以在列表推导式中使用 <code class="language-plaintext highlighter-rouge">:=</code> 运算符。这种情况下，我们往往需要将计算后的结果放到列表中：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="nf">if </span><span class="p">(</span><span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></div></div> <p>上面的代码能够帮我简化一次 <code class="language-plaintext highlighter-rouge">n * 2</code> 的计算，对于一些复杂的计算，这种方式会更加简洁且效率更高。</p> <h2 id="海象运算符变量的作用域">海象运算符变量的作用域</h2> <p><code class="language-plaintext highlighter-rouge">:=</code> 运算符定义的变量的作用域是当前函数，除非目标变量使用 <code class="language-plaintext highlighter-rouge">global</code> 或者 <code class="language-plaintext highlighter-rouge">nonlocal</code> 修饰：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># OK
</span></code></pre></div></div> <h1 id="切片">切片</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的切片是一个非常强大的功能，我们可以使用切片来获取列表、元组、字符串等序列的子序列。</p> <h2 id="切片对象">切片对象</h2> <p>除了基础的切片用法之外，我们可以通过 <code class="language-plaintext highlighter-rouge">slice</code> 类来创建切片对象，这样我们就可以在多个地方使用同一个切片对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">s1</span> <span class="o">=</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># start = 1, end = 5, step = 1
</span><span class="n">s2</span> <span class="o">=</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># start = 1, end = None, step = 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">s1</span><span class="p">])</span> <span class="c1"># [2, 3, 4, 5]
</span><span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">s2</span><span class="p">])</span> <span class="c1"># [2, 3, 4, 5, 6, 7, 8, 9]
</span></code></pre></div></div> <p>切片获取到的对象可以通过赋值来修改原对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 10, 20, 30, 40, 6, 7, 8, 9]
</span></code></pre></div></div> <p>上面的例子说明切片获取到的是引用，对于可变对象而言我们可以修改切片后，原对象也会发生变化：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="c1"># 修改切片的第一个元素的第一个值
</span><span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 等价于 test[0][0] = -1
</span><span class="nf">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="c1"># [[-1, 2, 3], [4, 5, 6], [7, 8, 9]]
</span>
<span class="c1"># test 中保存的是不可变对象，所以 test 本身不会发生变化
</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="c1"># [1, 2, 3]
</span></code></pre></div></div> <h1 id="memoryview"><code class="language-plaintext highlighter-rouge">memoryview</code></h1> <p><code class="language-plaintext highlighter-rouge">memoryview</code> 是一个内置类，它可以让我们直接操作内存，而不需要复制数据。<code class="language-plaintext highlighter-rouge">memoryview</code> 对象可以通过 <code class="language-plaintext highlighter-rouge">memoryview()</code> 函数创建。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1"># 此时 mem 和 number 共享内存，但是此时我们可以随意更改 mem 的形状等
</span><span class="n">mem</span> <span class="o">=</span> <span class="nf">memoryview</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># 2 行 3 列
</span><span class="nf">print</span><span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="nf">tolist</span><span class="p">())</span> <span class="c1"># [[1, 2, 3], [4, 5, 6]]
</span><span class="n">mem</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 2, 3, 4, 5, 100]
</span></code></pre></div></div> <h1 id="字典">字典</h1> <h2 id="字典推导式">字典推导式</h2> <p>我们可以使用列表推导式快速创建列表，实际上，对于字典的创建也有类似的语法：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">}</span>
</code></pre></div></div> <h2 id="在-matchcase-中匹配字典">在 <code class="language-plaintext highlighter-rouge">match/case</code> 中匹配字典</h2> <p><code class="language-plaintext highlighter-rouge">match/case</code> 语句还可以用来匹配字典：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">False</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">False</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">({</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span> <span class="c1"># Light Red
</span></code></pre></div></div> <p>上面的匹配式的意思是只要含有这些键值对的都会被匹配，而且顺序不重要，即使是一个 <code class="language-plaintext highlighter-rouge">OrderDict</code> 也会被忽略 顺序。</p> <h1 id="集合">集合</h1> <h2 id="集合推导式">集合推导式</h2> <p>也可以使用集合推导式创建集合：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">}</span>
</code></pre></div></div> <h2 id="判断集合的包含关系">判断集合的包含关系</h2> <p>使用比较运算符可以判断集合的包含关系：</p> <table> <thead> <tr> <th>运算符</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;=</code></td> <td>子集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;</code></td> <td>真子集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;=</code></td> <td>超集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;</code></td> <td>真超集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">==</code></td> <td>相等</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">!=</code></td> <td>不相等</td> </tr> </tbody> </table> <h1 id="可变对象与不可变对象">可变对象与不可变对象</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的对象分为可变对象和不可变对象，可变对象是指对象的值可以改变，而不可变对象是指对象的值不可以改变。</p> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的不可变对象有：<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">complex</code>、<code class="language-plaintext highlighter-rouge">str</code>、<code class="language-plaintext highlighter-rouge">tuple</code>、<code class="language-plaintext highlighter-rouge">frozenset</code> 等。</p> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的可变对象有：<code class="language-plaintext highlighter-rouge">list</code>、<code class="language-plaintext highlighter-rouge">dict</code>、<code class="language-plaintext highlighter-rouge">set</code> 等。</p> <p>一个对象如果可以通过 <code class="language-plaintext highlighter-rouge">hash</code> 函数计算哈希值且不抛出异常，那么这个对象就是不可变对象。例如我们可以通过 以下的代码来判断一个对象是否是可变对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nf">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span> <span class="c1"># True
</span></code></pre></div></div> <h2 id="避免可变对象作为默认值">避免可变对象作为默认值</h2> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中如果使用可变对象绑定到默认值，那么在函数调用时会共享这个可变对象，这样会导致默认值的改变：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1, 1]
</span></code></pre></div></div> <p>如果我们想要避免这种情况，我们可以使用 <code class="language-plaintext highlighter-rouge">None</code> 作为默认值，然后在函数内部判断是否为 <code class="language-plaintext highlighter-rouge">None</code>，然后创建一个新的对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span></code></pre></div></div> <h1 id="类属性和实例属性">类属性和实例属性</h1> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中，存在类属性和实例属性的区分，一般而言，类属性可以通过在类的开头定义，而实例对象可以在 <code class="language-plaintext highlighter-rouge">__init__</code> 方法中定义。类属性可以通过类名或者实例对象访问，而实例属性则可以通过实例对象访问。例如：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">class_attr</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">instance_attr</span><span class="p">)</span> <span class="c1"># 2
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span></code></pre></div></div> <p>如果通过实例对象去修改类属性，那么实际上是创建了一个新的实例属性：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 创建一个新的实例对象，名字与类属性相同
</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 3
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
# 可以通过 del 删除实例属性
</span><span class="k">del</span> <span class="n">a</span><span class="p">.</span><span class="n">class_attr</span>
<span class="c1"># 由于实例对象的 class_attr 属性被删除，所以会访问类属性
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span></code></pre></div></div> <h2 id="静态方法类方法和实例方法">静态方法、类方法和实例方法</h2> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 的类中，有三种方法：静态方法、类方法和实例方法。</p> <p>首先介绍最常见的实例方法，实例方法的第一个参数是 <code class="language-plaintext highlighter-rouge">self</code>，表示实例对象本身：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">instance_method</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 实例方法可以访问实例属性
</span>        <span class="k">return</span> <span class="n">self</span>
</code></pre></div></div> <p>实例方法可以通过实例对象调用，也可以通过类对象调用，但是需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">())</span> <span class="c1"># &lt;__main__.A object at 0x7f8b3c7b3d30&gt;
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c1"># &lt;__main__.A object at 0x7f8b3c7b3d30&gt;
</span></code></pre></div></div> <p>类方法使用 <code class="language-plaintext highlighter-rouge">@classmethod</code> 装饰器来定义，类方法的第一个参数是 <code class="language-plaintext highlighter-rouge">cls</code>，表示类对象本身：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_method</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="c1"># 类方法可以访问类属性
</span>        <span class="k">return</span> <span class="n">cls</span>
</code></pre></div></div> <p>类方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">class_method</span><span class="p">())</span> <span class="c1"># &lt;class '__main__.A'&gt;
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">class_method</span><span class="p">())</span> <span class="c1"># &lt;class '__main__.A'&gt;
</span></code></pre></div></div> <p>静态方法使用 <code class="language-plaintext highlighter-rouge">@staticmethod</code> 装饰器来定义，静态方法没有 <code class="language-plaintext highlighter-rouge">self</code> 和 <code class="language-plaintext highlighter-rouge">cls</code> 参数：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_method</span><span class="p">():</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s">static method</span><span class="sh">'</span>
</code></pre></div></div> <p>静态方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">static_method</span><span class="p">())</span> <span class="c1"># static method
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">static_method</span><span class="p">())</span> <span class="c1"># static method
</span></code></pre></div></div> <p>静态方法其实更像是一个普通的函数，它不能访问类属性和实例属性，但是他可以被实例方法或者类方法调用， 所以如果需要处理的逻辑只会被当前的类多次调用，那么可以使用静态方法实现代码的复用。</p>]]></content><author><name></name></author><category term="Python"/><summary type="html"><![CDATA[本文介绍一些 Python 高级技巧。 拆包 在 Python 中，我们可以使用拆包的方式来将一个序列或者字典中的元素赋值给多个变量。下面是最简单的用法： a, b=(1, 2) print(a, b) # 1 2 我们还可以使用 * 来拆包，* 会将多个元素拆包为一个列表： a, *b = (1, 2, 3) print(a, b) # 1 [2, 3] * 还可以用在中间位置，这样可以将中间的元素拆包为一个列表： a, *b, c=(1, 2, 3, 4) print(a, b, c) # 1 [2, 3] 4 * 还可以用在左边，这样可以将右边的元素拆包为一个列表： *a, b=(1, 2, 3) print(a, b) # [1, 2] 3 * 还可以直接用在列表变量中，这样可以将列表中的所有元素拆包为多个变量： a=[1, 2, 3] print(a) # [1, 2, 3] print(*a) # 1 2 3 * 还可以用在字典中，这样可以将字典中的所有键拆包为一个列表： a, *b = {'a': 1, 'b': 2, 'c': 3} print(a, b) # 'a' ['b', 'c'] * 可以用在函数的参数中，这样可以将参数拆包为多个参数： def f1(a, b, *c): return a, b, c print(f1(1, 2, 3, 4, 5)) # (1, 2, (3, 4, 5)) ** 可以用在函数的参数中，这样可以将参数记录成字典： def g1(a, b, **c): return a, b, c print(g1(1, 2, x=3, y=4, z=5)) # (1, 2, {'x': 3, 'y': 4, 'z': 5}) fstring fstring 是 Python 3.6 新增的字符串格式化方法，可以使用 {} 和 f 前缀来格式化字符串。 !r, !s 和 !a fstring 中的 !r 和 !s 分别表示调用对象的 __repr__ 和 __str__ 方法。 !a 则会调用 ascii，注意这里没有以 __ 开头结尾，这是一个 Python 提供的方法，不是一个特殊方法。 在默认情况下 f'{number} 会调用 number.__str__ 方法，而 f'{number!r} 会调用 number.__repr__ 方法。 :f, :e, :E, :g 和 :% fstring 中的 :f, :e, :E, :g 和 :% 分别表示浮点数、科学计数法、科学计数法大写、通用格式和百分比。 number=123.456 print(f'{number:f}') # '123.456000' print(f'{number:e}') # '1.234560e+02' print(f'{number:E}') # '1.234560E+02' print(f'{number:g}') # '123.456' print(f'{number:%}') # '12345.600000%' :&gt;, :&lt; 和 :^ fstring 中的 :&gt;, :&lt; 和 :^ 分别表示右对齐、左对齐和居中对齐。 number=123 print(f'{number:&gt;8}') # ' 123' print(f'{number:&lt;8}') # '123 ' print(f'{number:^8}') # ' 123 ' 我们还可以指定填充字符，例如 f'{number:0&gt;8} 表示右对齐，不足 8 位的部分用 0 填充。 :b, :d, :o, :x 和 :X fstring 中的 :b, :d, :o, :x 和 :X 分别表示二进制、十进制、八进制、十六进制小写和十六进制大写。 例如 f'{number:b} 表示将 number 转换为二进制字符串。还可以通过设置宽度和填充字符来格式化字符串，例如 f'{number:08b} 表示将 number 转换为 8 位的二进制字符串，不足 8 位的部分用 0 填充。 千分位分隔符 fstring 中可以使用 , 等来添加千分位分隔符。 number=1234567890 print(f'{number:,}') # 1,234,567,890 print(f'{number:_}') # 123_456_7890 自定义 __format__ 方法 我们可以通过自定义 __format__ 方法来实现自定义的格式化方法。 class Number: def __init__(self, number): self.number = number def __format__(self, format_spec): if format_spec== 'b': return f'{self.number:08b}' elif format_spec== 'd': return f'{self.number:08d}' elif format_spec== 'o': return f'{self.number:08o}' elif format_spec== 'x': return f'{self.number:08x}' elif format_spec== 'X': return f'{self.number:08X}' else: return str(self.number) number=Number(10) print(f'{number:b}') # '00001010' print(f'{number:d}') # '00000010' print(f'{number:o}') # '00000012' print(f'{number:x}') # '0000000a' print(f'{number:X}') # '0000000A' 上面的代码中，我们更改了 Number 类的 __format__ 方法，使得 Number 类的 :b, :d, :o, :x 和 :X 变成了 8 位的二进制、十进制、八进制、十六进制小写和十六进制大写。 match/case 语句 Python 3.10 新增了 match/case 语句，这是一种新的模式匹配语法，可以替代 if/elif/else 语句。 def match_color(color): match color: case 'red': print('Red') case 'green': print('Green') case 'blue': print('Blue') case _: print('Unknown') match_color('red') # Red match 语句会依次匹配 case 语句，如果匹配成功则执行对应的代码块，如果没有匹配成功则执行 _ 代码块。 match 语句还可以使用 | 来匹配多个值： def match_color(color): match color: case 'red' | 'green' | 'blue': print('Primary') case 'cyan' | 'magenta' | 'yellow': print('Secondary') case _: print('Unknown') match_color('red') # Primary match 语句还可以使用 if 来添加条件： def match_color(color, light): match color: case 'red' if light: print('Light Red') case 'red': print('Dark Red') case 'green' if light: print('Light Green') case 'green': print('Dark Green') case _: print('Unknown') match_color('red', True) # Light Red 在 case 语句中，我们可以指定匹配模式： def match_color(info): match info: case ['red', _, _, light] if light: print('Light Red') case ['red', _, _, light] if not light: print('Dark Red') case ['green', _, _, light] if light: print('Light Green') # 也可以使用 *_ 来匹配任意项 case ['green', *_, light] if not light: print('Dark Green') case _: print('Unknown') match_color(['red', 1, 2, True]) # Light Red match_color(['red', 1, 2, False]) # Dark Red 还可以使用 as 来重新命名变量： def match_color(info): match info: case [('red', light) as color, _] if light: print(f'Light {color}') case [('red', light) as color, _] if not light: print(f'Dark {color}') case [('green', light) as color, _] if light: print(f'Light {color}') case [('green', light) as color, _] if not light: print(f'Dark {color}') case _: print('Unknown') match_color([('red', True), 1]) # Light ('red', True) 需要注意的是，只有以下的类型支持对序列进行拆分的写法： list memoryview array.array tuple range collections.deque 需要注意的是在序列结构中使用 str() 等是标明匹配项必须是 str 类型，而不是进行字符串转换： def match_color(info): match info: case [str(name), bool(light)] if light: print('Light ' + name) case _: print('Unknown') match_color((1, True)) # Unknown match_color(('red', True)) # Light red 特殊方法 Python 中的特殊方法也叫魔术方法 (Magic Method)，这些方法以 __ 开头和结尾，比如 __init__、 __str__、__repr__ 等。这些方法是 Python 解释器调用的，我们可以重写这些方法，从而实现自定义的功能。 这里给出常用的特殊方法的定义与调用方式。 类型转换 方法 说明 调用方式 __bool__(self) 布尔化 bool(obj) __int__(self) 整型化 int(obj) __float__(self) 浮点化 float(obj) __complex__(self) 复数化 complex(obj) __bytes__(self) 字节化 bytes(obj) __str__(self) 字符串化 str(obj) 一元运算符 方法 说明 调用方式 __neg__(self) 取负 -obj __pos__(self) 取正 +obj __abs__(self) 取绝对值 abs(obj) __round__(self, ndigits) 四舍五入 round(obj, ndigits) 算数运算 方法 说明 调用方式 __add__(self, other) 加法 obj + other __sub__(self, other) 减法 obj - other __mul__(self, other) 乘法 obj * other __truediv__(self, other) 除法 obj / other __floordiv__(self, other) 整除 obj // other __mod__(self, other) 取模 obj % other __pow__(self, other) 幂运算 obj ** other 说明：上述的所有方法增加了 r 前缀，比如 __radd__、__rsub__ 等，表示反向运算，即 other + obj。 增加了 i 前缀，比如 __iadd__、__isub__ 等，表示增量运算，即 obj += other。 比较 方法 说明 调用方式 __eq__(self, other) 等于 obj== other __ne__(self, other) 不等于 obj != other __lt__(self, other) 小于 obj &lt; other __le__(self, other) 小于等于 obj &lt;= other __gt__(self, other) 大于 obj &gt; other __ge__(self, other) 大于等于 obj &gt;= other 迭代 方法 说明 调用方式 __len__(self) 长度 len(obj) __getitem__(self, pos) 获取元素 obj[pos] __setitem__(self, pos, value) 设置元素 obj[pos] = value __iter__(self) 迭代器 for i in obj: __contains__(self, value) 是否包含 value in obj __next__(self) 下一个 next(obj) __reversed__(self) 反向迭代器 reversed(obj) 位运算 方法 说明 调用方式 __and__(self, other) 与运算 obj &amp; other __or__(self, other) 或运算 obj | other __xor__(self, other) 异或运算 obj ^ other __lshift__(self, other) 左移 obj &lt;&lt; other __rshift__(self, other) 右移 obj &gt;&gt; other __invert__(self) 取反 ~obj 说明：上述的所有方法增加了 r 前缀，比如 __rand__、__ror__ 等，表示反向运算，即 other &amp; obj。 增加了 i 前缀，比如 __iand__、__ior__ 等，表示增量运算，即 obj &amp;= other。 构造与析构 方法 说明 调用方式 __init__(self, ...) 构造方法 obj=CalssName(...) __new__(cls, ...) 创建对象 obj=ClassName(...) __del__(self) 析构方法 del obj 其中的 __new__ 方法是一个类方法，用于创建对象，而 __init__ 方法是一个实例方法，用于初始化对象。 __new__ 方法需要返回一个对象，通常是调用父类的 __new__ 方法，这个返回值会传递给 __init__ 方法， 而 __init__ 方法不需要返回值。 其他 方法 说明 调用方式 __repr__(self) 表示形式 repr(obj) __format__(self, format_spec) 格式化 format(obj, format_spec) __hash__(self) 哈希值 hash(obj) __index__ 索引值 index(obj) __call__(self, ...) 调用 obj(...) __delitem__(self, pos) 删除元素 del obj[pos] __getattr__(self, name) 获取属性 obj.name __setattr__(self, name, value) 设置属性 obj.name = value __delattr__(self, name) 删除属性 del obj.name __enter__(self) 上下文管理器 with obj as ...: __exit__(self, exc_type, exc_value, traceback) 上下文管理器 with obj as ...: 注意：实现方法后的调用方式可能并不只有一种，比如 __str__ 方法可以通过 str(obj) 或 print(obj) 来调用。 而如果实现了 __bool__，那么 not、and 和 or 也会调用这个方法。 注意：Python 中的很多特殊方法即使不进行实现也能使用其支持的调用形式，例如对于一个只实现了 __add__ 方法的类，也可以使用 a += b 这种形式，此时会被解释为 a=a + b，即先调用 __add__ 方法，然后进行赋值。 海象运算符 := 这个符号被称为海象运算符，仅仅是因为它的形状像海象。 := 运算符是 Python 3.8 新增的，它可以在表达式中赋值，这样我们就可以在表达式中使用赋值的变量： if (n := len('hello')) &gt; 5: print(f'Length of hello is {n}') # 如果不使用 := 运算符，那么代码会变得更加冗长 n=len('hello') if n &gt; 5: print(f'Length of hello is {n}') 一个更加常见的例子是在循环中使用 := 运算符： file=open(filename, "r") while (line := file.readline()): print(line.strip()) # 如果不使用 := 运算符，那么代码会变得更加冗长 file=open(filename, "r") while True: line=file.readline() if not line: break print(line.strip()) 我们还可以在列表推导式中使用 := 运算符。这种情况下，我们往往需要将计算后的结果放到列表中： numbers=[1, 2, 3, 4, 5] evens=[x for n in numbers if (x := n * 2) &gt;= 10] # 如果不使用 := 运算符，那么代码会变得更加冗长 evens=[n * 2 for n in numbers if n * 2 &gt;= 10] 上面的代码能够帮我简化一次 n * 2 的计算，对于一些复杂的计算，这种方式会更加简洁且效率更高。 海象运算符变量的作用域 := 运算符定义的变量的作用域是当前函数，除非目标变量使用 global 或者 nonlocal 修饰： if (n := len('hello')) &gt; 5: print(f'Length of hello is {n}') print(n) # OK 切片 Python 中的切片是一个非常强大的功能，我们可以使用切片来获取列表、元组、字符串等序列的子序列。 切片对象 除了基础的切片用法之外，我们可以通过 slice 类来创建切片对象，这样我们就可以在多个地方使用同一个切片对象： numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9] s1=slice(1, 5) # start=1, end=5, step=1 s2=slice(1) # start=1, end=None, step=1 print(numbers[s1]) # [2, 3, 4, 5] print(numbers[s2]) # [2, 3, 4, 5, 6, 7, 8, 9] 切片获取到的对象可以通过赋值来修改原对象： numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[1:5] = [10, 20, 30, 40] print(numbers) # [1, 10, 20, 30, 40, 6, 7, 8, 9] 上面的例子说明切片获取到的是引用，对于可变对象而言我们可以修改切片后，原对象也会发生变化： test=[[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 修改切片的第一个元素的第一个值 test[0:2][0][0] = -1 # 等价于 test[0][0] = -1 print(test) # [[-1, 2, 3], [4, 5, 6], [7, 8, 9]] # test 中保存的是不可变对象，所以 test 本身不会发生变化 test=[1, 2, 3] test[0:2][0] = -1 print(test) # [1, 2, 3] memoryview memoryview 是一个内置类，它可以让我们直接操作内存，而不需要复制数据。memoryview 对象可以通过 memoryview() 函数创建。 numbers=array.array('B', [1, 2, 3, 4, 5, 6]) # 此时 mem 和 number 共享内存，但是此时我们可以随意更改 mem 的形状等 mem=memoryview(numbers) mem=mem.cast('B', [2, 3]) # 2 行 3 列 print(mem.tolist()) # [[1, 2, 3], [4, 5, 6]] mem[1, 2] = 100 print(numbers) # [1, 2, 3, 4, 5, 100] 字典 字典推导式 我们可以使用列表推导式快速创建列表，实际上，对于字典的创建也有类似的语法： {key: value for key, value in iterable} 在 match/case 中匹配字典 match/case 语句还可以用来匹配字典： def match_color(info): match info: case {'color': 'red', 'light': True}: print('Light Red') case {'color': 'red', 'light': False}: print('Dark Red') case {'color': 'green', 'light': True}: print('Light Green') case {'color': 'green', 'light': False}: print('Dark Green') case _: print('Unknown') match_color({'color': 'red', 'light': True}) # Light Red 上面的匹配式的意思是只要含有这些键值对的都会被匹配，而且顺序不重要，即使是一个 OrderDict 也会被忽略 顺序。 集合 集合推导式 也可以使用集合推导式创建集合： {value for value in iterable} 判断集合的包含关系 使用比较运算符可以判断集合的包含关系： 运算符 说明 &lt;= 子集 &lt; 真子集 &gt;= 超集 &gt; 真超集 == 相等 != 不相等 可变对象与不可变对象 Python 中的对象分为可变对象和不可变对象，可变对象是指对象的值可以改变，而不可变对象是指对象的值不可以改变。 Python 中的不可变对象有：int、float、complex、str、tuple、frozenset 等。 Python 中的可变对象有：list、dict、set 等。 一个对象如果可以通过 hash 函数计算哈希值且不抛出异常，那么这个对象就是不可变对象。例如我们可以通过 以下的代码来判断一个对象是否是可变对象： def is_mutable(obj): try: hash(obj) return False except TypeError: return True print(is_mutable(1)) # False print(is_mutable('hello')) # False print(is_mutable([1, 2, 3])) # True 避免可变对象作为默认值 在 Python 中如果使用可变对象绑定到默认值，那么在函数调用时会共享这个可变对象，这样会导致默认值的改变： def f(a=[]): a.append(1) return a print(f()) # [1] print(f()) # [1, 1] 如果我们想要避免这种情况，我们可以使用 None 作为默认值，然后在函数内部判断是否为 None，然后创建一个新的对象： def f(a=None): if a is None: a=[] a.append(1) return a print(f()) # [1] print(f()) # [1] 类属性和实例属性 在 Python 中，存在类属性和实例属性的区分，一般而言，类属性可以通过在类的开头定义，而实例对象可以在 __init__ 方法中定义。类属性可以通过类名或者实例对象访问，而实例属性则可以通过实例对象访问。例如： class A: class_attr=1 def __init__(self): self.instance_attr = 2 a=A() print(a.class_attr) # 1 print(a.instance_attr) # 2 print(A.class_attr) # 1 如果通过实例对象去修改类属性，那么实际上是创建了一个新的实例属性： # 创建一个新的实例对象，名字与类属性相同 a.class_attr = 3 print(a.class_attr) # 3 print(A.class_attr) # 1 # 可以通过 del 删除实例属性 del a.class_attr # 由于实例对象的 class_attr 属性被删除，所以会访问类属性 print(a.class_attr) # 1 静态方法、类方法和实例方法 在 Python 的类中，有三种方法：静态方法、类方法和实例方法。 首先介绍最常见的实例方法，实例方法的第一个参数是 self，表示实例对象本身： class A: def instance_method(self): # 实例方法可以访问实例属性 return self 实例方法可以通过实例对象调用，也可以通过类对象调用，但是需要传入实例对象： a=A() print(a.instance_method()) # &lt;__main__.A object at 0x7f8b3c7b3d30&gt; print(A.instance_method(a)) # &lt;__main__.A object at 0x7f8b3c7b3d30&gt; 类方法使用 @classmethod 装饰器来定义，类方法的第一个参数是 cls，表示类对象本身： class A: @classmethod def class_method(cls): # 类方法可以访问类属性 return cls 类方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象： a=A() print(a.class_method()) # &lt;class '__main__.A'&gt; print(A.class_method()) # &lt;class '__main__.A'&gt; 静态方法使用 @staticmethod 装饰器来定义，静态方法没有 self 和 cls 参数： class A: @staticmethod def static_method(): return 'static method' 静态方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象： a=A() print(a.static_method()) # static method print(A.static_method()) # static method 静态方法其实更像是一个普通的函数，它不能访问类属性和实例属性，但是他可以被实例方法或者类方法调用， 所以如果需要处理的逻辑只会被当前的类多次调用，那么可以使用静态方法实现代码的复用。]]></summary></entry><entry><title type="html">使用 Spring-Doc 生成接口文档</title><link href="https://kaiser-yang.github.io/blog/2024/spring-doc-intro/" rel="alternate" type="text/html" title="使用 Spring-Doc 生成接口文档"/><published>2024-08-21T13:44:57+00:00</published><updated>2024-08-21T13:44:57+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-doc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-doc-intro/"><![CDATA[<p>本文主要介绍如何使用 <code class="language-plaintext highlighter-rouge">OpenAPI 3.0</code> 为一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目 (<code class="language-plaintext highlighter-rouge">web</code> 项目) 生成 <code class="language-plaintext highlighter-rouge">API</code> 文档。</p> <h1 id="常用注解">常用注解</h1> <h2 id="tag"><code class="language-plaintext highlighter-rouge">@Tag</code></h2> <p><code class="language-plaintext highlighter-rouge">@Tag</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 分组，可以为 <code class="language-plaintext highlighter-rouge">@Tag</code> 指定 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">description</code>。<code class="language-plaintext highlighter-rouge">name</code> 相同的 <code class="language-plaintext highlighter-rouge">@Tag</code> 会被合并到一起。</p> <p>通常情况下，我们会使用 <code class="language-plaintext highlighter-rouge">@Tag</code> 标识一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类。</p> <h2 id="operation"><code class="language-plaintext highlighter-rouge">@Operation</code></h2> <p><code class="language-plaintext highlighter-rouge">@Operation</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加描述信息，可以为 <code class="language-plaintext highlighter-rouge">@Operation</code> 指定 <code class="language-plaintext highlighter-rouge">summary</code> 和 <code class="language-plaintext highlighter-rouge">description</code>。</p> <h2 id="parameters-和-parameter"><code class="language-plaintext highlighter-rouge">@Parameters</code> 和 <code class="language-plaintext highlighter-rouge">@Parameter</code></h2> <p><code class="language-plaintext highlighter-rouge">@Parameters</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加参数信息，<code class="language-plaintext highlighter-rouge">@Parameters</code> 中包含多个 <code class="language-plaintext highlighter-rouge">@Parameter</code>。</p> <p><code class="language-plaintext highlighter-rouge">@Parameter</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加参数信息，可以为 <code class="language-plaintext highlighter-rouge">@Parameter</code> 指定 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">in</code>、<code class="language-plaintext highlighter-rouge">description</code>、 <code class="language-plaintext highlighter-rouge">required</code>、<code class="language-plaintext highlighter-rouge">schema</code> 等属性。</p> <h2 id="schema"><code class="language-plaintext highlighter-rouge">@Schema</code></h2> <p><code class="language-plaintext highlighter-rouge">@Schema</code> 用于给对象添加描述信息，可以为 <code class="language-plaintext highlighter-rouge">@Schema</code> 指定 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">title</code>、<code class="language-plaintext highlighter-rouge">description</code>、<code class="language-plaintext highlighter-rouge">example</code> 等属性。</p> <h2 id="hidden-parameterhidden--true-和-operationhidden--true"><code class="language-plaintext highlighter-rouge">@Hidden</code>, <code class="language-plaintext highlighter-rouge">@Parameter(hidden = true)</code> 和 <code class="language-plaintext highlighter-rouge">@Operation(hidden = true)</code></h2> <p><code class="language-plaintext highlighter-rouge">@Hidden</code> 用于隐藏一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类，<code class="language-plaintext highlighter-rouge">@Parameter(hidden = true)</code> 用于隐藏一个参数，<code class="language-plaintext highlighter-rouge">@Operation(hidden = true)</code> 用于隐藏一个 <code class="language-plaintext highlighter-rouge">API</code> (方法)。</p> <h2 id="apiresponses-和-apiresponse"><code class="language-plaintext highlighter-rouge">@ApiResponses</code> 和 <code class="language-plaintext highlighter-rouge">@ApiResponse</code></h2> <p><code class="language-plaintext highlighter-rouge">@ApiResponses</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加响应信息，<code class="language-plaintext highlighter-rouge">@ApiResponses</code> 中包含多个 <code class="language-plaintext highlighter-rouge">@ApiResponse</code>。</p> <p><code class="language-plaintext highlighter-rouge">@ApiResponse</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加响应信息，可以为 <code class="language-plaintext highlighter-rouge">@ApiResponse</code> 指定 <code class="language-plaintext highlighter-rouge">responseCode</code>、<code class="language-plaintext highlighter-rouge">description</code>、 <code class="language-plaintext highlighter-rouge">content</code> 等属性。</p> <h1 id="一个完整的例子">一个完整的例子</h1> <p>我们首先为 <code class="language-plaintext highlighter-rouge">DTO</code> 对象添加各种的 <code class="language-plaintext highlighter-rouge">@Schema</code> 注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"User Data Transfer Object"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">accessMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">AccessMode</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"Username"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"Email"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin@cmipt.edu"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"User Password (Unencrypted)"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>接下来我们为一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类添加 <code class="language-plaintext highlighter-rouge">@Tag</code>、<code class="language-plaintext highlighter-rouge">@Operation</code>、<code class="language-plaintext highlighter-rouge">@ApiResponses</code> 和 <code class="language-plaintext highlighter-rouge">@ApiResponse</code> 等注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="nd">@Tag</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"User"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User Related APIs"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="nd">@Operation</span><span class="o">(</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="s">"Create a new user"</span><span class="o">,</span>
        <span class="n">description</span> <span class="o">=</span> <span class="s">"Create a new user with the given information"</span><span class="o">,</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"User"</span><span class="o">,</span> <span class="s">"Post Method"</span> <span class="o">}</span>
    <span class="o">)</span>
    <span class="nd">@ApiResponses</span><span class="o">({</span>
            <span class="nd">@ApiResponse</span><span class="o">(</span><span class="n">responseCode</span> <span class="o">=</span> <span class="s">"200"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User created successfully"</span><span class="o">),</span>
            <span class="nd">@ApiResponse</span><span class="o">(</span><span class="n">responseCode</span> <span class="o">=</span> <span class="s">"400"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User creation failed"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// some code here</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上面的操作后，我们启动程序，访问 <code class="language-plaintext highlighter-rouge">http://localhost:8080/swagger-ui/index.html</code>，就可以看到生成的 <code class="language-plaintext highlighter-rouge">API</code> 文档了。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20240821214051.png" alt="" class="img-fluid"/></p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring-Doc"/><category term="OpenAPI"/><summary type="html"><![CDATA[本文主要介绍如何使用 OpenAPI 3.0 为一个 Spring Boot 项目 (web 项目) 生成 API 文档。 常用注解 @Tag @Tag 用于为 API 文档中的 API 分组，可以为 @Tag 指定 name 和 description。name 相同的 @Tag 会被合并到一起。 通常情况下，我们会使用 @Tag 标识一个 Controller 类。 @Operation @Operation 用于为 API 文档中的 API 添加描述信息，可以为 @Operation 指定 summary 和 description。 @Parameters 和 @Parameter @Parameters 用于为 API 文档中的 API 添加参数信息，@Parameters 中包含多个 @Parameter。 @Parameter 用于为 API 文档中的 API 添加参数信息，可以为 @Parameter 指定 name、in、description、 required、schema 等属性。 @Schema @Schema 用于给对象添加描述信息，可以为 @Schema 指定 name、title、description、example 等属性。 @Hidden, @Parameter(hidden = true) 和 @Operation(hidden = true) @Hidden 用于隐藏一个 Controller 类，@Parameter(hidden = true) 用于隐藏一个参数，@Operation(hidden = true) 用于隐藏一个 API (方法)。 @ApiResponses 和 @ApiResponse @ApiResponses 用于为 API 文档中的 API 添加响应信息，@ApiResponses 中包含多个 @ApiResponse。 @ApiResponse 用于为 API 文档中的 API 添加响应信息，可以为 @ApiResponse 指定 responseCode、description、 content 等属性。 一个完整的例子 我们首先为 DTO 对象添加各种的 @Schema 注解： @Data @Schema(description = "User Data Transfer Object") public class UserDTO { @Schema(accessMode = Schema.AccessMode.READ_ONLY, description="User ID") private Long id; @Schema(description = "Username", requiredMode=Schema.RequiredMode.REQUIRED, example="admin") private String username; @Schema(description = "Email", requiredMode=Schema.RequiredMode.REQUIRED, example="admin@cmipt.edu") private String email; @Schema(description = "User Password (Unencrypted)", requiredMode=Schema.RequiredMode.REQUIRED, example="admin") private String userPassword; } 接下来我们为一个 Controller 类添加 @Tag、@Operation、@ApiResponses 和 @ApiResponse 等注解： @Controller @RequestMapping("/user") @Tag(name = "User", description="User Related APIs") public class UserController { @Autowired private UserService userService; @PostMapping @Operation( summary="Create a new user", description="Create a new user with the given information", tags={ "User", "Post Method" } ) @ApiResponses({ @ApiResponse(responseCode = "200", description="User created successfully"), @ApiResponse(responseCode = "400", description="User creation failed") }) public ResponseEntity&lt;Void&gt; createUser(@RequestBody UserDTO user) { // some code here return ResponseEntity.ok().build(); } } 经过上面的操作后，我们启动程序，访问 http://localhost:8080/swagger-ui/index.html，就可以看到生成的 API 文档了。]]></summary></entry><entry><title type="html">MyBatis-Plus 简介</title><link href="https://kaiser-yang.github.io/blog/2024/mybatis-plus-intro/" rel="alternate" type="text/html" title="MyBatis-Plus 简介"/><published>2024-08-21T06:43:00+00:00</published><updated>2024-08-21T06:43:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/mybatis-plus-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/mybatis-plus-intro/"><![CDATA[<h1 id="mybatis-与-mybatis-plus-的区别"><code class="language-plaintext highlighter-rouge">MyBatis</code> 与 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 的区别</h1> <p><code class="language-plaintext highlighter-rouge">MyBatis</code> 的主要功能是提供了对 <code class="language-plaintext highlighter-rouge">SQL</code> 的封装，可以通过 <code class="language-plaintext highlighter-rouge">XML</code> 或者注解的方式来配置 <code class="language-plaintext highlighter-rouge">SQL</code>，并且提供了对 <code class="language-plaintext highlighter-rouge">SQL</code> 的执行、结果映射等功能。<code class="language-plaintext highlighter-rouge">MyBatis</code> 对于所有的 <code class="language-plaintext highlighter-rouge">SQL</code> 都需要自己来编写。</p> <p><code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 可以理解成是 <code class="language-plaintext highlighter-rouge">MyBatis</code> 的增强工具，提供了很多实用的功能，比如分页、条件构造器、代码生成器等。 其中最重要的功能是提供了通用的 <code class="language-plaintext highlighter-rouge">CRUD</code> 方法，可以直接通过调用方法来实现 <code class="language-plaintext highlighter-rouge">CRUD</code> 操作，不需要自己编写 <code class="language-plaintext highlighter-rouge">SQL</code>。</p> <p>除此之外，我在查阅文档的时候发现 <code class="language-plaintext highlighter-rouge">MyBatis-Spring</code> 部分的文档比较简陋，而 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 拥有更加详细的文档。</p> <h1 id="使用-mybatis-plus-实现-crud">使用 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 实现 <code class="language-plaintext highlighter-rouge">CRUD</code></h1> <h2 id="mapperscan"><code class="language-plaintext highlighter-rouge">@MapperScan</code></h2> <p>与 <code class="language-plaintext highlighter-rouge">MyBatis</code> 相同的时，我们需要在启动类上添加 <code class="language-plaintext highlighter-rouge">@MapperScan</code> 注解，指定 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口的包路径。例如 可以通过 <code class="language-plaintext highlighter-rouge">@MapperScan("edu.cmipt.gcs.dao")</code> 指定 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口的包路径为 <code class="language-plaintext highlighter-rouge">edu.cmipt.gcs.dao</code>。这样 指定后 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 会自动将该路径下的 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口注册到 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中。</p> <h2 id="po-对象"><code class="language-plaintext highlighter-rouge">PO</code> 对象</h2> <p><code class="language-plaintext highlighter-rouge">PO</code> 对象是持久化对象，对应数据库中的表。通常情况下，我们会为每个表创建一个对应的 <code class="language-plaintext highlighter-rouge">PO</code> 对象。<code class="language-plaintext highlighter-rouge">PO</code> 对象 通常包含表中的字段，以及对应的 <code class="language-plaintext highlighter-rouge">getter</code> 和 <code class="language-plaintext highlighter-rouge">setter</code> 方法。</p> <p>例如一张 <code class="language-plaintext highlighter-rouge">user</code> 表的结构如下：</p> <table> <thead> <tr> <th>字段名</th> <th>类型</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">id</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">name</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">age</code></td> <td><code class="language-plaintext highlighter-rouge">INT</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">email</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> </tbody> </table> <p>我们可以创建如下的 <code class="language-plaintext highlighter-rouge">UserPO</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserPO</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="tablename"><code class="language-plaintext highlighter-rouge">@TableName</code></h3> <p>上述的实例在 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 中对应的表名为 <code class="language-plaintext highlighter-rouge">user_p_o</code>，这是因为 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 默认会将驼峰命名的 字段转换为下划线分割的表名。如果我们希望使用自定义的表名，可以在 <code class="language-plaintext highlighter-rouge">PO</code> 类上添加 <code class="language-plaintext highlighter-rouge">@TableName</code> 注解，指定 表名。也就是说我们需要在类的头部添加 <code class="language-plaintext highlighter-rouge">@TableName("user")</code> 注解，指定表名为 <code class="language-plaintext highlighter-rouge">user</code>。</p> <h3 id="tableid"><code class="language-plaintext highlighter-rouge">@TableID</code></h3> <p>如果上面的例子中的 <code class="language-plaintext highlighter-rouge">id</code> 字段是主键，我们可以在 <code class="language-plaintext highlighter-rouge">id</code> 字段上添加 <code class="language-plaintext highlighter-rouge">@TableID</code> 注解，指定主键的类型。这样 指定后才能使用 <code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 提供的一些与 <code class="language-plaintext highlighter-rouge">ID</code> 相关的方法。如果表中和 <code class="language-plaintext highlighter-rouge">PO</code> 类中的主键字段都叫 <code class="language-plaintext highlighter-rouge">id</code>， 则可以不用使用该注解。</p> <h2 id="basemapper-接口"><code class="language-plaintext highlighter-rouge">BaseMapper</code> 接口</h2> <p>通常情况下，我们会为每个 <code class="language-plaintext highlighter-rouge">PO</code> 对象创建一个对应的 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口，继承 <code class="language-plaintext highlighter-rouge">BaseMapper</code> 接口。<code class="language-plaintext highlighter-rouge">BaseMapper</code> 接口提供了一些通用的 <code class="language-plaintext highlighter-rouge">CRUD</code> 方法，我们可以直接调用这些方法来实现 <code class="language-plaintext highlighter-rouge">CRUD</code> 操作。</p> <p>例如我们可以通过以下方式创建一个 <code class="language-plaintext highlighter-rouge">UserMapper</code> 接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserMapper</span> <span class="kd">extends</span> <span class="nc">BaseMapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div> <h3 id="insert"><code class="language-plaintext highlighter-rouge">insert</code></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// T 在这里代表继承时指定的 PO 类型，返回值代表受影响的行数</span>
<span class="kt">int</span> <span class="nf">insert</span><span class="o">(</span><span class="no">T</span> <span class="n">entity</span><span class="o">);</span>
</code></pre></div></div> <p>我们可以配合自动装配轻松地使用 <code class="language-plaintext highlighter-rouge">insert</code> 方法，例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">UserMapper</span> <span class="n">userMapper</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertUser</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">userMapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：上面的接口返回值代表受影响的行数，通常情况下插入成功时返回 <code class="language-plaintext highlighter-rouge">1</code>，而插入失败时返回 <code class="language-plaintext highlighter-rouge">0</code> 。</p> <h3 id="delete"><code class="language-plaintext highlighter-rouge">delete</code></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 根据 entity 条件，删除记录</span>
<span class="kt">int</span> <span class="nf">delete</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">wrapper</span><span class="o">);</span>
<span class="c1">// 删除（根据ID 批量删除）</span>
<span class="kt">int</span> <span class="nf">deleteBatchIds</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">COLLECTION</span><span class="o">)</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Serializable</span><span class="o">&gt;</span> <span class="n">idList</span><span class="o">);</span>
<span class="c1">// 根据 ID 删除</span>
<span class="kt">int</span> <span class="nf">deleteById</span><span class="o">(</span><span class="nc">Serializable</span> <span class="n">id</span><span class="o">);</span>
<span class="c1">// 根据 columnMap 条件，删除记录</span>
<span class="kt">int</span> <span class="nf">deleteByMap</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">COLUMN_MAP</span><span class="o">)</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">columnMap</span><span class="o">);</span>
</code></pre></div></div> <p>上面的后三种方式的使用方法应该是一目了然的，这里简单介绍一下第一种方式。<code class="language-plaintext highlighter-rouge">Wrapper</code> 是一个条件构造器， 我们可以通过 <code class="language-plaintext highlighter-rouge">QueryWrapper</code> 或者 <code class="language-plaintext highlighter-rouge">UpdateWrapper</code> 来构造条件。例如我们可以通过以下方式删除年龄大于 <code class="language-plaintext highlighter-rouge">18</code> 的用户：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteUser</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">queryWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;&gt;();</span>
    <span class="n">queryWrapper</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">18</span><span class="o">);</span>
    <span class="n">userMapper</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">queryWrapper</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>而对于其他的方法，我们完全可以在编写的时候通过 <code class="language-plaintext highlighter-rouge">IDE</code> 的自动补全来查看使用方法。</p> <h3 id="update"><code class="language-plaintext highlighter-rouge">update</code></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 根据 whereWrapper 条件，更新记录</span>
<span class="kt">int</span> <span class="nf">update</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">ENTITY</span><span class="o">)</span> <span class="no">T</span> <span class="n">updateEntity</span><span class="o">,</span> <span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">whereWrapper</span><span class="o">);</span>
<span class="c1">// 根据 ID 修改</span>
<span class="kt">int</span> <span class="nf">updateById</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">ENTITY</span><span class="o">)</span> <span class="no">T</span> <span class="n">entity</span><span class="o">);</span>
</code></pre></div></div> <p>例如，我们可以通过以下的方式修改 <code class="language-plaintext highlighter-rouge">age</code> 字段为 <code class="language-plaintext highlighter-rouge">20</code> 的用户的邮箱：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateUser</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">UserPO</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserPO</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="s">"123456@xxx.xxx"</span><span class="o">);</span>
    <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">updateWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateWrapper</span><span class="o">&lt;&gt;();</span>
    <span class="n">queryWrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>
    <span class="n">userMapper</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">updateWrapper</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面出现了 <code class="language-plaintext highlighter-rouge">UpdateWrapper</code> 和 <code class="language-plaintext highlighter-rouge">QueryWrapper</code> 两个类，这两个类的功能非常类似，但是一般情况下我们 会使用 <code class="language-plaintext highlighter-rouge">QueryWrapper</code> 来构造查询条件，使用 <code class="language-plaintext highlighter-rouge">UpdateWrapper</code> 来构造更新条件。<code class="language-plaintext highlighter-rouge">UpdateWrapper</code> 提供了 <code class="language-plaintext highlighter-rouge">set</code> 方法，可以设置需要更新的字段，而不需要传入一个完整的 <code class="language-plaintext highlighter-rouge">PO</code> 对象。例如上面的例子我们可以修改成：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateUser</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">updateWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateWrapper</span><span class="o">&lt;&gt;();</span>
    <span class="n">queryWrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">20</span><span class="o">).</span><span class="na">set</span><span class="o">(</span><span class="s">"email"</span><span class="o">,</span> <span class="s">"123456@xxx.xxx"</span><span class="o">);</span>
    <span class="n">userMapper</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">updateWrapper</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="select"><code class="language-plaintext highlighter-rouge">select</code></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 根据 ID 查询</span>
<span class="no">T</span> <span class="nf">selectById</span><span class="o">(</span><span class="nc">Serializable</span> <span class="n">id</span><span class="o">);</span>
<span class="c1">// 根据 entity 条件，查询一条记录</span>
<span class="no">T</span> <span class="nf">selectOne</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>

<span class="c1">// 查询（根据ID 批量查询）</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">selectBatchIds</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">COLLECTION</span><span class="o">)</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Serializable</span><span class="o">&gt;</span> <span class="n">idList</span><span class="o">);</span>
<span class="c1">// 根据 entity 条件，查询全部记录</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">selectList</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
<span class="c1">// 查询（根据 columnMap 条件）</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">selectByMap</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">COLUMN_MAP</span><span class="o">)</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">columnMap</span><span class="o">);</span>
<span class="c1">// 根据 Wrapper 条件，查询全部记录</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="nf">selectMaps</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
<span class="c1">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">selectObjs</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
<span class="c1">// 根据 entity 条件，查询全部记录（并分页）</span>
<span class="nc">IPage</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">selectPage</span><span class="o">(</span><span class="nc">IPage</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">page</span><span class="o">,</span> <span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
<span class="c1">// 根据 Wrapper 条件，查询全部记录（并分页）</span>
<span class="nc">IPage</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="nf">selectMapsPage</span><span class="o">(</span><span class="nc">IPage</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">page</span><span class="o">,</span> <span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
<span class="c1">// 根据 Wrapper 条件，查询总记录数</span>
<span class="nc">Integer</span> <span class="nf">selectCount</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="nc">Constants</span><span class="o">.</span><span class="na">WRAPPER</span><span class="o">)</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">queryWrapper</span><span class="o">);</span>
</code></pre></div></div> <p>下面详细介绍以下分页查询的使用方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">selectUser</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 每页 10 条记录，查询第 1 页</span>
    <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">page</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Page</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
    <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">queryWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;&gt;();</span>
    <span class="n">queryWrapper</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">18</span><span class="o">);</span>
    <span class="nc">IPage</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">userPage</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">selectPage</span><span class="o">(</span><span class="n">page</span><span class="o">,</span> <span class="n">queryWrapper</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="n">userPage</span><span class="o">.</span><span class="na">getRecords</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">UserPO</span> <span class="n">user</span> <span class="o">:</span> <span class="n">userList</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="iservice-接口"><code class="language-plaintext highlighter-rouge">IService</code> 接口</h2> <p>通常情况下，我们会为每个 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口创建一个对应的 <code class="language-plaintext highlighter-rouge">Service</code> 接口，继承 <code class="language-plaintext highlighter-rouge">IService</code> 接口。<code class="language-plaintext highlighter-rouge">IService</code> 接口提供了一些通用的 <code class="language-plaintext highlighter-rouge">CRUD</code> 方法，我们可以直接调用这些方法来实现 <code class="language-plaintext highlighter-rouge">CRUD</code> 操作。与直接调用 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口 相比，使用 <code class="language-plaintext highlighter-rouge">Service</code> 接口可以更好地实现业务逻辑与数据访问的分离。</p> <p><code class="language-plaintext highlighter-rouge">IService</code> 的适用方式与 <code class="language-plaintext highlighter-rouge">BaseMapper</code> 类似，例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="kd">extends</span> <span class="nc">IService</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div> <p>完成上述操作后，我们便可以使用 <code class="language-plaintext highlighter-rouge">UserService</code> 接口中提供的各种方法了。使用的方式与直接调用 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口类似，这里不再赘述。</p> <h1 id="逻辑删除">逻辑删除</h1> <p>逻辑删除指的是通过一个字段来标识资源是否已经被删除，而不是真的从数据库中删除资源。逻辑删除的好处是可以 保留删除的记录，方便日后的数据分析。而逻辑删除的原理就是在 <code class="language-plaintext highlighter-rouge">CRUD</code> 操作时，通过增加一个条件来判断资源 是否已经被删除。例如使用逻辑删除后的查询语句均需要增加 <code class="language-plaintext highlighter-rouge">where deleted = 0</code> 的条件 (如果 <code class="language-plaintext highlighter-rouge">deleted = 0</code> 表示未被删除，<code class="language-plaintext highlighter-rouge">deleted = 1</code> 表示逻辑删除)。而有些数据库的设计者通过设置删除时间来实现 逻辑删除，例如 <code class="language-plaintext highlighter-rouge">deleted_time</code> 字段，如果 <code class="language-plaintext highlighter-rouge">deleted_time</code> 不为 <code class="language-plaintext highlighter-rouge">null</code> 则表示已经被删除。</p> <p><code class="language-plaintext highlighter-rouge">MyBatis-Plus</code> 对逻辑删除提供了支持，可以在 <code class="language-plaintext highlighter-rouge">application.yml</code> 配置全局的逻辑删除：</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">mybatis-plus</span><span class="pi">:</span>
  <span class="na">global-config</span><span class="pi">:</span>
    <span class="na">db-config</span><span class="pi">:</span>
      <span class="na">logic-delete-field</span><span class="pi">:</span> <span class="s">deleted</span> <span class="c1"># 全局逻辑删除字段名</span>
      <span class="na">logic-delete-value</span><span class="pi">:</span> <span class="m">1</span> <span class="c1"># 逻辑已删除值</span>
      <span class="na">logic-not-delete-value</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># 逻辑未删除值</span>
</code></pre></div></div> <p>可以在 <code class="language-plaintext highlighter-rouge">PO</code> 类中添加 <code class="language-plaintext highlighter-rouge">@TableLogic</code> 注解，指定逻辑删除字段：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserPO</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">,</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span>
    <span class="nd">@TableLogic</span> <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">deleted</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：即使配置了全局的逻辑删除字段，也 <strong>必须</strong> 在 <code class="language-plaintext highlighter-rouge">PO</code> 类中添加 <code class="language-plaintext highlighter-rouge">@TableLogic</code> 注解，指定逻辑删除字段。</p> <p>如果逻辑删除键使用的是类型是 <code class="language-plaintext highlighter-rouge">datetime</code> 类型，则可以使用如下的配置：</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">mybatis-plus</span><span class="pi">:</span>
  <span class="na">global-config</span><span class="pi">:</span>
    <span class="na">db-config</span><span class="pi">:</span>
      <span class="na">logic-delete-field</span><span class="pi">:</span> <span class="s">gmt_deleted</span> <span class="c1"># 全局逻辑删除字段名</span>
      <span class="na">logic-delete-value</span><span class="pi">:</span> <span class="s">now()</span> <span class="c1"># 逻辑已删除值</span>
      <span class="na">logic-not-delete-value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">null"</span> <span class="c1"># 逻辑未删除值 此处不能直接使用 null 而应该传入字符串的 "null"</span>
</code></pre></div></div> <h1 id="扩展-service">扩展 <code class="language-plaintext highlighter-rouge">Service</code></h1> <p>在实际的开发中，我们可能需要为 <code class="language-plaintext highlighter-rouge">Service</code> 接口添加一些自定义的方法。这里简单介绍如何进行扩展。假设我们 已经通过继承 <code class="language-plaintext highlighter-rouge">IService</code> 接口创建了一个 <code class="language-plaintext highlighter-rouge">UserService</code> 接口，我们可以通过以下方式为 <code class="language-plaintext highlighter-rouge">UserService</code> 接口 添加自定义的方法。</p> <p>首先，我们需要在 <code class="language-plaintext highlighter-rouge">UserService</code> 中定义自定义的方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="kd">extends</span> <span class="nc">IService</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">customMethod</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <p>接着，我们需要为 <code class="language-plaintext highlighter-rouge">UserService</code> 创建一个实现类，实现自定义的方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImpl</span> <span class="kd">extends</span> <span class="nc">ServiceImpl</span><span class="o">&lt;</span><span class="nc">UserMapper</span><span class="o">,</span> <span class="nc">UserPO</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">customMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 自定义的方法实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在实现类中，我们需要继承 <code class="language-plaintext highlighter-rouge">ServiceImpl</code> 类，这个类的泛型参数分别是 <code class="language-plaintext highlighter-rouge">Mapper</code> 接口和 <code class="language-plaintext highlighter-rouge">PO</code> 类，同时我们 还需要实现 <code class="language-plaintext highlighter-rouge">UserService</code> 接口中定义的方法。</p> <p>通过上述的操作后，自动装配 <code class="language-plaintext highlighter-rouge">UserService</code> 接口时会自动装配 <code class="language-plaintext highlighter-rouge">UserServiceImpl</code> 类，这样我们就可以使用 <code class="language-plaintext highlighter-rouge">UserService</code> 接口中定义的方法了。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring Boot"/><category term="MyBatis-Plus"/><summary type="html"><![CDATA[MyBatis 与 MyBatis-Plus 的区别 MyBatis 的主要功能是提供了对 SQL 的封装，可以通过 XML 或者注解的方式来配置 SQL，并且提供了对 SQL 的执行、结果映射等功能。MyBatis 对于所有的 SQL 都需要自己来编写。 MyBatis-Plus 可以理解成是 MyBatis 的增强工具，提供了很多实用的功能，比如分页、条件构造器、代码生成器等。 其中最重要的功能是提供了通用的 CRUD 方法，可以直接通过调用方法来实现 CRUD 操作，不需要自己编写 SQL。 除此之外，我在查阅文档的时候发现 MyBatis-Spring 部分的文档比较简陋，而 MyBatis-Plus 拥有更加详细的文档。 使用 MyBatis-Plus 实现 CRUD @MapperScan 与 MyBatis 相同的时，我们需要在启动类上添加 @MapperScan 注解，指定 Mapper 接口的包路径。例如 可以通过 @MapperScan("edu.cmipt.gcs.dao") 指定 Mapper 接口的包路径为 edu.cmipt.gcs.dao。这样 指定后 MyBatis-Plus 会自动将该路径下的 Mapper 接口注册到 Spring 容器中。 PO 对象 PO 对象是持久化对象，对应数据库中的表。通常情况下，我们会为每个表创建一个对应的 PO 对象。PO 对象 通常包含表中的字段，以及对应的 getter 和 setter 方法。 例如一张 user 表的结构如下： 字段名 类型 id BIGINT name VARCHAR age INT email VARCHAR 我们可以创建如下的 UserPO 类： @Data public class UserPO { private Long id, private String name, private Integer age, private String email } @TableName 上述的实例在 MyBatis-Plus 中对应的表名为 user_p_o，这是因为 MyBatis-Plus 默认会将驼峰命名的 字段转换为下划线分割的表名。如果我们希望使用自定义的表名，可以在 PO 类上添加 @TableName 注解，指定 表名。也就是说我们需要在类的头部添加 @TableName("user") 注解，指定表名为 user。 @TableID 如果上面的例子中的 id 字段是主键，我们可以在 id 字段上添加 @TableID 注解，指定主键的类型。这样 指定后才能使用 MyBatis-Plus 提供的一些与 ID 相关的方法。如果表中和 PO 类中的主键字段都叫 id， 则可以不用使用该注解。 BaseMapper 接口 通常情况下，我们会为每个 PO 对象创建一个对应的 Mapper 接口，继承 BaseMapper 接口。BaseMapper 接口提供了一些通用的 CRUD 方法，我们可以直接调用这些方法来实现 CRUD 操作。 例如我们可以通过以下方式创建一个 UserMapper 接口： public interface UserMapper extends BaseMapper&lt;UserPO&gt; {} insert // T 在这里代表继承时指定的 PO 类型，返回值代表受影响的行数 int insert(T entity); 我们可以配合自动装配轻松地使用 insert 方法，例如： @Autowired private UserMapper userMapper; public void insertUser(UserPO user) { userMapper.insert(user); } 注意：上面的接口返回值代表受影响的行数，通常情况下插入成功时返回 1，而插入失败时返回 0 。 delete // 根据 entity 条件，删除记录 int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); // 删除（根据ID 批量删除） int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); // 根据 ID 删除 int deleteById(Serializable id); // 根据 columnMap 条件，删除记录 int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 上面的后三种方式的使用方法应该是一目了然的，这里简单介绍一下第一种方式。Wrapper 是一个条件构造器， 我们可以通过 QueryWrapper 或者 UpdateWrapper 来构造条件。例如我们可以通过以下方式删除年龄大于 18 的用户： public void deleteUser() { Wrapper&lt;UserPO&gt; queryWrapper=new QueryWrapper&lt;&gt;(); queryWrapper.gt("age", 18); userMapper.delete(queryWrapper); } 而对于其他的方法，我们完全可以在编写的时候通过 IDE 的自动补全来查看使用方法。 update // 根据 whereWrapper 条件，更新记录 int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper); // 根据 ID 修改 int updateById(@Param(Constants.ENTITY) T entity); 例如，我们可以通过以下的方式修改 age 字段为 20 的用户的邮箱： public void updateUser() { UserPO user=new UserPO(null, null, 20, "123456@xxx.xxx"); Wrapper&lt;UserPO&gt; updateWrapper=new UpdateWrapper&lt;&gt;(); queryWrapper.eq("age", 20); userMapper.update(user, updateWrapper); } 上面出现了 UpdateWrapper 和 QueryWrapper 两个类，这两个类的功能非常类似，但是一般情况下我们 会使用 QueryWrapper 来构造查询条件，使用 UpdateWrapper 来构造更新条件。UpdateWrapper 提供了 set 方法，可以设置需要更新的字段，而不需要传入一个完整的 PO 对象。例如上面的例子我们可以修改成： public void updateUser() { Wrapper&lt;UserPO&gt; updateWrapper=new UpdateWrapper&lt;&gt;(); queryWrapper.eq("age", 20).set("email", "123456@xxx.xxx"); userMapper.update(updateWrapper); } select // 根据 ID 查询 T selectById(Serializable id); // 根据 entity 条件，查询一条记录 T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 查询（根据ID 批量查询） List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); // 根据 entity 条件，查询全部记录 List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 查询（根据 columnMap 条件） List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); // 根据 Wrapper 条件，查询全部记录 List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值 List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 根据 entity 条件，查询全部记录（并分页） IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 根据 Wrapper 条件，查询全部记录（并分页） IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); // 根据 Wrapper 条件，查询总记录数 Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 下面详细介绍以下分页查询的使用方法： public void selectUser() { // 每页 10 条记录，查询第 1 页 Page&lt;UserPO&gt; page=new Page&lt;&gt;(1, 10); Wrapper&lt;UserPO&gt; queryWrapper=new QueryWrapper&lt;&gt;(); queryWrapper.gt("age", 18); IPage&lt;UserPO&gt; userPage=userMapper.selectPage(page, queryWrapper); List&lt;UserPO&gt; userList=userPage.getRecords(); for (UserPO user : userList) { System.out.println(user); } } IService 接口 通常情况下，我们会为每个 Mapper 接口创建一个对应的 Service 接口，继承 IService 接口。IService 接口提供了一些通用的 CRUD 方法，我们可以直接调用这些方法来实现 CRUD 操作。与直接调用 Mapper 接口 相比，使用 Service 接口可以更好地实现业务逻辑与数据访问的分离。 IService 的适用方式与 BaseMapper 类似，例如： public interface UserService extends IService&lt;UserPO&gt; {} 完成上述操作后，我们便可以使用 UserService 接口中提供的各种方法了。使用的方式与直接调用 Mapper 接口类似，这里不再赘述。 逻辑删除 逻辑删除指的是通过一个字段来标识资源是否已经被删除，而不是真的从数据库中删除资源。逻辑删除的好处是可以 保留删除的记录，方便日后的数据分析。而逻辑删除的原理就是在 CRUD 操作时，通过增加一个条件来判断资源 是否已经被删除。例如使用逻辑删除后的查询语句均需要增加 where deleted=0 的条件 (如果 deleted=0 表示未被删除，deleted = 1 表示逻辑删除)。而有些数据库的设计者通过设置删除时间来实现 逻辑删除，例如 deleted_time 字段，如果 deleted_time 不为 null 则表示已经被删除。 MyBatis-Plus 对逻辑删除提供了支持，可以在 application.yml 配置全局的逻辑删除： mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除字段名 logic-delete-value: 1 # 逻辑已删除值 logic-not-delete-value: 0 # 逻辑未删除值 可以在 PO 类中添加 @TableLogic 注解，指定逻辑删除字段： @Data public class UserPO { private Long id, private String name, private Integer age, private String email, @TableLogic private Integer deleted } 注意：即使配置了全局的逻辑删除字段，也 必须 在 PO 类中添加 @TableLogic 注解，指定逻辑删除字段。 如果逻辑删除键使用的是类型是 datetime 类型，则可以使用如下的配置： mybatis-plus: global-config: db-config: logic-delete-field: gmt_deleted # 全局逻辑删除字段名 logic-delete-value: now() # 逻辑已删除值 logic-not-delete-value: "null" # 逻辑未删除值 此处不能直接使用 null 而应该传入字符串的 "null" 扩展 Service 在实际的开发中，我们可能需要为 Service 接口添加一些自定义的方法。这里简单介绍如何进行扩展。假设我们 已经通过继承 IService 接口创建了一个 UserService 接口，我们可以通过以下方式为 UserService 接口 添加自定义的方法。 首先，我们需要在 UserService 中定义自定义的方法： public interface UserService extends IService&lt;UserPO&gt; { void customMethod(); } 接着，我们需要为 UserService 创建一个实现类，实现自定义的方法： @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserPO&gt; implements UserService { @Override public void customMethod() { // 自定义的方法实现 } } 在实现类中，我们需要继承 ServiceImpl 类，这个类的泛型参数分别是 Mapper 接口和 PO 类，同时我们 还需要实现 UserService 接口中定义的方法。 通过上述的操作后，自动装配 UserService 接口时会自动装配 UserServiceImpl 类，这样我们就可以使用 UserService 接口中定义的方法了。]]></summary></entry><entry><title type="html">Spring MVC 简介</title><link href="https://kaiser-yang.github.io/blog/2024/spring-mvc-intro/" rel="alternate" type="text/html" title="Spring MVC 简介"/><published>2024-08-14T03:59:00+00:00</published><updated>2024-08-14T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-mvc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-mvc-intro/"><![CDATA[<h1 id="servlet-与-spring-mvc"><code class="language-plaintext highlighter-rouge">Servlet</code> 与 <code class="language-plaintext highlighter-rouge">Spring MVC</code></h1> <p>在开始介绍 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 之前，我们需要先了解一下什么 <code class="language-plaintext highlighter-rouge">Servlet</code>。</p> <h2 id="servlet"><code class="language-plaintext highlighter-rouge">Servlet</code></h2> <p><code class="language-plaintext highlighter-rouge">Servlet</code> 是 <code class="language-plaintext highlighter-rouge">Java</code> 的一个规范，其提供了 <code class="language-plaintext highlighter-rouge">Java</code> 处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的能力，<code class="language-plaintext highlighter-rouge">Servlet</code> 是基于 <code class="language-plaintext highlighter-rouge">Java</code> 的 <code class="language-plaintext highlighter-rouge">Web</code> 开发的基础，通过自定义 <code class="language-plaintext highlighter-rouge">Servlet</code> 并继承 <code class="language-plaintext highlighter-rouge">HttpServlet</code> 可以处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求。而在 <code class="language-plaintext highlighter-rouge">MVC</code> 的架构中， <code class="language-plaintext highlighter-rouge">Servlet</code> 通常可以看成时 <code class="language-plaintext highlighter-rouge">Controller</code> 层。</p> <h2 id="spring-mvc"><code class="language-plaintext highlighter-rouge">Spring MVC</code></h2> <p><code class="language-plaintext highlighter-rouge">Spring MVC</code> 是 <code class="language-plaintext highlighter-rouge">Spring</code> 框架的一个模块，其提供了一个 <code class="language-plaintext highlighter-rouge">MVC</code> 的架构，可以帮助我们更好的开发 <code class="language-plaintext highlighter-rouge">Web</code> 应用。 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 是基于 <code class="language-plaintext highlighter-rouge">Servlet</code> 的，其提供了一个 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code> 来处理请求，<code class="language-plaintext highlighter-rouge">Controller</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象， <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象包含了 <code class="language-plaintext highlighter-rouge">Model</code> 和 <code class="language-plaintext highlighter-rouge">View</code>，<code class="language-plaintext highlighter-rouge">Model</code> 用于存放数据，<code class="language-plaintext highlighter-rouge">View</code> 用于展示数据。但是在 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 中 <code class="language-plaintext highlighter-rouge">Controller</code> 通常不会返回 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象，而是直接返回一个对象，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动将对象转换为 <code class="language-plaintext highlighter-rouge">JSON</code> 格式返回给客户端。</p> <h1 id="dispatcherservlet"><code class="language-plaintext highlighter-rouge">DispatcherServlet</code></h1> <p><code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 是 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 的核心，其继承自 <code class="language-plaintext highlighter-rouge">HttpServlet</code>，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code> 来处理请求，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到一个 <code class="language-plaintext highlighter-rouge">HandlerMapping</code> 对象， <code class="language-plaintext highlighter-rouge">HandlerMapping</code> 对象会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code>，<code class="language-plaintext highlighter-rouge">Controller</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象， <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象找到对应的 <code class="language-plaintext highlighter-rouge">View</code> 来展示数据。</p> <p>不过在现在看来 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 已经渐渐的失去了 <code class="language-plaintext highlighter-rouge">V</code> 的功能，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 通常只用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，而 <code class="language-plaintext highlighter-rouge">View</code> 通常是前端框架来处理的，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 通常会直接返回一个对象，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动将对象转换为 <code class="language-plaintext highlighter-rouge">JSON</code> 格式返回给客户端。</p> <p>因此在介绍的时候不会完整恩介绍 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 而是着重的介绍如何使用一些 <code class="language-plaintext highlighter-rouge">Controller</code> 层的注解。</p> <h1 id="filters"><code class="language-plaintext highlighter-rouge">Filters</code></h1> <p><code class="language-plaintext highlighter-rouge">Filters</code> 是 <code class="language-plaintext highlighter-rouge">Servlet</code> 的一个规范，其可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，<code class="language-plaintext highlighter-rouge">Filters</code> 通常用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的 一些预处理和后处理，<code class="language-plaintext highlighter-rouge">Filters</code> 通常可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的编码，<code class="language-plaintext highlighter-rouge">HTTP</code> 请求的安全等。例如我们可以 <code class="language-plaintext highlighter-rouge">Filter</code> 只允许通过 <code class="language-plaintext highlighter-rouge">Get</code> 方法访问某个 <code class="language-plaintext highlighter-rouge">URL</code>，或者我们可以在 <code class="language-plaintext highlighter-rouge">Filter</code> 中对 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的编码进行处理。 同一个 <code class="language-plaintext highlighter-rouge">URL</code> 可以有多个 <code class="language-plaintext highlighter-rouge">Filter</code>，<code class="language-plaintext highlighter-rouge">Filter</code> 会按照 <code class="language-plaintext highlighter-rouge">Filter</code> 的 <code class="language-plaintext highlighter-rouge">order</code> 属性的值来执行，<code class="language-plaintext highlighter-rouge">order</code> 的值 越小越先执行。 <code class="language-plaintext highlighter-rouge">Filter</code> 运行在 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 之前。</p> <h1 id="请求与多线程">请求与多线程</h1> <p>在这里不得不介绍一下 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的多线程问题，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 是基于 <code class="language-plaintext highlighter-rouge">Servlet</code> 的，<code class="language-plaintext highlighter-rouge">Servlet</code> 是多线程的，<code class="language-plaintext highlighter-rouge">Servlet</code> 会为每一个请求创建一个线程来处理请求，因此在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的方法是多线程的， 而线程池是由 <code class="language-plaintext highlighter-rouge">Tomcat</code> (默认的 <code class="language-plaintext highlighter-rouge">Web</code> 服务器) 来管理的。</p> <p>这也就涉及到了老生常谈的问题：<code class="language-plaintext highlighter-rouge">Spring</code> 与多线程的问题。<code class="language-plaintext highlighter-rouge">Spring</code> 本身对于多线程并没有什么特殊的处理， 且在使用单俐模式创建对象时，<code class="language-plaintext highlighter-rouge">Spring</code> 不是线程安全的，而在 <code class="language-plaintext highlighter-rouge">Spring</code> 处理请求的过程中，我们知道 <code class="language-plaintext highlighter-rouge">Tomcat</code> 会为每一个 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求创建一个线程进行处理，因此在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的方法是多线程的，这会引发 线程安全的问题，但是在实际的过程中，大多数情况下不会出现线程安全问题，这又是为什么呢？</p> <p>在实际处理一个请求的 <code class="language-plaintext highlighter-rouge">Controller</code> 类中，我们会发现出现的所有的变量都是局部变量，这样的类也被称为 无状态类，无状态类是线程安全的，因为每一个线程都会有自己的局部变量，不会出现线程安全的问题。但是对于 <code class="language-plaintext highlighter-rouge">DAO</code> 层的类，我们往往需要额外考虑线程安全的问题。</p> <h1 id="使用注解编写-controller">使用注解编写 <code class="language-plaintext highlighter-rouge">Controller</code></h1> <h2 id="controller"><code class="language-plaintext highlighter-rouge">@Controller</code></h2> <p>该注解用于标记一个类是 <code class="language-plaintext highlighter-rouge">Controller</code> 类，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动扫描所有的 <code class="language-plaintext highlighter-rouge">Controller</code> 类，并将其注册到 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中。</p> <h2 id="requestmapping"><code class="language-plaintext highlighter-rouge">@RequestMapping</code></h2> <p>该注解用于标记一个方法处理的 <code class="language-plaintext highlighter-rouge">URL</code>，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 可以标记在类上，也可以标记在方法上，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 可以接受一个 <code class="language-plaintext highlighter-rouge">URL</code>，也可以接受一个 <code class="language-plaintext highlighter-rouge">URL</code> 的数组，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 还可以接受一些参数，例如：<code class="language-plaintext highlighter-rouge">method</code>、 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code>。</p> <p><code class="language-plaintext highlighter-rouge">method</code> 用于指定请求的方法，<code class="language-plaintext highlighter-rouge">consumes</code> 用于指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code>，<code class="language-plaintext highlighter-rouge">produces</code> 用于指定返回的 <code class="language-plaintext highlighter-rouge">Content-Type</code>，<code class="language-plaintext highlighter-rouge">headers</code> 用于指定请求的头部信息，<code class="language-plaintext highlighter-rouge">params</code> 用于指定请求的参数。</p> <p>但是，一般情况下我们并不直接使用 <code class="language-plaintext highlighter-rouge">@RequestMapping</code> 注解，而是使用以下几种衍生注解：</p> <ul> <li><code class="language-plaintext highlighter-rouge">@GetMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">GET</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.GET)</code></li> <li><code class="language-plaintext highlighter-rouge">@PostMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">POST</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.POST)</code></li> <li><code class="language-plaintext highlighter-rouge">@PutMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">PUT</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.PUT)</code></li> <li><code class="language-plaintext highlighter-rouge">@DeleteMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">DELETE</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.DELETE)</code></li> </ul> <p>以下的几个例子展示了如何指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code>、<code class="language-plaintext highlighter-rouge">Accept</code>、<code class="language-plaintext highlighter-rouge">Headers</code>、<code class="language-plaintext highlighter-rouge">Params</code>：</p> <ol> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', consumes = 'application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'Content-Type=application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', produces = 'application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'Accept=application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'MyHeader=myValue')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', params = 'myParam=myValue')</code></li> </ol> <p>上述的例子中的第一条于第二条、第三条于第四条等价。也就是说对于 <code class="language-plaintext highlighter-rouge">consumes</code> 参数而言，只有当请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 与 <code class="language-plaintext highlighter-rouge">consumes</code> 参数的值相同时，才会匹配成功，对于 <code class="language-plaintext highlighter-rouge">produces</code> 参数而言，只有当请求头中的 <code class="language-plaintext highlighter-rouge">Accept</code> 与 <code class="language-plaintext highlighter-rouge">produces</code> 参数的值相同时，才会匹配成功。<code class="language-plaintext highlighter-rouge">Spring MVC</code> 官方更加推荐使用 <code class="language-plaintext highlighter-rouge">consumes</code> 和 <code class="language-plaintext highlighter-rouge">produces</code> 参数来指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 和 <code class="language-plaintext highlighter-rouge">Accept</code>。</p> <p>其他的几个注解可以类似地使用 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数。</p> <p>NOTE: 如果一个 <code class="language-plaintext highlighter-rouge">Controller</code> 的每个方法都需要指定 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数， 那么我们可以在 <code class="language-plaintext highlighter-rouge">Controller</code> 类上使用 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数，这样在 <code class="language-plaintext highlighter-rouge">Controller</code> 类中的每个方法都会默认使用这些参数，而如果某个方法需要不同的参数，那么可以在方法上覆盖这些参数。</p> <p>接下来介绍一下 <code class="language-plaintext highlighter-rouge">path</code> 参数地模糊匹配规则：</p> <ul> <li><code class="language-plaintext highlighter-rouge">"?"</code> 匹配一个字符。</li> <li><code class="language-plaintext highlighter-rouge">"*"</code> 匹配一个路径下的任意字符。</li> <li><code class="language-plaintext highlighter-rouge">"**"</code> 匹配一个或者多个路径下的任意字符。</li> <li><code class="language-plaintext highlighter-rouge">"/projects/{project}/versions"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">project</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数。</li> <li><code class="language-plaintext highlighter-rouge">"/projects/{project:[a-z]+}/versions"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">project</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数， 且 <code class="language-plaintext highlighter-rouge">project</code> 的值必须是小写字母。</li> <li><code class="language-plaintext highlighter-rouge">"/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">name</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数，<code class="language-plaintext highlighter-rouge">version</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数，<code class="language-plaintext highlighter-rouge">ext</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数， <code class="language-plaintext highlighter-rouge">name</code> 的值必须是小写字母和 <code class="language-plaintext highlighter-rouge">-</code>，<code class="language-plaintext highlighter-rouge">version</code> 的值必须是 <code class="language-plaintext highlighter-rouge">x.x.x</code> 的格式，<code class="language-plaintext highlighter-rouge">ext</code> 的值必须是 <code class="language-plaintext highlighter-rouge">.</code> 开头的小写字母。</li> </ul> <h1 id="使用不同的注解获取参数">使用不同的注解获取参数</h1> <h2 id="requestparam"><code class="language-plaintext highlighter-rouge">@RequestParam</code></h2> <p>对于一些方法，我们需要获取请求参数，而 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解可以帮助我们从请求中获取参数 (也就是 <code class="language-plaintext highlighter-rouge">?</code> 后面的参数)。<code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>例如一个方法的参数被 <code class="language-plaintext highlighter-rouge">@RequestParma("id")</code> 修饰，而请求中包含 <code class="language-plaintext highlighter-rouge">?id=3</code> 那么这个参数将会被填入 <code class="language-plaintext highlighter-rouge">3</code>。</p> <p>NOTE: 通常对于一个没有任何注解标注的参数，其默认会通过 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解来获取参数。</p> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="requestheader"><code class="language-plaintext highlighter-rouge">@RequestHeader</code></h2> <p>该注解用于获取请求头中的参数，<code class="language-plaintext highlighter-rouge">@RequestHeader</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="cookievalue"><code class="language-plaintext highlighter-rouge">@CookieValue</code></h2> <p>其实该注解也是用于获取请求头中的参数，只不过该注解往往标识获取 <code class="language-plaintext highlighter-rouge">coockie</code> 信息能够增加码的可读性。其 使用方法与 <code class="language-plaintext highlighter-rouge">@RequestHeader</code> 类似。</p> <h2 id="pathvariable"><code class="language-plaintext highlighter-rouge">@PathVariable</code></h2> <p>该注解用于获取 <code class="language-plaintext highlighter-rouge">URL</code> 中的参数，<code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>例如一个方法被 <code class="language-plaintext highlighter-rouge">@GetMapping("/test/{id}")</code> 修饰，其某个参数被 <code class="language-plaintext highlighter-rouge">@PathVariable("id")</code> 修饰，而请求中 为 <code class="language-plaintext highlighter-rouge">/test/3</code> 那么被修饰的参数将会填上 <code class="language-plaintext highlighter-rouge">3</code>。</p> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="requestpart"><code class="language-plaintext highlighter-rouge">@RequestPart</code></h2> <p>该注解用于获取请求中的 <code class="language-plaintext highlighter-rouge">Multipart</code> 参数，<code class="language-plaintext highlighter-rouge">@RequestPart</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p>该注解一般用在 <code class="language-plaintext highlighter-rouge">MultipartFile</code> 类型的参数上，用于获取上传的文件。</p> <h2 id="requestbody"><code class="language-plaintext highlighter-rouge">@RequestBody</code></h2> <p>使用该注解可以获取请求体中的参数，<code class="language-plaintext highlighter-rouge">@RequestBody</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p>该注解一般用于 <code class="language-plaintext highlighter-rouge">POST</code> 方法获取请求体中的参数。需要注意的是，<code class="language-plaintext highlighter-rouge">@RequestBody</code> 注解只能用于一个参数上， 其作用是将整个请求体封装到这个参数中。一般而言，对于 <code class="language-plaintext highlighter-rouge">JSON</code> 格式的请求体，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动将其转换为 <code class="language-plaintext highlighter-rouge">Java</code> 对象，当然这得要求请求体中的键值对与 <code class="language-plaintext highlighter-rouge">Java</code> 对象的属性名一致。在两者不一致的时候，可以在 <code class="language-plaintext highlighter-rouge">Java</code> 对象的属性上使用 <code class="language-plaintext highlighter-rouge">@JsonProperty</code> 注解来指定键值对的键名。也可以使用 <code class="language-plaintext highlighter-rouge">@JsonAlias</code> 注解来指定多个键名， 但是这个注解必须要依赖于 <code class="language-plaintext highlighter-rouge">setter</code> 和 <code class="language-plaintext highlighter-rouge">getter</code>。</p> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">Swagger</code> 中也有一个注解 <code class="language-plaintext highlighter-rouge">@RequestBody</code>，其作用是指定请求体的格式，这两个注解是不同的。 在 <code class="language-plaintext highlighter-rouge">import</code> 的时候要注意引入正确的注解。</p> <h1 id="controller-返回数据"><code class="language-plaintext highlighter-rouge">Controller</code> 返回数据</h1> <h2 id="responsebody"><code class="language-plaintext highlighter-rouge">@ResponseBody</code></h2> <p>该注解用于标记一个方法的返回值会放置到 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应体中，<code class="language-plaintext highlighter-rouge">Spring</code> 会根据请求头中的 <code class="language-plaintext highlighter-rouge">Accept</code> 内容自动 选择合适的 <code class="language-plaintext highlighter-rouge">HttpMessageConverter</code> 转换返回值。当声明了 <code class="language-plaintext highlighter-rouge">produces="application/json"</code> 时，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动选择 <code class="language-plaintext highlighter-rouge">MappingJackson2HttpMessageConverter</code> 来转换返回值。</p> <h2 id="restcontroller"><code class="language-plaintext highlighter-rouge">@RestController</code></h2> <p>该注解是 <code class="language-plaintext highlighter-rouge">@Controller</code> 和 <code class="language-plaintext highlighter-rouge">@ResponseBody</code> 的组合。标明该类的所有方法都被 <code class="language-plaintext highlighter-rouge">@ResponseBody</code> 标注。</p> <h1 id="跨域问题">跨域问题</h1> <p>在通常的情况下，为了保护用户的数据，浏览器会限制跨域请求，也就是说浏览器不允许一个源向另一个源发送 请求。同一个源指的是协议、域名、端口号都相同。</p> <p>而对于一个前后端分离的程序而言，其前端永远也不可能和后端在同一个源上，这也意味着：即使前端和后端程序 部署在同一个服务器上，但是由于端口不同，也会被浏览器拦截。</p> <p>而对于浏览器的拦截策略，其往往有以下过程：</p> <ol> <li>浏览器向服务器发送一个 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求，询问服务器是否允许跨域请求。</li> <li>服务器返回信息以说明是否允许跨域请求。</li> <li>当访问的域名没有被允许时，浏览器会拦截请求。否则，浏览器会发送真正的请求。</li> </ol> <p>也就是说要解决跨域问题，我们只需要在服务端增加能够处理特定 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 的请求，在对应的响应体中添加支持 跨域访问的 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息即可。</p> <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing</a> 介绍了 <code class="language-plaintext highlighter-rouge">CORS</code> 是如何工作的，你可以阅读这篇文章以获取更加详细的信息。</p> <p>在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中解决跨域问题使容易的，因为 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 为跨域问题做了内置的处理: 当收到一个 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求时，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 会寻找用户的跨域配置，如果找到了，那么 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 会自动返回一个 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息。 否则，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 会直接拒绝。</p> <h2 id="使用-crossorigin-解决局部跨域问题">使用 <code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 解决局部跨域问题</h2> <p>该注解用于标注一个方法支持跨域请求，<code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">origins</code> 用于指定允许跨域的源，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">methods</code> 用于指定允许跨域的方法，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">allowedHeaders</code> 用于指定允许跨域的头部信息，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">exposedHeaders</code> 用于指定允许跨域的头部信息，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">allowCredentials</code> 用于指定是否允许携带 <code class="language-plaintext highlighter-rouge">cookie</code>，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">maxAge</code> 用于指定 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求的缓存时间，单位为秒。</li> </ul> <p>默认情况下，<code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 注解会允许所有的跨域请求，并且支持所有头部信息，不允许携带 <code class="language-plaintext highlighter-rouge">cookie</code>，<code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求的缓存时间为 <code class="language-plaintext highlighter-rouge">1800</code> 秒。</p> <p>当然该注解可以标注在类上，用于标识该 <code class="language-plaintext highlighter-rouge">Controller</code> 的所有方法默认支持跨域请求。</p> <h2 id="使用-webmvcconfigurer-解决全局跨域问题">使用 <code class="language-plaintext highlighter-rouge">WebMvcConfigurer</code> 解决全局跨域问题</h2> <p>在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中可以通过添加一个如下的配置类为全局配置代理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCorsMappings</span><span class="o">(</span><span class="nc">CorsRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">"/api/**"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedOrigins</span><span class="o">(</span><span class="s">"https://domain2.com"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedMethods</span><span class="o">(</span><span class="s">"PUT"</span><span class="o">,</span> <span class="s">"DELETE"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedHeaders</span><span class="o">(</span><span class="s">"header1"</span><span class="o">,</span> <span class="s">"header2"</span><span class="o">,</span> <span class="s">"header3"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">exposedHeaders</span><span class="o">(</span><span class="s">"header1"</span><span class="o">,</span> <span class="s">"header2"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">).</span><span class="na">maxAge</span><span class="o">(</span><span class="mi">3600</span><span class="o">);</span>

        <span class="c1">// Add more mappings...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="使用-filter-来解决跨域问题">使用 <code class="language-plaintext highlighter-rouge">Filter</code> 来解决跨域问题</h2> <p>在前面的介绍中我们提到了跨域要允许跨域只需要对特定的 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求返回 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息即可，而我们 介绍了 <code class="language-plaintext highlighter-rouge">Filter</code> 可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的预处理和后处理，因此我们可以使用 <code class="language-plaintext highlighter-rouge">Filter</code> 来处理跨域问题。 而 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中默认提供了一个类型为 <code class="language-plaintext highlighter-rouge">CorFilter</code> 的过滤器用于处理跨域问题，我们只需要在 <code class="language-plaintext highlighter-rouge">Spring</code> 的 <code class="language-plaintext highlighter-rouge">IoC</code> 容器中注册这个过滤器即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CorsConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CorsFilter</span> <span class="nf">corsFilter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">UrlBasedCorsConfigurationSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlBasedCorsConfigurationSource</span><span class="o">();</span>
        <span class="nc">CorsConfiguration</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedOrigin</span><span class="o">(</span><span class="s">"http://localhost:3000"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedHeader</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">source</span><span class="o">.</span><span class="na">registerCorsConfiguration</span><span class="o">(</span><span class="s">"/**"</span><span class="o">,</span> <span class="n">config</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CorsFilter</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在更改 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 的配置的时候需要增加 <code class="language-plaintext highlighter-rouge">@EnableWebMvc</code> 注解。</p> <p><code class="language-plaintext highlighter-rouge">@ResponseStatus</code> <code class="language-plaintext highlighter-rouge">@SessionAttributes</code> <code class="language-plaintext highlighter-rouge">@ModelAttribute</code> <code class="language-plaintext highlighter-rouge">@InitBinder</code> <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> <code class="language-plaintext highlighter-rouge">@CrossOrigin</code></p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><summary type="html"><![CDATA[Servlet 与 Spring MVC 在开始介绍 Spring MVC 之前，我们需要先了解一下什么 Servlet。 Servlet Servlet 是 Java 的一个规范，其提供了 Java 处理 HTTP 请求的能力，Servlet 是基于 Java 的 Web 开发的基础，通过自定义 Servlet 并继承 HttpServlet 可以处理 HTTP 请求。而在 MVC 的架构中， Servlet 通常可以看成时 Controller 层。 Spring MVC Spring MVC 是 Spring 框架的一个模块，其提供了一个 MVC 的架构，可以帮助我们更好的开发 Web 应用。 Spring MVC 是基于 Servlet 的，其提供了一个 DispatcherServlet 来处理 HTTP 请求，DispatcherServlet 会根据请求的 URL 找到对应的 Controller 来处理请求，Controller 会返回一个 ModelAndView 对象， ModelAndView 对象包含了 Model 和 View，Model 用于存放数据，View 用于展示数据。但是在 Spring Boot 中 Controller 通常不会返回 ModelAndView 对象，而是直接返回一个对象，Spring Boot 会自动将对象转换为 JSON 格式返回给客户端。 DispatcherServlet DispatcherServlet 是 Spring MVC 的核心，其继承自 HttpServlet，DispatcherServlet 会根据请求的 URL 找到对应的 Controller 来处理请求，DispatcherServlet 会根据请求的 URL 找到一个 HandlerMapping 对象， HandlerMapping 对象会根据请求的 URL 找到对应的 Controller，Controller 会返回一个 ModelAndView 对象， DispatcherServlet 会根据 ModelAndView 对象找到对应的 View 来展示数据。 不过在现在看来 Spring MVC 已经渐渐的失去了 V 的功能，Spring MVC 通常只用来处理 HTTP 请求，而 View 通常是前端框架来处理的，Spring Boot 通常会直接返回一个对象，Spring Boot 会自动将对象转换为 JSON 格式返回给客户端。 因此在介绍的时候不会完整恩介绍 Spring MVC 而是着重的介绍如何使用一些 Controller 层的注解。 Filters Filters 是 Servlet 的一个规范，其可以用来处理 HTTP 请求，Filters 通常用来处理 HTTP 请求的 一些预处理和后处理，Filters 通常可以用来处理 HTTP 请求的编码，HTTP 请求的安全等。例如我们可以 Filter 只允许通过 Get 方法访问某个 URL，或者我们可以在 Filter 中对 HTTP 请求的编码进行处理。 同一个 URL 可以有多个 Filter，Filter 会按照 Filter 的 order 属性的值来执行，order 的值 越小越先执行。 Filter 运行在 DispatcherServlet 之前。 请求与多线程 在这里不得不介绍一下 Spring MVC 中处理请求的多线程问题，Spring MVC 是基于 Servlet 的，Servlet 是多线程的，Servlet 会为每一个请求创建一个线程来处理请求，因此在 Spring MVC 中处理请求的方法是多线程的， 而线程池是由 Tomcat (默认的 Web 服务器) 来管理的。 这也就涉及到了老生常谈的问题：Spring 与多线程的问题。Spring 本身对于多线程并没有什么特殊的处理， 且在使用单俐模式创建对象时，Spring 不是线程安全的，而在 Spring 处理请求的过程中，我们知道 Tomcat 会为每一个 HTTP 请求创建一个线程进行处理，因此在 Spring MVC 中处理请求的方法是多线程的，这会引发 线程安全的问题，但是在实际的过程中，大多数情况下不会出现线程安全问题，这又是为什么呢？ 在实际处理一个请求的 Controller 类中，我们会发现出现的所有的变量都是局部变量，这样的类也被称为 无状态类，无状态类是线程安全的，因为每一个线程都会有自己的局部变量，不会出现线程安全的问题。但是对于 DAO 层的类，我们往往需要额外考虑线程安全的问题。 使用注解编写 Controller @Controller 该注解用于标记一个类是 Controller 类，Spring 会自动扫描所有的 Controller 类，并将其注册到 Spring 容器中。 @RequestMapping 该注解用于标记一个方法处理的 URL，@RequestMapping 可以标记在类上，也可以标记在方法上，@RequestMapping 可以接受一个 URL，也可以接受一个 URL 的数组，@RequestMapping 还可以接受一些参数，例如：method、 consumes、produces、headers、params。 method 用于指定请求的方法，consumes 用于指定请求的 Content-Type，produces 用于指定返回的 Content-Type，headers 用于指定请求的头部信息，params 用于指定请求的参数。 但是，一般情况下我们并不直接使用 @RequestMapping 注解，而是使用以下几种衍生注解： @GetMapping 用于处理 GET 请求，等价于 @RequestMapping(method = RequestMethod.GET) @PostMapping 用于处理 POST 请求，等价于 @RequestMapping(method = RequestMethod.POST) @PutMapping 用于处理 PUT 请求，等价于 @RequestMapping(method = RequestMethod.PUT) @DeleteMapping 用于处理 DELETE 请求，等价于 @RequestMapping(method = RequestMethod.DELETE) 以下的几个例子展示了如何指定请求的 Content-Type、Accept、Headers、Params： @GetMapping(path = '/test', consumes='application/json') @GetMapping(path = '/test', headers='Content-Type=application/json') @GetMapping(path = '/test', produces='application/json') @GetMapping(path = '/test', headers='Accept=application/json') @GetMapping(path = '/test', headers='MyHeader=myValue') @GetMapping(path = '/test', params='myParam=myValue') 上述的例子中的第一条于第二条、第三条于第四条等价。也就是说对于 consumes 参数而言，只有当请求头中的 Content-Type 与 consumes 参数的值相同时，才会匹配成功，对于 produces 参数而言，只有当请求头中的 Accept 与 produces 参数的值相同时，才会匹配成功。Spring MVC 官方更加推荐使用 consumes 和 produces 参数来指定请求的 Content-Type 和 Accept。 其他的几个注解可以类似地使用 consumes、produces、headers、params 参数。 NOTE: 如果一个 Controller 的每个方法都需要指定 consumes、produces、headers、params 参数， 那么我们可以在 Controller 类上使用 consumes、produces、headers、params 参数，这样在 Controller 类中的每个方法都会默认使用这些参数，而如果某个方法需要不同的参数，那么可以在方法上覆盖这些参数。 接下来介绍一下 path 参数地模糊匹配规则： "?" 匹配一个字符。 "*" 匹配一个路径下的任意字符。 "**" 匹配一个或者多个路径下的任意字符。 "/projects/{project}/versions" 匹配后将 project 的值传递给 @PathVariable 注解的参数。 "/projects/{project:[a-z]+}/versions" 匹配后将 project 的值传递给 @PathVariable 注解的参数， 且 project 的值必须是小写字母。 "/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}" 匹配后将 name 的值传递给 @PathVariable 注解的参数，version 的值传递给 @PathVariable 注解的参数，ext 的值传递给 @PathVariable 注解的参数， name 的值必须是小写字母和 -，version 的值必须是 x.x.x 的格式，ext 的值必须是 . 开头的小写字母。 使用不同的注解获取参数 @RequestParam 对于一些方法，我们需要获取请求参数，而 @RequestParam 注解可以帮助我们从请求中获取参数 (也就是 ? 后面的参数)。@RequestParam 注解可以接受以下参数： value 或 name 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 例如一个方法的参数被 @RequestParma("id") 修饰，而请求中包含 ?id=3 那么这个参数将会被填入 3。 NOTE: 通常对于一个没有任何注解标注的参数，其默认会通过 @RequestParam 注解来获取参数。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @RequestHeader 该注解用于获取请求头中的参数，@RequestHeader 注解可以接受以下参数： value 或 name 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @CookieValue 其实该注解也是用于获取请求头中的参数，只不过该注解往往标识获取 coockie 信息能够增加码的可读性。其 使用方法与 @RequestHeader 类似。 @PathVariable 该注解用于获取 URL 中的参数，@PathVariable 注解可以接受以下参数： value 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 例如一个方法被 @GetMapping("/test/{id}") 修饰，其某个参数被 @PathVariable("id") 修饰，而请求中 为 /test/3 那么被修饰的参数将会填上 3。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @RequestPart 该注解用于获取请求中的 Multipart 参数，@RequestPart 注解可以接受以下参数： value 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 该注解一般用在 MultipartFile 类型的参数上，用于获取上传的文件。 @RequestBody 使用该注解可以获取请求体中的参数，@RequestBody 注解可以接受以下参数： required 用于指定参数是否必须，默认为 true。 该注解一般用于 POST 方法获取请求体中的参数。需要注意的是，@RequestBody 注解只能用于一个参数上， 其作用是将整个请求体封装到这个参数中。一般而言，对于 JSON 格式的请求体，Spring 会自动将其转换为 Java 对象，当然这得要求请求体中的键值对与 Java 对象的属性名一致。在两者不一致的时候，可以在 Java 对象的属性上使用 @JsonProperty 注解来指定键值对的键名。也可以使用 @JsonAlias 注解来指定多个键名， 但是这个注解必须要依赖于 setter 和 getter。 注意：在 Swagger 中也有一个注解 @RequestBody，其作用是指定请求体的格式，这两个注解是不同的。 在 import 的时候要注意引入正确的注解。 Controller 返回数据 @ResponseBody 该注解用于标记一个方法的返回值会放置到 HTTP 响应体中，Spring 会根据请求头中的 Accept 内容自动 选择合适的 HttpMessageConverter 转换返回值。当声明了 produces="application/json" 时，Spring 会自动选择 MappingJackson2HttpMessageConverter 来转换返回值。 @RestController 该注解是 @Controller 和 @ResponseBody 的组合。标明该类的所有方法都被 @ResponseBody 标注。 跨域问题 在通常的情况下，为了保护用户的数据，浏览器会限制跨域请求，也就是说浏览器不允许一个源向另一个源发送 请求。同一个源指的是协议、域名、端口号都相同。 而对于一个前后端分离的程序而言，其前端永远也不可能和后端在同一个源上，这也意味着：即使前端和后端程序 部署在同一个服务器上，但是由于端口不同，也会被浏览器拦截。 而对于浏览器的拦截策略，其往往有以下过程： 浏览器向服务器发送一个 OPTIONS 请求，询问服务器是否允许跨域请求。 服务器返回信息以说明是否允许跨域请求。 当访问的域名没有被允许时，浏览器会拦截请求。否则，浏览器会发送真正的请求。 也就是说要解决跨域问题，我们只需要在服务端增加能够处理特定 OPTIONS 的请求，在对应的响应体中添加支持 跨域访问的 CORS 的头部信息即可。 Cross-Origin Resource Sharing 介绍了 CORS 是如何工作的，你可以阅读这篇文章以获取更加详细的信息。 在 Spring MVC 中解决跨域问题使容易的，因为 Spring MVC 为跨域问题做了内置的处理: 当收到一个 OPTIONS 请求时，Spring MVC 会寻找用户的跨域配置，如果找到了，那么 Spring MVC 会自动返回一个 CORS 的头部信息。 否则，Spring MVC 会直接拒绝。 使用 @CrossOrigin 解决局部跨域问题 该注解用于标注一个方法支持跨域请求，@CrossOrigin 注解可以接受以下参数： origins 用于指定允许跨域的源，可以是一个字符串数组。 methods 用于指定允许跨域的方法，可以是一个字符串数组。 allowedHeaders 用于指定允许跨域的头部信息，可以是一个字符串数组。 exposedHeaders 用于指定允许跨域的头部信息，可以是一个字符串数组。 allowCredentials 用于指定是否允许携带 cookie，默认为 false。 maxAge 用于指定 OPTIONS 请求的缓存时间，单位为秒。 默认情况下，@CrossOrigin 注解会允许所有的跨域请求，并且支持所有头部信息，不允许携带 cookie，OPTIONS 请求的缓存时间为 1800 秒。 当然该注解可以标注在类上，用于标识该 Controller 的所有方法默认支持跨域请求。 使用 WebMvcConfigurer 解决全局跨域问题 在 Spring MVC 中可以通过添加一个如下的配置类为全局配置代理： @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/api/**") .allowedOrigins("https://domain2.com") .allowedMethods("PUT", "DELETE") .allowedHeaders("header1", "header2", "header3") .exposedHeaders("header1", "header2") .allowCredentials(true).maxAge(3600); // Add more mappings... } } 使用 Filter 来解决跨域问题 在前面的介绍中我们提到了跨域要允许跨域只需要对特定的 OPTIONS 请求返回 CORS 的头部信息即可，而我们 介绍了 Filter 可以用来处理 HTTP 请求的预处理和后处理，因此我们可以使用 Filter 来处理跨域问题。 而 Spring MVC 中默认提供了一个类型为 CorFilter 的过滤器用于处理跨域问题，我们只需要在 Spring 的 IoC 容器中注册这个过滤器即可： @Configuration @EnableWebMvc public class CorsConfig { @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource(); CorsConfiguration config=new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("http://localhost:3000"); config.addAllowedHeader("*"); config.addAllowedMethod("*"); source.registerCorsConfiguration("/**", config); return new CorsFilter(source); } } 在更改 Spring MVC 的配置的时候需要增加 @EnableWebMvc 注解。 @ResponseStatus @SessionAttributes @ModelAttribute @InitBinder @ExceptionHandler @ControllerAdvice @CrossOrigin]]></summary></entry><entry><title type="html">Mock Mvc 简介</title><link href="https://kaiser-yang.github.io/blog/2024/mock-mvc-intro/" rel="alternate" type="text/html" title="Mock Mvc 简介"/><published>2024-08-13T03:59:00+00:00</published><updated>2024-08-13T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/mock-mvc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/mock-mvc-intro/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">MockMvc</code> 是 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 框架提供的一个用于测试控制器的工具类，它可以模拟发送 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求并接收 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应， 从而可以方便地测试控制器的功能。<code class="language-plaintext highlighter-rouge">MockMvc</code> 的使用非常简单，只需要通过 <code class="language-plaintext highlighter-rouge">MockMvcBuilders</code> 类的 <code class="language-plaintext highlighter-rouge">standaloneSetup</code> 方法创建一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，然后使用 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象的 <code class="language-plaintext highlighter-rouge">perform</code> 方法发送 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，即可得到 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应。 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象还提供了一系列的方法，可以用来验证 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应的状态码、响应头、响应体等信息。</p> <h1 id="mockmvc-的使用"><code class="language-plaintext highlighter-rouge">MockMvc</code> 的使用</h1> <p>前面提到了可以使用 <code class="language-plaintext highlighter-rouge">MockMvcBuilders</code> 类的 <code class="language-plaintext highlighter-rouge">standaloneSetup</code> 方法创建一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，但是如果我们 在一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目中，可以直接使用 <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> 注解注入一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，这样就 不需要手动创建 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象了。</p> <p>接下来简单介绍一下 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的基本步骤：</p> <ol> <li>对要测试的 <code class="language-plaintext highlighter-rouge">Controller</code> 创建一个对应的测试类；通常命名为原来的控制器类名后面加上 <code class="language-plaintext highlighter-rouge">Test</code>， 如 <code class="language-plaintext highlighter-rouge">UserController</code> 的测试类命名为 <code class="language-plaintext highlighter-rouge">UserControllerTest</code>；</li> <li>为这个类添加 <code class="language-plaintext highlighter-rouge">@SpringBootTest</code> 注解，表明这是一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 测试类；</li> <li>为这个类添加 <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> 注解，自动向 <code class="language-plaintext highlighter-rouge">IoC</code> 容器中注入一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象；</li> <li>在测试类中定义一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，并使用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 注解注入；</li> <li>添加测试方法，测试方法使用 <code class="language-plaintext highlighter-rouge">@Test</code> 进行标注；</li> </ol> <p>经过上述的步骤，我可以得到一个类似下面的代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserControllerTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>接下来需要编写测试方法的逻辑，一般情况下我们只需要按照以下的顺序编写即可：</p> <ol> <li>发送请求；</li> <li>验证响应状态码；</li> <li>验证响应头；</li> <li>验证响应体。</li> </ol> <p>下面我们以此介绍这几个步骤。对于发送请求，我们主要使用 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象的 <code class="language-plaintext highlighter-rouge">perform</code> 方法，该方法接收一个 <code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象，<code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象可以通过 <code class="language-plaintext highlighter-rouge">MockMvcRequestBuilders</code> 类的静态方法创建， 如 <code class="language-plaintext highlighter-rouge">get</code>、<code class="language-plaintext highlighter-rouge">post</code>、<code class="language-plaintext highlighter-rouge">put</code>、<code class="language-plaintext highlighter-rouge">delete</code> 等方法。<code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象还提供了一系列的方法，可以设置请求的 路径、请求参数、请求头等信息。下面的代码展示了如何模拟一个带有 <code class="language-plaintext highlighter-rouge">token</code> 的 <code class="language-plaintext highlighter-rouge">GET</code> 请求：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">mockMvc.perform</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ResultActions</code> 对象，该对象提供以下的几种方法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">andDo(ResultHandler)</code></li> <li><code class="language-plaintext highlighter-rouge">andExpect(ResultMatcher)</code></li> <li><code class="language-plaintext highlighter-rouge">andExpectAll(ResultMatcher...)</code></li> <li><code class="language-plaintext highlighter-rouge">andReturn()</code></li> </ul> <p>上面的几个方法均会再次返回一个 <code class="language-plaintext highlighter-rouge">ResultActions</code> 对象，这意味着我们可以进行链式调用。</p> <p>接下来我们只需要搞清楚 <code class="language-plaintext highlighter-rouge">ResultHandler</code> 和 <code class="language-plaintext highlighter-rouge">ResultMatcher</code> 的用法即可。<code class="language-plaintext highlighter-rouge">ResultHandler</code> 用于处理 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的结果，<code class="language-plaintext highlighter-rouge">ResultMatcher</code> 用于验证 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的结果。<code class="language-plaintext highlighter-rouge">ResultHandler</code> 和 <code class="language-plaintext highlighter-rouge">ResultMatcher</code> 均是函数式接口，可以使用 <code class="language-plaintext highlighter-rouge">lambda</code> 表达式来实现。</p> <p>对于 <code class="language-plaintext highlighter-rouge">RequestHandler</code> 接口，我们只需要实现一个 <code class="language-plaintext highlighter-rouge">handle</code> 方法，该方法接收一个 <code class="language-plaintext highlighter-rouge">MvcResult</code> 对象，表明 我们希望对结果做什么操作，常见的时候我们会使用 <code class="language-plaintext highlighter-rouge">print</code> 方法打印结果：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的 <code class="language-plaintext highlighter-rouge">print()</code> 是 <code class="language-plaintext highlighter-rouge">MockMvcResultHandlers</code> 类的静态方法，用于打印结果。<code class="language-plaintext highlighter-rouge">MockMvcResultHandlers</code> 类 还提供了其他的方法，如 <code class="language-plaintext highlighter-rouge">log()</code>、<code class="language-plaintext highlighter-rouge">logIfError()</code>、<code class="language-plaintext highlighter-rouge">logDebug()</code> 等。</p> <p>同样的 <code class="language-plaintext highlighter-rouge">MockMvcResultMatches</code> 中也提供了许多静态方法进行结果的验证，如 <code class="language-plaintext highlighter-rouge">status()</code>、<code class="language-plaintext highlighter-rouge">content()</code>、 <code class="language-plaintext highlighter-rouge">jsonPath()</code> 等。下面的代码展示了如何验证响应的状态码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">status().isOk()</code> 方法用于验证响应的状态码是否为 <code class="language-plaintext highlighter-rouge">200</code>。<code class="language-plaintext highlighter-rouge">status()</code> 方法还提供了其他的 方法，如 <code class="language-plaintext highlighter-rouge">isBadRequest()</code>、<code class="language-plaintext highlighter-rouge">isNotFound()</code>、<code class="language-plaintext highlighter-rouge">isInternalServerError()</code> 等。</p> <p>接下来我们可以验证响应头，<code class="language-plaintext highlighter-rouge">MockMvcResultMatchers</code> 类中提供了 <code class="language-plaintext highlighter-rouge">header()</code> 方法，用于验证响应头的信息。 下面的代码展示了如何验证响应头：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">header().string("Content-Type", "application/json")</code> 方法用于验证响应头中 <code class="language-plaintext highlighter-rouge">Content-Type</code> 的值是否为 <code class="language-plaintext highlighter-rouge">application/json</code>。</p> <p>最后我们可以验证响应体，<code class="language-plaintext highlighter-rouge">MockMvcResultMatchers</code> 类中提供了 <code class="language-plaintext highlighter-rouge">content()</code> 方法，用于验证响应体的信息。 下面的代码展示了如何验证响应体：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}"</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">"{\"id\":1,\"name\":\"kaiser\"}"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">content().json("{\"id\":1,\"name\":\"kaiser\"}")</code> 方法用于验证响应体是否为 <code class="language-plaintext highlighter-rouge">{"id":1,"name":"kaiser"}</code>。</p> <p>上面的代码过于冗长，我们可以使用 <code class="language-plaintext highlighter-rouge">andExpectAll</code> 方法将所有的验证合并到一起，如下所示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpectAll</span><span class="o">(</span>
                    <span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">(),</span>
                    <span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">),</span>
                    <span class="n">content</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">"{\"id\":1,\"name\":\"kaiser\"}"</span><span class="o">)</span>
            <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="文件上传">文件上传</h1> <p>文件上传是指客户端向服务器发送文件，通常使用 <code class="language-plaintext highlighter-rouge">POST</code> 请求，请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 为 <code class="language-plaintext highlighter-rouge">multipart/form-data</code>。 <code class="language-plaintext highlighter-rouge">MockMvc</code> 提供了 <code class="language-plaintext highlighter-rouge">file</code> 方法用于模拟文件上传，下面的代码展示了如何模拟文件上传：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testUploadFile</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">multipart</span><span class="o">(</span><span class="s">"/file/upload"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="k">new</span> <span class="nc">MockMultipartFile</span><span class="o">(</span><span class="s">"file"</span><span class="o">,</span> <span class="s">"test.txt"</span><span class="o">,</span> <span class="s">"text/plain"</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">))))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"success"</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 也可以使用以下的方式：</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testUploadFile</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">multipart</span><span class="o">(</span><span class="s">"/file/upload"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">"file"</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"success"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">multipart("/file/upload")</code> 方法用于模拟一个 <code class="language-plaintext highlighter-rouge">POST</code> 请求，请求路径为 <code class="language-plaintext highlighter-rouge">/file/upload</code>， <code class="language-plaintext highlighter-rouge">file</code> 方法用于模拟文件上传，<code class="language-plaintext highlighter-rouge">new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes())</code> 用于模拟一个名为 <code class="language-plaintext highlighter-rouge">test.txt</code>，文件类型为 <code class="language-plaintext highlighter-rouge">text/plain</code>，文件内容为 <code class="language-plaintext highlighter-rouge">hello</code>。</p> <p>上面的第二种方式中，<code class="language-plaintext highlighter-rouge">file("file", "hello".getBytes())</code> 方法用于模拟一个名为 <code class="language-plaintext highlighter-rouge">file</code>，文件内容为 <code class="language-plaintext highlighter-rouge">hello</code>。</p> ]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="MockMvc"/><summary type="html"><![CDATA[MockMvc 是 Spring MVC 框架提供的一个用于测试控制器的工具类，它可以模拟发送 HTTP 请求并接收 HTTP 响应， 从而可以方便地测试控制器的功能。MockMvc 的使用非常简单，只需要通过 MockMvcBuilders 类的 standaloneSetup 方法创建一个 MockMvc 对象，然后使用 MockMvc 对象的 perform 方法发送 HTTP 请求，即可得到 HTTP 响应。 MockMvc 对象还提供了一系列的方法，可以用来验证 HTTP 响应的状态码、响应头、响应体等信息。 MockMvc 的使用 前面提到了可以使用 MockMvcBuilders 类的 standaloneSetup 方法创建一个 MockMvc 对象，但是如果我们 在一个 Spring Boot 项目中，可以直接使用 @AutoConfigureMockMvc 注解注入一个 MockMvc 对象，这样就 不需要手动创建 MockMvc 对象了。 接下来简单介绍一下 MockMvc 的基本步骤： 对要测试的 Controller 创建一个对应的测试类；通常命名为原来的控制器类名后面加上 Test， 如 UserController 的测试类命名为 UserControllerTest； 为这个类添加 @SpringBootTest 注解，表明这是一个 Spring Boot 测试类； 为这个类添加 @AutoConfigureMockMvc 注解，自动向 IoC 容器中注入一个 MockMvc 对象； 在测试类中定义一个 MockMvc 对象，并使用 @Autowired 注解注入； 添加测试方法，测试方法使用 @Test 进行标注； 经过上述的步骤，我可以得到一个类似下面的代码： @SpringBootTest @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mockMvc; @Test public void testGetUser() throws Exception { } } 接下来需要编写测试方法的逻辑，一般情况下我们只需要按照以下的顺序编写即可： 发送请求； 验证响应状态码； 验证响应头； 验证响应体。 下面我们以此介绍这几个步骤。对于发送请求，我们主要使用 MockMvc 对象的 perform 方法，该方法接收一个 RequestBuilder 对象，RequestBuilder 对象可以通过 MockMvcRequestBuilders 类的静态方法创建， 如 get、post、put、delete 等方法。RequestBuilder 对象还提供了一系列的方法，可以设置请求的 路径、请求参数、请求头等信息。下面的代码展示了如何模拟一个带有 token 的 GET 请求： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")); } mockMvc.perform 会返回一个 ResultActions 对象，该对象提供以下的几种方法： andDo(ResultHandler) andExpect(ResultMatcher) andExpectAll(ResultMatcher...) andReturn() 上面的几个方法均会再次返回一个 ResultActions 对象，这意味着我们可以进行链式调用。 接下来我们只需要搞清楚 ResultHandler 和 ResultMatcher 的用法即可。ResultHandler 用于处理 MockMvc 的结果，ResultMatcher 用于验证 MockMvc 的结果。ResultHandler 和 ResultMatcher 均是函数式接口，可以使用 lambda 表达式来实现。 对于 RequestHandler 接口，我们只需要实现一个 handle 方法，该方法接收一个 MvcResult 对象，表明 我们希望对结果做什么操作，常见的时候我们会使用 print 方法打印结果： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()); } 上面的 print() 是 MockMvcResultHandlers 类的静态方法，用于打印结果。MockMvcResultHandlers 类 还提供了其他的方法，如 log()、logIfError()、logDebug() 等。 同样的 MockMvcResultMatches 中也提供了许多静态方法进行结果的验证，如 status()、content()、 jsonPath() 等。下面的代码展示了如何验证响应的状态码： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpect(status().isOk()); } 上面的代码中，status().isOk() 方法用于验证响应的状态码是否为 200。status() 方法还提供了其他的 方法，如 isBadRequest()、isNotFound()、isInternalServerError() 等。 接下来我们可以验证响应头，MockMvcResultMatchers 类中提供了 header() 方法，用于验证响应头的信息。 下面的代码展示了如何验证响应头： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpect(status().isOk()) .andExpect(header().string("Content-Type", "application/json")); } 上面的代码中，header().string("Content-Type", "application/json") 方法用于验证响应头中 Content-Type 的值是否为 application/json。 最后我们可以验证响应体，MockMvcResultMatchers 类中提供了 content() 方法，用于验证响应体的信息。 下面的代码展示了如何验证响应体： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}", 1).header("token", "123456")) .andDo(print()) .andExpect(status().isOk()) .andExpect(header().string("Content-Type", "application/json")) .andExpect(content().json("{\"id\":1,\"name\":\"kaiser\"}")); } 上面的代码中，content().json("{\"id\":1,\"name\":\"kaiser\"}") 方法用于验证响应体是否为 {"id":1,"name":"kaiser"}。 上面的代码过于冗长，我们可以使用 andExpectAll 方法将所有的验证合并到一起，如下所示： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpectAll( status().isOk(), header().string("Content-Type", "application/json"), content().json("{\"id\":1,\"name\":\"kaiser\"}") ); } 文件上传 文件上传是指客户端向服务器发送文件，通常使用 POST 请求，请求头中的 Content-Type 为 multipart/form-data。 MockMvc 提供了 file 方法用于模拟文件上传，下面的代码展示了如何模拟文件上传： @Test public void testUploadFile() throws Exception { mockMvc.perform(multipart("/file/upload") .file(new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes("UTF-8")))) .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string("success")); } // 也可以使用以下的方式： @Test public void testUploadFile() throws Exception { mockMvc.perform(multipart("/file/upload") .file("file", "hello".getBytes("UTF-8"))) .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string("success")); } 上面的代码中，multipart("/file/upload") 方法用于模拟一个 POST 请求，请求路径为 /file/upload， file 方法用于模拟文件上传，new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes()) 用于模拟一个名为 test.txt，文件类型为 text/plain，文件内容为 hello。 上面的第二种方式中，file("file", "hello".getBytes()) 方法用于模拟一个名为 file，文件内容为 hello。]]></summary></entry></feed>