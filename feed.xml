<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2024-08-19T13:49:34+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>This homepage is for sharing everything I know. </subtitle><entry><title type="html">Spring MVC 简介</title><link href="https://kaiser-yang.github.io/blog/2024/spring-mvc-intro/" rel="alternate" type="text/html" title="Spring MVC 简介"/><published>2024-08-14T03:59:00+00:00</published><updated>2024-08-14T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-mvc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-mvc-intro/"><![CDATA[<h1 id="servlet-与-spring-mvc"><code class="language-plaintext highlighter-rouge">Servlet</code> 与 <code class="language-plaintext highlighter-rouge">Spring MVC</code></h1> <p>在开始介绍 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 之前，我们需要先了解一下什么 <code class="language-plaintext highlighter-rouge">Servlet</code>。</p> <h2 id="servlet"><code class="language-plaintext highlighter-rouge">Servlet</code></h2> <p><code class="language-plaintext highlighter-rouge">Servlet</code> 是 <code class="language-plaintext highlighter-rouge">Java</code> 的一个规范，其提供了 <code class="language-plaintext highlighter-rouge">Java</code> 处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的能力，<code class="language-plaintext highlighter-rouge">Servlet</code> 是基于 <code class="language-plaintext highlighter-rouge">Java</code> 的 <code class="language-plaintext highlighter-rouge">Web</code> 开发的基础，通过自定义 <code class="language-plaintext highlighter-rouge">Servlet</code> 并继承 <code class="language-plaintext highlighter-rouge">HttpServlet</code> 可以处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求。而在 <code class="language-plaintext highlighter-rouge">MVC</code> 的架构中， <code class="language-plaintext highlighter-rouge">Servlet</code> 通常可以看成时 <code class="language-plaintext highlighter-rouge">Controller</code> 层。</p> <h2 id="spring-mvc"><code class="language-plaintext highlighter-rouge">Spring MVC</code></h2> <p><code class="language-plaintext highlighter-rouge">Spring MVC</code> 是 <code class="language-plaintext highlighter-rouge">Spring</code> 框架的一个模块，其提供了一个 <code class="language-plaintext highlighter-rouge">MVC</code> 的架构，可以帮助我们更好的开发 <code class="language-plaintext highlighter-rouge">Web</code> 应用。 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 是基于 <code class="language-plaintext highlighter-rouge">Servlet</code> 的，其提供了一个 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code> 来处理请求，<code class="language-plaintext highlighter-rouge">Controller</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象， <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象包含了 <code class="language-plaintext highlighter-rouge">Model</code> 和 <code class="language-plaintext highlighter-rouge">View</code>，<code class="language-plaintext highlighter-rouge">Model</code> 用于存放数据，<code class="language-plaintext highlighter-rouge">View</code> 用于展示数据。但是在 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 中 <code class="language-plaintext highlighter-rouge">Controller</code> 通常不会返回 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象，而是直接返回一个对象，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动将对象转换为 <code class="language-plaintext highlighter-rouge">JSON</code> 格式返回给客户端。</p> <h1 id="dispatcherservlet"><code class="language-plaintext highlighter-rouge">DispatcherServlet</code></h1> <p><code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 是 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 的核心，其继承自 <code class="language-plaintext highlighter-rouge">HttpServlet</code>，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code> 来处理请求，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到一个 <code class="language-plaintext highlighter-rouge">HandlerMapping</code> 对象， <code class="language-plaintext highlighter-rouge">HandlerMapping</code> 对象会根据请求的 <code class="language-plaintext highlighter-rouge">URL</code> 找到对应的 <code class="language-plaintext highlighter-rouge">Controller</code>，<code class="language-plaintext highlighter-rouge">Controller</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象， <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 会根据 <code class="language-plaintext highlighter-rouge">ModelAndView</code> 对象找到对应的 <code class="language-plaintext highlighter-rouge">View</code> 来展示数据。</p> <p>不过在现在看来 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 已经渐渐的失去了 <code class="language-plaintext highlighter-rouge">V</code> 的功能，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 通常只用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，而 <code class="language-plaintext highlighter-rouge">View</code> 通常是前端框架来处理的，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 通常会直接返回一个对象，<code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动将对象转换为 <code class="language-plaintext highlighter-rouge">JSON</code> 格式返回给客户端。</p> <p>因此在介绍的时候不会完整恩介绍 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 而是着重的介绍如何使用一些 <code class="language-plaintext highlighter-rouge">Controller</code> 层的注解。</p> <h1 id="filters"><code class="language-plaintext highlighter-rouge">Filters</code></h1> <p><code class="language-plaintext highlighter-rouge">Filters</code> 是 <code class="language-plaintext highlighter-rouge">Servlet</code> 的一个规范，其可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，<code class="language-plaintext highlighter-rouge">Filters</code> 通常用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的 一些预处理和后处理，<code class="language-plaintext highlighter-rouge">Filters</code> 通常可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的编码，<code class="language-plaintext highlighter-rouge">HTTP</code> 请求的安全等。例如我们可以 <code class="language-plaintext highlighter-rouge">Filter</code> 只允许通过 <code class="language-plaintext highlighter-rouge">Get</code> 方法访问某个 <code class="language-plaintext highlighter-rouge">URL</code>，或者我们可以在 <code class="language-plaintext highlighter-rouge">Filter</code> 中对 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的编码进行处理。 同一个 <code class="language-plaintext highlighter-rouge">URL</code> 可以有多个 <code class="language-plaintext highlighter-rouge">Filter</code>，<code class="language-plaintext highlighter-rouge">Filter</code> 会按照 <code class="language-plaintext highlighter-rouge">Filter</code> 的 <code class="language-plaintext highlighter-rouge">order</code> 属性的值来执行，<code class="language-plaintext highlighter-rouge">order</code> 的值 越小越先执行。 <code class="language-plaintext highlighter-rouge">Filter</code> 运行在 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 之前。</p> <h1 id="请求与多线程">请求与多线程</h1> <p>在这里不得不介绍一下 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的多线程问题，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 是基于 <code class="language-plaintext highlighter-rouge">Servlet</code> 的，<code class="language-plaintext highlighter-rouge">Servlet</code> 是多线程的，<code class="language-plaintext highlighter-rouge">Servlet</code> 会为每一个请求创建一个线程来处理请求，因此在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的方法是多线程的， 而线程池是由 <code class="language-plaintext highlighter-rouge">Tomcat</code> (默认的 <code class="language-plaintext highlighter-rouge">Web</code> 服务器) 来管理的。</p> <p>这也就涉及到了老生常谈的问题：<code class="language-plaintext highlighter-rouge">Spring</code> 与多线程的问题。<code class="language-plaintext highlighter-rouge">Spring</code> 本身对于多线程并没有什么特殊的处理， 且在使用单俐模式创建对象时，<code class="language-plaintext highlighter-rouge">Spring</code> 不是线程安全的，而在 <code class="language-plaintext highlighter-rouge">Spring</code> 处理请求的过程中，我们知道 <code class="language-plaintext highlighter-rouge">Tomcat</code> 会为每一个 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求创建一个线程进行处理，因此在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中处理请求的方法是多线程的，这会引发 线程安全的问题，但是在实际的过程中，大多数情况下不会出现线程安全问题，这又是为什么呢？</p> <p>在实际处理一个请求的 <code class="language-plaintext highlighter-rouge">Controller</code> 类中，我们会发现出现的所有的变量都是局部变量，这样的类也被称为 无状态类，无状态类是线程安全的，因为每一个线程都会有自己的局部变量，不会出现线程安全的问题。但是对于 <code class="language-plaintext highlighter-rouge">DAO</code> 层的类，我们往往需要额外考虑线程安全的问题。</p> <h1 id="使用注解编写-controller">使用注解编写 <code class="language-plaintext highlighter-rouge">Controller</code></h1> <h2 id="controller"><code class="language-plaintext highlighter-rouge">@Controller</code></h2> <p>该注解用于标记一个类是 <code class="language-plaintext highlighter-rouge">Controller</code> 类，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动扫描所有的 <code class="language-plaintext highlighter-rouge">Controller</code> 类，并将其注册到 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中。</p> <h2 id="requestmapping"><code class="language-plaintext highlighter-rouge">@RequestMapping</code></h2> <p>该注解用于标记一个方法处理的 <code class="language-plaintext highlighter-rouge">URL</code>，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 可以标记在类上，也可以标记在方法上，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 可以接受一个 <code class="language-plaintext highlighter-rouge">URL</code>，也可以接受一个 <code class="language-plaintext highlighter-rouge">URL</code> 的数组，<code class="language-plaintext highlighter-rouge">@RequestMapping</code> 还可以接受一些参数，例如：<code class="language-plaintext highlighter-rouge">method</code>、 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code>。</p> <p><code class="language-plaintext highlighter-rouge">method</code> 用于指定请求的方法，<code class="language-plaintext highlighter-rouge">consumes</code> 用于指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code>，<code class="language-plaintext highlighter-rouge">produces</code> 用于指定返回的 <code class="language-plaintext highlighter-rouge">Content-Type</code>，<code class="language-plaintext highlighter-rouge">headers</code> 用于指定请求的头部信息，<code class="language-plaintext highlighter-rouge">params</code> 用于指定请求的参数。</p> <p>但是，一般情况下我们并不直接使用 <code class="language-plaintext highlighter-rouge">@RequestMapping</code> 注解，而是使用以下几种衍生注解：</p> <ul> <li><code class="language-plaintext highlighter-rouge">@GetMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">GET</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.GET)</code></li> <li><code class="language-plaintext highlighter-rouge">@PostMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">POST</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.POST)</code></li> <li><code class="language-plaintext highlighter-rouge">@PutMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">PUT</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.PUT)</code></li> <li><code class="language-plaintext highlighter-rouge">@DeleteMapping</code> 用于处理 <code class="language-plaintext highlighter-rouge">DELETE</code> 请求，等价于 <code class="language-plaintext highlighter-rouge">@RequestMapping(method = RequestMethod.DELETE)</code></li> </ul> <p>以下的几个例子展示了如何指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code>、<code class="language-plaintext highlighter-rouge">Accept</code>、<code class="language-plaintext highlighter-rouge">Headers</code>、<code class="language-plaintext highlighter-rouge">Params</code>：</p> <ol> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', consumes = 'application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'Content-Type=application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', produces = 'application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'Accept=application/json')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', headers = 'MyHeader=myValue')</code></li> <li><code class="language-plaintext highlighter-rouge">@GetMapping(path = '/test', params = 'myParam=myValue')</code></li> </ol> <p>上述的例子中的第一条于第二条、第三条于第四条等价。也就是说对于 <code class="language-plaintext highlighter-rouge">consumes</code> 参数而言，只有当请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 与 <code class="language-plaintext highlighter-rouge">consumes</code> 参数的值相同时，才会匹配成功，对于 <code class="language-plaintext highlighter-rouge">produces</code> 参数而言，只有当请求头中的 <code class="language-plaintext highlighter-rouge">Accept</code> 与 <code class="language-plaintext highlighter-rouge">produces</code> 参数的值相同时，才会匹配成功。<code class="language-plaintext highlighter-rouge">Spring MVC</code> 官方更加推荐使用 <code class="language-plaintext highlighter-rouge">consumes</code> 和 <code class="language-plaintext highlighter-rouge">produces</code> 参数来指定请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 和 <code class="language-plaintext highlighter-rouge">Accept</code>。</p> <p>其他的几个注解可以类似地使用 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数。</p> <p>NOTE: 如果一个 <code class="language-plaintext highlighter-rouge">Controller</code> 的每个方法都需要指定 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数， 那么我们可以在 <code class="language-plaintext highlighter-rouge">Controller</code> 类上使用 <code class="language-plaintext highlighter-rouge">consumes</code>、<code class="language-plaintext highlighter-rouge">produces</code>、<code class="language-plaintext highlighter-rouge">headers</code>、<code class="language-plaintext highlighter-rouge">params</code> 参数，这样在 <code class="language-plaintext highlighter-rouge">Controller</code> 类中的每个方法都会默认使用这些参数，而如果某个方法需要不同的参数，那么可以在方法上覆盖这些参数。</p> <p>接下来介绍一下 <code class="language-plaintext highlighter-rouge">path</code> 参数地模糊匹配规则：</p> <ul> <li><code class="language-plaintext highlighter-rouge">"?"</code> 匹配一个字符。</li> <li><code class="language-plaintext highlighter-rouge">"*"</code> 匹配一个路径下的任意字符。</li> <li><code class="language-plaintext highlighter-rouge">"**"</code> 匹配一个或者多个路径下的任意字符。</li> <li><code class="language-plaintext highlighter-rouge">"/projects/{project}/versions"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">project</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数。</li> <li><code class="language-plaintext highlighter-rouge">"/projects/{project:[a-z]+}/versions"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">project</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数， 且 <code class="language-plaintext highlighter-rouge">project</code> 的值必须是小写字母。</li> <li><code class="language-plaintext highlighter-rouge">"/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}"</code> 匹配后将 <code class="language-plaintext highlighter-rouge">name</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数，<code class="language-plaintext highlighter-rouge">version</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数，<code class="language-plaintext highlighter-rouge">ext</code> 的值传递给 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解的参数， <code class="language-plaintext highlighter-rouge">name</code> 的值必须是小写字母和 <code class="language-plaintext highlighter-rouge">-</code>，<code class="language-plaintext highlighter-rouge">version</code> 的值必须是 <code class="language-plaintext highlighter-rouge">x.x.x</code> 的格式，<code class="language-plaintext highlighter-rouge">ext</code> 的值必须是 <code class="language-plaintext highlighter-rouge">.</code> 开头的小写字母。</li> </ul> <h1 id="使用不同的注解获取参数">使用不同的注解获取参数</h1> <h2 id="requestparam"><code class="language-plaintext highlighter-rouge">@RequestParam</code></h2> <p>对于一些方法，我们需要获取请求参数，而 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解可以帮助我们从请求中获取参数 (也就是 <code class="language-plaintext highlighter-rouge">?</code> 后面的参数)。<code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>例如一个方法的参数被 <code class="language-plaintext highlighter-rouge">@RequestParma("id")</code> 修饰，而请求中包含 <code class="language-plaintext highlighter-rouge">?id=3</code> 那么这个参数将会被填入 <code class="language-plaintext highlighter-rouge">3</code>。</p> <p>NOTE: 通常对于一个没有任何注解标注的参数，其默认会通过 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 注解来获取参数。</p> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="requestheader"><code class="language-plaintext highlighter-rouge">@RequestHeader</code></h2> <p>该注解用于获取请求头中的参数，<code class="language-plaintext highlighter-rouge">@RequestHeader</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="cookievalue"><code class="language-plaintext highlighter-rouge">@CookieValue</code></h2> <p>其实该注解也是用于获取请求头中的参数，只不过该注解往往标识获取 <code class="language-plaintext highlighter-rouge">coockie</code> 信息能够增加码的可读性。其 使用方法与 <code class="language-plaintext highlighter-rouge">@RequestHeader</code> 类似。</p> <h2 id="pathvariable"><code class="language-plaintext highlighter-rouge">@PathVariable</code></h2> <p>该注解用于获取 <code class="language-plaintext highlighter-rouge">URL</code> 中的参数，<code class="language-plaintext highlighter-rouge">@PathVariable</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">defaultValue</code> 用于指定参数的默认值。</li> </ul> <p>例如一个方法被 <code class="language-plaintext highlighter-rouge">@GetMapping("/test/{id}")</code> 修饰，其某个参数被 <code class="language-plaintext highlighter-rouge">@PathVariable("id")</code> 修饰，而请求中 为 <code class="language-plaintext highlighter-rouge">/test/3</code> 那么被修饰的参数将会填上 <code class="language-plaintext highlighter-rouge">3</code>。</p> <p>NOTE: 当该注解用于一个 <code class="language-plaintext highlighter-rouge">Map</code> 类型的参数时，<code class="language-plaintext highlighter-rouge">Spring</code> 会将所有的请求参数都填入这个 <code class="language-plaintext highlighter-rouge">Map</code> 中。</p> <h2 id="requestpart"><code class="language-plaintext highlighter-rouge">@RequestPart</code></h2> <p>该注解用于获取请求中的 <code class="language-plaintext highlighter-rouge">Multipart</code> 参数，<code class="language-plaintext highlighter-rouge">@RequestPart</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code> 用于指定参数的名称。</li> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p>该注解一般用在 <code class="language-plaintext highlighter-rouge">MultipartFile</code> 类型的参数上，用于获取上传的文件。</p> <h2 id="requestbody"><code class="language-plaintext highlighter-rouge">@RequestBody</code></h2> <p>使用该注解可以获取请求体中的参数，<code class="language-plaintext highlighter-rouge">@RequestBody</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">required</code> 用于指定参数是否必须，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p>该注解一般用于 <code class="language-plaintext highlighter-rouge">POST</code> 方法获取请求体中的参数。需要注意的是，<code class="language-plaintext highlighter-rouge">@RequestBody</code> 注解只能用于一个参数上， 其作用是将整个请求体封装到这个参数中。一般而言，对于 <code class="language-plaintext highlighter-rouge">JSON</code> 格式的请求体，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动将其转换为 <code class="language-plaintext highlighter-rouge">Java</code> 对象，当然这得要求请求体中的键值对与 <code class="language-plaintext highlighter-rouge">Java</code> 对象的属性名一致。在两者不一致的时候，可以在 <code class="language-plaintext highlighter-rouge">Java</code> 对象的属性上使用 <code class="language-plaintext highlighter-rouge">@JsonProperty</code> 注解来指定键值对的键名。也可以使用 <code class="language-plaintext highlighter-rouge">@JsonAlias</code> 注解来指定多个键名， 但是这个注解必须要依赖于 <code class="language-plaintext highlighter-rouge">setter</code> 和 <code class="language-plaintext highlighter-rouge">getter</code>。</p> <h1 id="controller-返回数据"><code class="language-plaintext highlighter-rouge">Controller</code> 返回数据</h1> <h2 id="responsebody"><code class="language-plaintext highlighter-rouge">@ResponseBody</code></h2> <p>该注解用于标记一个方法的返回值会放置到 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应体中，<code class="language-plaintext highlighter-rouge">Spring</code> 会根据请求头中的 <code class="language-plaintext highlighter-rouge">Accept</code> 内容自动 选择合适的 <code class="language-plaintext highlighter-rouge">HttpMessageConverter</code> 转换返回值。当声明了 <code class="language-plaintext highlighter-rouge">produces="application/json"</code> 时，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动选择 <code class="language-plaintext highlighter-rouge">MappingJackson2HttpMessageConverter</code> 来转换返回值。</p> <h2 id="restcontroller"><code class="language-plaintext highlighter-rouge">@RestController</code></h2> <p>该注解是 <code class="language-plaintext highlighter-rouge">@Controller</code> 和 <code class="language-plaintext highlighter-rouge">@ResponseBody</code> 的组合。标明该类的所有方法都被 <code class="language-plaintext highlighter-rouge">@ResponseBody</code> 标注。</p> <h1 id="跨域问题">跨域问题</h1> <p>在通常的情况下，为了保护用户的数据，浏览器会限制跨域请求，也就是说浏览器不允许一个源向另一个源发送 请求。同一个源指的是协议、域名、端口号都相同。</p> <p>而对于一个前后端分离的程序而言，其前端永远也不可能和后端在同一个源上，这也意味着：即使前端和后端程序 部署在同一个服务器上，但是由于端口不同，也会被浏览器拦截。</p> <p>而对于浏览器的拦截策略，其往往有以下过程：</p> <ol> <li>浏览器向服务器发送一个 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求，询问服务器是否允许跨域请求。</li> <li>服务器返回信息以说明是否允许跨域请求。</li> <li>当访问的域名没有被允许时，浏览器会拦截请求。否则，浏览器会发送真正的请求。</li> </ol> <p>也就是说要解决跨域问题，我们只需要在服务端增加能够处理特定 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 的请求，在对应的响应体中添加支持 跨域访问的 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息即可。</p> <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing</a> 介绍了 <code class="language-plaintext highlighter-rouge">CORS</code> 是如何工作的，你可以阅读这篇文章以获取更加详细的信息。</p> <p>在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中解决跨域问题使容易的，因为 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 为跨域问题做了内置的处理: 当收到一个 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求时，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 会寻找用户的跨域配置，如果找到了，那么 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 会自动返回一个 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息。 否则，<code class="language-plaintext highlighter-rouge">Spring MVC</code> 会直接拒绝。</p> <h2 id="使用-crossorigin-解决局部跨域问题">使用 <code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 解决局部跨域问题</h2> <p>该注解用于标注一个方法支持跨域请求，<code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 注解可以接受以下参数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">origins</code> 用于指定允许跨域的源，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">methods</code> 用于指定允许跨域的方法，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">allowedHeaders</code> 用于指定允许跨域的头部信息，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">exposedHeaders</code> 用于指定允许跨域的头部信息，可以是一个字符串数组。</li> <li><code class="language-plaintext highlighter-rouge">allowCredentials</code> 用于指定是否允许携带 <code class="language-plaintext highlighter-rouge">cookie</code>，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">maxAge</code> 用于指定 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求的缓存时间，单位为秒。</li> </ul> <p>默认情况下，<code class="language-plaintext highlighter-rouge">@CrossOrigin</code> 注解会允许所有的跨域请求，并且支持所有头部信息，不允许携带 <code class="language-plaintext highlighter-rouge">cookie</code>，<code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求的缓存时间为 <code class="language-plaintext highlighter-rouge">1800</code> 秒。</p> <p>当然该注解可以标注在类上，用于标识该 <code class="language-plaintext highlighter-rouge">Controller</code> 的所有方法默认支持跨域请求。</p> <h2 id="使用-webmvcconfigurer-解决全局跨域问题">使用 <code class="language-plaintext highlighter-rouge">WebMvcConfigurer</code> 解决全局跨域问题</h2> <p>在 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中可以通过添加一个如下的配置类为全局配置代理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCorsMappings</span><span class="o">(</span><span class="nc">CorsRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">"/api/**"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedOrigins</span><span class="o">(</span><span class="s">"https://domain2.com"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedMethods</span><span class="o">(</span><span class="s">"PUT"</span><span class="o">,</span> <span class="s">"DELETE"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowedHeaders</span><span class="o">(</span><span class="s">"header1"</span><span class="o">,</span> <span class="s">"header2"</span><span class="o">,</span> <span class="s">"header3"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">exposedHeaders</span><span class="o">(</span><span class="s">"header1"</span><span class="o">,</span> <span class="s">"header2"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">allowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">).</span><span class="na">maxAge</span><span class="o">(</span><span class="mi">3600</span><span class="o">);</span>

        <span class="c1">// Add more mappings...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="使用-filter-来解决跨域问题">使用 <code class="language-plaintext highlighter-rouge">Filter</code> 来解决跨域问题</h2> <p>在前面的介绍中我们提到了跨域要允许跨域只需要对特定的 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 请求返回 <code class="language-plaintext highlighter-rouge">CORS</code> 的头部信息即可，而我们 介绍了 <code class="language-plaintext highlighter-rouge">Filter</code> 可以用来处理 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求的预处理和后处理，因此我们可以使用 <code class="language-plaintext highlighter-rouge">Filter</code> 来处理跨域问题。 而 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 中默认提供了一个类型为 <code class="language-plaintext highlighter-rouge">CorFilter</code> 的过滤器用于处理跨域问题，我们只需要在 <code class="language-plaintext highlighter-rouge">Spring</code> 的 <code class="language-plaintext highlighter-rouge">IoC</code> 容器中注册这个过滤器即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CorsConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CorsFilter</span> <span class="nf">corsFilter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">UrlBasedCorsConfigurationSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlBasedCorsConfigurationSource</span><span class="o">();</span>
        <span class="nc">CorsConfiguration</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedOrigin</span><span class="o">(</span><span class="s">"http://localhost:3000"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedHeader</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">source</span><span class="o">.</span><span class="na">registerCorsConfiguration</span><span class="o">(</span><span class="s">"/**"</span><span class="o">,</span> <span class="n">config</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CorsFilter</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在更改 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 的配置的时候需要增加 <code class="language-plaintext highlighter-rouge">@EnableWebMvc</code> 注解。</p> <p><code class="language-plaintext highlighter-rouge">@ResponseStatus</code> <code class="language-plaintext highlighter-rouge">@SessionAttributes</code> <code class="language-plaintext highlighter-rouge">@ModelAttribute</code> <code class="language-plaintext highlighter-rouge">@InitBinder</code> <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> <code class="language-plaintext highlighter-rouge">@CrossOrigin</code></p>]]></content><author><name></name></author><category term="Java"/><summary type="html"><![CDATA[Servlet 与 Spring MVC 在开始介绍 Spring MVC 之前，我们需要先了解一下什么 Servlet。 Servlet Servlet 是 Java 的一个规范，其提供了 Java 处理 HTTP 请求的能力，Servlet 是基于 Java 的 Web 开发的基础，通过自定义 Servlet 并继承 HttpServlet 可以处理 HTTP 请求。而在 MVC 的架构中， Servlet 通常可以看成时 Controller 层。 Spring MVC Spring MVC 是 Spring 框架的一个模块，其提供了一个 MVC 的架构，可以帮助我们更好的开发 Web 应用。 Spring MVC 是基于 Servlet 的，其提供了一个 DispatcherServlet 来处理 HTTP 请求，DispatcherServlet 会根据请求的 URL 找到对应的 Controller 来处理请求，Controller 会返回一个 ModelAndView 对象， ModelAndView 对象包含了 Model 和 View，Model 用于存放数据，View 用于展示数据。但是在 Spring Boot 中 Controller 通常不会返回 ModelAndView 对象，而是直接返回一个对象，Spring Boot 会自动将对象转换为 JSON 格式返回给客户端。 DispatcherServlet DispatcherServlet 是 Spring MVC 的核心，其继承自 HttpServlet，DispatcherServlet 会根据请求的 URL 找到对应的 Controller 来处理请求，DispatcherServlet 会根据请求的 URL 找到一个 HandlerMapping 对象， HandlerMapping 对象会根据请求的 URL 找到对应的 Controller，Controller 会返回一个 ModelAndView 对象， DispatcherServlet 会根据 ModelAndView 对象找到对应的 View 来展示数据。 不过在现在看来 Spring MVC 已经渐渐的失去了 V 的功能，Spring MVC 通常只用来处理 HTTP 请求，而 View 通常是前端框架来处理的，Spring Boot 通常会直接返回一个对象，Spring Boot 会自动将对象转换为 JSON 格式返回给客户端。 因此在介绍的时候不会完整恩介绍 Spring MVC 而是着重的介绍如何使用一些 Controller 层的注解。 Filters Filters 是 Servlet 的一个规范，其可以用来处理 HTTP 请求，Filters 通常用来处理 HTTP 请求的 一些预处理和后处理，Filters 通常可以用来处理 HTTP 请求的编码，HTTP 请求的安全等。例如我们可以 Filter 只允许通过 Get 方法访问某个 URL，或者我们可以在 Filter 中对 HTTP 请求的编码进行处理。 同一个 URL 可以有多个 Filter，Filter 会按照 Filter 的 order 属性的值来执行，order 的值 越小越先执行。 Filter 运行在 DispatcherServlet 之前。 请求与多线程 在这里不得不介绍一下 Spring MVC 中处理请求的多线程问题，Spring MVC 是基于 Servlet 的，Servlet 是多线程的，Servlet 会为每一个请求创建一个线程来处理请求，因此在 Spring MVC 中处理请求的方法是多线程的， 而线程池是由 Tomcat (默认的 Web 服务器) 来管理的。 这也就涉及到了老生常谈的问题：Spring 与多线程的问题。Spring 本身对于多线程并没有什么特殊的处理， 且在使用单俐模式创建对象时，Spring 不是线程安全的，而在 Spring 处理请求的过程中，我们知道 Tomcat 会为每一个 HTTP 请求创建一个线程进行处理，因此在 Spring MVC 中处理请求的方法是多线程的，这会引发 线程安全的问题，但是在实际的过程中，大多数情况下不会出现线程安全问题，这又是为什么呢？ 在实际处理一个请求的 Controller 类中，我们会发现出现的所有的变量都是局部变量，这样的类也被称为 无状态类，无状态类是线程安全的，因为每一个线程都会有自己的局部变量，不会出现线程安全的问题。但是对于 DAO 层的类，我们往往需要额外考虑线程安全的问题。 使用注解编写 Controller @Controller 该注解用于标记一个类是 Controller 类，Spring 会自动扫描所有的 Controller 类，并将其注册到 Spring 容器中。 @RequestMapping 该注解用于标记一个方法处理的 URL，@RequestMapping 可以标记在类上，也可以标记在方法上，@RequestMapping 可以接受一个 URL，也可以接受一个 URL 的数组，@RequestMapping 还可以接受一些参数，例如：method、 consumes、produces、headers、params。 method 用于指定请求的方法，consumes 用于指定请求的 Content-Type，produces 用于指定返回的 Content-Type，headers 用于指定请求的头部信息，params 用于指定请求的参数。 但是，一般情况下我们并不直接使用 @RequestMapping 注解，而是使用以下几种衍生注解： @GetMapping 用于处理 GET 请求，等价于 @RequestMapping(method = RequestMethod.GET) @PostMapping 用于处理 POST 请求，等价于 @RequestMapping(method = RequestMethod.POST) @PutMapping 用于处理 PUT 请求，等价于 @RequestMapping(method = RequestMethod.PUT) @DeleteMapping 用于处理 DELETE 请求，等价于 @RequestMapping(method = RequestMethod.DELETE) 以下的几个例子展示了如何指定请求的 Content-Type、Accept、Headers、Params： @GetMapping(path = '/test', consumes='application/json') @GetMapping(path = '/test', headers='Content-Type=application/json') @GetMapping(path = '/test', produces='application/json') @GetMapping(path = '/test', headers='Accept=application/json') @GetMapping(path = '/test', headers='MyHeader=myValue') @GetMapping(path = '/test', params='myParam=myValue') 上述的例子中的第一条于第二条、第三条于第四条等价。也就是说对于 consumes 参数而言，只有当请求头中的 Content-Type 与 consumes 参数的值相同时，才会匹配成功，对于 produces 参数而言，只有当请求头中的 Accept 与 produces 参数的值相同时，才会匹配成功。Spring MVC 官方更加推荐使用 consumes 和 produces 参数来指定请求的 Content-Type 和 Accept。 其他的几个注解可以类似地使用 consumes、produces、headers、params 参数。 NOTE: 如果一个 Controller 的每个方法都需要指定 consumes、produces、headers、params 参数， 那么我们可以在 Controller 类上使用 consumes、produces、headers、params 参数，这样在 Controller 类中的每个方法都会默认使用这些参数，而如果某个方法需要不同的参数，那么可以在方法上覆盖这些参数。 接下来介绍一下 path 参数地模糊匹配规则： "?" 匹配一个字符。 "*" 匹配一个路径下的任意字符。 "**" 匹配一个或者多个路径下的任意字符。 "/projects/{project}/versions" 匹配后将 project 的值传递给 @PathVariable 注解的参数。 "/projects/{project:[a-z]+}/versions" 匹配后将 project 的值传递给 @PathVariable 注解的参数， 且 project 的值必须是小写字母。 "/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}" 匹配后将 name 的值传递给 @PathVariable 注解的参数，version 的值传递给 @PathVariable 注解的参数，ext 的值传递给 @PathVariable 注解的参数， name 的值必须是小写字母和 -，version 的值必须是 x.x.x 的格式，ext 的值必须是 . 开头的小写字母。 使用不同的注解获取参数 @RequestParam 对于一些方法，我们需要获取请求参数，而 @RequestParam 注解可以帮助我们从请求中获取参数 (也就是 ? 后面的参数)。@RequestParam 注解可以接受以下参数： value 或 name 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 例如一个方法的参数被 @RequestParma("id") 修饰，而请求中包含 ?id=3 那么这个参数将会被填入 3。 NOTE: 通常对于一个没有任何注解标注的参数，其默认会通过 @RequestParam 注解来获取参数。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @RequestHeader 该注解用于获取请求头中的参数，@RequestHeader 注解可以接受以下参数： value 或 name 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @CookieValue 其实该注解也是用于获取请求头中的参数，只不过该注解往往标识获取 coockie 信息能够增加码的可读性。其 使用方法与 @RequestHeader 类似。 @PathVariable 该注解用于获取 URL 中的参数，@PathVariable 注解可以接受以下参数： value 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 defaultValue 用于指定参数的默认值。 例如一个方法被 @GetMapping("/test/{id}") 修饰，其某个参数被 @PathVariable("id") 修饰，而请求中 为 /test/3 那么被修饰的参数将会填上 3。 NOTE: 当该注解用于一个 Map 类型的参数时，Spring 会将所有的请求参数都填入这个 Map 中。 @RequestPart 该注解用于获取请求中的 Multipart 参数，@RequestPart 注解可以接受以下参数： value 用于指定参数的名称。 required 用于指定参数是否必须，默认为 true。 该注解一般用在 MultipartFile 类型的参数上，用于获取上传的文件。 @RequestBody 使用该注解可以获取请求体中的参数，@RequestBody 注解可以接受以下参数： required 用于指定参数是否必须，默认为 true。 该注解一般用于 POST 方法获取请求体中的参数。需要注意的是，@RequestBody 注解只能用于一个参数上， 其作用是将整个请求体封装到这个参数中。一般而言，对于 JSON 格式的请求体，Spring 会自动将其转换为 Java 对象，当然这得要求请求体中的键值对与 Java 对象的属性名一致。在两者不一致的时候，可以在 Java 对象的属性上使用 @JsonProperty 注解来指定键值对的键名。也可以使用 @JsonAlias 注解来指定多个键名， 但是这个注解必须要依赖于 setter 和 getter。 Controller 返回数据 @ResponseBody 该注解用于标记一个方法的返回值会放置到 HTTP 响应体中，Spring 会根据请求头中的 Accept 内容自动 选择合适的 HttpMessageConverter 转换返回值。当声明了 produces="application/json" 时，Spring 会自动选择 MappingJackson2HttpMessageConverter 来转换返回值。 @RestController 该注解是 @Controller 和 @ResponseBody 的组合。标明该类的所有方法都被 @ResponseBody 标注。 跨域问题 在通常的情况下，为了保护用户的数据，浏览器会限制跨域请求，也就是说浏览器不允许一个源向另一个源发送 请求。同一个源指的是协议、域名、端口号都相同。 而对于一个前后端分离的程序而言，其前端永远也不可能和后端在同一个源上，这也意味着：即使前端和后端程序 部署在同一个服务器上，但是由于端口不同，也会被浏览器拦截。 而对于浏览器的拦截策略，其往往有以下过程： 浏览器向服务器发送一个 OPTIONS 请求，询问服务器是否允许跨域请求。 服务器返回信息以说明是否允许跨域请求。 当访问的域名没有被允许时，浏览器会拦截请求。否则，浏览器会发送真正的请求。 也就是说要解决跨域问题，我们只需要在服务端增加能够处理特定 OPTIONS 的请求，在对应的响应体中添加支持 跨域访问的 CORS 的头部信息即可。 Cross-Origin Resource Sharing 介绍了 CORS 是如何工作的，你可以阅读这篇文章以获取更加详细的信息。 在 Spring MVC 中解决跨域问题使容易的，因为 Spring MVC 为跨域问题做了内置的处理: 当收到一个 OPTIONS 请求时，Spring MVC 会寻找用户的跨域配置，如果找到了，那么 Spring MVC 会自动返回一个 CORS 的头部信息。 否则，Spring MVC 会直接拒绝。 使用 @CrossOrigin 解决局部跨域问题 该注解用于标注一个方法支持跨域请求，@CrossOrigin 注解可以接受以下参数： origins 用于指定允许跨域的源，可以是一个字符串数组。 methods 用于指定允许跨域的方法，可以是一个字符串数组。 allowedHeaders 用于指定允许跨域的头部信息，可以是一个字符串数组。 exposedHeaders 用于指定允许跨域的头部信息，可以是一个字符串数组。 allowCredentials 用于指定是否允许携带 cookie，默认为 false。 maxAge 用于指定 OPTIONS 请求的缓存时间，单位为秒。 默认情况下，@CrossOrigin 注解会允许所有的跨域请求，并且支持所有头部信息，不允许携带 cookie，OPTIONS 请求的缓存时间为 1800 秒。 当然该注解可以标注在类上，用于标识该 Controller 的所有方法默认支持跨域请求。 使用 WebMvcConfigurer 解决全局跨域问题 在 Spring MVC 中可以通过添加一个如下的配置类为全局配置代理： @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/api/**") .allowedOrigins("https://domain2.com") .allowedMethods("PUT", "DELETE") .allowedHeaders("header1", "header2", "header3") .exposedHeaders("header1", "header2") .allowCredentials(true).maxAge(3600); // Add more mappings... } } 使用 Filter 来解决跨域问题 在前面的介绍中我们提到了跨域要允许跨域只需要对特定的 OPTIONS 请求返回 CORS 的头部信息即可，而我们 介绍了 Filter 可以用来处理 HTTP 请求的预处理和后处理，因此我们可以使用 Filter 来处理跨域问题。 而 Spring MVC 中默认提供了一个类型为 CorFilter 的过滤器用于处理跨域问题，我们只需要在 Spring 的 IoC 容器中注册这个过滤器即可： @Configuration @EnableWebMvc public class CorsConfig { @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource(); CorsConfiguration config=new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("http://localhost:3000"); config.addAllowedHeader("*"); config.addAllowedMethod("*"); source.registerCorsConfiguration("/**", config); return new CorsFilter(source); } } 在更改 Spring MVC 的配置的时候需要增加 @EnableWebMvc 注解。 @ResponseStatus @SessionAttributes @ModelAttribute @InitBinder @ExceptionHandler @ControllerAdvice @CrossOrigin]]></summary></entry><entry><title type="html">Mock Mvc 简介</title><link href="https://kaiser-yang.github.io/blog/2024/mock-mvc-intro/" rel="alternate" type="text/html" title="Mock Mvc 简介"/><published>2024-08-13T03:59:00+00:00</published><updated>2024-08-13T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/mock-mvc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/mock-mvc-intro/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">MockMvc</code> 是 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 框架提供的一个用于测试控制器的工具类，它可以模拟发送 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求并接收 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应， 从而可以方便地测试控制器的功能。<code class="language-plaintext highlighter-rouge">MockMvc</code> 的使用非常简单，只需要通过 <code class="language-plaintext highlighter-rouge">MockMvcBuilders</code> 类的 <code class="language-plaintext highlighter-rouge">standaloneSetup</code> 方法创建一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，然后使用 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象的 <code class="language-plaintext highlighter-rouge">perform</code> 方法发送 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求，即可得到 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应。 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象还提供了一系列的方法，可以用来验证 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应的状态码、响应头、响应体等信息。</p> <h1 id="mockmvc-的使用"><code class="language-plaintext highlighter-rouge">MockMvc</code> 的使用</h1> <p>前面提到了可以使用 <code class="language-plaintext highlighter-rouge">MockMvcBuilders</code> 类的 <code class="language-plaintext highlighter-rouge">standaloneSetup</code> 方法创建一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，但是如果我们 在一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目中，可以直接使用 <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> 注解注入一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，这样就 不需要手动创建 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象了。</p> <p>接下来简单介绍一下 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的基本步骤：</p> <ol> <li>对要测试的 <code class="language-plaintext highlighter-rouge">Controller</code> 创建一个对应的测试类；通常命名为原来的控制器类名后面加上 <code class="language-plaintext highlighter-rouge">Test</code>， 如 <code class="language-plaintext highlighter-rouge">UserController</code> 的测试类命名为 <code class="language-plaintext highlighter-rouge">UserControllerTest</code>；</li> <li>为这个类添加 <code class="language-plaintext highlighter-rouge">@SpringBootTest</code> 注解，表明这是一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 测试类；</li> <li>为这个类添加 <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> 注解，自动向 <code class="language-plaintext highlighter-rouge">IoC</code> 容器中注入一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象；</li> <li>在测试类中定义一个 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象，并使用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 注解注入；</li> <li>添加测试方法，测试方法使用 <code class="language-plaintext highlighter-rouge">@Test</code> 进行标注；</li> </ol> <p>经过上述的步骤，我可以得到一个类似下面的代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserControllerTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>接下来需要编写测试方法的逻辑，一般情况下我们只需要按照以下的顺序编写即可：</p> <ol> <li>发送请求；</li> <li>验证响应状态码；</li> <li>验证响应头；</li> <li>验证响应体。</li> </ol> <p>下面我们以此介绍这几个步骤。对于发送请求，我们主要使用 <code class="language-plaintext highlighter-rouge">MockMvc</code> 对象的 <code class="language-plaintext highlighter-rouge">perform</code> 方法，该方法接收一个 <code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象，<code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象可以通过 <code class="language-plaintext highlighter-rouge">MockMvcRequestBuilders</code> 类的静态方法创建， 如 <code class="language-plaintext highlighter-rouge">get</code>、<code class="language-plaintext highlighter-rouge">post</code>、<code class="language-plaintext highlighter-rouge">put</code>、<code class="language-plaintext highlighter-rouge">delete</code> 等方法。<code class="language-plaintext highlighter-rouge">RequestBuilder</code> 对象还提供了一系列的方法，可以设置请求的 路径、请求参数、请求头等信息。下面的代码展示了如何模拟一个带有 <code class="language-plaintext highlighter-rouge">token</code> 的 <code class="language-plaintext highlighter-rouge">GET</code> 请求：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">mockMvc.perform</code> 会返回一个 <code class="language-plaintext highlighter-rouge">ResultActions</code> 对象，该对象提供以下的几种方法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">andDo(ResultHandler)</code></li> <li><code class="language-plaintext highlighter-rouge">andExpect(ResultMatcher)</code></li> <li><code class="language-plaintext highlighter-rouge">andExpectAll(ResultMatcher...)</code></li> <li><code class="language-plaintext highlighter-rouge">andReturn()</code></li> </ul> <p>上面的几个方法均会再次返回一个 <code class="language-plaintext highlighter-rouge">ResultActions</code> 对象，这意味着我们可以进行链式调用。</p> <p>接下来我们只需要搞清楚 <code class="language-plaintext highlighter-rouge">ResultHandler</code> 和 <code class="language-plaintext highlighter-rouge">ResultMatcher</code> 的用法即可。<code class="language-plaintext highlighter-rouge">ResultHandler</code> 用于处理 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的结果，<code class="language-plaintext highlighter-rouge">ResultMatcher</code> 用于验证 <code class="language-plaintext highlighter-rouge">MockMvc</code> 的结果。<code class="language-plaintext highlighter-rouge">ResultHandler</code> 和 <code class="language-plaintext highlighter-rouge">ResultMatcher</code> 均是函数式接口，可以使用 <code class="language-plaintext highlighter-rouge">lambda</code> 表达式来实现。</p> <p>对于 <code class="language-plaintext highlighter-rouge">RequestHandler</code> 接口，我们只需要实现一个 <code class="language-plaintext highlighter-rouge">handle</code> 方法，该方法接收一个 <code class="language-plaintext highlighter-rouge">MvcResult</code> 对象，表明 我们希望对结果做什么操作，常见的时候我们会使用 <code class="language-plaintext highlighter-rouge">print</code> 方法打印结果：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的 <code class="language-plaintext highlighter-rouge">print()</code> 是 <code class="language-plaintext highlighter-rouge">MockMvcResultHandlers</code> 类的静态方法，用于打印结果。<code class="language-plaintext highlighter-rouge">MockMvcResultHandlers</code> 类 还提供了其他的方法，如 <code class="language-plaintext highlighter-rouge">log()</code>、<code class="language-plaintext highlighter-rouge">logIfError()</code>、<code class="language-plaintext highlighter-rouge">logDebug()</code> 等。</p> <p>同样的 <code class="language-plaintext highlighter-rouge">MockMvcResultMatches</code> 中也提供了许多静态方法进行结果的验证，如 <code class="language-plaintext highlighter-rouge">status()</code>、<code class="language-plaintext highlighter-rouge">content()</code>、 <code class="language-plaintext highlighter-rouge">jsonPath()</code> 等。下面的代码展示了如何验证响应的状态码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">status().isOk()</code> 方法用于验证响应的状态码是否为 <code class="language-plaintext highlighter-rouge">200</code>。<code class="language-plaintext highlighter-rouge">status()</code> 方法还提供了其他的 方法，如 <code class="language-plaintext highlighter-rouge">isBadRequest()</code>、<code class="language-plaintext highlighter-rouge">isNotFound()</code>、<code class="language-plaintext highlighter-rouge">isInternalServerError()</code> 等。</p> <p>接下来我们可以验证响应头，<code class="language-plaintext highlighter-rouge">MockMvcResultMatchers</code> 类中提供了 <code class="language-plaintext highlighter-rouge">header()</code> 方法，用于验证响应头的信息。 下面的代码展示了如何验证响应头：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">header().string("Content-Type", "application/json")</code> 方法用于验证响应头中 <code class="language-plaintext highlighter-rouge">Content-Type</code> 的值是否为 <code class="language-plaintext highlighter-rouge">application/json</code>。</p> <p>最后我们可以验证响应体，<code class="language-plaintext highlighter-rouge">MockMvcResultMatchers</code> 类中提供了 <code class="language-plaintext highlighter-rouge">content()</code> 方法，用于验证响应体的信息。 下面的代码展示了如何验证响应体：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}"</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">"{\"id\":1,\"name\":\"kaiser\"}"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">content().json("{\"id\":1,\"name\":\"kaiser\"}")</code> 方法用于验证响应体是否为 <code class="language-plaintext highlighter-rouge">{"id":1,"name":"kaiser"}</code>。</p> <p>上面的代码过于冗长，我们可以使用 <code class="language-plaintext highlighter-rouge">andExpectAll</code> 方法将所有的验证合并到一起，如下所示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetUser</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/user/{id}, 1"</span><span class="o">).</span><span class="na">header</span><span class="o">(</span><span class="s">"token"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpectAll</span><span class="o">(</span>
                    <span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">(),</span>
                    <span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">),</span>
                    <span class="n">content</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">"{\"id\":1,\"name\":\"kaiser\"}"</span><span class="o">)</span>
            <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="文件上传">文件上传</h1> <p>文件上传是指客户端向服务器发送文件，通常使用 <code class="language-plaintext highlighter-rouge">POST</code> 请求，请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 为 <code class="language-plaintext highlighter-rouge">multipart/form-data</code>。 <code class="language-plaintext highlighter-rouge">MockMvc</code> 提供了 <code class="language-plaintext highlighter-rouge">file</code> 方法用于模拟文件上传，下面的代码展示了如何模拟文件上传：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testUploadFile</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">multipart</span><span class="o">(</span><span class="s">"/file/upload"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="k">new</span> <span class="nc">MockMultipartFile</span><span class="o">(</span><span class="s">"file"</span><span class="o">,</span> <span class="s">"test.txt"</span><span class="o">,</span> <span class="s">"text/plain"</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">))))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"success"</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 也可以使用以下的方式：</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testUploadFile</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">multipart</span><span class="o">(</span><span class="s">"/file/upload"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">"file"</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">print</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"success"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码中，<code class="language-plaintext highlighter-rouge">multipart("/file/upload")</code> 方法用于模拟一个 <code class="language-plaintext highlighter-rouge">POST</code> 请求，请求路径为 <code class="language-plaintext highlighter-rouge">/file/upload</code>， <code class="language-plaintext highlighter-rouge">file</code> 方法用于模拟文件上传，<code class="language-plaintext highlighter-rouge">new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes())</code> 用于模拟一个名为 <code class="language-plaintext highlighter-rouge">test.txt</code>，文件类型为 <code class="language-plaintext highlighter-rouge">text/plain</code>，文件内容为 <code class="language-plaintext highlighter-rouge">hello</code>。</p> <p>上面的第二种方式中，<code class="language-plaintext highlighter-rouge">file("file", "hello".getBytes())</code> 方法用于模拟一个名为 <code class="language-plaintext highlighter-rouge">file</code>，文件内容为 <code class="language-plaintext highlighter-rouge">hello</code>。</p> ]]></content><author><name></name></author><summary type="html"><![CDATA[MockMvc 是 Spring MVC 框架提供的一个用于测试控制器的工具类，它可以模拟发送 HTTP 请求并接收 HTTP 响应， 从而可以方便地测试控制器的功能。MockMvc 的使用非常简单，只需要通过 MockMvcBuilders 类的 standaloneSetup 方法创建一个 MockMvc 对象，然后使用 MockMvc 对象的 perform 方法发送 HTTP 请求，即可得到 HTTP 响应。 MockMvc 对象还提供了一系列的方法，可以用来验证 HTTP 响应的状态码、响应头、响应体等信息。 MockMvc 的使用 前面提到了可以使用 MockMvcBuilders 类的 standaloneSetup 方法创建一个 MockMvc 对象，但是如果我们 在一个 Spring Boot 项目中，可以直接使用 @AutoConfigureMockMvc 注解注入一个 MockMvc 对象，这样就 不需要手动创建 MockMvc 对象了。 接下来简单介绍一下 MockMvc 的基本步骤： 对要测试的 Controller 创建一个对应的测试类；通常命名为原来的控制器类名后面加上 Test， 如 UserController 的测试类命名为 UserControllerTest； 为这个类添加 @SpringBootTest 注解，表明这是一个 Spring Boot 测试类； 为这个类添加 @AutoConfigureMockMvc 注解，自动向 IoC 容器中注入一个 MockMvc 对象； 在测试类中定义一个 MockMvc 对象，并使用 @Autowired 注解注入； 添加测试方法，测试方法使用 @Test 进行标注； 经过上述的步骤，我可以得到一个类似下面的代码： @SpringBootTest @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mockMvc; @Test public void testGetUser() throws Exception { } } 接下来需要编写测试方法的逻辑，一般情况下我们只需要按照以下的顺序编写即可： 发送请求； 验证响应状态码； 验证响应头； 验证响应体。 下面我们以此介绍这几个步骤。对于发送请求，我们主要使用 MockMvc 对象的 perform 方法，该方法接收一个 RequestBuilder 对象，RequestBuilder 对象可以通过 MockMvcRequestBuilders 类的静态方法创建， 如 get、post、put、delete 等方法。RequestBuilder 对象还提供了一系列的方法，可以设置请求的 路径、请求参数、请求头等信息。下面的代码展示了如何模拟一个带有 token 的 GET 请求： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")); } mockMvc.perform 会返回一个 ResultActions 对象，该对象提供以下的几种方法： andDo(ResultHandler) andExpect(ResultMatcher) andExpectAll(ResultMatcher...) andReturn() 上面的几个方法均会再次返回一个 ResultActions 对象，这意味着我们可以进行链式调用。 接下来我们只需要搞清楚 ResultHandler 和 ResultMatcher 的用法即可。ResultHandler 用于处理 MockMvc 的结果，ResultMatcher 用于验证 MockMvc 的结果。ResultHandler 和 ResultMatcher 均是函数式接口，可以使用 lambda 表达式来实现。 对于 RequestHandler 接口，我们只需要实现一个 handle 方法，该方法接收一个 MvcResult 对象，表明 我们希望对结果做什么操作，常见的时候我们会使用 print 方法打印结果： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()); } 上面的 print() 是 MockMvcResultHandlers 类的静态方法，用于打印结果。MockMvcResultHandlers 类 还提供了其他的方法，如 log()、logIfError()、logDebug() 等。 同样的 MockMvcResultMatches 中也提供了许多静态方法进行结果的验证，如 status()、content()、 jsonPath() 等。下面的代码展示了如何验证响应的状态码： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpect(status().isOk()); } 上面的代码中，status().isOk() 方法用于验证响应的状态码是否为 200。status() 方法还提供了其他的 方法，如 isBadRequest()、isNotFound()、isInternalServerError() 等。 接下来我们可以验证响应头，MockMvcResultMatchers 类中提供了 header() 方法，用于验证响应头的信息。 下面的代码展示了如何验证响应头： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpect(status().isOk()) .andExpect(header().string("Content-Type", "application/json")); } 上面的代码中，header().string("Content-Type", "application/json") 方法用于验证响应头中 Content-Type 的值是否为 application/json。 最后我们可以验证响应体，MockMvcResultMatchers 类中提供了 content() 方法，用于验证响应体的信息。 下面的代码展示了如何验证响应体： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}", 1).header("token", "123456")) .andDo(print()) .andExpect(status().isOk()) .andExpect(header().string("Content-Type", "application/json")) .andExpect(content().json("{\"id\":1,\"name\":\"kaiser\"}")); } 上面的代码中，content().json("{\"id\":1,\"name\":\"kaiser\"}") 方法用于验证响应体是否为 {"id":1,"name":"kaiser"}。 上面的代码过于冗长，我们可以使用 andExpectAll 方法将所有的验证合并到一起，如下所示： @Test public void testGetUser() throws Exception { mockMvc.perform(get("/user/{id}, 1").header("token", "123456")) .andDo(print()) .andExpectAll( status().isOk(), header().string("Content-Type", "application/json"), content().json("{\"id\":1,\"name\":\"kaiser\"}") ); } 文件上传 文件上传是指客户端向服务器发送文件，通常使用 POST 请求，请求头中的 Content-Type 为 multipart/form-data。 MockMvc 提供了 file 方法用于模拟文件上传，下面的代码展示了如何模拟文件上传： @Test public void testUploadFile() throws Exception { mockMvc.perform(multipart("/file/upload") .file(new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes("UTF-8")))) .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string("success")); } // 也可以使用以下的方式： @Test public void testUploadFile() throws Exception { mockMvc.perform(multipart("/file/upload") .file("file", "hello".getBytes("UTF-8"))) .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string("success")); } 上面的代码中，multipart("/file/upload") 方法用于模拟一个 POST 请求，请求路径为 /file/upload， file 方法用于模拟文件上传，new MockMultipartFile("file", "test.txt", "text/plain", "hello".getBytes()) 用于模拟一个名为 test.txt，文件类型为 text/plain，文件内容为 hello。 上面的第二种方式中，file("file", "hello".getBytes()) 方法用于模拟一个名为 file，文件内容为 hello。]]></summary></entry><entry><title type="html">gcs-back-end v0.1.0 开发实录</title><link href="https://kaiser-yang.github.io/blog/2024/gcs-back-end-v0.1.0/" rel="alternate" type="text/html" title="gcs-back-end v0.1.0 开发实录"/><published>2024-08-12T03:59:00+00:00</published><updated>2024-08-12T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/gcs-back-end-v0.1.0</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/gcs-back-end-v0.1.0/"><![CDATA[<p>NOTE: 文章内容按照时间 <code class="language-plaintext highlighter-rouge">pr</code> 创建的时间线进行排列。</p> <p>仓库地址：<a href="https://github.com/CMIPT/gcs-back-end">gcs-back-end</a></p> <h1 id="add-docker-creator-and-format-action">Add docker creator and format action</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/1">gcs-pull-1</a></p> <h2 id="google-java-style-format">Google Java Style Format</h2> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>添加了<code class="language-plaintext highlighter-rouge">docker</code>的创建和格式化<code class="language-plaintext highlighter-rouge">action</code>。该<code class="language-plaintext highlighter-rouge">action</code>能够在创建合入<code class="language-plaintext highlighter-rouge">master</code>和<code class="language-plaintext highlighter-rouge">develop</code>的 <code class="language-plaintext highlighter-rouge">pr</code>时，自动使用<code class="language-plaintext highlighter-rouge">Google Java Style Format</code>对<code class="language-plaintext highlighter-rouge">Java</code>代码进行格式化，并且自动创建一个新的<code class="language-plaintext highlighter-rouge">commit</code>提交 格式化后的代码。</p> <p>创建这个<code class="language-plaintext highlighter-rouge">git action</code>的主要目的是为了保证整个团队编码风格的一致性。</p> <p>Issues:</p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>这个<code class="language-plaintext highlighter-rouge">action</code>目前还有一些问题，比如新创建的提交依然会触发一次该<code class="language-plaintext highlighter-rouge">action</code>。</li> </ul> <p>NOTE: <code class="language-plaintext highlighter-rouge">git action</code>的代码中出现了<code class="language-plaintext highlighter-rouge">secrets.PAT</code>，该字段需要在仓库的设置部分自行进行设置，值的内容是一 个<code class="language-plaintext highlighter-rouge">token</code>该<code class="language-plaintext highlighter-rouge">token</code>具有仓库的写权限，这样自动提交的时候才能保证能够成功提交。而<code class="language-plaintext highlighter-rouge">token</code>的创建方法是在 个人的<code class="language-plaintext highlighter-rouge">github</code>账号中。</p> <p>在<code class="language-plaintext highlighter-rouge">github</code>中创建<code class="language-plaintext highlighter-rouge">token</code>：</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20240801102637.png" alt="" class="img-fluid"/></p> <p>如何在仓库的<code class="language-plaintext highlighter-rouge">secrets</code>中添加<code class="language-plaintext highlighter-rouge">token</code>：</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20240801102200.png" alt="" class="img-fluid"/></p> <h2 id="docker-creator">Docker Creator</h2> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>中还添加了一个第三方依赖，用于创建<code class="language-plaintext highlighter-rouge">docker</code>镜像。这个镜像能够自动创建一个<code class="language-plaintext highlighter-rouge">docker</code>镜像并安装 一些基础的工具，例如<code class="language-plaintext highlighter-rouge">ssh</code>等。</p> <p>第三方依赖的地址：<a href="https://github.com/CMIPT/docker-script.git">docker-creator</a></p> <h1 id="initialize-the-project">Initialize the project</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/2">gcs-pull-2</a></p> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>是从<a href="https://start.spring.io/">spring-io</a>上创建了一个<code class="language-plaintext highlighter-rouge">Spring Boot</code>的项目，然后将其解压到了 仓库中。</p> <p>TODO:</p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>添加<code class="language-plaintext highlighter-rouge">spring</code>的基本使用介绍</li> </ul> <h1 id="build-the-initial-database-script">Build the initial database script</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/3">gcs-pull-3</a></p> <h1 id="provide-python-scripts-to-process-json-files">Provide Python scripts to process Json files</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/6">gcs-pull-6</a></p> <p>本次的<code class="language-plaintext highlighter-rouge">pr</code>提供了处理<code class="language-plaintext highlighter-rouge">Json</code>文件的<code class="language-plaintext highlighter-rouge">Python</code>脚本，脚本接受一个参数，表示文件所在目录。默认值为 <code class="language-plaintext highlighter-rouge">../config.json</code>。脚本内置函数将<code class="language-plaintext highlighter-rouge">Json</code>文件的内容值存入对象<code class="language-plaintext highlighter-rouge">a</code>, 并可以通过点操作符<code class="language-plaintext highlighter-rouge">.</code>访问对象属性来 获取对应内容值。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">loadJsonAsObject</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="c1"># transmit dictronary into object
</span>    <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">object_hook</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nc">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">))</span>


<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">Process JSON file.</span><span class="sh">"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">'</span><span class="s">file_path</span><span class="sh">'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="sh">'</span><span class="s">?</span><span class="sh">'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="sh">'</span><span class="s">../config.json</span><span class="sh">'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">Path to the JSON file</span><span class="sh">"</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
</code></pre></div></div> <p>下面介绍一下上述代码使用的<code class="language-plaintext highlighter-rouge">argparse</code>功能：</p> <ul> <li><code class="language-plaintext highlighter-rouge">argparse.ArgumentParser</code>：该类用于创建一个参数解析器对象。<code class="language-plaintext highlighter-rouge">description</code>参数可以用于设置命令行工具的简短描述。</li> <li><code class="language-plaintext highlighter-rouge">parser.add_argument</code>：定义程序可以接受的命令行参数。 <ul> <li><code class="language-plaintext highlighter-rouge">file_path</code>：这是定义的命令行参数名。它将接受用户输入的文件路径。</li> <li><code class="language-plaintext highlighter-rouge">nargs='?'</code>：表示该参数是可选的。如果用户没有提供该参数，则使用默认值。</li> <li><code class="language-plaintext highlighter-rouge">default='../config.json'</code>：如果用户没有提供<code class="language-plaintext highlighter-rouge">file_path</code>参数，则默认使用<code class="language-plaintext highlighter-rouge">../config.json</code>作为文件路径。</li> <li><code class="language-plaintext highlighter-rouge">help="Path to the JSON file"</code>：提供该参数的帮助信息，当用户使用<code class="language-plaintext highlighter-rouge">--help</code>选项时会显示这些信息。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">args = parser.parse_args()</code>：解析命令行参数，并将结果存储在<code class="language-plaintext highlighter-rouge">args</code>对象中。</li> </ul> <p>函数<code class="language-plaintext highlighter-rouge">loadJsonAsObject()</code>使用<code class="language-plaintext highlighter-rouge">json.loads()</code>时默认将内容解析成字典对象<code class="language-plaintext highlighter-rouge">dict</code>, 使用<code class="language-plaintext highlighter-rouge">SimpleNamespace</code>参数 后，允许像访问对象属性一样访问字典键。</p> <h1 id="add-spring-doc-for-restful-api">Add spring-doc for restful api</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/7">gcs-pull-7</a></p> <p>本次的<code class="language-plaintext highlighter-rouge">pr</code>主要是添加了<code class="language-plaintext highlighter-rouge">spring-doc</code>的依赖，用于生成<code class="language-plaintext highlighter-rouge">restful api</code>的文档。</p> <p>集成文档的时候开始在尝试使用<code class="language-plaintext highlighter-rouge">spring-fox</code>和<code class="language-plaintext highlighter-rouge">spring-swagger</code>。结果发现和<code class="language-plaintext highlighter-rouge">spring3.x</code>的版本不兼容，然后 搜索资料发现了<code class="language-plaintext highlighter-rouge">spring-doc</code>这个依赖，然后就使用了这个依赖。</p> <p>TODO:</p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>添加<code class="language-plaintext highlighter-rouge">spring-doc</code>的使用介绍</li> </ul> <h1 id="finish-part-of-the-deploy-script">Finish part of the deploy script</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/9">gcs-pull-9</a></p> <p>创建这个脚本的目的是希望能够仅仅通过编写一个<code class="language-plaintext highlighter-rouge">json</code>的配置文件，就能够完成整个项目的部署。这个<code class="language-plaintext highlighter-rouge">pr</code>完成 了部分的功能，还有一些功能没有完成。</p> <p>主脚本是一个<code class="language-plaintext highlighter-rouge">bash</code>脚本，在<code class="language-plaintext highlighter-rouge">bash</code>脚本中会自动安装<code class="language-plaintext highlighter-rouge">python</code>等依赖，然后调用<code class="language-plaintext highlighter-rouge">python</code>脚本来完成部署。部署 的主要逻辑是通过读取<code class="language-plaintext highlighter-rouge">json</code>文件，然后根据配置文件完成一系列处理，最后将<code class="language-plaintext highlighter-rouge">jar</code>通过<code class="language-plaintext highlighter-rouge">Sys V init</code>注册成 一个服务。</p> <p><code class="language-plaintext highlighter-rouge">Sys V init</code>创建服务的方式非常简单，只需要在<code class="language-plaintext highlighter-rouge">/etc/init.d/</code>目录下放置一个可执行文件，然后即可通过 <code class="language-plaintext highlighter-rouge">service xxx start</code>来启动服务。在本次的<code class="language-plaintext highlighter-rouge">pr</code>中，直接创建了一个软连接连接到了打包出来的<code class="language-plaintext highlighter-rouge">jar</code>文件，但是 在后续的使用过程中发现这样做存在问题。</p> <p>在本次的提交中，我发现<code class="language-plaintext highlighter-rouge">junit</code>可以使用<code class="language-plaintext highlighter-rouge">spring-boot-test</code>进行替代，于是将之前的<code class="language-plaintext highlighter-rouge">junit</code>的依赖替换成了 <code class="language-plaintext highlighter-rouge">spring-boot-test</code>，并且删除了之前添加的<code class="language-plaintext highlighter-rouge">log4j</code>依赖（后续可以自己设置<code class="language-plaintext highlighter-rouge">spring-boot</code>的日志系统）。</p> <p>下面介绍一下几个脚本有什么作用：</p> <ul> <li><code class="language-plaintext highlighter-rouge">deploy_ubuntu.sh</code>：这个脚本是主脚本，用于在<code class="language-plaintext highlighter-rouge">ubuntu</code>系统上部署项目，这个脚本再安装一些依赖后便将控制权交给<code class="language-plaintext highlighter-rouge">script/deploy_helper.py</code>。</li> <li><code class="language-plaintext highlighter-rouge">script/deploy_helper.py</code>：这个脚本读取<code class="language-plaintext highlighter-rouge">json</code>配置文件，然后根据配置文件完成一系列操作，最后将<code class="language-plaintext highlighter-rouge">jar</code>注册成一个服务。</li> <li><code class="language-plaintext highlighter-rouge">script/get_jar_position.sh</code>：获取<code class="language-plaintext highlighter-rouge">jar</code>的位置，这个脚本会在<code class="language-plaintext highlighter-rouge">deploy_helper.py</code>中被调用，用于获取<code class="language-plaintext highlighter-rouge">mvn package</code>输出位置。</li> </ul> <p>Issues:</p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>这个脚本在某些环境使用的时候出现了问题，详见<a href="https://github.com/CMIPT/gcs-back-end/issues/14">gcs-issues-14</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>错误的添加使用了<code class="language-plaintext highlighter-rouge">spring-boot-test</code>导致添加了<code class="language-plaintext highlighter-rouge">spring-boot-starter-webflux</code>依赖，这个依赖目前应该是不用的。</li> </ul> <h1 id="add-mit-license-and-developers-info">Add MIT license and developers info</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/13">gcs-pull-13</a></p> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>主要是添加了<code class="language-plaintext highlighter-rouge">MIT</code>的开源协议，以及开发者的信息。</p> <h1 id="substitute-the-sys-v-init-with-systemd">Substitute the Sys V init with systemd</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/15">gcs-pull-15</a></p> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>主要是将<code class="language-plaintext highlighter-rouge">Sys V init</code>部署服务的方式替换成了<code class="language-plaintext highlighter-rouge">systemd</code>。这样做是因为发现现代的<code class="language-plaintext highlighter-rouge">Linux</code>系统更多地 使用<code class="language-plaintext highlighter-rouge">systemd</code>来管理服务，且<code class="language-plaintext highlighter-rouge">systemd</code>的启动速度等更加优秀，配置更加简单。这次的提交修复了 <a href="https://github.com/CMIPT/gcs-back-end/issues/14">gcs-issues-14</a>。</p> <p>这次的提交中还增加了<code class="language-plaintext highlighter-rouge">config_default.json</code>文件，<code class="language-plaintext highlighter-rouge">config_default.json</code>文件存储默认的配置，当一个配置项 没有被用户重写的时候会使用默认的配置。</p> <p>同时新增了一个<code class="language-plaintext highlighter-rouge">clean_ubuntu.sh</code>脚本用于清空创建的服务等。</p> <p>下面简单介绍一下<code class="language-plaintext highlighter-rouge">systemd</code>的使用方法。</p> <p>要使用<code class="language-plaintext highlighter-rouge">systemd</code>来管理服务，首先需要创建一个<code class="language-plaintext highlighter-rouge">service</code>文件，然后将这个文件放置在<code class="language-plaintext highlighter-rouge">/etc/systemd/system/</code> 目录下。<code class="language-plaintext highlighter-rouge">service</code>文件的内容大致如下：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>Git server center back-end service
<span class="nv">After</span><span class="o">=</span>network.target

<span class="o">[</span>Service]
<span class="nv">PIDFile</span><span class="o">=</span>/var/run/gcs.pid
<span class="nv">User</span><span class="o">=</span>gcs
<span class="nv">WorkingDirectory</span><span class="o">=</span>/opt/gcs
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">RestartSec</span><span class="o">=</span>5
<span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/java <span class="nt">-jar</span> /opt/gcs/gcs.jar

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div> <p>上面的大部分字段是不用解释的，这里给出一些注意事项：</p> <ul> <li>路径全部使用绝对路径。</li> <li><code class="language-plaintext highlighter-rouge">systemctl enable gcs</code>表示将服务设置为开机启动，但是如果当前的服务并没有启动，那么这个命令并不会启动服务。</li> <li><code class="language-plaintext highlighter-rouge">systemctl start gcs</code>表示启动当前的服务，这与<code class="language-plaintext highlighter-rouge">gcs</code>是否被设置为开机启动无关。</li> <li><code class="language-plaintext highlighter-rouge">systemctl disable gcs</code>和<code class="language-plaintext highlighter-rouge">systemctl stop gcs</code>的关系与上述类似。</li> </ul> <p>NOTE: 简单解释一下<code class="language-plaintext highlighter-rouge">systemctl enable gcs</code>和<code class="language-plaintext highlighter-rouge">systemctl disable gcs</code>的原理。两者只做了一件事情： 根据<code class="language-plaintext highlighter-rouge">[Install]</code>部分的内容创建或者删除软连接，例如上面的例子中，<code class="language-plaintext highlighter-rouge">systemctl enable gcs</code>会在 <code class="language-plaintext highlighter-rouge">/etc/systemd/system/multi-user.target.wants/</code>目录下创建一个<code class="language-plaintext highlighter-rouge">gcs.service</code>的软连接，而 <code class="language-plaintext highlighter-rouge">systemctl disable gcs</code>会删除这个软连接。这个软连接的作用是在<code class="language-plaintext highlighter-rouge">multi-user.target</code>启动的时候启动<code class="language-plaintext highlighter-rouge">gcs</code> 而<code class="language-plaintext highlighter-rouge">Linux</code>系统启动的时候会启动<code class="language-plaintext highlighter-rouge">multi-user.target</code>，所以<code class="language-plaintext highlighter-rouge">gcs</code>也能在开机的时候自动启动。</p> <h1 id="add-command_checker-and-setup_logger-to-scriptdeploy_helperpy">Add command_checker and setup_logger to script/deploy_helper.py</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/17">gcs-pull-17</a></p> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>修改了<code class="language-plaintext highlighter-rouge">script/deploy_helper.py</code>，增加了日志功能。在执行<code class="language-plaintext highlighter-rouge">deploy_helper.py</code>时，如果命令执行失败， 会输出执行失败的命令的日志信息，包括时间，日志等级，行号，执行失败的命令。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">logging</span>
<span class="kn">import</span> <span class="n">inspect</span>
</code></pre></div></div> <p>首先，实现这个<code class="language-plaintext highlighter-rouge">pr</code>的功能，需要导入<code class="language-plaintext highlighter-rouge">logging</code>和<code class="language-plaintext highlighter-rouge">inspect</code>模块。<code class="language-plaintext highlighter-rouge">logging</code>模块是<code class="language-plaintext highlighter-rouge">Python</code>内置的日志模块， <code class="language-plaintext highlighter-rouge">inspect</code>模块是<code class="language-plaintext highlighter-rouge">Python</code>内置模块，在这里用于获取命令的行号。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_logger</span><span class="p">(</span><span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Configure the global logging system.

    :param log_level: Set the logging level, defaulting to INFO.
    </span><span class="sh">"""</span>
    <span class="n">logging</span><span class="p">.</span><span class="nf">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">log_level</span><span class="p">,</span>
                        <span class="nb">format</span><span class="o">=</span><span class="sh">'</span><span class="s">%(asctime)s -%(levelname)s- in %(pathname)s:%(caller_lineno)d: %(message)s</span><span class="sh">'</span><span class="p">,</span> 
                        <span class="n">datefmt</span><span class="o">=</span><span class="sh">'</span><span class="s">%Y-%m-%d %H:%M:%S</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">setup_logger</code>函数用于配置全局的日志系统。<code class="language-plaintext highlighter-rouge">log_level</code>参数用于设置日志级别，默认为<code class="language-plaintext highlighter-rouge">INFO</code>。<code class="language-plaintext highlighter-rouge">logging.basicConfig</code> 定义输出日志的格式，包括时间，日志等级，行号，执行失败的命令。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">command_checker</span><span class="p">(</span><span class="n">status_code</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expected_code</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Check if the command execution status code meets the expected value.

    :param status_code: The actual status code of the command execution.
    :param message: The log message to be recorded.
    :param expected_code: The expected status code, defaulting to 0.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">status_code</span> <span class="o">!=</span> <span class="n">expected_code</span><span class="p">:</span>
        <span class="n">caller_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">.</span><span class="nf">currentframe</span><span class="p">().</span><span class="n">f_back</span>
        <span class="n">logging</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">caller_lineno</span><span class="sh">'</span><span class="p">:</span> <span class="n">caller_frame</span><span class="p">.</span><span class="n">f_lineno</span><span class="p">})</span>
        <span class="nf">exit</span><span class="p">(</span><span class="n">status_code</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">command_checker</code>用于比较命令执行返回的状态码与期望的状态码是否一致，如果不一致，则说明命令执行失败， 则打印出相应的日志，且返回状态码，如果一致则说明命令执行成功，不做任何操作。</p> <ul> <li><code class="language-plaintext highlighter-rouge">status_code</code>: 命令执行的实际状态码</li> <li><code class="language-plaintext highlighter-rouge">message</code>: 要打印的日志信息</li> <li><code class="language-plaintext highlighter-rouge">expected_code</code>: 期望的状态码，默认为0</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message_tmp</span> <span class="o">=</span> <span class="sh">'''</span><span class="se">\
</span><span class="s">The command below failed:
    {0}
Expected status code 0, got status code {1}
</span><span class="sh">'''</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">message_tmp</code>是一个模板字符串，用于格式化输出日志信息，在这里会将执行失败的命令和状态码输出到日志中。</p> <h1 id="remove-unsed-dependency-and-add-doc-for-configuration">Remove unsed dependency and add doc for configuration</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/22">gcs-pull-22</a></p> <p>本次<code class="language-plaintext highlighter-rouge">pr</code>主要是将<code class="language-plaintext highlighter-rouge">spring-boot-starter-webflux</code>依赖删除，因为这个依赖是多余的。同时添加了一个<code class="language-plaintext highlighter-rouge">README-zh.md</code> 文件，用于存储配置文件的说明。</p> <h1 id="refactor-the-database-script">Refactor the database script</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/23">gcs-pull-23</a></p> <p>在本次提交中，对数据库脚本进行了重构，将一个sql脚本分割成多个功能不同的sql脚本并放入不同的目录当中， 降低了数据库代码的耦合度，方便后续更新。并且还提供了一个数据库部署脚本<code class="language-plaintext highlighter-rouge">database_deploy.sh</code>，运行这个 脚本就能够自动调用前面的<code class="language-plaintext highlighter-rouge">SQL</code>脚本，从而部署数据库。</p> <p>目前<code class="language-plaintext highlighter-rouge">database</code>的目录结果如下所示： <img src="https://typora-picture-cloud.oss-cn-chengdu.aliyuncs.com/img1/202408191959133.png" alt="" class="img-fluid"/></p> <p>在<code class="language-plaintext highlighter-rouge">constraint/all_column_constraint.sql</code>文件中，定义了表的主键和唯一键约束；<code class="language-plaintext highlighter-rouge">update_gmt_updated_column</code> 文件包含一个函数，用于在更新时自动将<code class="language-plaintext highlighter-rouge">gmt_updated</code>列设置为当前的时间戳；<code class="language-plaintext highlighter-rouge">sequence/all_column_seq.sql</code> 文件和<code class="language-plaintext highlighter-rouge">sequence/sequence_set.sql</code>为表的主键列定义了序列以及设定列的当前值；在<code class="language-plaintext highlighter-rouge">table</code>目录下面的三个文 件定义了三个表，并且为每列添加了注释；<code class="language-plaintext highlighter-rouge">trigger/all_table_trigger.sql</code>文件为表添加了触发器，自动在更新 行的时候更新<code class="language-plaintext highlighter-rouge">gmt_updated</code>列。</p> <h1 id="finish-the-script-for-deploying-in-docker">Finish the script for deploying in docker</h1> <p><code class="language-plaintext highlighter-rouge">pr</code>的链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/24">gcs-pull-24</a></p> <p>在本次的提交中，增加了自动在 <code class="language-plaintext highlighter-rouge">docker</code> 中部署的功能。在编写这部分功能的时候，发现 <code class="language-plaintext highlighter-rouge">docker</code> 在默认情况下 是不能够使用 <code class="language-plaintext highlighter-rouge">systemd</code> 的，只有当指明 <code class="language-plaintext highlighter-rouge">--privileged=true</code> 的时候才能够使用 <code class="language-plaintext highlighter-rouge">systemd</code>。这个参数的作用 是让 <code class="language-plaintext highlighter-rouge">docker</code> 在容器中运行的时候拥有直接操作宿主机的权限。如果通过样的方式创建 <code class="language-plaintext highlighter-rouge">docker</code> 失去了 <code class="language-plaintext highlighter-rouge">docker</code> 的部分安全性，因此我将在 <code class="language-plaintext highlighter-rouge">docker</code> 中的部署改用成了 <code class="language-plaintext highlighter-rouge">Sys Init V</code> 的方式，而在物理机上的部署继续保持 <code class="language-plaintext highlighter-rouge">systemd</code> 的方式。</p> <p><code class="language-plaintext highlighter-rouge">Sys Init V</code> 的脚本模板来自于 <a href="https://gist.github.com/naholyr/4275302">_service.md</a> 。我对其中进行了 部分的修改，得到了如下的文件：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">PIDDIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">LOGDIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$LOGFILE</span><span class="s2">"</span><span class="si">)</span>
start<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PIDDIR</span><span class="s2">/</span><span class="nv">$PIDNAME</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nt">-0</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$PIDDIR</span><span class="s2">/</span><span class="nv">$PIDNAME</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s1">'Service already running'</span> <span class="o">&gt;</span>&amp;2
    <span class="k">return </span>1
  <span class="k">fi
  </span><span class="nb">echo</span> <span class="s1">'Starting service…'</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">local </span><span class="nv">CMD</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SCRIPT</span><span class="s2"> &amp;&gt; </span><span class="se">\"</span><span class="nv">$LOGFILE</span><span class="se">\"</span><span class="s2"> &amp; echo </span><span class="se">\$</span><span class="s2">!"</span>
  su <span class="nt">-c</span> <span class="s2">"mkdir -p ""</span><span class="nv">$PIDDIR</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$RUNAS</span><span class="s2">"</span>
  su <span class="nt">-c</span> <span class="s2">"mkdir -p ""</span><span class="nv">$LOGDIR</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$RUNAS</span><span class="s2">"</span>
  su <span class="nt">-c</span> <span class="s2">"</span><span class="nv">$CMD</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$RUNAS</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s1">'Service started'</span> <span class="o">&gt;</span>&amp;2
<span class="o">}</span>

stop<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">!</span> <span class="nb">kill</span> <span class="nt">-0</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s1">'Service not running'</span> <span class="o">&gt;</span>&amp;2
    <span class="k">return </span>1
  <span class="k">fi
  </span><span class="nb">echo</span> <span class="s1">'Stopping service…'</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">kill</span> <span class="nt">-15</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s1">'Service stopped'</span> <span class="o">&gt;</span>&amp;2
<span class="o">}</span>

uninstall<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] "</span>
  <span class="nb">local </span>SURE
  <span class="nb">read </span>SURE
  <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$SURE</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"yes"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span>stop
    <span class="nb">rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PIDFILE</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"Notice: log file is not be removed: '</span><span class="nv">$LOGFILE</span><span class="s2">'"</span> <span class="o">&gt;</span>&amp;2
    update-rc.d <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$NAME</span><span class="s2">"</span> remove
    <span class="nb">rm</span> <span class="nt">-fv</span> <span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span>
  <span class="k">fi</span>
<span class="o">}</span>

<span class="k">case</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="k">in
  </span>start<span class="p">)</span>
    start
    <span class="p">;;</span>
  stop<span class="p">)</span>
    stop
    <span class="p">;;</span>
  uninstall<span class="p">)</span>
    uninstall
    <span class="p">;;</span>
  restart<span class="p">)</span>
    stop
    start
    <span class="p">;;</span>
  <span class="k">*</span><span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> {start|stop|restart|uninstall}"</span>
<span class="k">esac</span>
</code></pre></div></div> <p>上面的脚本需要在最开始添加以下内容才能运行 (等号后面需要添加值)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/env bash</span>
<span class="nv">NAME</span><span class="o">=</span>
<span class="nv">SCRIPT</span><span class="o">=</span>
<span class="nv">RUNAS</span><span class="o">=</span>
<span class="nv">PIDFILE</span><span class="o">=</span>
<span class="nv">LOGFILE</span><span class="o">=</span>
</code></pre></div></div> <p>我通过 <code class="language-plaintext highlighter-rouge">Python</code> 脚本读取 <code class="language-plaintext highlighter-rouge">json</code> 配置文件，然后将配置文件的内容写入到 <code class="language-plaintext highlighter-rouge">Sys Init V</code> 的脚本中，最后将 后将这个脚本拷贝到指定目录：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_sys_v_init_service</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">script/service_tmp.sh</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">service_content</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nf">command_checker</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'''</span><span class="s">#!/bin/env bash
NAME=</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="s">
SCRIPT=</span><span class="sh">"</span><span class="si">{</span><span class="nf">parse_iterable_into_str</span><span class="p">([</span><span class="n">config</span><span class="p">.</span><span class="n">serviceStartJavaCommand</span><span class="p">]</span> <span class="o">+</span>
<span class="n">config</span><span class="p">.</span><span class="n">serviceStartJavaArgs</span> <span class="o">+</span> <span class="p">[</span><span class="n">config</span><span class="p">.</span><span class="n">serviceStartJarFile</span><span class="p">])</span><span class="si">}</span><span class="sh">"</span><span class="s">
RUNAS=</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceUser</span><span class="si">}</span><span class="s">
PIDFILE=</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">servicePIDFile</span><span class="si">}</span><span class="s">
LOGFILE=</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceLogFile</span><span class="si">}</span><span class="s">
</span><span class="sh">'''</span>
    <span class="n">service_content</span> <span class="o">=</span> <span class="n">header</span> <span class="o">+</span> <span class="n">service_content</span>
    <span class="nf">log_debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">service_content:</span><span class="se">\n</span><span class="s"> </span><span class="si">{</span><span class="n">service_content</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span>
        <span class="sa">f</span><span class="sh">"</span><span class="s">echo </span><span class="sh">'</span><span class="si">{</span><span class="n">service_content</span><span class="si">}</span><span class="sh">'</span><span class="s"> | </span><span class="si">{</span><span class="n">sudo_cmd</span><span class="si">}</span><span class="s"> tee </span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceSysVInitDirectory</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">command_checker</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Failed to create </span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceSysVInitDirectory</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">sudo_cmd</span><span class="si">}</span><span class="s"> chmod +x </span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceSysVInitDirectory</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">command_checker</span><span class="p">(</span>
        <span class="n">res</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Failed to chmod +x </span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceSysVInitDirectory</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">().</span><span class="n">level</span> <span class="o">==</span> <span class="n">logging</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceSysVInitDirectory</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">config</span><span class="p">.</span><span class="n">serviceName</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="nf">log_debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Service content:</span><span class="se">\n</span><span class="s"> </span><span class="si">{</span><span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nf">command_checker</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span>
</code></pre></div></div> <p>除了这些更改以外，将依赖的安装交给了 <code class="language-plaintext highlighter-rouge">Python</code> 脚本管理，<code class="language-plaintext highlighter-rouge">bash</code> 脚本仅仅负责安装 <code class="language-plaintext highlighter-rouge">python</code> 依赖。</p> <h1 id="finish-the-deploy-script-for-database">Finish the deploy script for database</h1> <p><code class="language-plaintext highlighter-rouge">pr</code> 链接：<a href="https://github.com/CMIPT/gcs-back-end/pull/25">gcs-pull-25</a></p> <p>本次的 <code class="language-plaintext highlighter-rouge">pr</code> 主要完成了数据库部署部分，根据之前提供的 <code class="language-plaintext highlighter-rouge">SQL</code> 脚本，我们在部署脚本中调用了 <code class="language-plaintext highlighter-rouge">SQL</code> 脚本去 部署数据库。</p> <p>在部署数据库部分，先在数据库中检查是否存在指定的用户，不存在就进行创建，并根据配置文件的密码修改数据 库中用户的密码。之后检查是否存在数据库，不存在就创建数据库。然后给当前用户赋予指定数据库的所有权限。 最后就是通过该用户去调用 <code class="language-plaintext highlighter-rouge">SQL</code> 脚本创建表。</p> <p>除了数据库部分的部署外，还增加了激活不同配置文件的功能。在 <code class="language-plaintext highlighter-rouge">deploy_helper.py</code> 中增加了一个函数：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">active_profile</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">profile_format</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">spring.profiles.active=</span><span class="si">{</span><span class="nf">parse_iterable_into_str</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">profiles</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>
    <span class="nf">log_debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Profile format: </span><span class="si">{</span><span class="n">profile_format</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">exists</span><span class="p">(</span><span class="n">application_config_file_path</span><span class="p">):</span>
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">application_config_file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">readlines</span><span class="p">()</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">application_config_file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lines</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">'</span><span class="s">spring.profiles.active</span><span class="sh">'</span><span class="p">):</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">profile_format</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nf">command_checker</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>除此之外，我们将 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的相关配置使用 <code class="language-plaintext highlighter-rouge">yml</code> 格式进行配置，而脚本创建的配置则放置在了 <code class="language-plaintext highlighter-rouge">properties</code> 文件中。这样能保证后续增加的配置一定能生效，因为 <code class="language-plaintext highlighter-rouge">properties</code> 文件的优先级高于 <code class="language-plaintext highlighter-rouge">yml</code> 文件。</p>]]></content><author><name></name></author><category term="Java"/><summary type="html"><![CDATA[NOTE: 文章内容按照时间 pr 创建的时间线进行排列。 仓库地址：gcs-back-end Add docker creator and format action pr的链接：gcs-pull-1 Google Java Style Format 本次pr添加了docker的创建和格式化action。该action能够在创建合入master和develop的 pr时，自动使用Google Java Style Format对Java代码进行格式化，并且自动创建一个新的commit提交 格式化后的代码。 创建这个git action的主要目的是为了保证整个团队编码风格的一致性。 Issues: 这个action目前还有一些问题，比如新创建的提交依然会触发一次该action。 NOTE: git action的代码中出现了secrets.PAT，该字段需要在仓库的设置部分自行进行设置，值的内容是一 个token该token具有仓库的写权限，这样自动提交的时候才能保证能够成功提交。而token的创建方法是在 个人的github账号中。 在github中创建token： 如何在仓库的secrets中添加token： Docker Creator 本次pr中还添加了一个第三方依赖，用于创建docker镜像。这个镜像能够自动创建一个docker镜像并安装 一些基础的工具，例如ssh等。 第三方依赖的地址：docker-creator Initialize the project pr的链接：gcs-pull-2 本次pr是从spring-io上创建了一个Spring Boot的项目，然后将其解压到了 仓库中。 TODO: 添加spring的基本使用介绍 Build the initial database script pr的链接：gcs-pull-3 Provide Python scripts to process Json files pr的链接：gcs-pull-6 本次的pr提供了处理Json文件的Python脚本，脚本接受一个参数，表示文件所在目录。默认值为 ../config.json。脚本内置函数将Json文件的内容值存入对象a, 并可以通过点操作符.访问对象属性来 获取对应内容值。 def loadJsonAsObject(file_path: str): with open(file_path, 'r', encoding='utf-8') as file: data=json.load(file) # transmit dictronary into object return json.loads(json.dumps(data), object_hook=lambda d: SimpleNamespace(**d)) parser=argparse.ArgumentParser(description="Process JSON file.") parser.add_argument('file_path', nargs='?', default='../config.json', help="Path to the JSON file") args=parser.parse_args() 下面介绍一下上述代码使用的argparse功能： argparse.ArgumentParser：该类用于创建一个参数解析器对象。description参数可以用于设置命令行工具的简短描述。 parser.add_argument：定义程序可以接受的命令行参数。 file_path：这是定义的命令行参数名。它将接受用户输入的文件路径。 nargs='?'：表示该参数是可选的。如果用户没有提供该参数，则使用默认值。 default='../config.json'：如果用户没有提供file_path参数，则默认使用../config.json作为文件路径。 help="Path to the JSON file"：提供该参数的帮助信息，当用户使用--help选项时会显示这些信息。 args=parser.parse_args()：解析命令行参数，并将结果存储在args对象中。 函数loadJsonAsObject()使用json.loads()时默认将内容解析成字典对象dict, 使用SimpleNamespace参数 后，允许像访问对象属性一样访问字典键。 Add spring-doc for restful api pr的链接：gcs-pull-7 本次的pr主要是添加了spring-doc的依赖，用于生成restful api的文档。 集成文档的时候开始在尝试使用spring-fox和spring-swagger。结果发现和spring3.x的版本不兼容，然后 搜索资料发现了spring-doc这个依赖，然后就使用了这个依赖。 TODO: 添加spring-doc的使用介绍 Finish part of the deploy script pr的链接：gcs-pull-9 创建这个脚本的目的是希望能够仅仅通过编写一个json的配置文件，就能够完成整个项目的部署。这个pr完成 了部分的功能，还有一些功能没有完成。 主脚本是一个bash脚本，在bash脚本中会自动安装python等依赖，然后调用python脚本来完成部署。部署 的主要逻辑是通过读取json文件，然后根据配置文件完成一系列处理，最后将jar通过Sys V init注册成 一个服务。 Sys V init创建服务的方式非常简单，只需要在/etc/init.d/目录下放置一个可执行文件，然后即可通过 service xxx start来启动服务。在本次的pr中，直接创建了一个软连接连接到了打包出来的jar文件，但是 在后续的使用过程中发现这样做存在问题。 在本次的提交中，我发现junit可以使用spring-boot-test进行替代，于是将之前的junit的依赖替换成了 spring-boot-test，并且删除了之前添加的log4j依赖（后续可以自己设置spring-boot的日志系统）。 下面介绍一下几个脚本有什么作用： deploy_ubuntu.sh：这个脚本是主脚本，用于在ubuntu系统上部署项目，这个脚本再安装一些依赖后便将控制权交给script/deploy_helper.py。 script/deploy_helper.py：这个脚本读取json配置文件，然后根据配置文件完成一系列操作，最后将jar注册成一个服务。 script/get_jar_position.sh：获取jar的位置，这个脚本会在deploy_helper.py中被调用，用于获取mvn package输出位置。 Issues: 这个脚本在某些环境使用的时候出现了问题，详见gcs-issues-14 错误的添加使用了spring-boot-test导致添加了spring-boot-starter-webflux依赖，这个依赖目前应该是不用的。 Add MIT license and developers info pr的链接：gcs-pull-13 本次pr主要是添加了MIT的开源协议，以及开发者的信息。 Substitute the Sys V init with systemd pr的链接：gcs-pull-15 本次pr主要是将Sys V init部署服务的方式替换成了systemd。这样做是因为发现现代的Linux系统更多地 使用systemd来管理服务，且systemd的启动速度等更加优秀，配置更加简单。这次的提交修复了 gcs-issues-14。 这次的提交中还增加了config_default.json文件，config_default.json文件存储默认的配置，当一个配置项 没有被用户重写的时候会使用默认的配置。 同时新增了一个clean_ubuntu.sh脚本用于清空创建的服务等。 下面简单介绍一下systemd的使用方法。 要使用systemd来管理服务，首先需要创建一个service文件，然后将这个文件放置在/etc/systemd/system/ 目录下。service文件的内容大致如下： [Unit] Description=Git server center back-end service After=network.target [Service] PIDFile=/var/run/gcs.pid User=gcs WorkingDirectory=/opt/gcs Restart=always RestartSec=5 ExecStart=/usr/bin/java -jar /opt/gcs/gcs.jar [Install] WantedBy=multi-user.target 上面的大部分字段是不用解释的，这里给出一些注意事项： 路径全部使用绝对路径。 systemctl enable gcs表示将服务设置为开机启动，但是如果当前的服务并没有启动，那么这个命令并不会启动服务。 systemctl start gcs表示启动当前的服务，这与gcs是否被设置为开机启动无关。 systemctl disable gcs和systemctl stop gcs的关系与上述类似。 NOTE: 简单解释一下systemctl enable gcs和systemctl disable gcs的原理。两者只做了一件事情： 根据[Install]部分的内容创建或者删除软连接，例如上面的例子中，systemctl enable gcs会在 /etc/systemd/system/multi-user.target.wants/目录下创建一个gcs.service的软连接，而 systemctl disable gcs会删除这个软连接。这个软连接的作用是在multi-user.target启动的时候启动gcs 而Linux系统启动的时候会启动multi-user.target，所以gcs也能在开机的时候自动启动。 Add command_checker and setup_logger to script/deploy_helper.py pr的链接：gcs-pull-17 本次pr修改了script/deploy_helper.py，增加了日志功能。在执行deploy_helper.py时，如果命令执行失败， 会输出执行失败的命令的日志信息，包括时间，日志等级，行号，执行失败的命令。 import logging import inspect 首先，实现这个pr的功能，需要导入logging和inspect模块。logging模块是Python内置的日志模块， inspect模块是Python内置模块，在这里用于获取命令的行号。 def setup_logger(log_level=logging.INFO): """ Configure the global logging system. :param log_level: Set the logging level, defaulting to INFO. """ logging.basicConfig(level=log_level, format='%(asctime)s -%(levelname)s- in %(pathname)s:%(caller_lineno)d: %(message)s', datefmt='%Y-%m-%d %H:%M:%S') setup_logger函数用于配置全局的日志系统。log_level参数用于设置日志级别，默认为INFO。logging.basicConfig 定义输出日志的格式，包括时间，日志等级，行号，执行失败的命令。 def command_checker(status_code: int, message: str, expected_code: int=0): """ Check if the command execution status code meets the expected value. :param status_code: The actual status code of the command execution. :param message: The log message to be recorded. :param expected_code: The expected status code, defaulting to 0. """ if status_code != expected_code: caller_frame=inspect.currentframe().f_back logging.error(message, extra={'caller_lineno': caller_frame.f_lineno}) exit(status_code) command_checker用于比较命令执行返回的状态码与期望的状态码是否一致，如果不一致，则说明命令执行失败， 则打印出相应的日志，且返回状态码，如果一致则说明命令执行成功，不做任何操作。 status_code: 命令执行的实际状态码 message: 要打印的日志信息 expected_code: 期望的状态码，默认为0 message_tmp='''\ The command below failed: {0} Expected status code 0, got status code {1} ''' message_tmp是一个模板字符串，用于格式化输出日志信息，在这里会将执行失败的命令和状态码输出到日志中。 Remove unsed dependency and add doc for configuration pr的链接：gcs-pull-22 本次pr主要是将spring-boot-starter-webflux依赖删除，因为这个依赖是多余的。同时添加了一个README-zh.md 文件，用于存储配置文件的说明。 Refactor the database script pr的链接：gcs-pull-23 在本次提交中，对数据库脚本进行了重构，将一个sql脚本分割成多个功能不同的sql脚本并放入不同的目录当中， 降低了数据库代码的耦合度，方便后续更新。并且还提供了一个数据库部署脚本database_deploy.sh，运行这个 脚本就能够自动调用前面的SQL脚本，从而部署数据库。 目前database的目录结果如下所示： 在constraint/all_column_constraint.sql文件中，定义了表的主键和唯一键约束；update_gmt_updated_column 文件包含一个函数，用于在更新时自动将gmt_updated列设置为当前的时间戳；sequence/all_column_seq.sql 文件和sequence/sequence_set.sql为表的主键列定义了序列以及设定列的当前值；在table目录下面的三个文 件定义了三个表，并且为每列添加了注释；trigger/all_table_trigger.sql文件为表添加了触发器，自动在更新 行的时候更新gmt_updated列。 Finish the script for deploying in docker pr的链接：gcs-pull-24 在本次的提交中，增加了自动在 docker 中部署的功能。在编写这部分功能的时候，发现 docker 在默认情况下 是不能够使用 systemd 的，只有当指明 --privileged=true 的时候才能够使用 systemd。这个参数的作用 是让 docker 在容器中运行的时候拥有直接操作宿主机的权限。如果通过样的方式创建 docker 失去了 docker 的部分安全性，因此我将在 docker 中的部署改用成了 Sys Init V 的方式，而在物理机上的部署继续保持 systemd 的方式。 Sys Init V 的脚本模板来自于 _service.md 。我对其中进行了 部分的修改，得到了如下的文件： PIDDIR=$(dirname "$PIDFILE") LOGDIR=$(dirname "$LOGFILE") start() { if [ -f "$PIDDIR/$PIDNAME" ] &amp;&amp; kill -0 "$(cat "$PIDDIR/$PIDNAME")"; then echo 'Service already running' &gt;&amp;2 return 1 fi echo 'Starting service…' &gt;&amp;2 local CMD="$SCRIPT &amp;&gt; \"$LOGFILE\" &amp; echo \$!" su -c "mkdir -p ""$PIDDIR" "$RUNAS" su -c "mkdir -p ""$LOGDIR" "$RUNAS" su -c "$CMD" "$RUNAS" &gt; "$PIDFILE" echo 'Service started' &gt;&amp;2 } stop() { if [ ! -f "$PIDFILE" ] || ! kill -0 "$(cat "$PIDFILE")"; then echo 'Service not running' &gt;&amp;2 return 1 fi echo 'Stopping service…' &gt;&amp;2 kill -15 "$(cat "$PIDFILE")" &amp;&amp; rm -f "$PIDFILE" echo 'Service stopped' &gt;&amp;2 } uninstall() { echo -n "Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] " local SURE read SURE if [ "$SURE" = "yes" ]; then stop rm -f "$PIDFILE" echo "Notice: log file is not be removed: '$LOGFILE'" &gt;&amp;2 update-rc.d -f "$NAME" remove rm -fv "$0" fi } case "$1" in start) start ;; stop) stop ;; uninstall) uninstall ;; restart) stop start ;; *) echo "Usage: $0 {start|stop|restart|uninstall}" esac 上面的脚本需要在最开始添加以下内容才能运行 (等号后面需要添加值)： #!/bin/env bash NAME=SCRIPT= RUNAS=PIDFILE= LOGFILE=我通过 Python 脚本读取 json 配置文件，然后将配置文件的内容写入到 Sys Init V 的脚本中，最后将 后将这个脚本拷贝到指定目录： def create_sys_v_init_service(config): try: with open('script/service_tmp.sh', 'r') as f: service_content=f.read() except Exception as e: command_checker(1, f"Error: {e}") return header=f'''#!/bin/env bash NAME={config.serviceName} SCRIPT="{parse_iterable_into_str([config.serviceStartJavaCommand] + config.serviceStartJavaArgs + [config.serviceStartJarFile])}" RUNAS={config.serviceUser} PIDFILE={config.servicePIDFile} LOGFILE={config.serviceLogFile} ''' service_content=header + service_content log_debug(f"service_content:\n {service_content}") res=os.system( f"echo '{service_content}' | {sudo_cmd} tee {config.serviceSysVInitDirectory}/{config.serviceName}") command_checker(res, f"Failed to create {config.serviceSysVInitDirectory}/{config.serviceName}") res=os.system(f'{sudo_cmd} chmod +x {config.serviceSysVInitDirectory}/{config.serviceName}') command_checker( res, f"Failed to chmod +x {config.serviceSysVInitDirectory}/{config.serviceName}") if logging.getLogger().level == logging.DEBUG: try: with open(f'{config.serviceSysVInitDirectory}/{config.serviceName}', 'r') as f: log_debug(f"Service content:\n {f.read()}") except Exception as e: command_checker(1, f"Error: {e}") return 除了这些更改以外，将依赖的安装交给了 Python 脚本管理，bash 脚本仅仅负责安装 python 依赖。 Finish the deploy script for database pr 链接：gcs-pull-25 本次的 pr 主要完成了数据库部署部分，根据之前提供的 SQL 脚本，我们在部署脚本中调用了 SQL 脚本去 部署数据库。 在部署数据库部分，先在数据库中检查是否存在指定的用户，不存在就进行创建，并根据配置文件的密码修改数据 库中用户的密码。之后检查是否存在数据库，不存在就创建数据库。然后给当前用户赋予指定数据库的所有权限。 最后就是通过该用户去调用 SQL 脚本创建表。 除了数据库部分的部署外，还增加了激活不同配置文件的功能。在 deploy_helper.py 中增加了一个函数： def active_profile(config): profile_format=f"spring.profiles.active={parse_iterable_into_str(config.profiles, sep=',')}" log_debug(f"Profile format: {profile_format}") try: lines=None if os.path.exists(application_config_file_path): with open(application_config_file_path, 'r') as f: lines=f.readlines() with open(application_config_file_path, 'w') as f: if lines: for line in lines: if not line.startswith('spring.profiles.active'): f.write(line) f.write(profile_format) except Exception as e: command_checker(1, f"Error: {e}") 除此之外，我们将 Spring Boot 的相关配置使用 yml 格式进行配置，而脚本创建的配置则放置在了 properties 文件中。这样能保证后续增加的配置一定能生效，因为 properties 文件的优先级高于 yml 文件。]]></summary></entry><entry><title type="html">Spring 简介</title><link href="https://kaiser-yang.github.io/blog/2024/spring-intro/" rel="alternate" type="text/html" title="Spring 简介"/><published>2024-08-12T03:59:00+00:00</published><updated>2024-08-12T03:59:00+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-intro/"><![CDATA[<p>对于最原始的 <code class="language-plaintext highlighter-rouge">Spring</code> 而言，<code class="language-plaintext highlighter-rouge">Spring</code> 往往指的是能够对对象进行管理的框架，<code class="language-plaintext highlighter-rouge">IoC</code> 和 <code class="language-plaintext highlighter-rouge">AOP</code> 是其两大核心思想。 而在最初的 <code class="language-plaintext highlighter-rouge">Spring</code> 中，多数是使用 <code class="language-plaintext highlighter-rouge">xml</code> 文件进行配置，不过在目前看来使用 <code class="language-plaintext highlighter-rouge">xml</code> 进行配置的方式已经不再流行， 而是使用 <code class="language-plaintext highlighter-rouge">Java</code> 配置的方式 (即通过 <code class="language-plaintext highlighter-rouge">Java</code> 注解的方式进行配置)，这样也更好的与 <code class="language-plaintext highlighter-rouge">Spring-Boot</code> 相互配合。 因此本文只是介绍一些常用的 <code class="language-plaintext highlighter-rouge">Spring</code> 注解，以及 <code class="language-plaintext highlighter-rouge">Spring</code> 的一些基本概念。</p> <h1 id="什么是-bean">什么是 <code class="language-plaintext highlighter-rouge">Bean</code></h1> <p><code class="language-plaintext highlighter-rouge">Bean</code> 可以理解为 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中的对象，<code class="language-plaintext highlighter-rouge">Spring</code> 容器负责创建 <code class="language-plaintext highlighter-rouge">Bean</code>，并将 <code class="language-plaintext highlighter-rouge">Bean</code> 管理起来。</p> <p>再简单一点，一个 <code class="language-plaintext highlighter-rouge">Bean</code> 就是一个 <code class="language-plaintext highlighter-rouge">Java</code> 中的对象。</p> <h2 id="bean-与-ioc"><code class="language-plaintext highlighter-rouge">Bean</code> 与 <code class="language-plaintext highlighter-rouge">IoC</code></h2> <p>在不使用 <code class="language-plaintext highlighter-rouge">Spring</code> 进行开发的环境中，如果需要创建一个对象，通常是通过 <code class="language-plaintext highlighter-rouge">new</code> 关键字来创建对象。这样的话， 对象的创建和对象的销毁都是由程序员来控制的。</p> <p>而 <code class="language-plaintext highlighter-rouge">IoC</code> 则指的是控制反转，即对象的创建和对象的销毁不再由程序员来控制。最简单的 <code class="language-plaintext highlighter-rouge">IoC</code> 的例子是使用 <code class="language-plaintext highlighter-rouge">setter</code> 进行依赖注入。</p> <p>NOTE: 在 <code class="language-plaintext highlighter-rouge">Spring</code> 中将一个类的成员成为其依赖，所谓的依赖注入指的就是为每个成员变量设置对应的值。</p> <p>通过使用 <code class="language-plaintext highlighter-rouge">setter</code> 的方式进行依赖注入的好处是可以根据用户的配置文件中的不同配置决定注入的具体对象，而如果是 使用 <code class="language-plaintext highlighter-rouge">new</code> 进行对象的创建，那么对象的创建就是固定的了。</p> <p>而 <code class="language-plaintext highlighter-rouge">Spring</code> 所做的一切通过读取这个配置文件来决定创建哪个对象，以及创建对象的时候需要注入哪些对象，这样就 实现了对象的创建和对象的销毁不再由程序员来控制，也就完成了 <code class="language-plaintext highlighter-rouge">IoC</code>。</p> <h2 id="使用注解添加-bean">使用注解添加 <code class="language-plaintext highlighter-rouge">Bean</code></h2> <h3 id="configuration"><code class="language-plaintext highlighter-rouge">@Configuration</code></h3> <p><code class="language-plaintext highlighter-rouge">@Configuration</code> 注解用于指定当前类是一个配置类，相当于一个 <code class="language-plaintext highlighter-rouge">Spring</code> 配置的 <code class="language-plaintext highlighter-rouge">xml</code> 文件。在配置类中可以 使用 <code class="language-plaintext highlighter-rouge">@Bean</code> 注解向 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中注册 <code class="language-plaintext highlighter-rouge">Bean</code>。</p> <h3 id="bean"><code class="language-plaintext highlighter-rouge">@Bean</code></h3> <p><code class="language-plaintext highlighter-rouge">@Bean</code> 注解用于指定一个方法是一个 <code class="language-plaintext highlighter-rouge">Bean</code> 的生产者，返回值是一个 <code class="language-plaintext highlighter-rouge">Bean</code>。<code class="language-plaintext highlighter-rouge">@Bean</code> 注解可以指定 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称，如果不指定 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称，那么 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称默认为方法名。</p> <h3 id="component"><code class="language-plaintext highlighter-rouge">@Component</code></h3> <p><code class="language-plaintext highlighter-rouge">@Component</code> 注解用于指定当前类是一个 <code class="language-plaintext highlighter-rouge">Bean</code>，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动扫描该类，并将该类注册到 <code class="language-plaintext highlighter-rouge">Spring</code> 容器中。 <code class="language-plaintext highlighter-rouge">@Component</code> 注解可以指定 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称，如果不指定 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称，那么 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称默认为类名，首字母 小写。</p> <h3 id="controller"><code class="language-plaintext highlighter-rouge">@Controller</code></h3> <p>该注解与 <code class="language-plaintext highlighter-rouge">@Component</code> 类似，只是表明一个控制器(<code class="language-plaintext highlighter-rouge">controller</code>)的时候，一般使用该注解。</p> <h3 id="service"><code class="language-plaintext highlighter-rouge">@Service</code></h3> <p>该注解与 <code class="language-plaintext highlighter-rouge">@Component</code> 类似，只是表明一个服务(<code class="language-plaintext highlighter-rouge">service</code>)的时候，一般使用该注解。</p> <h3 id="repository"><code class="language-plaintext highlighter-rouge">@Repository</code></h3> <p>该注解与 <code class="language-plaintext highlighter-rouge">@Component</code> 类似，只是表明一个仓库(<code class="language-plaintext highlighter-rouge">dao</code>)的时候，一般使用该注解。</p> <h3 id="componentscan"><code class="language-plaintext highlighter-rouge">@ComponentScan</code></h3> <p>该注解用于指定哪些位置的类会被 <code class="language-plaintext highlighter-rouge">Spring</code> 扫描，例如 <code class="language-plaintext highlighter-rouge">@ComponentScan("com.example")</code> 表示扫描 <code class="language-plaintext highlighter-rouge">com.example</code> 通常情况下，我们并不需要使用该注解，因为 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动扫描 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 注解所在类的 包及其子包。实际上是因为 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 包含了 <code class="language-plaintext highlighter-rouge">@ComponentScan</code> 注解。而只有需要托管不在 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 所在包及其子包的类时才需要使用 <code class="language-plaintext highlighter-rouge">@ComponentScan</code>。</p> <h3 id="import"><code class="language-plaintext highlighter-rouge">@Import</code></h3> <p><code class="language-plaintext highlighter-rouge">@Import</code> 注解用于导入其他配置类，例如：<code class="language-plaintext highlighter-rouge">@Import(XXXConfig.class)</code> 表示导入 <code class="language-plaintext highlighter-rouge">XXXConfig</code> 配置类。但是， 在 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 中，我们很少使用到这个注解，因为 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 会自动扫描 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 所在类的包及其子包，因此我们只需要将配置类放置在 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 所在包及其子包即可。</p> <h2 id="bean-作用域介绍"><code class="language-plaintext highlighter-rouge">Bean</code> 作用域介绍</h2> <p><code class="language-plaintext highlighter-rouge">Spring</code> 的 <code class="language-plaintext highlighter-rouge">Bean</code> 作用域有以下几种:</p> <table> <thead> <tr> <th>作用域</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">singleton</code></td> <td><code class="language-plaintext highlighter-rouge">Spring</code> 的默认值，一个 <code class="language-plaintext highlighter-rouge">IoC</code> 容器只有一个 <code class="language-plaintext highlighter-rouge">Bean</code> 的实例，为所有对象提供共享的 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">prototype</code></td> <td>每次请求都会创建一个新的 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">request</code></td> <td>每次 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求中只会创建一个新的 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">session</code></td> <td>每次 <code class="language-plaintext highlighter-rouge">HTTP</code> 会话中只会创建一个新的 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">application</code></td> <td>每个 <code class="language-plaintext highlighter-rouge">ServletContext</code> 中只会创建一个 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">websockt</code></td> <td>每个 <code class="language-plaintext highlighter-rouge">WebSocket</code> 中只会创建一个 <code class="language-plaintext highlighter-rouge">Bean</code> 实例</td> </tr> </tbody> </table> <p>这几个作用域对应的注解如下:</p> <ul> <li><code class="language-plaintext highlighter-rouge">@Scope("singleton")</code></li> <li><code class="language-plaintext highlighter-rouge">@Scope("prototype")</code></li> <li><code class="language-plaintext highlighter-rouge">@RequestScope</code></li> <li><code class="language-plaintext highlighter-rouge">@SessionScope</code></li> <li><code class="language-plaintext highlighter-rouge">@ApplicationScope</code></li> <li><code class="language-plaintext highlighter-rouge">@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)</code></li> </ul> <p>TODO：增加解释说明为什么 <code class="language-plaintext highlighter-rouge">mvc</code> 应用的注解不同。</p> <h1 id="自动装配">自动装配</h1> <p>自动装配指的是根据 <code class="language-plaintext highlighter-rouge">IoC</code> 容器中已经有的 <code class="language-plaintext highlighter-rouge">Bean</code> 进行为某些依赖自动注入的过程。<code class="language-plaintext highlighter-rouge">Spring</code> 提供了以下几种 自动装配的方式:</p> <table> <thead> <tr> <th>模式</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">no</code></td> <td>默认值，不进行自动装配，需要手动指定依赖</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">byName</code></td> <td>根据 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称进行自动装配，需要包含指定名字的 <code class="language-plaintext highlighter-rouge">setter</code>，且 <code class="language-plaintext highlighter-rouge">Bean</code> 唯一匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">byType</code></td> <td>根据 <code class="language-plaintext highlighter-rouge">Bean</code> 的类型进行自动装配，需要 <code class="language-plaintext highlighter-rouge">Bean</code> 唯一匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">constructor</code></td> <td>根据构造函数进行自动装配，需要构造函数对应的所有参数类型在容器中均有唯一的 <code class="language-plaintext highlighter-rouge">Bean</code></td> </tr> </tbody> </table> <h2 id="自动装配-1">自动装配</h2> <h3 id="autowired"><code class="language-plaintext highlighter-rouge">@Autowired</code></h3> <p><code class="language-plaintext highlighter-rouge">@Autowired</code> 注解可以用于字段、构造函数、方法上，用于自动装配 <code class="language-plaintext highlighter-rouge">Bean</code>。<code class="language-plaintext highlighter-rouge">@Autowired</code> 注解可以用于字段、 构造函数、方法上，用于自动装配 <code class="language-plaintext highlighter-rouge">Bean</code>。</p> <p>如果直接使用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 注解，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会根据 <code class="language-plaintext highlighter-rouge">byType</code> 的方式进行自动装配，如果有多个 <code class="language-plaintext highlighter-rouge">Bean</code> 类型相同，那么会抛出异常。当然，如果没有一个 <code class="language-plaintext highlighter-rouge">Bean</code> 类型相同，那么也会抛出异常。</p> <p>值得注意的一点是：如果 <code class="language-plaintext highlighter-rouge">@Autowired</code> 用于数组或者集合类型的字段，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会将所有匹配的 <code class="language-plaintext highlighter-rouge">Bean</code> 进行注入。如果放置在 <code class="language-plaintext highlighter-rouge">Map</code> 类型的字段上，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会将所有匹配的 <code class="language-plaintext highlighter-rouge">Bean</code> 进行注入，<code class="language-plaintext highlighter-rouge">Bean</code> 的名字 作为 <code class="language-plaintext highlighter-rouge">key</code>，<code class="language-plaintext highlighter-rouge">Bean</code> 作为 <code class="language-plaintext highlighter-rouge">value</code>。</p> <p>如果想要在没有找到同类型的 <code class="language-plaintext highlighter-rouge">Bean</code> 的时候不抛出异常，可以使用 <code class="language-plaintext highlighter-rouge">@Autowired(required = false)</code>。这样的话， 如果没有找到同类型的 <code class="language-plaintext highlighter-rouge">Bean</code>，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 不会进行任何操作，这意味着如果注解在方法上，那么这个方法 不会被调用，如果注解在字段上，那么这个字段的值为默认值。</p> <h3 id="primary"><code class="language-plaintext highlighter-rouge">@Primary</code></h3> <p>如果想要在有多个类型相同的 <code class="language-plaintext highlighter-rouge">Bean</code> 的时候不抛出异常，可以使用 <code class="language-plaintext highlighter-rouge">@Primary</code> 注解，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 会优先 选择被 <code class="language-plaintext highlighter-rouge">@Primary</code> 注解的 <code class="language-plaintext highlighter-rouge">Bean</code> 进行注入 (注意这个注解是放在被依赖的类上)。</p> <h3 id="qualifier"><code class="language-plaintext highlighter-rouge">@Qualifier</code></h3> <p>如果想要获得更加精确的控制，可以使用 <code class="language-plaintext highlighter-rouge">@Qualifier</code> 注解，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 会根据 <code class="language-plaintext highlighter-rouge">@Qualifier</code> 注解的 值进行注入，例如：如果 <code class="language-plaintext highlighter-rouge">@Qualifier("userDao")</code> 和 <code class="language-plaintext highlighter-rouge">@Autowired</code> 同时使用，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会注入名字为 <code class="language-plaintext highlighter-rouge">userDao</code> 的 <code class="language-plaintext highlighter-rouge">Bean</code>。不过在这样使用的时候需要注意的是：<code class="language-plaintext highlighter-rouge">@Autowired</code> 依然只会在类型匹配的时候进行注入。</p> <p><code class="language-plaintext highlighter-rouge">@Qualifier</code> 使用的时候也可不指定值，这样的话，作用就与 <code class="language-plaintext highlighter-rouge">@Primary</code> 一样，不过 <code class="language-plaintext highlighter-rouge">@Qualifier</code> 的优先级更高。</p> <h3 id="resource"><code class="language-plaintext highlighter-rouge">@Resource</code></h3> <p>如果想要完全通过 <code class="language-plaintext highlighter-rouge">Bean</code> 的名字进行注入，可以使用 <code class="language-plaintext highlighter-rouge">JavaEE</code> 的 <code class="language-plaintext highlighter-rouge">@Resource</code> 注解，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 会 根据 <code class="language-plaintext highlighter-rouge">@Resource</code> 注解的值进行注入，不过这个注解只能用于字段和 <code class="language-plaintext highlighter-rouge">setter</code> 方法上。当没有显式指定名称时， 如果该注解放置在字段上，那么字段的名称将作为 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称，如果该注解放置在 <code class="language-plaintext highlighter-rouge">setter</code> 方法上，那么 <code class="language-plaintext highlighter-rouge">setter</code> 方法的名称 (去掉 <code class="language-plaintext highlighter-rouge">set</code> 后首字母小写) 将作为 <code class="language-plaintext highlighter-rouge">Bean</code> 的名称。</p> <h3 id="value"><code class="language-plaintext highlighter-rouge">@Value</code></h3> <p><code class="language-plaintext highlighter-rouge">@Value</code> 注解可以用于字段、构造函数、方法上，用于注入 <code class="language-plaintext highlighter-rouge">Bean</code> 的值。<code class="language-plaintext highlighter-rouge">@Value</code> 注解有两种使用形式：</p> <ul> <li><code class="language-plaintext highlighter-rouge">@Value("#{}")</code></li> <li><code class="language-plaintext highlighter-rouge">@Value("${}")</code></li> </ul> <p><code class="language-plaintext highlighter-rouge">@Value("#{}")</code> 用于注入 <code class="language-plaintext highlighter-rouge">Bean</code> 的值，<code class="language-plaintext highlighter-rouge">#</code> 用于引用 <code class="language-plaintext highlighter-rouge">Spring</code> 的 <code class="language-plaintext highlighter-rouge">Bean</code>，<code class="language-plaintext highlighter-rouge">{}</code> 用于引用 <code class="language-plaintext highlighter-rouge">Bean</code> 的属性。 例如：<code class="language-plaintext highlighter-rouge">@Value("#userDao.name")</code> 会注入 <code class="language-plaintext highlighter-rouge">userDao</code> 的 <code class="language-plaintext highlighter-rouge">name</code> 属性，这里的 <code class="language-plaintext highlighter-rouge">userDao</code> 是一个 <code class="language-plaintext highlighter-rouge">Bean</code>。而 <code class="language-plaintext highlighter-rouge">@Value("#userDao.getName()")</code> 会注入 <code class="language-plaintext highlighter-rouge">userDao</code> 的 <code class="language-plaintext highlighter-rouge">getName()</code> 方法的返回值。这部分的更多内容可以查看 <code class="language-plaintext highlighter-rouge">SpEL</code>。</p> <p><code class="language-plaintext highlighter-rouge">@Value("${}")</code> 用于引用配置文件中的属性，例如在 <code class="language-plaintext highlighter-rouge">application.properties</code> 文件中有 <code class="language-plaintext highlighter-rouge">name=Tom</code>，那么 <code class="language-plaintext highlighter-rouge">@Value("${name}")</code> 就会注入 <code class="language-plaintext highlighter-rouge">Tom</code>。也可以用 <code class="language-plaintext highlighter-rouge">@Value("${name:default}")</code> 为找不到 <code class="language-plaintext highlighter-rouge">name</code> 时指定默认值。</p> <p>使用 <code class="language-plaintext highlighter-rouge">@Value</code> 的时候需要写好配置文件，下面简单介绍一下如何读取配置文件。对于一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的项目， 在完成初始化后，在 <code class="language-plaintext highlighter-rouge">src/main/resources</code> 目录下会存在一个 <code class="language-plaintext highlighter-rouge">application.properties</code> 文件，这个文件就是 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的配置文件，可以在这个文件中写入一些配置信息，然后通过 <code class="language-plaintext highlighter-rouge">@Value</code> 注解进行读取。如果没有 这个文件自行创建就可以了，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动加载以下路径下的 <code class="language-plaintext highlighter-rouge">application.properties</code> 或者 <code class="language-plaintext highlighter-rouge">application.yml</code>：</p> <ol> <li><code class="language-plaintext highlighter-rouge">file:./config</code></li> <li><code class="language-plaintext highlighter-rouge">file:./</code></li> <li><code class="language-plaintext highlighter-rouge">classpath:/config/</code></li> <li><code class="language-plaintext highlighter-rouge">classpath:/</code></li> </ol> <p>上述路径中，<code class="language-plaintext highlighter-rouge">file:./config</code> 表示当前项目根目录下的 <code class="language-plaintext highlighter-rouge">config</code> 目录，<code class="language-plaintext highlighter-rouge">file:./</code> 表示当前项目根目录， <code class="language-plaintext highlighter-rouge">classpath:/config/</code> 表示 <code class="language-plaintext highlighter-rouge">resources</code> 目录下的 <code class="language-plaintext highlighter-rouge">config</code> 目录，<code class="language-plaintext highlighter-rouge">classpath:/</code> 表示 <code class="language-plaintext highlighter-rouge">resources</code> 目录。 优先级从高到低，也就是说 <code class="language-plaintext highlighter-rouge">file:./config</code> 的优先级最高，<code class="language-plaintext highlighter-rouge">classpath:/</code> 的优先级最低。</p> <p>当两个文件同时存在的时候，<code class="language-plaintext highlighter-rouge">application.properties</code> 会被优先加载。</p> <p>通常情况下，不会将所有的配置都放置在 <code class="language-plaintext highlighter-rouge">application.properties</code> 文件中，而是将不同的配置放置在不同的配置文件中。 下面来介绍如何加载一个这样的配置文件。一般在 <code class="language-plaintext highlighter-rouge">src/main/resources/config</code> 中放入配置文件，例如 <code class="language-plaintext highlighter-rouge">XXXConfig.properties</code>，然后在启动类同级目录会创建一个 <code class="language-plaintext highlighter-rouge">config/XXXConfig.java</code> 的类去读取配置文件：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@PropertySource</span><span class="o">(</span><span class="s">"classpath:config/XXXConfig.properties"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">XXXConfig</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过上述的操作后，可以在任何地方使用 <code class="language-plaintext highlighter-rouge">@Value</code> 读取到配置文件中的值，新版的 <code class="language-plaintext highlighter-rouge">Spring</code> (我测试了 <code class="language-plaintext highlighter-rouge">Spring 6</code>) 现在支持自动解析 <code class="language-plaintext highlighter-rouge">yml</code> 文件，不再需要指定 <code class="language-plaintext highlighter-rouge">@PropertySource</code> 中的 <code class="language-plaintext highlighter-rouge">factory</code>。</p> <h1 id="其他注解">其他注解</h1> <h2 id="description"><code class="language-plaintext highlighter-rouge">@Description</code></h2> <p>该注解可以为 <code class="language-plaintext highlighter-rouge">Bean</code> 添加描述信息，这样的话可以通过 <code class="language-plaintext highlighter-rouge">Spring</code> 的 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 获取到这个描述信息。</p> <h2 id="profile"><code class="language-plaintext highlighter-rouge">@Profile</code></h2> <p>该注解用于指定 <code class="language-plaintext highlighter-rouge">Bean</code> 的环境，例如：<code class="language-plaintext highlighter-rouge">@Profile("dev")</code> 表示这个 <code class="language-plaintext highlighter-rouge">Bean</code> 只在 <code class="language-plaintext highlighter-rouge">dev</code> 环境下生效。</p> <h2 id="nullable"><code class="language-plaintext highlighter-rouge">@Nullable</code></h2> <p>该注解用于标记一个字段可以为 <code class="language-plaintext highlighter-rouge">null</code>，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 在注入的时候如果没有找到对应的 <code class="language-plaintext highlighter-rouge">Bean</code>，那么 不会抛出异常。</p> <h2 id="nonnull"><code class="language-plaintext highlighter-rouge">@NonNull</code></h2> <p>该注解用于标记一个字段不可以为 <code class="language-plaintext highlighter-rouge">null</code>，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 在注入的时候如果没有找到对应的 <code class="language-plaintext highlighter-rouge">Bean</code>，那么 会抛出异常。</p> <h2 id="nonnullapi"><code class="language-plaintext highlighter-rouge">@NonNullApi</code></h2> <p>该注解用于标记一个包下的所有类的字段不可以为 <code class="language-plaintext highlighter-rouge">null</code>，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 在注入的时候如果没有找到对应的 <code class="language-plaintext highlighter-rouge">Bean</code>，那么会抛出异常。该注解一般写在 <code class="language-plaintext highlighter-rouge">package</code> 语句上方。</p> <h2 id="nonnullfields"><code class="language-plaintext highlighter-rouge">@NonNullFields</code></h2> <p>该注解用于标记一个类的所有字段不可以为 <code class="language-plaintext highlighter-rouge">null</code>，这样的话 <code class="language-plaintext highlighter-rouge">Spring</code> 在注入的时候如果没有找到对应的 <code class="language-plaintext highlighter-rouge">Bean</code>， 那么会抛出异常。该注解一般写在 <code class="language-plaintext highlighter-rouge">package</code> 语句上方。</p> ]]></content><author><name></name></author><category term="Java"/><summary type="html"><![CDATA[对于最原始的 Spring 而言，Spring 往往指的是能够对对象进行管理的框架，IoC 和 AOP 是其两大核心思想。 而在最初的 Spring 中，多数是使用 xml 文件进行配置，不过在目前看来使用 xml 进行配置的方式已经不再流行， 而是使用 Java 配置的方式 (即通过 Java 注解的方式进行配置)，这样也更好的与 Spring-Boot 相互配合。 因此本文只是介绍一些常用的 Spring 注解，以及 Spring 的一些基本概念。 什么是 Bean Bean 可以理解为 Spring 容器中的对象，Spring 容器负责创建 Bean，并将 Bean 管理起来。 再简单一点，一个 Bean 就是一个 Java 中的对象。 Bean 与 IoC 在不使用 Spring 进行开发的环境中，如果需要创建一个对象，通常是通过 new 关键字来创建对象。这样的话， 对象的创建和对象的销毁都是由程序员来控制的。 而 IoC 则指的是控制反转，即对象的创建和对象的销毁不再由程序员来控制。最简单的 IoC 的例子是使用 setter 进行依赖注入。 NOTE: 在 Spring 中将一个类的成员成为其依赖，所谓的依赖注入指的就是为每个成员变量设置对应的值。 通过使用 setter 的方式进行依赖注入的好处是可以根据用户的配置文件中的不同配置决定注入的具体对象，而如果是 使用 new 进行对象的创建，那么对象的创建就是固定的了。 而 Spring 所做的一切通过读取这个配置文件来决定创建哪个对象，以及创建对象的时候需要注入哪些对象，这样就 实现了对象的创建和对象的销毁不再由程序员来控制，也就完成了 IoC。 使用注解添加 Bean @Configuration @Configuration 注解用于指定当前类是一个配置类，相当于一个 Spring 配置的 xml 文件。在配置类中可以 使用 @Bean 注解向 Spring 容器中注册 Bean。 @Bean @Bean 注解用于指定一个方法是一个 Bean 的生产者，返回值是一个 Bean。@Bean 注解可以指定 Bean 的名称，如果不指定 Bean 的名称，那么 Bean 的名称默认为方法名。 @Component @Component 注解用于指定当前类是一个 Bean，Spring 会自动扫描该类，并将该类注册到 Spring 容器中。 @Component 注解可以指定 Bean 的名称，如果不指定 Bean 的名称，那么 Bean 的名称默认为类名，首字母 小写。 @Controller 该注解与 @Component 类似，只是表明一个控制器(controller)的时候，一般使用该注解。 @Service 该注解与 @Component 类似，只是表明一个服务(service)的时候，一般使用该注解。 @Repository 该注解与 @Component 类似，只是表明一个仓库(dao)的时候，一般使用该注解。 @ComponentScan 该注解用于指定哪些位置的类会被 Spring 扫描，例如 @ComponentScan("com.example") 表示扫描 com.example 通常情况下，我们并不需要使用该注解，因为 Spring Boot 会自动扫描 @SpringBootApplication 注解所在类的 包及其子包。实际上是因为 @SpringBootApplication 包含了 @ComponentScan 注解。而只有需要托管不在 @SpringBootApplication 所在包及其子包的类时才需要使用 @ComponentScan。 @Import @Import 注解用于导入其他配置类，例如：@Import(XXXConfig.class) 表示导入 XXXConfig 配置类。但是， 在 Spring Boot 中，我们很少使用到这个注解，因为 Spring Boot 会自动扫描 @SpringBootApplication 所在类的包及其子包，因此我们只需要将配置类放置在 @SpringBootApplication 所在包及其子包即可。 Bean 作用域介绍 Spring 的 Bean 作用域有以下几种: 作用域 描述 singleton Spring 的默认值，一个 IoC 容器只有一个 Bean 的实例，为所有对象提供共享的 Bean 实例 prototype 每次请求都会创建一个新的 Bean 实例 request 每次 HTTP 请求中只会创建一个新的 Bean 实例 session 每次 HTTP 会话中只会创建一个新的 Bean 实例 application 每个 ServletContext 中只会创建一个 Bean 实例 websockt 每个 WebSocket 中只会创建一个 Bean 实例 这几个作用域对应的注解如下: @Scope("singleton") @Scope("prototype") @RequestScope @SessionScope @ApplicationScope @Scope(scopeName = "websocket", proxyMode=ScopedProxyMode.TARGET_CLASS) TODO：增加解释说明为什么 mvc 应用的注解不同。 自动装配 自动装配指的是根据 IoC 容器中已经有的 Bean 进行为某些依赖自动注入的过程。Spring 提供了以下几种 自动装配的方式: 模式 描述 no 默认值，不进行自动装配，需要手动指定依赖 byName 根据 Bean 的名称进行自动装配，需要包含指定名字的 setter，且 Bean 唯一匹配 byType 根据 Bean 的类型进行自动装配，需要 Bean 唯一匹配 constructor 根据构造函数进行自动装配，需要构造函数对应的所有参数类型在容器中均有唯一的 Bean 自动装配 @Autowired @Autowired 注解可以用于字段、构造函数、方法上，用于自动装配 Bean。@Autowired 注解可以用于字段、 构造函数、方法上，用于自动装配 Bean。 如果直接使用 @Autowired 注解，那么 Spring 会根据 byType 的方式进行自动装配，如果有多个 Bean 类型相同，那么会抛出异常。当然，如果没有一个 Bean 类型相同，那么也会抛出异常。 值得注意的一点是：如果 @Autowired 用于数组或者集合类型的字段，那么 Spring 会将所有匹配的 Bean 进行注入。如果放置在 Map 类型的字段上，那么 Spring 会将所有匹配的 Bean 进行注入，Bean 的名字 作为 key，Bean 作为 value。 如果想要在没有找到同类型的 Bean 的时候不抛出异常，可以使用 @Autowired(required = false)。这样的话， 如果没有找到同类型的 Bean，那么 Spring 不会进行任何操作，这意味着如果注解在方法上，那么这个方法 不会被调用，如果注解在字段上，那么这个字段的值为默认值。 @Primary 如果想要在有多个类型相同的 Bean 的时候不抛出异常，可以使用 @Primary 注解，这样的话 Spring 会优先 选择被 @Primary 注解的 Bean 进行注入 (注意这个注解是放在被依赖的类上)。 @Qualifier 如果想要获得更加精确的控制，可以使用 @Qualifier 注解，这样的话 Spring 会根据 @Qualifier 注解的 值进行注入，例如：如果 @Qualifier("userDao") 和 @Autowired 同时使用，那么 Spring 会注入名字为 userDao 的 Bean。不过在这样使用的时候需要注意的是：@Autowired 依然只会在类型匹配的时候进行注入。 @Qualifier 使用的时候也可不指定值，这样的话，作用就与 @Primary 一样，不过 @Qualifier 的优先级更高。 @Resource 如果想要完全通过 Bean 的名字进行注入，可以使用 JavaEE 的 @Resource 注解，这样的话 Spring 会 根据 @Resource 注解的值进行注入，不过这个注解只能用于字段和 setter 方法上。当没有显式指定名称时， 如果该注解放置在字段上，那么字段的名称将作为 Bean 的名称，如果该注解放置在 setter 方法上，那么 setter 方法的名称 (去掉 set 后首字母小写) 将作为 Bean 的名称。 @Value @Value 注解可以用于字段、构造函数、方法上，用于注入 Bean 的值。@Value 注解有两种使用形式： @Value("#{}") @Value("${}") @Value("#{}") 用于注入 Bean 的值，# 用于引用 Spring 的 Bean，{} 用于引用 Bean 的属性。 例如：@Value("#userDao.name") 会注入 userDao 的 name 属性，这里的 userDao 是一个 Bean。而 @Value("#userDao.getName()") 会注入 userDao 的 getName() 方法的返回值。这部分的更多内容可以查看 SpEL。 @Value("${}") 用于引用配置文件中的属性，例如在 application.properties 文件中有 name=Tom，那么 @Value("${name}") 就会注入 Tom。也可以用 @Value("${name:default}") 为找不到 name 时指定默认值。 使用 @Value 的时候需要写好配置文件，下面简单介绍一下如何读取配置文件。对于一个 Spring Boot 的项目， 在完成初始化后，在 src/main/resources 目录下会存在一个 application.properties 文件，这个文件就是 Spring Boot 的配置文件，可以在这个文件中写入一些配置信息，然后通过 @Value 注解进行读取。如果没有 这个文件自行创建就可以了，Spring 会自动加载以下路径下的 application.properties 或者 application.yml： file:./config file:./ classpath:/config/ classpath:/ 上述路径中，file:./config 表示当前项目根目录下的 config 目录，file:./ 表示当前项目根目录， classpath:/config/ 表示 resources 目录下的 config 目录，classpath:/ 表示 resources 目录。 优先级从高到低，也就是说 file:./config 的优先级最高，classpath:/ 的优先级最低。 当两个文件同时存在的时候，application.properties 会被优先加载。 通常情况下，不会将所有的配置都放置在 application.properties 文件中，而是将不同的配置放置在不同的配置文件中。 下面来介绍如何加载一个这样的配置文件。一般在 src/main/resources/config 中放入配置文件，例如 XXXConfig.properties，然后在启动类同级目录会创建一个 config/XXXConfig.java 的类去读取配置文件： @Configuration @PropertySource("classpath:config/XXXConfig.properties") public class XXXConfig { } 通过上述的操作后，可以在任何地方使用 @Value 读取到配置文件中的值，新版的 Spring (我测试了 Spring 6) 现在支持自动解析 yml 文件，不再需要指定 @PropertySource 中的 factory。 其他注解 @Description 该注解可以为 Bean 添加描述信息，这样的话可以通过 Spring 的 BeanFactory 获取到这个描述信息。 @Profile 该注解用于指定 Bean 的环境，例如：@Profile("dev") 表示这个 Bean 只在 dev 环境下生效。 @Nullable 该注解用于标记一个字段可以为 null，这样的话 Spring 在注入的时候如果没有找到对应的 Bean，那么 不会抛出异常。 @NonNull 该注解用于标记一个字段不可以为 null，这样的话 Spring 在注入的时候如果没有找到对应的 Bean，那么 会抛出异常。 @NonNullApi 该注解用于标记一个包下的所有类的字段不可以为 null，这样的话 Spring 在注入的时候如果没有找到对应的 Bean，那么会抛出异常。该注解一般写在 package 语句上方。 @NonNullFields 该注解用于标记一个类的所有字段不可以为 null，这样的话 Spring 在注入的时候如果没有找到对应的 Bean， 那么会抛出异常。该注解一般写在 package 语句上方。]]></summary></entry></feed>