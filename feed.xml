<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2025-01-04T09:06:23+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>This homepage is for sharing everything I know. </subtitle><entry><title type="html">IEEE Xtreme 18.0 题解</title><link href="https://kaiser-yang.github.io/blog/2024/ieeextreme-18-solution/" rel="alternate" type="text/html" title="IEEE Xtreme 18.0 题解"/><published>2024-10-28T09:10:49+00:00</published><updated>2024-10-28T09:10:49+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/ieeextreme-18-solution</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/ieeextreme-18-solution/"><![CDATA[<p>注意：代码将会在后续开放提交后提供。</p> <h1 id="two-fridges"><a href="https://csacademy.com/ieeextreme-practice/task/two-fridges">Two Fridges</a></h1> <p>由于题目中的温度范围非常小，我们只需要从小到大枚举温度，对于每个枚举，检查是否所有区间都被覆盖。 第一个覆盖所有区间的温度对即是答案。如果找不到输出 \(-1\) 即可。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/two_fridges.cpp">two_fridges.cpp</a></p> <h1 id="star-road"><a href="https://csacademy.com/ieeextreme-practice/task/star-road">Star Road</a></h1> <p>对于本题我们可以使用线段树和线段树的合并来解决这个问题。</p> <p>具体的，我们首先需要将 \(star\) 离散化，使得其值在 \([1, len]\) 之间， 其中 \(len\) 是不同的星星的个数。 然后我们从任意一个结点开始进行 <code class="language-plaintext highlighter-rouge">DFS</code>，当我们到达一个结点时，我们为这个结点建立一个线段树。</p> <p>对于线段树的叶子结点 (其表示的区间设为 \([l, l]\) ) ，它会保存两个值：</p> <ul> <li>\(LIS\)：以 \(l\) 结尾的最长递增子序列的长度。</li> <li>\(LDS\)：以 \(l\) 结尾的最长递减子序列的长度。</li> </ul> <p>对于线段树的非叶子结点 (其表示的区间为 \([l, r]\) )，它会保存两个值：</p> <ul> <li>\(LIS\)：其子结点的 \(LIS\) 的最大值。</li> <li>\(LDS\)：其子结点的 \(LDS\) 的最大值。</li> </ul> <p>当我们开始回溯时，我们可以得到：</p> <ul> <li>\(son[i].LIS\)：子结点 \(i\) 所在线段树在区间 \([1, star[u] - 1]\) 的 \(LIS\)。</li> <li>\(son[i].LDS\)：子结点 \(i\) 所在线段树在区间 \([star[u] + 1, len]\) 的 \(LDS\)。</li> </ul> <p>我们使用 \(star[u] - 1\) 和 \(star[u] + 1\) 是为了保证 \(star[u]\) 可以被选中， 因此如果我们选中 \(u\)， 那么我们可以得到 \(ans = max(ans, son[i].LIS + 1 + son[j].LDS), i \ne j\)， 这里可以分别按照 \(LID\) 和 \(LDS\) 排序来规避掉枚举 \(i, j\) 的问题。</p> <p>那么如果我们不选中 \(u\)，我们如何得到这部分的答案呢？我们可以在合并线段树的过程中解决这个问题。 在合并线段树 \(a\) 和线段树 \(b\) 时，设我们当前处于区间 \([l, r]\)， 我们可以得到 \(a\) (或 \(b\)) 在 \([l, mid]\) 区间的 \(LIS\)， 以及 \(b\) (或 \(a\)) 的 \([mid + 1, r]\) 区间的 \(LDS\)， 那么这两部分可以合并，这些合并包括了不选中 \(u\) 的部分。 也就是 \(ans = max(ans, LIS[lc[a]] + LDS[rc[b]], LIS[lc[b]] + LDS[rc[a]])\)。</p> <p>当我们完成了所有的结点的合并后，我们需要进行两次单点更新：</p> <ul> <li>如果 \(max(son[i].LIS + 1)\) 比线段树 \(u\) 在 \(star[u]\) 处的 \(LIS\) 大， 我们需要将其更新为 \(max(son[i].LIS + 1)\)， 这表示以 \(star[u]\) 结尾的最长递增子序列的长度发生了变化。</li> <li>如果 \(max(son[i].LDS + 1)\) 比线段树 \(u\) 在 \(star[u]\) 处的 \(LDS\) 大， 我们需要将其更新为 \(max(son[i].LDS + 1)\)， 这表示以 \(star[u]\) 结尾的最长递减子序列的长度发生了变化。</li> </ul> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/star_road.cpp">star_road.cpp</a></p> <h1 id="increasing-table"><a href="https://csacademy.com/ieeextreme-practice/task/increasing-table">Increasing table</a></h1> <p>考虑到当第一行的元素确定后，第二行的元素也就确定了，因此我们只需要计算第一行的方案数即可。 对于输入，我们可以维护一个序列，序列中的元素表示第一行可以填入的数，以及这个数是否一定要填入到第一行， 序列按照可以填入的数从小到大排序。 现在我们需要计算从这个序列中选出 \(N\) 个数的方案数。 如果我们不考虑每一列是否满足递增关系，那么我们可以很轻松的用动态规划解决这个问题。 具体的，我们用 \(dp[i][j][0]\) 表示前 \(i\) 个数中选出 \(j\) 个数， 且第 \(i\) 个数不被选择时的方案数；用 \(dp[i][j][1]\) 表示前 \(i\) 个数中选出 \(j\) 个数， 且第 \(i\) 个数被选择时的方案数。</p> \[\begin{aligned} dp[i][j][0] &amp; = \begin{cases} 0，\text{当前必选} \\ dp[i - 1][j][0] + dp[i - 1][j][1]，\text{其他} \end{cases} \\ dp[i][j][1] &amp; = dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] \end{aligned}\] <p>我们现在考虑必须要让列也递增的情况，我们来依次来考虑第一行的每个数最大可能的取值：</p> <ul> <li>对于第一个数，其只能是 \(1\)。</li> <li>对于第二个数，其最大是 \(3\)，因为当第二个数是 \(4\) 的时候，第二行一定得出现 \(2，3\) 此时 第二列一定不可能递增。</li> <li>对于第三个数，其最大是 \(5\)，因为当第三个数是 \(6\) 的时候，第二行一定得出现 \(3，4，5\) (或者更小的数字) 此时第三列一定不可能递增。</li> <li>……</li> <li>对于第 \(i\) 个数，其最大是 \(2i - 1\)。</li> </ul> <p>不难发现，对于一个方案中的第 \(i\) 个数，若其均小于等于 \(2i - 1\)，那么方案一定满足列是递增的。</p> <p>因此，我们只需要对上面的转移方程增加一个限制条件即可：</p> \[\begin{aligned} dp[i][j][0] &amp; = \begin{cases} 0，\text{当前必选} \\ dp[i - 1][j][0] + dp[i - 1][j][1]，\text{其他} \end{cases} \\ dp[i][j][1] &amp; = \begin{cases} dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1]，\text{当前小于等于} 2i - 1 \\ 0，\text{其他} \end{cases} \end{aligned}\] <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/increasing_table.cpp">increasing_table.cpp</a></p> <h1 id="bounded-tuple"><a href="">Bounded tuple</a></h1> <p>Not finished yet.</p> <p>代码：</p> <h1 id="laser-defense"><a href="https://csacademy.com/ieeextreme-practice/task/laser-defense">Laser Defense</a></h1> <p>我们将激光分成四种：</p> <ul> <li>\(a_u\)：\(a_u[i]\) 表示 \(A\) 点发出的第 \(i\) 条与上边界的交点座标。</li> <li>\(a_r\)：\(a_r[i]\) 表示 \(A\) 点发出的第 \(i\) 条与右边界的交点座标。</li> <li>\(b_u\)：\(b_u[i]\) 表示 \(B\) 点发出的第 \(i\) 条与上边界的交点座标。</li> <li>\(b_l\)：\(b_l[i]\) 表示 \(B\) 点发出的第 \(i\) 条与左边界的交点座标。</li> </ul> <p>我们分别对上面四种激光进行排序。</p> <p>我们首先考虑只有 \(A\) 点激光的情况，此时被分成了 \(len(a_u) + len(a_r) + 1\) 个区域。</p> <p>接着对于某个 \(B\) 点发出的激光，如果其到达左边界， 那么此时区域个数会增加 \(len(a_u) + len(a_r) + 1\)；如果其到达上边界， 此时我们可以用二分查找在 \(a_u\) 中找到有多少个激光出现在其左边，不妨设为 \(x\)， 那么此时区域个数会增加 \(len(a_u) + len(a_r) + 1 - x\)。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/laser_defense.cpp">laser_defense.cpp</a></p> <h1 id="another-sliding-window-problem"><a href="https://csacademy.com/ieeextreme-practice/task/another-sliding-window-problem">Another Sliding Window Problem</a></h1> <p>首先我们不难发现要获得一个序列的 <code class="language-plaintext highlighter-rouge">optimal cost</code>，如果序列有偶数个元素，那么最大的要和最小的配对， 第二大的要和第二小的配对，以此类推；如果序列有奇数个元素，那么最大的元素要单独拎出来， 而其余元素按照序列有偶数个元素的情况处理。</p> <p>有了上面的结论，我们可以有以下推论：</p> <blockquote> <p>如果一个序列的 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\)， 那么删除最大的元素后的序列的 <code class="language-plaintext highlighter-rouge">optimal cost</code> 一定小于等于 \(x\)。</p> </blockquote> <p>证明如下：</p> <blockquote> <p>如果一开始序列有奇数个元素，那么删除最大的元素后，序列有偶数个元素， 那么 <code class="language-plaintext highlighter-rouge">optimal cost</code> 的取值集合少了最后一个元素，因此 <code class="language-plaintext highlighter-rouge">optimal cost</code> 不会增加。 如果一开始序列有偶数个元素，那么删除最大的元素后，序列有奇数个元素， 那么 <code class="language-plaintext highlighter-rouge">optimal cost</code> 的取值集合中某一个元素变小了，因此 <code class="language-plaintext highlighter-rouge">optimal cost</code> 不会增加。</p> </blockquote> <p>利用上面的推论，当我们计算出一个满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 的区间 \([l, r]\) 后， 那么 \([l, r - 1], [l, r - 2], \cdots, [l, l]\) 一定也满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\)， 如果我们用 \(s[i]\) 表示 \([1, i]\) 的前缀和， 那么这些区间的对答案的贡献为：\(s[r] - s[l - 1] - (r - l + 1) \times a[l]\)。</p> <p>接下来我们考虑对于一个给定的 \(l\)， 如何快速求出最大的 \(r\) 使得 \([l, r]\) 满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\)。</p> <p>我们还是需要利用 <code class="language-plaintext highlighter-rouge">optimal cost</code> 的配对性质，首先我们先找到最后一个小于等于 \(x\) 的元素的位置， 不妨设为 \(r\)，初始 \(l = r\)，那么对于当前的区间 \([l, r]\) 中的 \(r\) 一定是满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 最大的。接下来我们考虑如何求解 \(l - 1\) 对应的最大的 \(r'\)。 实际上 \(r'\) 只有可能是 \(\{r - 1, r, r + 1\}\) 中的一个。这是因为：</p> <ul> <li>如果 \([l, r]\) 的长度是偶数，那么 \([l - 1, r]\) 的长度是奇数，此时 \([l - 1, r]\) 一定是满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 的，因为此时可以让 \(a[l - 1]\) 单独一组；同时按照匹配规则， 如果 \(a[l - 1] + a[r + 1] \le x\) 那么 \([l - 1, r + 1]\) 也一定是满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 的。而对于 \([l - 1, r + 2]\) 一定是不满足的，因为如果该区间满足， 那么 \([l - 1, r + 1]\) 也一定满足，而 \([l - 1, r + 1]\) 长度是偶数，此时我们把 \(a[l - 1]\) 删除掉，那么 \([l, r + 1]\) 一定满足，这与 \(r\) 是最大的矛盾。 所以当前情况下 \(r'\) 只有可能是 \(\{r, r + 1\}\) 中的一个。</li> <li>如果 \([l, r]\) 的长度是奇数，那么 \([l - 1, r]\) 的长度是偶数， 此时如果 \(a[l - 1] + a[r] \le x\)，那么 \([l - 1, r]\) 一定是满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 的，进一步的有如果 \(a[r + 1] \le x\) 成立， 那么 \([l - 1, r + 1]\) 也一定是满足 <code class="language-plaintext highlighter-rouge">optimal cost</code> 小于等于 \(x\) 的。 而对于 \([l - 1, r + 2]\) 一定是不满足的，因为如果该区间满足，而 \([l - 1, r + 2]\) 长度是偶数， 此时我们把 \(a[l - 1], a[r + 2]\) 同时删除掉，那么 \([l, r + 1]\) 一定满足， 这与 \(r\) 是最大的矛盾。而如果一开始就不满足 \(a[l - 1] + a[r] \le x\)，那么由于 \([l, r]\) 区间长度是奇数，我们可以删除 \(a[r]\)，而增加 \(a[l - 1]\)，由于 \([l, r]\) 满足， 我们用一个更小的数字取替换了一个最大的数字形成的 \([l - 1, r - 1]\) 一定满足。 所以当前情况下 \(r'\) 只有可能是 \(\{r - 1, r, r + 1\}\) 中的一个。</li> </ul> <p>因此我们只需要按照上面的过程，每次减少 \(l\) 后，计算出新的 \(r\) 对答案进行统计即可。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/another_sliding_window_problem.cpp">another_sliding_window_problem.cpp</a></p> <h1 id="ieee754-emulator"><a href="https://csacademy.com/contest/ieeextreme-practice/task/ieee754-emulator/">IEEE754 Emulator</a></h1> <p>逻辑并不复杂，有几点需要注意的：</p> <ul> <li>不能直接计算 \(a * b + c\)，应该使用相关的库函数，例如 <code class="language-plaintext highlighter-rouge">C++</code> 的 <code class="language-plaintext highlighter-rouge">std::fma</code>，<code class="language-plaintext highlighter-rouge">Python</code> 的 <code class="language-plaintext highlighter-rouge">Math.fma</code> 等。</li> <li>类型之间的转换，例如 <code class="language-plaintext highlighter-rouge">int</code> 和 <code class="language-plaintext highlighter-rouge">float</code> 之间的转换，应该使用 <code class="language-plaintext highlighter-rouge">union</code> 或者 <code class="language-plaintext highlighter-rouge">memcpy</code> 等方法，</li> <li>输出要保留前导零，也就是在结果长度小于 <code class="language-plaintext highlighter-rouge">8</code> 的时候需要在前面补零。</li> </ul> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/ieee754_emulator.cpp">ieee754_emulator.cpp</a></p> <h1 id="triumvirates"><a href="">Triumvirates</a></h1> <p>Not finished yet.</p> <p>代码：</p> <h1 id="stick"><a href="https://csacademy.com/ieeextreme-practice/task/stick">Stick</a></h1> <p>除去第一个正方形外，每增加一个正方形，所增加的面积是一个定值， 其增加值为单个正方形的面积减去两个正方形的公共部分的面积。因此最终答案为 \(4NL^2 - (N-1)S\)。 其中 \(S\) 为两个连续正方形相交部分的面积。</p> <p>如果直接使用上面的公式，那么乘法的时候可能会溢出，因此我们可以将上面的公式进行变形成 \(N(4L^2 - S) + S\)。并且最后得使用 <code class="language-plaintext highlighter-rouge">unsigned long long</code> 才行。当然 <code class="language-plaintext highlighter-rouge">Life is short; you need Python</code>。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/stick.cpp">stick.cpp</a></p> <h1 id="increasing-decreasing-permutations"><a href="">Increasing-decreasing permutations</a></h1> <p>Not finished yet.</p> <p>代码：</p> <h1 id="cheap-construction"><a href="https://csacademy.com/ieeextreme-practice/task/cheap-construction">Cheap Construction</a></h1> <p>首先，对于本题，答案中所选的字符串一定可以是原始串的子串。这是因为如果我们不选择原始串的子串， 那么最终的联通块一定是 \(N\)，所以对于联通块个数小于 \(N\) 情况我们一定要选择原始串的子串。 而对于要让联通块个数为 \(N\) 的情况，我们可以选择一个长度为 \(1\) 的子串。</p> <p>有了上面的结论我们只需要枚举所有的子串，计算每个子串会产生的联通块个数即可。</p> <p>对于如何计算一个子串的联通块个数，我们需要先计算出所有子串的出现位置。这一步当然不能用 <code class="language-plaintext highlighter-rouge">KMP</code> 算法， 如果使用 <code class="language-plaintext highlighter-rouge">KMP</code> 算法整体复杂度就变成 \(O(N^3)\) 了，我们可以直接枚举所有的子串的起始位置， 将其记录下来，而不是单独去计算每个子串的出现位置。</p> <p>想到这一步之后又存在新的问题，我们不能直接使用一个字典去存储每个子串出现的位置， 因为不管是有序字典还是无序字典，其在对一个字符串进行映射的时候必须要遍历整个字符串， 这样复杂度又变成了 \(O(N^3)\)。</p> <p>正确的做法是使用字符串哈希，这样可以在 \(O(N)\) 的复杂度预处理后， 只需要 \(O(1)\) 复杂度即可获取任意子串的哈希值 (本题中得使用双哈希)。</p> <p>经过上面的操作后，我们获取到了每个子串的出现位置，接下来我们考虑如何计算一个子串的联通块个数。 首先我们需要保证一个子串的出现位置是从小到大排序的，这一步可以在前面枚举的时候实现， 接着我们遍历出现位置，同时记录上一个出现位置的结尾 \(las\) (即 \(las\_start\_pos + len - 1\) )， 比较 \(las\) 和当前起始位置 \(now\_start\_pos\) ， 如果 \(las \ge now\_start\_pos\) ，这意味着当前的子串和上一次的子串有重叠，此时不会产生新的联通块； 如果 \(las \lt now\_start\_pos\) ，那么从上一次的结尾到当前位置之前的将会形成新的联通块， 也就是个数会增加 \(now\_start\_pos - las\)。</p> <p>最后一点，本题对常数要求非常高，如果你按照上面的思路写，那么会 <code class="language-plaintext highlighter-rouge">TLE</code>。这里给出一种可行的优化方案： 我们并不在一开始枚举所有的子串，而是按照长度递增的方式枚举子串， 每计算出一个长度的所有子串出现位置后就进行一次答案的更新， 这样能够让字典中存储的子串个数不超过 \(N\) 个，从而实现常数优化的目的， 即使是这样你也需要注意其他地方的细节，尽可能的优化常数， 因为我的代码在最慢的一个测试点上花费了 \(946ms\)，这非常接近 <code class="language-plaintext highlighter-rouge">TLE</code>。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/cheap_construction.cpp">cheap_construction.cpp</a></p> <h1 id="disparate-date-sets"><a href="https://csacademy.com/ieeextreme-practice/task/disparate-datasets">Disparate Date Sets</a></h1> <p>本题逻辑实际上没有任何的难点，但是如果我使用以下的方式对输入进行处理，将会出现问题：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">str</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">Record</span> <span class="n">tmp_record</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">ch</span> <span class="o">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">','</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tmp_record</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'\"'</span><span class="p">)</span> <span class="p">{</span> <span class="n">cnt</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">tmp_record</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>而如果我将上面的读入替换成 <code class="language-plaintext highlighter-rouge">Python</code> 中的 <code class="language-plaintext highlighter-rouge">csv</code> 进行处理，就能够得到正确的结果。</p> <p>我目前仍然没有发现上面的读取方式对于合法的输入会存在什么问题。我们已经确定了输入一定满足以下的情况：</p> <ul> <li><code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">acronyms</code> 中开头和结尾一定为单个双引号。</li> <li>除去 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">acronyms</code> 开头和结尾的双引号后，其中不存在奇数个连续的双引号。</li> </ul> <p>如果你发现这段读入会对某些输入产生错误，请告诉我。</p> <p>代码部分将会提供使用 <code class="language-plaintext highlighter-rouge">csv</code> 读取数据并处理的 <code class="language-plaintext highlighter-rouge">Python</code> 代码。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/disparate_datasets.py">disparate_datasets.py</a></p> <h1 id="queries"><a href="https://csacademy.com/ieeextreme-practice/task/queries">Queries</a></h1> <p>首先感谢 <a href="https://codeforces.com/profile/cancaneed">cancaneed</a> 提供的思路。</p> <p>本题我们可以采用两次分块来进行实现。分块维护区间和。</p> <p>其中第一个分块用于处理在原始区间上面的更新，我们记为 \(ori\)， 第二个分块用于维护在 \(p\) 上面的更新，我们记为 \(perm\)。</p> <p>对于在原始区间上的更新，我们在 \(ori\) 上更新后 (\(ori.update(l, r, c)\))， 还需要考虑其对 \(p\) 上查询的影响。例如， 如果之前存在 \([l, r]\) 区间上的更新增加 \(c\)，此时我们查询索引为 \(p_{l'}, p_{l'+1}, \cdots, p_{r'}\) 的和，那么我们需要知道 \([l, r]\) 中有多少个下标在集合 \(\{p_{l'}, p_{l'+1}, \cdots, p_{r'}\}\) 中， 如果我们将这个数字记为 \(cnt\)，那么此次查询就需要增加 \(c \times cnt\)。 所以在执行原始区间的更新时，我们还需要更新此次操作对 \(perm\) 的影响， 我们将这一部分记为 \(perm\_sum\)， 其中 \(perm\_sum[i]\) 表示对原始区间上的更新会使 \(perm\) 的第 \(i\) 块增加 \(perm\_sum[i]\)。 具体的, 对于更新 \((l, r, c)\)， 我们需要进行如下更新：</p> \[perm\_sum[i] = perm\_sum[i] + c \times (perm\_cnt[i][r] - perm\_cnt[i][l - 1]), 0 \le i \le BLOCK\_CNT\] <p>这里的 \(perm\_cnt[i][j]\) 表示在 \(ori\) 的第 \(i\) 块维护的下标对应到 \(p\) 后，有多少是小于等于 \(j\) 的。</p> <p>对于在 \(p\) 上的更新，同理我们需要考虑其对 \(ori\) 的影响。我们将这一部分记为 \(ori\_sum\)， 其中 \(ori\_sum[i]\) 表示对 \(p\) 上的更新会使 \(ori\) 的第 \(i\) 块增加 \(ori\_sum[i]\)。 具体的，对于更新 \((l, r, c)\)， 我们需要进行如下更新：</p> \[ori\_sum[i] = ori\_sum[i] + c \times (ori\_cnt[i][r] - ori\_cnt[i][l - 1]), 0 \le i \le BLOCK\_CNT\] <p>这里的 \(ori\_cnt[i][j]\) 表示在 \(perm\) 的第 \(i\) 块维护的下标对应到 \(ori\) 后，有多少是小于等于 \(j\) 的。</p> <p>对于原始区间上的查询操作，首先需要查询 \(ori.query(l, r)\)， 对于覆盖到整个块 \(id\) 的部分，我们需要累加 \(ori\_sum[id]\)，对于部分块， 我们必须依次在 \(perm\) 上进行单点查询， 因此我们需要维护 \(inv\_p[i]\) 表示原始下标 \(i\) 在 \(perm\) 上的位置，即 \(inv\_p[p[i]] = i\)。</p> <p>对于 \(p\) 上的查询操作，首先需要查询 \(perm.query(l, r)\)， 对于覆盖到整个块 \(i\) 的部分，我们需要累加 \(perm\_sum[i]\)，对于部分块， 我们必须依次在 \(ori\) 上进行单点查询，也就是去查询 \(ori\) 中 \(p[i]\) 处的值。</p> <p>上面的操作时间复杂度均为 \(O({N \over BLOCK\_SIZE} + BLOCK\_SIZE)\) 的。</p> <p>最后我们还要考虑计算 \(perm\_cnt\) 和 \(ori\_cnt\) 的时间复杂度，这一部分， 我们预处理的时候枚举块数量以及下标即可，因此时间复杂度为 \(O({N^2 \over BLOCK\_SIZE})\)。</p> <p>由于空间的限制，我们的 \(BLOCK\_SIZE\) 不能太小，既不能选择理论最优值 \(BLOCK\_SIZE = \sqrt{N}\)， 此时我们可以选择 \(BLOCK\_SIZE = 600\)，能够保证通过。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/queries.cpp">queries.cpp</a></p> <h1 id="doubled-sequence"><a href="">Doubled Sequence</a></h1> <p>Not finished yet.</p> <p>代码：</p> <h1 id="icarus"><a href="https://csacademy.com/ieeextreme-practice/task/icarus">Icarus</a></h1> <p>我们记 \(l_c\) 表示 \(S\) 中 <code class="language-plaintext highlighter-rouge">L</code> 的出现次数，\(r_c\) 表示 \(S\) 中 <code class="language-plaintext highlighter-rouge">R</code> 的出现次数，\(u_c\) 表示 \(S\) 中 <code class="language-plaintext highlighter-rouge">U</code> 的出现次数。</p> <p>我们总可以通过构建一条链使其满足题目条件。这里我们以 \(l_c \le u_c\) 为例， 其余的情况可以进行类似的讨论。</p> <p>当 \(l_c \le u_c\) 时，我们可以构建一条有 \(u_c + 2\) 个结点的链， 链上的结点均以左结点的方式进行连接。这样构造后，输入中的 <code class="language-plaintext highlighter-rouge">R</code> 将可以被忽略， 同时我们可以在这个链上找到一个结点， 其满足从当前结点触发的第一轮操作中所有的 <code class="language-plaintext highlighter-rouge">L</code> 和 <code class="language-plaintext highlighter-rouge">U</code> 都是合法移动且最深的结点不会被访问到。</p> <p>如何找到这样的点呢？我们可以先假设我们在一个两端无限长的链上的某个结点，初始化 \(depth\) 为 \(0\)， 我们遍历输入中的移动操作，对于 <code class="language-plaintext highlighter-rouge">L</code> 我们将 \(depth\) 减一，对于 <code class="language-plaintext highlighter-rouge">U</code> 我们将 \(depth\) 加一，记录这个 过程中最小的 \(depth\)，不妨记为 \(high\)，如果我们将链上的结点按照深度从低到高进行编号， 那么我们从编号为 \(-high + 1\) 的结点出发，后续的所有操作一定不能访问到编号为 \(u_c + 2\) 的结点。</p> <p>这是因为我们从编号为 \(-high + 1\) 的点出发的话，第一轮操作肯定都是合法的， 且不会到达编号为 \(u_c + 2\) 的结点； 对于第二轮操作，我们的起点一定是编号 \(-high + 1\) 的结点或者其祖先。</p> <p>如果第二轮起点是编号为 \(-high + 1\) 的结点，那么此后续操作便开始循环，不会到达 \(u_c + 2\)；</p> <p>如果第二轮起点是编号为 \(-high + 1\) 的结点的祖先，那么第二轮可能会有一些 <code class="language-plaintext highlighter-rouge">U</code> 操作失效， 实际上第二轮的起点与第一轮的起点的深度差的绝对值 (不妨记为 \(x\)) 就是 <code class="language-plaintext highlighter-rouge">U</code> 操作最多失效的次数， 下面来解释为什么第二轮的 <code class="language-plaintext highlighter-rouge">U</code> 操作最多失效 \(x\) 次。如果有多于 \(x\) 次的 <code class="language-plaintext highlighter-rouge">U</code> 操作失效， 不妨记为 \(x'\)，此时我们假设链变成无限长， 那么这 \(x'\) 次失效的 <code class="language-plaintext highlighter-rouge">U</code> 操作将会使到达的最低深度减少 \(x'\)， 这意味着我们的起点深度较上一轮应该减少 \(x'\)，这就出现了矛盾。</p> <p>这个结论意味着，当 <code class="language-plaintext highlighter-rouge">U</code> 的失效次数达到最大值时，我们第二轮的终点也不过是回到了第一轮的起点， 且这个过程中到达的最大深度也不过是第一轮到达的最大深度；而其余情况下， 我们的终点深度一定小于第一轮的起点深度，到达的最大深度也一定小于第一轮到达的最大深度。 继续这样推下去，我们便可以发现之后每一轮都不会到达 \(u_c + 2\)。</p> <p>这里还有一点需要注意的是，如果 \(l_c = 0\)，而 \(u_c = 1\)， 此时按照上面的方法会构造出 \(3\) 个结点的树，这一点不满足题目的限制条件。 因此我们需要对这一部分进行特判。这里我们只需要构造一个有 \(2\) 个结点的树，\(2\) 为 \(1\) 的左结点， 那么从 \(1\) 号结点出发永远不会到达 \(2\) 号结点。 当然我们可以在上面的思路中选择构造结点个数为 \(2 (l_c + u_c + r_c)\) 的链，这样也可以解决这一部分。</p> <p>其余的情况可以进行类似的讨论。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/icarus.cpp">icarus.cpp</a></p> <h1 id="power-of-three"><a href="https://csacademy.com/ieeextreme-practice/task/power-of-three">Power of three</a></h1> <p>设 \(M\) 表示输入 \(N\) 的位数，我们计算出 \(x_{min} = (M - 1) \lfloor \log_3 10 \rfloor\)， 不难发现如果有解 \(x\)，那么 \(x \ge x_{min}\) 时，且在理论上 \(x - x_{min} \le 3\)， 这是因为 \(3^3 = 27\)，也就是乘以 \(3\) 个 \(3\) 之后，位数会增加 \(1\)。</p> <p>同时对于解 \(x\) 我们有 \(3^x \equiv N \pmod{P}\)，其中 \(P\) 是任意的数， 因此我们可以提前确定多个质数，从 \(x = x_{min}\) 开始， 然后检查是否对于这些质数都有 \(3^x \equiv N \pmod{P}\)，如果成立， 我们可以大概率认为这个 \(x\) 是答案。如果 \(x\) 在 \(3\) 次递增的过程中没有找到答案， 那么我们输出 \(-1\) 即可。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/power_of_three.cpp">power_of_three.cpp</a></p> <h1 id="halving"><a href="https://csacademy.com/ieeextreme-practice/task/halving">Halving</a></h1> <p>我们先考虑什么情况下无解。首先我们先尝试将能确定的元素进行确定，因为这些元素对方案数没有贡献。 哪些元素能够被确定下来？一共有两种：</p> <ul> <li>已经给定的元素。</li> <li>对于第 \(i\) 对，其中一个元素为 \(-1\)，另一个元素不为 \(B_i\)， 那么可以将为 \(-1\) 的元素确定为 \(B_i\)。</li> </ul> <p>经过上述操作后，我们只需要检查确定的元素是否只出现了一次， 以及如果第 \(i\) 对中两个元素同时被确定其是否满足最小值或最大值为 \(B_i\) 来判断是否有解。</p> <p>接下来我们考虑如何求解有解情况下的方案数。我们可以使用动态规划的方法， 原问题等价于求使用没有在 \(B\) 中出现的元素与在 \(B\) 中的元素进行配对 (不考虑顺序) 的方案数， 该方案数与答案相比只是少乘了 \(2^k\)，这是因为第一步填入确定元素的操作后， 我们需要确定的元素对只可能出现以下两种情况：</p> <ul> <li>两个元素均为 \(-1\)。</li> <li>一个元素为 \(-1\)，另一个元素为 \(B_i\)。</li> </ul> <p>对于第一种情况，我们可以确定其中一个为 \(B_i\)，另一个为比 \(B_i\) 大或者小的元素， 由于两者位置不确定，所以此时等价于求解能与 \(B_i\) 配对的元素的个数再乘以 \(2\)。</p> <p>对于第二种情况，等价于求解能与 \(B_i\) 配对的元素的个数。</p> <p>因此我们可以用 \(dp[i][j][k]\) 来表示用 \(1, 2, ..., i\) 中不在 \(B\) 中的元素与在 \(B\) 中的元素配对， 且在 \(1, 2, ..., i\) 中有 \(j\) 个在 \(B\) 中的元素未配对有 \(k\) 个不在 \(B\) 中的元素未配对 (这个定义有点拗口)。</p> <p>接下来我们考虑如何进行转移，首先我们需要确定 \(i\) 的三种情况：</p> <ul> <li>\(i\) 是一个已经拥有确定匹配的元素。</li> <li>\(i\) 未拥有确定匹配且在 \(B\) 中。</li> <li>\(i\) 未拥有确定匹配且不在 \(B\) 中。</li> </ul> <p>这里的拥有确定匹配是指：如果一对元素的两个元素均在第一步中被确定，那么这两个元素就拥有确定匹配。</p> <p>对于第一种情况，显然 \(dp[i][j][k] = dp[i - 1][j][k]\)。</p> <p>对于第二种情况，我们需要根据是需要找比 \(i\) 大的元素还是比 \(i\) 小的元素进行转移：</p> \[dp[i][j][k] = \begin{cases} dp[i - 1][j][k]，\text{找比} i \text{大的元素} \\ dp[i - 1][j[k + 1] \times (k + 1)，\text{找比} i \text{小的元素} \end{cases}\] <p>第二种情况的第一个转移方程是因为我们不能在 \(1, 2, 3, ..., i - 1\) 中找到比 \(i\) 大的元素， 所以此时只能暂时不对 \(i\) 进行配对。 第二个转移方程则是所有在 \(1, 2, 3, ..., i - 1\) 中不在 \(B\) 中的元素未配对的元素均可以与 \(i\) 配对， 且配对后这一部分未配对的元素个数会减少 \(1\)。</p> <p>对于第三种情况，由于在第二种情况中我们保证了 \(B\) 中未参与配对的元素一定是比 \(i\) 小的， 所以此时我们有以下的转移方程：</p> \[dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i - 1][j + 1][k] \times (j + 1)\] <p>第三种情况中的 \(dp[i - 1][j][k - 1]\) 表示我们可以暂时不对 \(i\) 进行配对， 而 \(dp[i - 1][j + 1][k] \times (j + 1)\) 代表我们可以选择任意一个在 \(B\) 中未参与配对的元素与 \(i\) 配对， 配对之后这一部分未配对的元素个数会减少 \(1\)。</p> <p>通过观察三部分的方程不难发现我们可以使用滚动数组将空间复杂度从 \(O(N^3)\) 优化到 \(O(N^2)\)。</p> <p>最后的答案即为 \(dp[2N][0][0] \times 2^k\)，其中 \(k\) 表示初始有多少对元素对中的元素同时为 \(-1\)。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/halving.cpp">halving.cpp</a></p> <h1 id="kings-order"><a href="https://csacademy.com/ieeextreme-practice/task/kings-order">King’s Order</a></h1> <p>直接使用拓扑排序即可，只是在拓扑排序中需要将普通队列替换成优先队列。 优先队列的比较器设置为题目要求即可。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/kings_order.cpp">kings_order.cpp</a></p> <h1 id="balls"><a href="https://csacademy.com/ieeextreme-practice/task/balls">Balls</a></h1> <p>本题是 <code class="language-plaintext highlighter-rouge">Codeforces</code> 在十三年前某场比赛的原题， 原题的链接：<a href="https://codeforces.com/problemset/problem/93/E">Codeforces 93 E. Lostborn</a>。</p> <p>本题的思路来源于题解：<a href="https://codeforces.com/blog/entry/2216">Codeforces Beta Round 76 - задача Е div 1 глазами ее автора.</a></p> <p>首先我们需要反向考虑问题，具体的， 我们定义 \(f_{E_1, E_2, \dots, E_K}(N)\) 表示给定 \(N\) 和 \(K\) 个球的情况下有多少个点没有被命中， 那么命中的点即为 \(N - f_{E_1, E_2, \dots, E_K}(N)\)。</p> <p>首先我们考虑 \(f_{E_1, E_2, \dots, E_K}(N)\) 是否存在某种递推关系。事实上，由容斥原理我们有以下的递推关系：</p> \[f_{E_1, E_2, \dots, E_K}(N) = f_{E_2, E_3, \dots, E_K}(N) - f_{E_2, E_3, \dots, E_K}(\lfloor \frac{N}{E_1} \rfloor)\] <p>为了理解上面的递推公式， 我们可以考虑对于给定 \(N\) 和 \(E_2, E_3, \dots, E_K\) 的情况下增加 \(E_1\) 会有多少个新的点被覆盖。</p> <p>我们知道如果增加 \(E_1\)， 那么 \(1 \times E_1, 2 \times E_1, \dots, \lfloor \frac{N}{E_1} \rfloor \times E_1\) 这些点会被覆盖， 那么这些点里面哪些点是新增的呢？由于 \(E_1\) 与其他的 \(E_i\) 互质，在 \(1, 2, \dots, \lfloor \frac{N}{E_1} \rfloor\) 这些数中如果某个数与所有的 \(E_i\) 互质，那么这个数一定是新增的点， 这一部分刚好对应 \(f_{E_2, E_3, \dots, E_K}(\lfloor \frac{N}{E_1} \rfloor)\)。这也是为什么我们会有以上的递推式。</p> <p>我们对上面的递推式起个别名：</p> \[dp[i][j] = f_{E_i, E_{i+1}, \dots, E_K}(j)\] <p>那么就有如下的动态转移方程：</p> \[dp[i][j] = dp[i + 1][j] - dp[i + 1][\lfloor \frac{j}{E_i} \rfloor]\] <p>接下来我们来考虑上面式子的复杂度。你可能会说这不是显然的 \(O(NK)\) 吗？是的如果使用递推来做的话， 复杂度确实是 \(O(NK)\)。但是实际上并不是所有的状态都是有用的状态， 因此如果我们使用递归来实现，我们的时间复杂度实际上为有用的状态个数。</p> <p>如何估计有用状态的个数？首先上面式子 \(i\) 的取值数一定是 \(K\) 种，接下来我们考虑 \(j\) 取值种数。 不难发现对于任何一个可能的 \(j\) 其一定可以写成 \(\lfloor \frac{N}{a} \rfloor\) 的形式， 其中 \(a\) 是某个正整数。也就是说要估计 \(j\) 的种类数， 我们只需要考虑 \(\lfloor \frac{N}{a} \rfloor\) 的种类数， 而 \(\lfloor \frac{N}{a} \rfloor\) 的种类数不会超过 \(min(a 的种类数, \lfloor \frac{N}{2} \rfloor + 2)\)， 这里第二部分是因为当 \(a = \lfloor \frac{N}{2} \rfloor, N \gt 3\) 时，\(\lfloor \frac{N}{a} \rfloor\) 为 \(2\)， 就算对于 \(a \in [1, \lfloor \frac{N}{2} \rfloor]\)，\(\lfloor \frac{N}{a} \rfloor\) 均获得了不同的值， 此时继续增加 \(a\) 也只能获得 \(1, 0\) 两种结果。</p> <p>考虑到显然有下式成立：</p> \[min(a, \lfloor \frac{N}{a} \rfloor) \le \sqrt{N}\] <p>故 \(j\) 的种类数不会超过 \(2 \sqrt{N}\)，因此有用状态的个数不会超过 \(2K \sqrt{N}\)。 这对应的时间复杂度为 \(O(K \sqrt{N})\)。但实际上如果我们对 \(E\) 按照从大到小的顺序排序， 那么 \(N\) 会下降的非常快，这样我们实际上的复杂度会远远小于 \(O(K \sqrt{N})\)。</p> <p>我们当然不能对所有可能的状态都进行记忆化，这样会导致我们不得不使用字典， 这往往会让我们的时间复杂度变为 \(O(K \sqrt{N} log(K \sqrt{N}))\)，且常数非常大。 正确的做法是我们只在 \(N\) 较小时进行记忆化的操作。 这是因为对于递归而言，我们越小的部分被重复计算的次数相较较大的部分会更多。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/balls.cpp">balls.cpp</a></p> <h1 id="corporation"><a href="https://csacademy.com/ieeextreme-practice/task/corporation">Corporation</a></h1> <p>首先感谢 <a href="https://codeforces.com/profile/yanire">yanire</a> 提供的思路。</p> <p>我们可以使用分块来解决这个问题，具体的我们将整个工资序列分成大小为 \(\sqrt{N}\) 的块， 最后一块的大小可能小于 \(\sqrt{N}\)。每块维护以下信息：</p> <ul> <li><code class="language-plaintext highlighter-rouge">sum_salary</code>：块内所有工资的和。</li> <li><code class="language-plaintext highlighter-rouge">sum_happiness</code>：块内幸福值的和。</li> <li><code class="language-plaintext highlighter-rouge">lazy_salary</code>：块内每个员工的工资增量。</li> <li><code class="language-plaintext highlighter-rouge">lazy_happiness</code>：块内每个员工的幸福值增量。</li> <li><code class="language-plaintext highlighter-rouge">all_same</code>：块内每个员工的工资值是否相同。</li> </ul> <p>对于增加操作：</p> <ul> <li>如果覆盖整个块，那么可以在 \(O(1)\) 的时间内完成更新，最多重复 \(O(\sqrt{N})\) 次， 时间复杂度为 \(O(\sqrt{N})\)。</li> <li>如果覆盖部分块，那么需要遍历当前被覆盖的块，然后重新计算块内的信息， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。</li> </ul> <p>对于设置操作：</p> <ul> <li>如果覆盖整个块且整个块的每个员工工资值相同，那么可以在 \(O(1)\) 的时间内完成更新， 最多出现 \(O(\sqrt{N})\) 次，时间复杂度为 \(O(\sqrt{N})\)。</li> <li>如果覆盖整个块但整个块的每个员工工资值不同，那么需要遍历整个块，然后重新计算块内的信息， 时间复杂度为 \(O(\sqrt{N})\)。对于这种情况下， 我们考虑一开始最多有 \(O(\sqrt{N})\) 个 <code class="language-plaintext highlighter-rouge">all_same</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 的块， 我们每次通过设置操作遍历一整个块的时候，<code class="language-plaintext highlighter-rouge">all_same</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 的块的数量会减少一， 而每次增加操作最多可能会让 <code class="language-plaintext highlighter-rouge">all_same</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 的块数量增加二， 这意味着 \(Q\) 次操作中最多会执行 \(O(\sqrt{N} + Q)\) 次遍历整个块的操作， 均摊下来每次操作只会执行 \(O(1)\) 次。</li> <li>如果覆盖部分块，那么需要遍历当前被覆盖的块，然后重新计算块内的信息， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。</li> </ul> <p>对于查询操作：</p> <ul> <li>如果覆盖整个块，那么可以在 \(O(1)\) 的时间内完成查询，最多重复 \(O(\sqrt{N})\) 次， 时间复杂度为 \(O(\sqrt{N})\)。</li> <li>如果覆盖部分块，那么需要遍历当前被覆盖的块， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。</li> </ul> <p>综上我们可以发现上述方法的时间复杂度为 \(O(\sqrt{N}N+\sqrt{N}Q)\)。</p> <p>最后需要使用快速读写减少常数的影响。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/corporation.cpp">corporation.cpp</a></p> <h1 id="this-is-not-an-optimization-problem"><a href="https://csacademy.com/ieeextreme-practice/task/this-is-not-an-optimization-problem">This is not an optimization problem</a></h1> <p>首先感谢 <a href="https://codeforces.com/profile/cancaneed">cancaneed</a> 提供的思路。</p> <p>首先我们考虑计算大小为 \(k\) 时的结果。 此时我们依次考虑每个结点 \(u, 1 \le u \le N\) 的权重对答案的贡献。 对于结点 \(u\) 而言， 其贡献次数显然为从 \(N\) 个结点中选择 \(k\) 个结点的方案数减去没有选中 \(u\) 的方案数。</p> <p>对于从 \(N\) 个结点中选择出 \(k\) 个结点的方案数，我们可以使用组合数的方法计算， 即为 \({N \choose k}\)。</p> <p>接下来我们考虑什么情况下不会选择 \(u\)。 如果选择了 \(k\) 个结点并通过增加一些其他结点构成一棵树且没有选择 \(u\) 那么所有选择的结点一定在 \(u\) 的同一个相邻分支中。 这是显然的，如果存在两个结点在 \(u\) 的不同分支中，那么这两个结点之间一定有一条路径需要经过 \(u\) 结点。 那么这一部分的方案数即为 \(\sum_{v \in adj(u)} {sz[v] \choose k}\)。 其中 \(sz[v]\) 表示删除 \(u\) 结点后，以 \(v\) 为根的子树的结点个数。</p> <p>结合上面两部分那么大小为 \(k\) 的答案即为：</p> \[\sum_u w[u]{N \choose k} - \sum_u \sum_{v \in adj(u)} w[u]{sz[v] \choose k}\] <p>接下来我们考虑将所有的相同组合数进行合并，设最后的系数为 \(b[i]\)，那么我们有：</p> \[\sum_{i = 0}^{N} b[i] {i \choose k} = \sum_{i = 0}^{N} \frac{i!b[i]}{k!(i-k)!} = \frac{1}{k!} \sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\] <p>首先我们考虑如何计算系数 \(b[i]\)。我们只需要考虑每个结点 \(u\) 对其邻居的影响即可。具体的， 我们在 <code class="language-plaintext highlighter-rouge">DFS</code> 的过程中，设当前到达的结点为 \(u\)，\(u\) 的父结点为 \(par\) 子结点为 \(v\)， 那么 \(u\) 可以作为一整棵子树与 \(par\) 相连， 也就是我们在计算 \(par\) 贡献的时候可以在以 \(u\) 为根的子树中选择 \(k\) 个结点， 此时 \(b[sz[u]]\) 会减少 \(w[par]\) (系数为负)；同时，我们在计算 \(v\) 贡献的时候， 可以在除去以 \(v\) 为根的子树后的其他结点中选择 \(k\) 个结点，此时对应 \(b[n - sz[v]]\) 减少 \(w[v]\)。 最后不要忘记 \(b[n]\) 还需要增加 \(w[u]\) (对应 \(\sum_u {N \choose k}\))。</p> <p>接下来我们考虑如何计算 \(\frac{1}{k!} \sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\)， 这里我们考虑计算 \(\sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\)， 最后的 \(\frac{1}{k!}\) 只需要在最后乘上乘法逆元即可。</p> <p>我们构造两个 \(N\) 次多项式：</p> \[\begin{aligned} P_1(x) &amp;= n!b[n] + (n - 1)!b[n-1]x + (n - 2)!b[n-2]x^2 + \dots + 0!b[0]x^n \\ P_2(x) &amp;= \frac{1}{0!} + \frac{1}{1!}x + \frac{1}{2!}x^2 + \dots + \frac{1}{n!}x^n \end{aligned}\] <p>我们考虑求 \(P_1(x)P_2(X)\) 的 \(x^{n-k}\) 的系数：</p> \[Coef(x^{n-k}, P_1(x)P_2(x)) = \frac{n!b[n]}{(n-k)!} + \frac{(n-1)!b[n-1]}{(n-k-1)!} + \dots + \frac{(n-k)!b[n-k]}{(0)!} = \sum_{i = 0}^{n} \frac{i!b[i]}{(i-k)!}\] <p>这意味着我们只需要计算 \(P_1(x)P_2(x)\) 的 \(x^{n-k}\) 的系数再乘上 \({1 \over k!}\) 即为答案，此过程通过任意模数的 <code class="language-plaintext highlighter-rouge">NTT</code> 算法即可完成。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/this_is_not_an_optimization_problem.cpp">this_is_not_an_optimization_problem.cpp</a></p> <h1 id="digits-swap"><a href="https://csacademy.com/ieeextreme-practice/task/digits-swap">Digits swap</a></h1> <p>直接暴力搜索即可，搜索的时候注意只有当当前这一位与其最大可能性不同时才进行搜索。 理论时间复杂度为 \(O(N^K)\)，但实际上跑得飞快。</p> <p>给出几种常见贪心的反例：</p> <ul> <li>每次选靠前最大的和当前位置交换：例如 \(12344\ 2\)，如果按照这种方法会得到 \(44312\) ， 实际最优为 \(44321\)。</li> <li>每次选靠后最大的和当前位置交换：例如 \(21344\ 2\)，如果按照这种方法会得到 \(44312\) ， 实际最优为 \(44321\)。</li> <li>每次选靠后最大的和当前位置交换，交换完某种数字后进行一次从大到小的排序：例如 \(45366\ 3\)， 选择靠后最大交换两次后 \(66345\)，对 \(45\) 进行排序得到 \(66354\)， 再进行一次交换得到 \(66534\)，实际最优为 \(66543\)。</li> </ul> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/digits_swap.cpp">digits_swap.cpp</a></p> <h1 id="brick-stacks"><a href="https://csacademy.com/ieeextreme-practice/task/brick-stacks">Brick stacks</a></h1> <p>我们先从小到大排序，然后依次处理每一个元素，对于当前元素，如果已经形成了 \(pile\) 堆， 我们只需要记录形成的堆的最下方的元素，不妨用 \(pile[i]\) 表示第 \(i\) 堆最下方的元素， 然后尝试将当前元素放到这些堆中，实际上我们只需要检查当前元素是否可以放到最小的 \(pile[i]\) 所在的堆中， 这是因为：</p> <ul> <li>如果当前的元素不能放入最小的 \(pile[i]\) 所在的堆中，那么它一定不能放入其他堆中；</li> <li>如果设 \(pile_{min}\) 表示最小的 \(pile_[i]\)，\(pile_j\) 表示其他任意一个非最小的 \(pile[i]\)， 那么不会存在当前元素可以放入 \(pile_{min}\) 和 \(pile_j\)，但在当前元素放入 \(pile_{min}\) 后， 下一个元素不能放入 \(pile_j\)，且如果当前元素放入 \(pile_j\) 后，下一个元素可以放入 \(pile_{min}\) 的情况。</li> </ul> <p>对于上述的第二点，可以有如下的证明：</p> <blockquote> <p>首先 \(pile_{min} + x \gt pile_j\)，否则可以将 \(pile_j\) 的最后一块放到 \(pile_{min}\) 后面。 其次如果 \(A_i + x \le A_{i+1}\)，那么下一个元素一定是能放在 \(A_i\) 所在堆的； 如果 \(A_i + x \gt A_{i+1}\)，而我们将上面第二点写成不等式与该不等式进行联立：</p> \[\begin{cases} pile_j &gt; pile_{min} \\ pile_{min} + x \gt pile_j \\ A_i + x \gt A_{i+1} \\ pile_{min} + x \le A_i \\ pile_{min} + x \le A_{i+1} \\ pile_j + x \gt A_{i+1} \\ pile_j + x \le A_i \\ A_{i+1} \gt A_{i} \\ \end{cases}\] <p>上面的最后三个存在矛盾，因此不可能有解。</p> </blockquote> <p>这就意味着，我们可以用一个小根堆维护形成的堆的最后一个元素，每次尝试将新的数放入到堆顶所形成的堆， 如果不能放置，则形成一个新的堆加入到堆中。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/brick_stacks.cpp">brick_stacks.cpp</a></p> <h1 id="stones"><a href="https://csacademy.com/ieeextreme-practice/task/stones">Stones</a></h1> <p>首先感谢 <a href="https://codeforces.com/profile/cancaneed">cancaneed</a> 提供的思路。</p> <p>我们记 \((R1, B1, R2, B2)\) 为藏球方红球有 \(R1\) 个，蓝球有 \(B1\) 个； 猜球方红球有 \(R2\) 个，蓝球有 \(B2\) 个的状态时猜球方的最优策略下的最大获胜概率。</p> <p>如果我们设 \(p\) 为藏红球的概率，\(q\) 为猜红球的概率， 同时我们设 \(rr := 1 - (R2, B2, R1-1, B1), rb := 1 - (R2, B2-1, R1, B1), br := 1 - (R2-1, B2, R1, B1), bb := 1 - (R2, B2, R1, B1 - 1)\)， 我们不难写出以下的转移方程：</p> \[(R1, B1, R2, B2) = p \cdot q \cdot rr \cdot + p \cdot (1-q) \cdot rb + (1-p) \cdot q \cdot br + (1-p) \cdot (1-q) \cdot bb\] <p>由于双方均追求最大化获胜结果，所以我们需要对上面的式子分别关于 \(p, q\) 求导并令其为 \(0\)：</p> \[\begin{cases} \frac{\partial (R1, B1, R2, B2)}{\partial p} = q \cdot rr + (1-q) \cdot rb - q \cdot br - (1-q) \cdot bb = 0 \\ \frac{\partial (R1, B1, R2, B2)}{\partial q} = p \cdot rr - p \cdot rb + (1-p) \cdot br - (1-p) \cdot bb = 0 \end{cases}\] <p>解上面的方程可以得到：</p> \[\begin{cases} p = \frac{bb - br}{rr - rb - br + br} \\ q = \frac{bb - rb}{rr - rb - br + bb} \\ \end{cases}\] <p>最后带入 \((R1, B1, R2, B2)\) 即可。</p> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/stones.cpp">stones.cpp</a></p> <h1 id="rectangles-and-arrays"><a href="https://csacademy.com/ieeextreme-practice/task/rectangles-and-arrays-ieeextreme-18">Rectangles and arrays</a></h1> <p>我们首先考虑不进行修改的情况，那么我们可以使用单调栈来解决这个问题，具体的，我们需要计算出：</p> <ul> <li>\(l1[i]\)：表示第 \(i\) 个元素左侧第一个比它小的元素的位置，如果不存在则设置为最小下标减一。</li> <li>\(r1[i]\)：表示第 \(i\) 个元素右侧第一个比它小的元素的位置，如果不存在则设置为最大下标加一。</li> </ul> <p>那么统计不进行修改的部分就是 \(\max\limits_{1 \le i \le N}(r1[i] - l1[i] - 1)A_i\)， 这里公式表示以 \(A_i\) 为最小值所能形成的最大的正方形。</p> <p>接下来我们考虑需要修改的情况，首先如果要修改某个元素， 我们直接将其修改为 \(X\) 一定会比修改成一个比 \(X\) 小的数更优。 这意味着对于 \(A_i \ge X\) 的元素，我们没有必要修改， 所有后面的修改将会针对满足 \(A_i \lt X\) 的元素。</p> <p>接下来我们考虑如果将 \(A_i\) 修改成 \(X\)，会对哪些部分产生影响。 显然对于 \(l1[j] = i, j \gt i\) 和 \(r1[j] = i, j \lt i\) 的位置 \(j\)， 其 \(l1[j], r1[j]\) 可能会发生变化。 对于 \(i\) 位置，其 \(l1[i], r1[i]\) 也可能会发生变化。</p> <p>因此， 我们只需要计算出修改 \(A_i\) 为 \(X\) 后的新的 \(l1_i, r1_i\) 即可按照之前的公式进行更新。</p> <p>实际上对于非 \(i\) 位置的变化，显然 \(l1, r1\) 会变成左右两侧第二个比它小的元素的位置。 为了避免混淆，我们增加以下定义：</p> <ul> <li>\(l2_i\)：表示第 \(i\) 个元素左侧第二个比它小的元素的位置，如果不存在则设置为最小下标减一。</li> <li>\(r2_i\)：表示第 \(i\) 个元素右侧第二个比它小的元素的位置，如果不存在则设置为最大下标加一。</li> <li>\(l3_i\): 表示将第 \(i\) 个元素修改为 \(X\) 后左侧第一个比它小的元素的位置，如果不存在则设置为最小下标减一。</li> <li>\(r3_i\): 表示将第 \(i\) 个元素修改为 \(X\) 后右侧第一个比它小的元素的位置，如果不存在则设置为最大下标加一。</li> </ul> <p>而修改 \(i\) 位置对 \(j\) 造成影响实际上就是在修改 \(j\) 位置左侧或者右侧第一个比它小的元素。</p> <p>因此这一部分的贡献就是 \(\max\limits_{1 \le i \le N}\{(r2[i] - l1[i] - 1)A_i, (r1[i] - l2[i] - 1)A_i, (r3[i] - l3[i] - 1)X\}\)。</p> <p>上面使用 \(r2[i] - l1[i] - 1\) 和 \(r1[i] - l2[i] - 1\) 而不直接使用 \(r2[i] - l2[i] - 1\) 是因为我们只能修改一个元素， 而不能同时将左右两个第一个比当前小的元素修改为 \(X\)。</p> <p>下面我们来介绍如何计算 \(l2, r2, l3, r3\)。</p> <p>这里以计算 \(l2\) 为例介绍如何计算 \(l2, r2\)。计算这一部分，我们需要用到三个栈， 第一个栈与在计算 \(l1\) 时作用一样，而第二个栈用于保存从第一个栈中弹出的元素，由于栈是先进后出的， 第三个栈用于将从第一个栈中弹出的元素逆序放入到第二个栈中。 当然也可以将第二个栈换成队列，每次从队首取元素即可。这样操作后当从第二个栈弹出元素的时候， 也就找到了左侧第二个比栈顶元素小的元素。代码如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s2</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">s2</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">l2</span><span class="p">[</span><span class="n">s2</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">s2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s1</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">s1</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">s3</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">s1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">s1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s3</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">s2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s3</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">s3</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">l2</span><span class="p">[</span><span class="n">s1</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">l2</span><span class="p">[</span><span class="n">s2</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>计算完成后不要忘记排除 \(X &lt; A_i\) 的情况：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里以计算 \(l3\) 为例介绍如何计算 \(l3, r3\)。计算 \(l3\) 与计算 \(l1\) 类似。 只是我们需要比较的值从 \(A_i\) 变成了 \(X\)，但是这样会导致后续计算的时候有一些元素被提前弹出了栈， 实际上，我们可以先将弹出的元素放到一个队列里面，等到计算完 \(l3[i]\) 后再将这些元素放回栈中。 代码如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">now_pop</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">now_pop</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">l3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">now_pop</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now_pop</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="n">now_pop</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/rectangles_and_arrays.cpp">rectangles_and_arrays.cpp</a></p> <h1 id="invertible-pairs"><a href="https://csacademy.com/ieeextreme-practice/task/invertible-pairs">Invertible Pairs</a></h1> <p>我们可以使用动态规划解决这一题，具体的我们用 \(dp[i][0]\) 表示前 \(i\) 个数， 以 \(i\) 结尾且第 \(i\) 个数不发生翻转的最大和，用 \(dp[i][1]\) 表示前 \(i\) 个数， 以 \(i\) 结尾且第 \(i\) 个数发生翻转的最大和。我们可以写出以下的转移方程：</p> \[\begin{aligned} dp[i][0] &amp;= \begin{cases} max(a[i], dp[i - 1][0] + a[i])，i \equiv 0 \pmod{2} \\ max(a[i], dp[i - 1][0] + a[i], dp[i - 1][1] + a[i])，i \equiv 1 \pmod{2} \\ \end{cases} \\ dp[i][1] &amp;= \begin{cases} max(-a[i], dp[i - 1][1] - a[i])，i \equiv 0 \pmod{2} \\ max(-a[i], dp[i - 1][0] - a[i], dp[i - 1][1] - a[i])，i \equiv 1 \pmod{2} \end{cases} \end{aligned}\] <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/invertible_pairs.cpp">invertible_pairs.cpp</a></p> <h1 id="sierpinski"><a href="https://csacademy.com/ieeextreme18/task/sierpinski">Sierpinski</a></h1> <p>我们可以直接使用递归的方法来解决，我们首先需要确定当前行号，需要经过多少次构建才能构建出来， 不妨设为 \(cnt\)，这样的操作是 \(O(logx)\) 的，因为每次构建行数为上一次的两倍加一。</p> <p>同时我们也可以获取到 \(cnt - 1\) 次构造后会有多少行，不妨设为 \(last\_end\)， 那么第 \(x\) 行的 \([x - las\_end，las\_end + 1]\) 列一定全是蓝色， 因为这一部分对应的是中间的大蓝三角形。因此我们有以下递归操作：</p> <ul> <li>如果 \(y \in [x - las\_end, las\_end + 1]\)，我们直接返回蓝色；</li> <li>如果 \(y \lt x - las\_end\)，不难发现当前颜色与 \((x - las\_end - 1, y)\) 相同，此时递归调用；</li> <li>如果 \(y \gt las\_end + 1\)，不难发现当前颜色与 \((x - las\_end - 1, y - las\_end - 1)\) 相同， 此时递归调用。</li> </ul> <p>代码：<a href="https://github.com/Kaiser-Yang/OJProblems/blob/main/IEEExtreme/18/sierpinski.cpp">invertible_pairs.cpp</a></p>]]></content><author><name></name></author><category term="Algorithm"/><category term="Algorithm"/><category term="IEEExtreme"/><summary type="html"><![CDATA[注意：代码将会在后续开放提交后提供。 Two Fridges 由于题目中的温度范围非常小，我们只需要从小到大枚举温度，对于每个枚举，检查是否所有区间都被覆盖。 第一个覆盖所有区间的温度对即是答案。如果找不到输出 \(-1\) 即可。 代码：two_fridges.cpp Star Road 对于本题我们可以使用线段树和线段树的合并来解决这个问题。 具体的，我们首先需要将 \(star\) 离散化，使得其值在 \([1, len]\) 之间， 其中 \(len\) 是不同的星星的个数。 然后我们从任意一个结点开始进行 DFS，当我们到达一个结点时，我们为这个结点建立一个线段树。 对于线段树的叶子结点 (其表示的区间设为 \([l, l]\) ) ，它会保存两个值： \(LIS\)：以 \(l\) 结尾的最长递增子序列的长度。 \(LDS\)：以 \(l\) 结尾的最长递减子序列的长度。 对于线段树的非叶子结点 (其表示的区间为 \([l, r]\) )，它会保存两个值： \(LIS\)：其子结点的 \(LIS\) 的最大值。 \(LDS\)：其子结点的 \(LDS\) 的最大值。 当我们开始回溯时，我们可以得到： \(son[i].LIS\)：子结点 \(i\) 所在线段树在区间 \([1, star[u] - 1]\) 的 \(LIS\)。 \(son[i].LDS\)：子结点 \(i\) 所在线段树在区间 \([star[u] + 1, len]\) 的 \(LDS\)。 我们使用 \(star[u] - 1\) 和 \(star[u] + 1\) 是为了保证 \(star[u]\) 可以被选中， 因此如果我们选中 \(u\)， 那么我们可以得到 \(ans = max(ans, son[i].LIS + 1 + son[j].LDS), i \ne j\)， 这里可以分别按照 \(LID\) 和 \(LDS\) 排序来规避掉枚举 \(i, j\) 的问题。 那么如果我们不选中 \(u\)，我们如何得到这部分的答案呢？我们可以在合并线段树的过程中解决这个问题。 在合并线段树 \(a\) 和线段树 \(b\) 时，设我们当前处于区间 \([l, r]\)， 我们可以得到 \(a\) (或 \(b\)) 在 \([l, mid]\) 区间的 \(LIS\)， 以及 \(b\) (或 \(a\)) 的 \([mid + 1, r]\) 区间的 \(LDS\)， 那么这两部分可以合并，这些合并包括了不选中 \(u\) 的部分。 也就是 \(ans = max(ans, LIS[lc[a]] + LDS[rc[b]], LIS[lc[b]] + LDS[rc[a]])\)。 当我们完成了所有的结点的合并后，我们需要进行两次单点更新： 如果 \(max(son[i].LIS + 1)\) 比线段树 \(u\) 在 \(star[u]\) 处的 \(LIS\) 大， 我们需要将其更新为 \(max(son[i].LIS + 1)\)， 这表示以 \(star[u]\) 结尾的最长递增子序列的长度发生了变化。 如果 \(max(son[i].LDS + 1)\) 比线段树 \(u\) 在 \(star[u]\) 处的 \(LDS\) 大， 我们需要将其更新为 \(max(son[i].LDS + 1)\)， 这表示以 \(star[u]\) 结尾的最长递减子序列的长度发生了变化。 代码：star_road.cpp Increasing table 考虑到当第一行的元素确定后，第二行的元素也就确定了，因此我们只需要计算第一行的方案数即可。 对于输入，我们可以维护一个序列，序列中的元素表示第一行可以填入的数，以及这个数是否一定要填入到第一行， 序列按照可以填入的数从小到大排序。 现在我们需要计算从这个序列中选出 \(N\) 个数的方案数。 如果我们不考虑每一列是否满足递增关系，那么我们可以很轻松的用动态规划解决这个问题。 具体的，我们用 \(dp[i][j][0]\) 表示前 \(i\) 个数中选出 \(j\) 个数， 且第 \(i\) 个数不被选择时的方案数；用 \(dp[i][j][1]\) 表示前 \(i\) 个数中选出 \(j\) 个数， 且第 \(i\) 个数被选择时的方案数。 \[\begin{aligned} dp[i][j][0] &amp; = \begin{cases} 0，\text{当前必选} \\ dp[i - 1][j][0] + dp[i - 1][j][1]，\text{其他} \end{cases} \\ dp[i][j][1] &amp; = dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] \end{aligned}\] 我们现在考虑必须要让列也递增的情况，我们来依次来考虑第一行的每个数最大可能的取值： 对于第一个数，其只能是 \(1\)。 对于第二个数，其最大是 \(3\)，因为当第二个数是 \(4\) 的时候，第二行一定得出现 \(2，3\) 此时 第二列一定不可能递增。 对于第三个数，其最大是 \(5\)，因为当第三个数是 \(6\) 的时候，第二行一定得出现 \(3，4，5\) (或者更小的数字) 此时第三列一定不可能递增。 …… 对于第 \(i\) 个数，其最大是 \(2i - 1\)。 不难发现，对于一个方案中的第 \(i\) 个数，若其均小于等于 \(2i - 1\)，那么方案一定满足列是递增的。 因此，我们只需要对上面的转移方程增加一个限制条件即可： \[\begin{aligned} dp[i][j][0] &amp; = \begin{cases} 0，\text{当前必选} \\ dp[i - 1][j][0] + dp[i - 1][j][1]，\text{其他} \end{cases} \\ dp[i][j][1] &amp; = \begin{cases} dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1]，\text{当前小于等于} 2i - 1 \\ 0，\text{其他} \end{cases} \end{aligned}\] 代码：increasing_table.cpp Bounded tuple Not finished yet. 代码： Laser Defense 我们将激光分成四种： \(a_u\)：\(a_u[i]\) 表示 \(A\) 点发出的第 \(i\) 条与上边界的交点座标。 \(a_r\)：\(a_r[i]\) 表示 \(A\) 点发出的第 \(i\) 条与右边界的交点座标。 \(b_u\)：\(b_u[i]\) 表示 \(B\) 点发出的第 \(i\) 条与上边界的交点座标。 \(b_l\)：\(b_l[i]\) 表示 \(B\) 点发出的第 \(i\) 条与左边界的交点座标。 我们分别对上面四种激光进行排序。 我们首先考虑只有 \(A\) 点激光的情况，此时被分成了 \(len(a_u) + len(a_r) + 1\) 个区域。 接着对于某个 \(B\) 点发出的激光，如果其到达左边界， 那么此时区域个数会增加 \(len(a_u) + len(a_r) + 1\)；如果其到达上边界， 此时我们可以用二分查找在 \(a_u\) 中找到有多少个激光出现在其左边，不妨设为 \(x\)， 那么此时区域个数会增加 \(len(a_u) + len(a_r) + 1 - x\)。 代码：laser_defense.cpp Another Sliding Window Problem 首先我们不难发现要获得一个序列的 optimal cost，如果序列有偶数个元素，那么最大的要和最小的配对， 第二大的要和第二小的配对，以此类推；如果序列有奇数个元素，那么最大的元素要单独拎出来， 而其余元素按照序列有偶数个元素的情况处理。 有了上面的结论，我们可以有以下推论： 如果一个序列的 optimal cost 小于等于 \(x\)， 那么删除最大的元素后的序列的 optimal cost 一定小于等于 \(x\)。 证明如下： 如果一开始序列有奇数个元素，那么删除最大的元素后，序列有偶数个元素， 那么 optimal cost 的取值集合少了最后一个元素，因此 optimal cost 不会增加。 如果一开始序列有偶数个元素，那么删除最大的元素后，序列有奇数个元素， 那么 optimal cost 的取值集合中某一个元素变小了，因此 optimal cost 不会增加。 利用上面的推论，当我们计算出一个满足 optimal cost 小于等于 \(x\) 的区间 \([l, r]\) 后， 那么 \([l, r - 1], [l, r - 2], \cdots, [l, l]\) 一定也满足 optimal cost 小于等于 \(x\)， 如果我们用 \(s[i]\) 表示 \([1, i]\) 的前缀和， 那么这些区间的对答案的贡献为：\(s[r] - s[l - 1] - (r - l + 1) \times a[l]\)。 接下来我们考虑对于一个给定的 \(l\)， 如何快速求出最大的 \(r\) 使得 \([l, r]\) 满足 optimal cost 小于等于 \(x\)。 我们还是需要利用 optimal cost 的配对性质，首先我们先找到最后一个小于等于 \(x\) 的元素的位置， 不妨设为 \(r\)，初始 \(l = r\)，那么对于当前的区间 \([l, r]\) 中的 \(r\) 一定是满足 optimal cost 小于等于 \(x\) 最大的。接下来我们考虑如何求解 \(l - 1\) 对应的最大的 \(r'\)。 实际上 \(r'\) 只有可能是 \(\{r - 1, r, r + 1\}\) 中的一个。这是因为： 如果 \([l, r]\) 的长度是偶数，那么 \([l - 1, r]\) 的长度是奇数，此时 \([l - 1, r]\) 一定是满足 optimal cost 小于等于 \(x\) 的，因为此时可以让 \(a[l - 1]\) 单独一组；同时按照匹配规则， 如果 \(a[l - 1] + a[r + 1] \le x\) 那么 \([l - 1, r + 1]\) 也一定是满足 optimal cost 小于等于 \(x\) 的。而对于 \([l - 1, r + 2]\) 一定是不满足的，因为如果该区间满足， 那么 \([l - 1, r + 1]\) 也一定满足，而 \([l - 1, r + 1]\) 长度是偶数，此时我们把 \(a[l - 1]\) 删除掉，那么 \([l, r + 1]\) 一定满足，这与 \(r\) 是最大的矛盾。 所以当前情况下 \(r'\) 只有可能是 \(\{r, r + 1\}\) 中的一个。 如果 \([l, r]\) 的长度是奇数，那么 \([l - 1, r]\) 的长度是偶数， 此时如果 \(a[l - 1] + a[r] \le x\)，那么 \([l - 1, r]\) 一定是满足 optimal cost 小于等于 \(x\) 的，进一步的有如果 \(a[r + 1] \le x\) 成立， 那么 \([l - 1, r + 1]\) 也一定是满足 optimal cost 小于等于 \(x\) 的。 而对于 \([l - 1, r + 2]\) 一定是不满足的，因为如果该区间满足，而 \([l - 1, r + 2]\) 长度是偶数， 此时我们把 \(a[l - 1], a[r + 2]\) 同时删除掉，那么 \([l, r + 1]\) 一定满足， 这与 \(r\) 是最大的矛盾。而如果一开始就不满足 \(a[l - 1] + a[r] \le x\)，那么由于 \([l, r]\) 区间长度是奇数，我们可以删除 \(a[r]\)，而增加 \(a[l - 1]\)，由于 \([l, r]\) 满足， 我们用一个更小的数字取替换了一个最大的数字形成的 \([l - 1, r - 1]\) 一定满足。 所以当前情况下 \(r'\) 只有可能是 \(\{r - 1, r, r + 1\}\) 中的一个。 因此我们只需要按照上面的过程，每次减少 \(l\) 后，计算出新的 \(r\) 对答案进行统计即可。 代码：another_sliding_window_problem.cpp IEEE754 Emulator 逻辑并不复杂，有几点需要注意的： 不能直接计算 \(a * b + c\)，应该使用相关的库函数，例如 C++ 的 std::fma，Python 的 Math.fma 等。 类型之间的转换，例如 int 和 float 之间的转换，应该使用 union 或者 memcpy 等方法， 输出要保留前导零，也就是在结果长度小于 8 的时候需要在前面补零。 代码：ieee754_emulator.cpp Triumvirates Not finished yet. 代码： Stick 除去第一个正方形外，每增加一个正方形，所增加的面积是一个定值， 其增加值为单个正方形的面积减去两个正方形的公共部分的面积。因此最终答案为 \(4NL^2 - (N-1)S\)。 其中 \(S\) 为两个连续正方形相交部分的面积。 如果直接使用上面的公式，那么乘法的时候可能会溢出，因此我们可以将上面的公式进行变形成 \(N(4L^2 - S) + S\)。并且最后得使用 unsigned long long 才行。当然 Life is short; you need Python。 代码：stick.cpp Increasing-decreasing permutations Not finished yet. 代码： Cheap Construction 首先，对于本题，答案中所选的字符串一定可以是原始串的子串。这是因为如果我们不选择原始串的子串， 那么最终的联通块一定是 \(N\)，所以对于联通块个数小于 \(N\) 情况我们一定要选择原始串的子串。 而对于要让联通块个数为 \(N\) 的情况，我们可以选择一个长度为 \(1\) 的子串。 有了上面的结论我们只需要枚举所有的子串，计算每个子串会产生的联通块个数即可。 对于如何计算一个子串的联通块个数，我们需要先计算出所有子串的出现位置。这一步当然不能用 KMP 算法， 如果使用 KMP 算法整体复杂度就变成 \(O(N^3)\) 了，我们可以直接枚举所有的子串的起始位置， 将其记录下来，而不是单独去计算每个子串的出现位置。 想到这一步之后又存在新的问题，我们不能直接使用一个字典去存储每个子串出现的位置， 因为不管是有序字典还是无序字典，其在对一个字符串进行映射的时候必须要遍历整个字符串， 这样复杂度又变成了 \(O(N^3)\)。 正确的做法是使用字符串哈希，这样可以在 \(O(N)\) 的复杂度预处理后， 只需要 \(O(1)\) 复杂度即可获取任意子串的哈希值 (本题中得使用双哈希)。 经过上面的操作后，我们获取到了每个子串的出现位置，接下来我们考虑如何计算一个子串的联通块个数。 首先我们需要保证一个子串的出现位置是从小到大排序的，这一步可以在前面枚举的时候实现， 接着我们遍历出现位置，同时记录上一个出现位置的结尾 \(las\) (即 \(las\_start\_pos + len - 1\) )， 比较 \(las\) 和当前起始位置 \(now\_start\_pos\) ， 如果 \(las \ge now\_start\_pos\) ，这意味着当前的子串和上一次的子串有重叠，此时不会产生新的联通块； 如果 \(las \lt now\_start\_pos\) ，那么从上一次的结尾到当前位置之前的将会形成新的联通块， 也就是个数会增加 \(now\_start\_pos - las\)。 最后一点，本题对常数要求非常高，如果你按照上面的思路写，那么会 TLE。这里给出一种可行的优化方案： 我们并不在一开始枚举所有的子串，而是按照长度递增的方式枚举子串， 每计算出一个长度的所有子串出现位置后就进行一次答案的更新， 这样能够让字典中存储的子串个数不超过 \(N\) 个，从而实现常数优化的目的， 即使是这样你也需要注意其他地方的细节，尽可能的优化常数， 因为我的代码在最慢的一个测试点上花费了 \(946ms\)，这非常接近 TLE。 代码：cheap_construction.cpp Disparate Date Sets 本题逻辑实际上没有任何的难点，但是如果我使用以下的方式对输入进行处理，将会出现问题： while (getline(cin, str)) { string tmp; Record tmp_record; int cnt=0; for (auto &amp;&amp;ch : str) { if (ch == ',' &amp;&amp; cnt % 2== 0) { tmp_record.push_back(tmp); tmp=""; cnt=0; } else { tmp.push_back(ch); if (ch == '\"') { cnt++; } } } tmp_record.push_back(tmp); } 而如果我将上面的读入替换成 Python 中的 csv 进行处理，就能够得到正确的结果。 我目前仍然没有发现上面的读取方式对于合法的输入会存在什么问题。我们已经确定了输入一定满足以下的情况： title 和 acronyms 中开头和结尾一定为单个双引号。 除去 title 和 acronyms 开头和结尾的双引号后，其中不存在奇数个连续的双引号。 如果你发现这段读入会对某些输入产生错误，请告诉我。 代码部分将会提供使用 csv 读取数据并处理的 Python 代码。 代码：disparate_datasets.py Queries 首先感谢 cancaneed 提供的思路。 本题我们可以采用两次分块来进行实现。分块维护区间和。 其中第一个分块用于处理在原始区间上面的更新，我们记为 \(ori\)， 第二个分块用于维护在 \(p\) 上面的更新，我们记为 \(perm\)。 对于在原始区间上的更新，我们在 \(ori\) 上更新后 (\(ori.update(l, r, c)\))， 还需要考虑其对 \(p\) 上查询的影响。例如， 如果之前存在 \([l, r]\) 区间上的更新增加 \(c\)，此时我们查询索引为 \(p_{l'}, p_{l'+1}, \cdots, p_{r'}\) 的和，那么我们需要知道 \([l, r]\) 中有多少个下标在集合 \(\{p_{l'}, p_{l'+1}, \cdots, p_{r'}\}\) 中， 如果我们将这个数字记为 \(cnt\)，那么此次查询就需要增加 \(c \times cnt\)。 所以在执行原始区间的更新时，我们还需要更新此次操作对 \(perm\) 的影响， 我们将这一部分记为 \(perm\_sum\)， 其中 \(perm\_sum[i]\) 表示对原始区间上的更新会使 \(perm\) 的第 \(i\) 块增加 \(perm\_sum[i]\)。 具体的, 对于更新 \((l, r, c)\)， 我们需要进行如下更新： \[perm\_sum[i] = perm\_sum[i] + c \times (perm\_cnt[i][r] - perm\_cnt[i][l - 1]), 0 \le i \le BLOCK\_CNT\] 这里的 \(perm\_cnt[i][j]\) 表示在 \(ori\) 的第 \(i\) 块维护的下标对应到 \(p\) 后，有多少是小于等于 \(j\) 的。 对于在 \(p\) 上的更新，同理我们需要考虑其对 \(ori\) 的影响。我们将这一部分记为 \(ori\_sum\)， 其中 \(ori\_sum[i]\) 表示对 \(p\) 上的更新会使 \(ori\) 的第 \(i\) 块增加 \(ori\_sum[i]\)。 具体的，对于更新 \((l, r, c)\)， 我们需要进行如下更新： \[ori\_sum[i] = ori\_sum[i] + c \times (ori\_cnt[i][r] - ori\_cnt[i][l - 1]), 0 \le i \le BLOCK\_CNT\] 这里的 \(ori\_cnt[i][j]\) 表示在 \(perm\) 的第 \(i\) 块维护的下标对应到 \(ori\) 后，有多少是小于等于 \(j\) 的。 对于原始区间上的查询操作，首先需要查询 \(ori.query(l, r)\)， 对于覆盖到整个块 \(id\) 的部分，我们需要累加 \(ori\_sum[id]\)，对于部分块， 我们必须依次在 \(perm\) 上进行单点查询， 因此我们需要维护 \(inv\_p[i]\) 表示原始下标 \(i\) 在 \(perm\) 上的位置，即 \(inv\_p[p[i]] = i\)。 对于 \(p\) 上的查询操作，首先需要查询 \(perm.query(l, r)\)， 对于覆盖到整个块 \(i\) 的部分，我们需要累加 \(perm\_sum[i]\)，对于部分块， 我们必须依次在 \(ori\) 上进行单点查询，也就是去查询 \(ori\) 中 \(p[i]\) 处的值。 上面的操作时间复杂度均为 \(O({N \over BLOCK\_SIZE} + BLOCK\_SIZE)\) 的。 最后我们还要考虑计算 \(perm\_cnt\) 和 \(ori\_cnt\) 的时间复杂度，这一部分， 我们预处理的时候枚举块数量以及下标即可，因此时间复杂度为 \(O({N^2 \over BLOCK\_SIZE})\)。 由于空间的限制，我们的 \(BLOCK\_SIZE\) 不能太小，既不能选择理论最优值 \(BLOCK\_SIZE = \sqrt{N}\)， 此时我们可以选择 \(BLOCK\_SIZE = 600\)，能够保证通过。 代码：queries.cpp Doubled Sequence Not finished yet. 代码： Icarus 我们记 \(l_c\) 表示 \(S\) 中 L 的出现次数，\(r_c\) 表示 \(S\) 中 R 的出现次数，\(u_c\) 表示 \(S\) 中 U 的出现次数。 我们总可以通过构建一条链使其满足题目条件。这里我们以 \(l_c \le u_c\) 为例， 其余的情况可以进行类似的讨论。 当 \(l_c \le u_c\) 时，我们可以构建一条有 \(u_c + 2\) 个结点的链， 链上的结点均以左结点的方式进行连接。这样构造后，输入中的 R 将可以被忽略， 同时我们可以在这个链上找到一个结点， 其满足从当前结点触发的第一轮操作中所有的 L 和 U 都是合法移动且最深的结点不会被访问到。 如何找到这样的点呢？我们可以先假设我们在一个两端无限长的链上的某个结点，初始化 \(depth\) 为 \(0\)， 我们遍历输入中的移动操作，对于 L 我们将 \(depth\) 减一，对于 U 我们将 \(depth\) 加一，记录这个 过程中最小的 \(depth\)，不妨记为 \(high\)，如果我们将链上的结点按照深度从低到高进行编号， 那么我们从编号为 \(-high + 1\) 的结点出发，后续的所有操作一定不能访问到编号为 \(u_c + 2\) 的结点。 这是因为我们从编号为 \(-high + 1\) 的点出发的话，第一轮操作肯定都是合法的， 且不会到达编号为 \(u_c + 2\) 的结点； 对于第二轮操作，我们的起点一定是编号 \(-high + 1\) 的结点或者其祖先。 如果第二轮起点是编号为 \(-high + 1\) 的结点，那么此后续操作便开始循环，不会到达 \(u_c + 2\)； 如果第二轮起点是编号为 \(-high + 1\) 的结点的祖先，那么第二轮可能会有一些 U 操作失效， 实际上第二轮的起点与第一轮的起点的深度差的绝对值 (不妨记为 \(x\)) 就是 U 操作最多失效的次数， 下面来解释为什么第二轮的 U 操作最多失效 \(x\) 次。如果有多于 \(x\) 次的 U 操作失效， 不妨记为 \(x'\)，此时我们假设链变成无限长， 那么这 \(x'\) 次失效的 U 操作将会使到达的最低深度减少 \(x'\)， 这意味着我们的起点深度较上一轮应该减少 \(x'\)，这就出现了矛盾。 这个结论意味着，当 U 的失效次数达到最大值时，我们第二轮的终点也不过是回到了第一轮的起点， 且这个过程中到达的最大深度也不过是第一轮到达的最大深度；而其余情况下， 我们的终点深度一定小于第一轮的起点深度，到达的最大深度也一定小于第一轮到达的最大深度。 继续这样推下去，我们便可以发现之后每一轮都不会到达 \(u_c + 2\)。 这里还有一点需要注意的是，如果 \(l_c = 0\)，而 \(u_c = 1\)， 此时按照上面的方法会构造出 \(3\) 个结点的树，这一点不满足题目的限制条件。 因此我们需要对这一部分进行特判。这里我们只需要构造一个有 \(2\) 个结点的树，\(2\) 为 \(1\) 的左结点， 那么从 \(1\) 号结点出发永远不会到达 \(2\) 号结点。 当然我们可以在上面的思路中选择构造结点个数为 \(2 (l_c + u_c + r_c)\) 的链，这样也可以解决这一部分。 其余的情况可以进行类似的讨论。 代码：icarus.cpp Power of three 设 \(M\) 表示输入 \(N\) 的位数，我们计算出 \(x_{min} = (M - 1) \lfloor \log_3 10 \rfloor\)， 不难发现如果有解 \(x\)，那么 \(x \ge x_{min}\) 时，且在理论上 \(x - x_{min} \le 3\)， 这是因为 \(3^3 = 27\)，也就是乘以 \(3\) 个 \(3\) 之后，位数会增加 \(1\)。 同时对于解 \(x\) 我们有 \(3^x \equiv N \pmod{P}\)，其中 \(P\) 是任意的数， 因此我们可以提前确定多个质数，从 \(x = x_{min}\) 开始， 然后检查是否对于这些质数都有 \(3^x \equiv N \pmod{P}\)，如果成立， 我们可以大概率认为这个 \(x\) 是答案。如果 \(x\) 在 \(3\) 次递增的过程中没有找到答案， 那么我们输出 \(-1\) 即可。 代码：power_of_three.cpp Halving 我们先考虑什么情况下无解。首先我们先尝试将能确定的元素进行确定，因为这些元素对方案数没有贡献。 哪些元素能够被确定下来？一共有两种： 已经给定的元素。 对于第 \(i\) 对，其中一个元素为 \(-1\)，另一个元素不为 \(B_i\)， 那么可以将为 \(-1\) 的元素确定为 \(B_i\)。 经过上述操作后，我们只需要检查确定的元素是否只出现了一次， 以及如果第 \(i\) 对中两个元素同时被确定其是否满足最小值或最大值为 \(B_i\) 来判断是否有解。 接下来我们考虑如何求解有解情况下的方案数。我们可以使用动态规划的方法， 原问题等价于求使用没有在 \(B\) 中出现的元素与在 \(B\) 中的元素进行配对 (不考虑顺序) 的方案数， 该方案数与答案相比只是少乘了 \(2^k\)，这是因为第一步填入确定元素的操作后， 我们需要确定的元素对只可能出现以下两种情况： 两个元素均为 \(-1\)。 一个元素为 \(-1\)，另一个元素为 \(B_i\)。 对于第一种情况，我们可以确定其中一个为 \(B_i\)，另一个为比 \(B_i\) 大或者小的元素， 由于两者位置不确定，所以此时等价于求解能与 \(B_i\) 配对的元素的个数再乘以 \(2\)。 对于第二种情况，等价于求解能与 \(B_i\) 配对的元素的个数。 因此我们可以用 \(dp[i][j][k]\) 来表示用 \(1, 2, ..., i\) 中不在 \(B\) 中的元素与在 \(B\) 中的元素配对， 且在 \(1, 2, ..., i\) 中有 \(j\) 个在 \(B\) 中的元素未配对有 \(k\) 个不在 \(B\) 中的元素未配对 (这个定义有点拗口)。 接下来我们考虑如何进行转移，首先我们需要确定 \(i\) 的三种情况： \(i\) 是一个已经拥有确定匹配的元素。 \(i\) 未拥有确定匹配且在 \(B\) 中。 \(i\) 未拥有确定匹配且不在 \(B\) 中。 这里的拥有确定匹配是指：如果一对元素的两个元素均在第一步中被确定，那么这两个元素就拥有确定匹配。 对于第一种情况，显然 \(dp[i][j][k] = dp[i - 1][j][k]\)。 对于第二种情况，我们需要根据是需要找比 \(i\) 大的元素还是比 \(i\) 小的元素进行转移： \[dp[i][j][k] = \begin{cases} dp[i - 1][j][k]，\text{找比} i \text{大的元素} \\ dp[i - 1][j[k + 1] \times (k + 1)，\text{找比} i \text{小的元素} \end{cases}\] 第二种情况的第一个转移方程是因为我们不能在 \(1, 2, 3, ..., i - 1\) 中找到比 \(i\) 大的元素， 所以此时只能暂时不对 \(i\) 进行配对。 第二个转移方程则是所有在 \(1, 2, 3, ..., i - 1\) 中不在 \(B\) 中的元素未配对的元素均可以与 \(i\) 配对， 且配对后这一部分未配对的元素个数会减少 \(1\)。 对于第三种情况，由于在第二种情况中我们保证了 \(B\) 中未参与配对的元素一定是比 \(i\) 小的， 所以此时我们有以下的转移方程： \[dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i - 1][j + 1][k] \times (j + 1)\] 第三种情况中的 \(dp[i - 1][j][k - 1]\) 表示我们可以暂时不对 \(i\) 进行配对， 而 \(dp[i - 1][j + 1][k] \times (j + 1)\) 代表我们可以选择任意一个在 \(B\) 中未参与配对的元素与 \(i\) 配对， 配对之后这一部分未配对的元素个数会减少 \(1\)。 通过观察三部分的方程不难发现我们可以使用滚动数组将空间复杂度从 \(O(N^3)\) 优化到 \(O(N^2)\)。 最后的答案即为 \(dp[2N][0][0] \times 2^k\)，其中 \(k\) 表示初始有多少对元素对中的元素同时为 \(-1\)。 代码：halving.cpp King’s Order 直接使用拓扑排序即可，只是在拓扑排序中需要将普通队列替换成优先队列。 优先队列的比较器设置为题目要求即可。 代码：kings_order.cpp Balls 本题是 Codeforces 在十三年前某场比赛的原题， 原题的链接：Codeforces 93 E. Lostborn。 本题的思路来源于题解：Codeforces Beta Round 76 - задача Е div 1 глазами ее автора. 首先我们需要反向考虑问题，具体的， 我们定义 \(f_{E_1, E_2, \dots, E_K}(N)\) 表示给定 \(N\) 和 \(K\) 个球的情况下有多少个点没有被命中， 那么命中的点即为 \(N - f_{E_1, E_2, \dots, E_K}(N)\)。 首先我们考虑 \(f_{E_1, E_2, \dots, E_K}(N)\) 是否存在某种递推关系。事实上，由容斥原理我们有以下的递推关系： \[f_{E_1, E_2, \dots, E_K}(N) = f_{E_2, E_3, \dots, E_K}(N) - f_{E_2, E_3, \dots, E_K}(\lfloor \frac{N}{E_1} \rfloor)\] 为了理解上面的递推公式， 我们可以考虑对于给定 \(N\) 和 \(E_2, E_3, \dots, E_K\) 的情况下增加 \(E_1\) 会有多少个新的点被覆盖。 我们知道如果增加 \(E_1\)， 那么 \(1 \times E_1, 2 \times E_1, \dots, \lfloor \frac{N}{E_1} \rfloor \times E_1\) 这些点会被覆盖， 那么这些点里面哪些点是新增的呢？由于 \(E_1\) 与其他的 \(E_i\) 互质，在 \(1, 2, \dots, \lfloor \frac{N}{E_1} \rfloor\) 这些数中如果某个数与所有的 \(E_i\) 互质，那么这个数一定是新增的点， 这一部分刚好对应 \(f_{E_2, E_3, \dots, E_K}(\lfloor \frac{N}{E_1} \rfloor)\)。这也是为什么我们会有以上的递推式。 我们对上面的递推式起个别名： \[dp[i][j] = f_{E_i, E_{i+1}, \dots, E_K}(j)\] 那么就有如下的动态转移方程： \[dp[i][j] = dp[i + 1][j] - dp[i + 1][\lfloor \frac{j}{E_i} \rfloor]\] 接下来我们来考虑上面式子的复杂度。你可能会说这不是显然的 \(O(NK)\) 吗？是的如果使用递推来做的话， 复杂度确实是 \(O(NK)\)。但是实际上并不是所有的状态都是有用的状态， 因此如果我们使用递归来实现，我们的时间复杂度实际上为有用的状态个数。 如何估计有用状态的个数？首先上面式子 \(i\) 的取值数一定是 \(K\) 种，接下来我们考虑 \(j\) 取值种数。 不难发现对于任何一个可能的 \(j\) 其一定可以写成 \(\lfloor \frac{N}{a} \rfloor\) 的形式， 其中 \(a\) 是某个正整数。也就是说要估计 \(j\) 的种类数， 我们只需要考虑 \(\lfloor \frac{N}{a} \rfloor\) 的种类数， 而 \(\lfloor \frac{N}{a} \rfloor\) 的种类数不会超过 \(min(a 的种类数, \lfloor \frac{N}{2} \rfloor + 2)\)， 这里第二部分是因为当 \(a = \lfloor \frac{N}{2} \rfloor, N \gt 3\) 时，\(\lfloor \frac{N}{a} \rfloor\) 为 \(2\)， 就算对于 \(a \in [1, \lfloor \frac{N}{2} \rfloor]\)，\(\lfloor \frac{N}{a} \rfloor\) 均获得了不同的值， 此时继续增加 \(a\) 也只能获得 \(1, 0\) 两种结果。 考虑到显然有下式成立： \[min(a, \lfloor \frac{N}{a} \rfloor) \le \sqrt{N}\] 故 \(j\) 的种类数不会超过 \(2 \sqrt{N}\)，因此有用状态的个数不会超过 \(2K \sqrt{N}\)。 这对应的时间复杂度为 \(O(K \sqrt{N})\)。但实际上如果我们对 \(E\) 按照从大到小的顺序排序， 那么 \(N\) 会下降的非常快，这样我们实际上的复杂度会远远小于 \(O(K \sqrt{N})\)。 我们当然不能对所有可能的状态都进行记忆化，这样会导致我们不得不使用字典， 这往往会让我们的时间复杂度变为 \(O(K \sqrt{N} log(K \sqrt{N}))\)，且常数非常大。 正确的做法是我们只在 \(N\) 较小时进行记忆化的操作。 这是因为对于递归而言，我们越小的部分被重复计算的次数相较较大的部分会更多。 代码：balls.cpp Corporation 首先感谢 yanire 提供的思路。 我们可以使用分块来解决这个问题，具体的我们将整个工资序列分成大小为 \(\sqrt{N}\) 的块， 最后一块的大小可能小于 \(\sqrt{N}\)。每块维护以下信息： sum_salary：块内所有工资的和。 sum_happiness：块内幸福值的和。 lazy_salary：块内每个员工的工资增量。 lazy_happiness：块内每个员工的幸福值增量。 all_same：块内每个员工的工资值是否相同。 对于增加操作： 如果覆盖整个块，那么可以在 \(O(1)\) 的时间内完成更新，最多重复 \(O(\sqrt{N})\) 次， 时间复杂度为 \(O(\sqrt{N})\)。 如果覆盖部分块，那么需要遍历当前被覆盖的块，然后重新计算块内的信息， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。 对于设置操作： 如果覆盖整个块且整个块的每个员工工资值相同，那么可以在 \(O(1)\) 的时间内完成更新， 最多出现 \(O(\sqrt{N})\) 次，时间复杂度为 \(O(\sqrt{N})\)。 如果覆盖整个块但整个块的每个员工工资值不同，那么需要遍历整个块，然后重新计算块内的信息， 时间复杂度为 \(O(\sqrt{N})\)。对于这种情况下， 我们考虑一开始最多有 \(O(\sqrt{N})\) 个 all_same 为 false 的块， 我们每次通过设置操作遍历一整个块的时候，all_same 为 false 的块的数量会减少一， 而每次增加操作最多可能会让 all_same 为 false 的块数量增加二， 这意味着 \(Q\) 次操作中最多会执行 \(O(\sqrt{N} + Q)\) 次遍历整个块的操作， 均摊下来每次操作只会执行 \(O(1)\) 次。 如果覆盖部分块，那么需要遍历当前被覆盖的块，然后重新计算块内的信息， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。 对于查询操作： 如果覆盖整个块，那么可以在 \(O(1)\) 的时间内完成查询，最多重复 \(O(\sqrt{N})\) 次， 时间复杂度为 \(O(\sqrt{N})\)。 如果覆盖部分块，那么需要遍历当前被覆盖的块， 最多会出现两次 (两个边界块) 这种情况，时间复杂度为 \(O(\sqrt{N})\)。 综上我们可以发现上述方法的时间复杂度为 \(O(\sqrt{N}N+\sqrt{N}Q)\)。 最后需要使用快速读写减少常数的影响。 代码：corporation.cpp This is not an optimization problem 首先感谢 cancaneed 提供的思路。 首先我们考虑计算大小为 \(k\) 时的结果。 此时我们依次考虑每个结点 \(u, 1 \le u \le N\) 的权重对答案的贡献。 对于结点 \(u\) 而言， 其贡献次数显然为从 \(N\) 个结点中选择 \(k\) 个结点的方案数减去没有选中 \(u\) 的方案数。 对于从 \(N\) 个结点中选择出 \(k\) 个结点的方案数，我们可以使用组合数的方法计算， 即为 \({N \choose k}\)。 接下来我们考虑什么情况下不会选择 \(u\)。 如果选择了 \(k\) 个结点并通过增加一些其他结点构成一棵树且没有选择 \(u\) 那么所有选择的结点一定在 \(u\) 的同一个相邻分支中。 这是显然的，如果存在两个结点在 \(u\) 的不同分支中，那么这两个结点之间一定有一条路径需要经过 \(u\) 结点。 那么这一部分的方案数即为 \(\sum_{v \in adj(u)} {sz[v] \choose k}\)。 其中 \(sz[v]\) 表示删除 \(u\) 结点后，以 \(v\) 为根的子树的结点个数。 结合上面两部分那么大小为 \(k\) 的答案即为： \[\sum_u w[u]{N \choose k} - \sum_u \sum_{v \in adj(u)} w[u]{sz[v] \choose k}\] 接下来我们考虑将所有的相同组合数进行合并，设最后的系数为 \(b[i]\)，那么我们有： \[\sum_{i = 0}^{N} b[i] {i \choose k} = \sum_{i = 0}^{N} \frac{i!b[i]}{k!(i-k)!} = \frac{1}{k!} \sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\] 首先我们考虑如何计算系数 \(b[i]\)。我们只需要考虑每个结点 \(u\) 对其邻居的影响即可。具体的， 我们在 DFS 的过程中，设当前到达的结点为 \(u\)，\(u\) 的父结点为 \(par\) 子结点为 \(v\)， 那么 \(u\) 可以作为一整棵子树与 \(par\) 相连， 也就是我们在计算 \(par\) 贡献的时候可以在以 \(u\) 为根的子树中选择 \(k\) 个结点， 此时 \(b[sz[u]]\) 会减少 \(w[par]\) (系数为负)；同时，我们在计算 \(v\) 贡献的时候， 可以在除去以 \(v\) 为根的子树后的其他结点中选择 \(k\) 个结点，此时对应 \(b[n - sz[v]]\) 减少 \(w[v]\)。 最后不要忘记 \(b[n]\) 还需要增加 \(w[u]\) (对应 \(\sum_u {N \choose k}\))。 接下来我们考虑如何计算 \(\frac{1}{k!} \sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\)， 这里我们考虑计算 \(\sum_{i = 0}^{N} \frac{i!b[i]}{(i-k)!}\)， 最后的 \(\frac{1}{k!}\) 只需要在最后乘上乘法逆元即可。 我们构造两个 \(N\) 次多项式： \[\begin{aligned} P_1(x) &amp;= n!b[n] + (n - 1)!b[n-1]x + (n - 2)!b[n-2]x^2 + \dots + 0!b[0]x^n \\ P_2(x) &amp;= \frac{1}{0!} + \frac{1}{1!}x + \frac{1}{2!}x^2 + \dots + \frac{1}{n!}x^n \end{aligned}\] 我们考虑求 \(P_1(x)P_2(X)\) 的 \(x^{n-k}\) 的系数： \[Coef(x^{n-k}, P_1(x)P_2(x)) = \frac{n!b[n]}{(n-k)!} + \frac{(n-1)!b[n-1]}{(n-k-1)!} + \dots + \frac{(n-k)!b[n-k]}{(0)!} = \sum_{i = 0}^{n} \frac{i!b[i]}{(i-k)!}\] 这意味着我们只需要计算 \(P_1(x)P_2(x)\) 的 \(x^{n-k}\) 的系数再乘上 \({1 \over k!}\) 即为答案，此过程通过任意模数的 NTT 算法即可完成。 代码：this_is_not_an_optimization_problem.cpp Digits swap 直接暴力搜索即可，搜索的时候注意只有当当前这一位与其最大可能性不同时才进行搜索。 理论时间复杂度为 \(O(N^K)\)，但实际上跑得飞快。 给出几种常见贪心的反例： 每次选靠前最大的和当前位置交换：例如 \(12344\ 2\)，如果按照这种方法会得到 \(44312\) ， 实际最优为 \(44321\)。 每次选靠后最大的和当前位置交换：例如 \(21344\ 2\)，如果按照这种方法会得到 \(44312\) ， 实际最优为 \(44321\)。 每次选靠后最大的和当前位置交换，交换完某种数字后进行一次从大到小的排序：例如 \(45366\ 3\)， 选择靠后最大交换两次后 \(66345\)，对 \(45\) 进行排序得到 \(66354\)， 再进行一次交换得到 \(66534\)，实际最优为 \(66543\)。 代码：digits_swap.cpp Brick stacks 我们先从小到大排序，然后依次处理每一个元素，对于当前元素，如果已经形成了 \(pile\) 堆， 我们只需要记录形成的堆的最下方的元素，不妨用 \(pile[i]\) 表示第 \(i\) 堆最下方的元素， 然后尝试将当前元素放到这些堆中，实际上我们只需要检查当前元素是否可以放到最小的 \(pile[i]\) 所在的堆中， 这是因为： 如果当前的元素不能放入最小的 \(pile[i]\) 所在的堆中，那么它一定不能放入其他堆中； 如果设 \(pile_{min}\) 表示最小的 \(pile_[i]\)，\(pile_j\) 表示其他任意一个非最小的 \(pile[i]\)， 那么不会存在当前元素可以放入 \(pile_{min}\) 和 \(pile_j\)，但在当前元素放入 \(pile_{min}\) 后， 下一个元素不能放入 \(pile_j\)，且如果当前元素放入 \(pile_j\) 后，下一个元素可以放入 \(pile_{min}\) 的情况。 对于上述的第二点，可以有如下的证明： 首先 \(pile_{min} + x \gt pile_j\)，否则可以将 \(pile_j\) 的最后一块放到 \(pile_{min}\) 后面。 其次如果 \(A_i + x \le A_{i+1}\)，那么下一个元素一定是能放在 \(A_i\) 所在堆的； 如果 \(A_i + x \gt A_{i+1}\)，而我们将上面第二点写成不等式与该不等式进行联立： \[\begin{cases} pile_j &gt; pile_{min} \\ pile_{min} + x \gt pile_j \\ A_i + x \gt A_{i+1} \\ pile_{min} + x \le A_i \\ pile_{min} + x \le A_{i+1} \\ pile_j + x \gt A_{i+1} \\ pile_j + x \le A_i \\ A_{i+1} \gt A_{i} \\ \end{cases}\] 上面的最后三个存在矛盾，因此不可能有解。 这就意味着，我们可以用一个小根堆维护形成的堆的最后一个元素，每次尝试将新的数放入到堆顶所形成的堆， 如果不能放置，则形成一个新的堆加入到堆中。 代码：brick_stacks.cpp Stones 首先感谢 cancaneed 提供的思路。 我们记 \((R1, B1, R2, B2)\) 为藏球方红球有 \(R1\) 个，蓝球有 \(B1\) 个； 猜球方红球有 \(R2\) 个，蓝球有 \(B2\) 个的状态时猜球方的最优策略下的最大获胜概率。 如果我们设 \(p\) 为藏红球的概率，\(q\) 为猜红球的概率， 同时我们设 \(rr := 1 - (R2, B2, R1-1, B1), rb := 1 - (R2, B2-1, R1, B1), br := 1 - (R2-1, B2, R1, B1), bb := 1 - (R2, B2, R1, B1 - 1)\)， 我们不难写出以下的转移方程： \[(R1, B1, R2, B2) = p \cdot q \cdot rr \cdot + p \cdot (1-q) \cdot rb + (1-p) \cdot q \cdot br + (1-p) \cdot (1-q) \cdot bb\] 由于双方均追求最大化获胜结果，所以我们需要对上面的式子分别关于 \(p, q\) 求导并令其为 \(0\)： \[\begin{cases} \frac{\partial (R1, B1, R2, B2)}{\partial p} = q \cdot rr + (1-q) \cdot rb - q \cdot br - (1-q) \cdot bb=0 \\ \frac{\partial (R1, B1, R2, B2)}{\partial q} = p \cdot rr - p \cdot rb + (1-p) \cdot br - (1-p) \cdot bb=0 \end{cases}\] 解上面的方程可以得到： \[\begin{cases} p=\frac{bb - br}{rr - rb - br + br} \\ q=\frac{bb - rb}{rr - rb - br + bb} \\ \end{cases}\] 最后带入 \((R1, B1, R2, B2)\) 即可。 代码：stones.cpp Rectangles and arrays 我们首先考虑不进行修改的情况，那么我们可以使用单调栈来解决这个问题，具体的，我们需要计算出： \(l1[i]\)：表示第 \(i\) 个元素左侧第一个比它小的元素的位置，如果不存在则设置为最小下标减一。 \(r1[i]\)：表示第 \(i\) 个元素右侧第一个比它小的元素的位置，如果不存在则设置为最大下标加一。 那么统计不进行修改的部分就是 \(\max\limits_{1 \le i \le N}(r1[i] - l1[i] - 1)A_i\)， 这里公式表示以 \(A_i\) 为最小值所能形成的最大的正方形。 接下来我们考虑需要修改的情况，首先如果要修改某个元素， 我们直接将其修改为 \(X\) 一定会比修改成一个比 \(X\) 小的数更优。 这意味着对于 \(A_i \ge X\) 的元素，我们没有必要修改， 所有后面的修改将会针对满足 \(A_i \lt X\) 的元素。 接下来我们考虑如果将 \(A_i\) 修改成 \(X\)，会对哪些部分产生影响。 显然对于 \(l1[j] = i, j \gt i\) 和 \(r1[j] = i, j \lt i\) 的位置 \(j\)， 其 \(l1[j], r1[j]\) 可能会发生变化。 对于 \(i\) 位置，其 \(l1[i], r1[i]\) 也可能会发生变化。 因此， 我们只需要计算出修改 \(A_i\) 为 \(X\) 后的新的 \(l1_i, r1_i\) 即可按照之前的公式进行更新。 实际上对于非 \(i\) 位置的变化，显然 \(l1, r1\) 会变成左右两侧第二个比它小的元素的位置。 为了避免混淆，我们增加以下定义： \(l2_i\)：表示第 \(i\) 个元素左侧第二个比它小的元素的位置，如果不存在则设置为最小下标减一。 \(r2_i\)：表示第 \(i\) 个元素右侧第二个比它小的元素的位置，如果不存在则设置为最大下标加一。 \(l3_i\): 表示将第 \(i\) 个元素修改为 \(X\) 后左侧第一个比它小的元素的位置，如果不存在则设置为最小下标减一。 \(r3_i\): 表示将第 \(i\) 个元素修改为 \(X\) 后右侧第一个比它小的元素的位置，如果不存在则设置为最大下标加一。 而修改 \(i\) 位置对 \(j\) 造成影响实际上就是在修改 \(j\) 位置左侧或者右侧第一个比它小的元素。 因此这一部分的贡献就是 \(\max\limits_{1 \le i \le N}\{(r2[i] - l1[i] - 1)A_i, (r1[i] - l2[i] - 1)A_i, (r3[i] - l3[i] - 1)X\}\)。 上面使用 \(r2[i] - l1[i] - 1\) 和 \(r1[i] - l2[i] - 1\) 而不直接使用 \(r2[i] - l2[i] - 1\) 是因为我们只能修改一个元素， 而不能同时将左右两个第一个比当前小的元素修改为 \(X\)。 下面我们来介绍如何计算 \(l2, r2, l3, r3\)。 这里以计算 \(l2\) 为例介绍如何计算 \(l2, r2\)。计算这一部分，我们需要用到三个栈， 第一个栈与在计算 \(l1\) 时作用一样，而第二个栈用于保存从第一个栈中弹出的元素，由于栈是先进后出的， 第三个栈用于将从第一个栈中弹出的元素逆序放入到第二个栈中。 当然也可以将第二个栈换成队列，每次从队首取元素即可。这样操作后当从第二个栈弹出元素的时候， 也就找到了左侧第二个比栈顶元素小的元素。代码如下： for (int i=n; i &gt;= 1; i--) { while (!s2.empty() &amp;&amp; a[s2.top()] &gt; a[i]) { l2[s2.top()] = i; s2.pop(); } while (!s1.empty() &amp;&amp; a[s1.top()] &gt;= a[i]) { s3.push(s1.top()); s1.pop(); } s1.push(i); while (!s3.empty()) { s2.push(s3.top()); s3.pop(); } } while (!s1.empty()) { l2[s1.top()] = 0; s1.pop(); } while (!s2.empty()) { l2[s2.top()] = 0; s2.pop(); } 计算完成后不要忘记排除 \(X &lt; A_i\) 的情况： for (int i=1; i &lt;= n; i++) { if (x &lt; a[i]) { l2[i] = l1[i]; } } 这里以计算 \(l3\) 为例介绍如何计算 \(l3, r3\)。计算 \(l3\) 与计算 \(l1\) 类似。 只是我们需要比较的值从 \(A_i\) 变成了 \(X\)，但是这样会导致后续计算的时候有一些元素被提前弹出了栈， 实际上，我们可以先将弹出的元素放到一个队列里面，等到计算完 \(l3[i]\) 后再将这些元素放回栈中。 代码如下： for (int i=1; i &lt;= n; i++) { queue&lt;int&gt; now_pop; while (!s.empty() &amp;&amp; a[s.top()] &gt;= x) { now_pop.push(s.top()); s.pop(); } l3[i] = (s.empty() ? 0 : s.top()); while (!now_pop.empty()) { s.push(now_pop.front()); now_pop.pop(); } while (!s.empty() &amp;&amp; a[s.top()] &gt;= a[i]) { s.pop(); } s.push(i); } 代码：rectangles_and_arrays.cpp Invertible Pairs 我们可以使用动态规划解决这一题，具体的我们用 \(dp[i][0]\) 表示前 \(i\) 个数， 以 \(i\) 结尾且第 \(i\) 个数不发生翻转的最大和，用 \(dp[i][1]\) 表示前 \(i\) 个数， 以 \(i\) 结尾且第 \(i\) 个数发生翻转的最大和。我们可以写出以下的转移方程： \[\begin{aligned} dp[i][0] &amp;= \begin{cases} max(a[i], dp[i - 1][0] + a[i])，i \equiv 0 \pmod{2} \\ max(a[i], dp[i - 1][0] + a[i], dp[i - 1][1] + a[i])，i \equiv 1 \pmod{2} \\ \end{cases} \\ dp[i][1] &amp;= \begin{cases} max(-a[i], dp[i - 1][1] - a[i])，i \equiv 0 \pmod{2} \\ max(-a[i], dp[i - 1][0] - a[i], dp[i - 1][1] - a[i])，i \equiv 1 \pmod{2} \end{cases} \end{aligned}\] 代码：invertible_pairs.cpp Sierpinski 我们可以直接使用递归的方法来解决，我们首先需要确定当前行号，需要经过多少次构建才能构建出来， 不妨设为 \(cnt\)，这样的操作是 \(O(logx)\) 的，因为每次构建行数为上一次的两倍加一。 同时我们也可以获取到 \(cnt - 1\) 次构造后会有多少行，不妨设为 \(last\_end\)， 那么第 \(x\) 行的 \([x - las\_end，las\_end + 1]\) 列一定全是蓝色， 因为这一部分对应的是中间的大蓝三角形。因此我们有以下递归操作： 如果 \(y \in [x - las\_end, las\_end + 1]\)，我们直接返回蓝色； 如果 \(y \lt x - las\_end\)，不难发现当前颜色与 \((x - las\_end - 1, y)\) 相同，此时递归调用； 如果 \(y \gt las\_end + 1\)，不难发现当前颜色与 \((x - las\_end - 1, y - las\_end - 1)\) 相同， 此时递归调用。 代码：invertible_pairs.cpp]]></summary></entry><entry><title type="html">马拉松 4 小时挑战记录</title><link href="https://kaiser-yang.github.io/blog/2024/marathon-4-hours-preparation/" rel="alternate" type="text/html" title="马拉松 4 小时挑战记录"/><published>2024-10-14T11:51:59+00:00</published><updated>2024-10-14T11:51:59+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/marathon-4-hours-preparation</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/marathon-4-hours-preparation/"><![CDATA[<p>本文主要用于实时记录自己马拉松破 <code class="language-plaintext highlighter-rouge">4:00:00</code> 的准备过程。</p> <h1 id="个人情况介绍">个人情况介绍</h1> <h2 id="基本信息">基本信息</h2> <table> <thead> <tr> <th>项目</th> <th>详情</th> </tr> </thead> <tbody> <tr> <td>性别</td> <td>男</td> </tr> <tr> <td>年龄</td> <td><code class="language-plaintext highlighter-rouge">23</code></td> </tr> <tr> <td>身高</td> <td><code class="language-plaintext highlighter-rouge">178cm</code></td> </tr> <tr> <td>体重</td> <td><code class="language-plaintext highlighter-rouge">71kg</code></td> </tr> </tbody> </table> <h2 id="跑步相关经历">跑步相关经历</h2> <ul> <li><code class="language-plaintext highlighter-rouge">2016-2017</code>：<code class="language-plaintext highlighter-rouge">16</code> 年年初开始运动 (以俯卧撑、引体向上等徒手训练为主)，一直坚持到年底，期间跑过 四五次 <code class="language-plaintext highlighter-rouge">1~3km</code> 距离的中长跑。</li> <li><code class="language-plaintext highlighter-rouge">2017-2018</code>：坚持徒手训练。跑过几次 <code class="language-plaintext highlighter-rouge">3km</code>。</li> <li><code class="language-plaintext highlighter-rouge">2018-2019</code>：徒手训练断断续续进行。秋天进行了一到两个月的跑步，每次距离在 <code class="language-plaintext highlighter-rouge">3km</code> 左右，当时配速 <code class="language-plaintext highlighter-rouge">5:00</code>，这段时间获得本人 <code class="language-plaintext highlighter-rouge">1km</code> 最好成绩：<code class="language-plaintext highlighter-rouge">3:40</code>。</li> <li><code class="language-plaintext highlighter-rouge">2019-2020</code>：断断续续徒手训练，秋天进行一个月左右的跑步，每次跑 <code class="language-plaintext highlighter-rouge">3km</code>，配速 <code class="language-plaintext highlighter-rouge">5:00</code>。年底办了健身房 的卡, 一年期限，开始徒手和器械结合训练。</li> <li><code class="language-plaintext highlighter-rouge">2020-2021</code>：到健身卡过期之前一直进行徒手和器械结合训练。秋天进行一个月左右的跑步，每次跑 <code class="language-plaintext highlighter-rouge">3.5km</code>， 配速 <code class="language-plaintext highlighter-rouge">5:00</code>。</li> <li><code class="language-plaintext highlighter-rouge">2021-2022</code>：很少进行力量训练，秋天进行一个月左右的跑步，每次跑 <code class="language-plaintext highlighter-rouge">3km</code>，配速 <code class="language-plaintext highlighter-rouge">5:00</code>。</li> <li><code class="language-plaintext highlighter-rouge">2022-2023</code>：几乎无运动经历。</li> <li><code class="language-plaintext highlighter-rouge">2023-2024</code>：<code class="language-plaintext highlighter-rouge">23</code> 年九月份之前几乎无运动经历，九月开始进行徒手力量训练。</li> <li><code class="language-plaintext highlighter-rouge">2024-2025</code>：<code class="language-plaintext highlighter-rouge">24</code> 年二月分之前一直进行徒手训练，二月至七月无运动经历。八月开始骑车，每次距离 <code class="language-plaintext highlighter-rouge">30-100km</code> 不等。八月底开始跑步，第一次的时候跑了 <code class="language-plaintext highlighter-rouge">3.6km</code>，配速 <code class="language-plaintext highlighter-rouge">7:22</code>。后面跑步固定一周五次，周一到周四每次 <code class="language-plaintext highlighter-rouge">6km</code>， 周五不低于 <code class="language-plaintext highlighter-rouge">10km</code>，周六骑行 <code class="language-plaintext highlighter-rouge">100km</code>，跑步配速不低于 <code class="language-plaintext highlighter-rouge">6:00</code>，骑车均速一般不低于 <code class="language-plaintext highlighter-rouge">25km/h</code>。</li> </ul> <h2 id="近期跑步成绩">近期跑步成绩</h2> <table> <thead> <tr> <th>项目</th> <th>详情</th> </tr> </thead> <tbody> <tr> <td>最好 <code class="language-plaintext highlighter-rouge">1km</code> 成绩</td> <td><code class="language-plaintext highlighter-rouge">3:59</code></td> </tr> <tr> <td>最好 <code class="language-plaintext highlighter-rouge">3km</code> 成绩</td> <td><code class="language-plaintext highlighter-rouge">13:37</code></td> </tr> <tr> <td>最好 <code class="language-plaintext highlighter-rouge">5km</code> 成绩</td> <td><code class="language-plaintext highlighter-rouge">23:32</code></td> </tr> <tr> <td>最好 <code class="language-plaintext highlighter-rouge">10km</code> 成绩</td> <td><code class="language-plaintext highlighter-rouge">49:16</code></td> </tr> <tr> <td>最远距离</td> <td><code class="language-plaintext highlighter-rouge">15km</code></td> </tr> <tr> <td>最远距离耗时</td> <td><code class="language-plaintext highlighter-rouge">1:15:06</code></td> </tr> </tbody> </table> <p>注意：以上成绩产生于 <code class="language-plaintext highlighter-rouge">2024-8-20</code> ~ <code class="language-plaintext highlighter-rouge">2024-10-13</code> 期间。</p> <h1 id="训练记录">训练记录</h1> <h2 id="2024-10-14">2024-10-14</h2> <p>今日训练目标：十公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">157</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/ccc5b8f17cc0ffe53ca19e0253b0c092.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241014194759.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-15">2024-10-15</h2> <p>今日训练目标：\(4 \times 3km\)，配速 <code class="language-plaintext highlighter-rouge">5:20</code>。</p> <p>是否达标：是。</p> <p>平均心率：</p> <ul> <li>第一组：<code class="language-plaintext highlighter-rouge">159</code>。</li> <li>第二组：<code class="language-plaintext highlighter-rouge">165</code>。</li> <li>第三组：<code class="language-plaintext highlighter-rouge">164</code>。</li> <li>第四组：<code class="language-plaintext highlighter-rouge">162</code>。</li> </ul> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184333.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184432.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184354.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184509.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184446.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184552.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184529.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241015184612.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-16">2024-10-16</h2> <p>今日训练目标：十公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均功率：<code class="language-plaintext highlighter-rouge">155</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/7bba47a3205ef6e174ffe7a334c5c8be.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241017143237.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-17">2024-10-17</h2> <p>今日训练目标：十公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">156</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241017200419.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241017200454.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-18">2024-10-18</h2> <p>今日训练目标：十公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">161</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/fd64d6f42601dc86046fc677503e9ae7.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241019145632.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-19">2024-10-19</h2> <p>今日训练目标：六公里节奏跑，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">150</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/2cb4801f343a880dcb171f4de1dcf1c7.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241019160224.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-20">2024-10-20</h2> <p>今日训练目标：半马，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">162</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/Screenshot_2024-10-20-17-10-50-88.jpg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241020191518.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-21">2024-10-21</h2> <p>今日训练目标：六公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">154</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/c8303d05a521b80d1884bd80e75333c4.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241022185405.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-22">2024-10-22</h2> <p>今日训练目标：一公里热身，\(6 \times 1km\)，配速 <code class="language-plaintext highlighter-rouge">4:45</code>，每个一公里后小跑 <code class="language-plaintext highlighter-rouge">500m</code> 休息，总共 <code class="language-plaintext highlighter-rouge">10km</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">167</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/96b259864c79a14f2f02dc129acb7080.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241022185626.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241022185711.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-23">2024-10-23</h2> <p>今日训练目标：十公里慢跑，配速 <code class="language-plaintext highlighter-rouge">6:00</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">160</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/e4ff8190080dd76ca1fc0049f7a3d1e0.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241024112958.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-24">2024-10-24</h2> <p>今日训练目标：六公里慢跑，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">168</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/cba65aa001bf8a9cfc85cb30b4ef90ca.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241025194112.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-25">2024-10-25</h2> <p>今日训练目标：马拉松，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：否。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">156</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/fb32e844b3dc998a8321927615abcd18.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241025194205.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-28">2024-10-28</h2> <p>今日训练目标：六公里，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">166</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/2f00f6e032f4c11ba70d026093353bce.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185056.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-29">2024-10-29</h2> <p>今日训练目标：一公里热身，\(6 \times 1km\)，配速 <code class="language-plaintext highlighter-rouge">4:45</code>，每个一公里后小跑 <code class="language-plaintext highlighter-rouge">500m</code> 休息，总共 <code class="language-plaintext highlighter-rouge">10km</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">162</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/0686a88e6fcacf28f9e87f621dc0b0ed.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105184957.png" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185217.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-30">2024-10-30</h2> <p>今日训练目标：六公里。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">143</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/23a5b24716428285f83e62c0972c5ef1.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185243.png" alt="" class="img-fluid"/></p> <h2 id="2024-10-31">2024-10-31</h2> <p>今日训练目标：六公里，配速：<code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">154</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/ed7dcb62b7d157a25eeccec33eafd271.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185259.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-1">2024-11-1</h2> <p>今日训练目标：十五公里，配速 <code class="language-plaintext highlighter-rouge">5:40</code></p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">157</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/ca0e8e25bf5791b47038a673fbf22a14.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185445.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-3">2024-11-3</h2> <p>今日训练目标：二十五公里，配速 <code class="language-plaintext highlighter-rouge">6:10</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">162</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/8e9c15682c99d36c6969234b56f6fd89.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185502.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-5">2024-11-5</h2> <p>今日训练目标：五公里，配速 <code class="language-plaintext highlighter-rouge">4:20</code>。</p> <p>是否达标：否。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">167</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/14edaa7fc62559092084d1881239473a.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241105185530.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-6">2024-11-6</h2> <p>今日训练目标：十公里，配速 <code class="language-plaintext highlighter-rouge">4:50</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">175</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/f100dace78cff6bbc45cb8ee730667f5.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241107184500.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-7">2024-11-7</h2> <p>今日训练目标：五公里，配速 <code class="language-plaintext highlighter-rouge">4:30</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">169</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/aa70d6b2e612a3147242ddd056a4d523.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241107184254.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-8">2024-11-8</h2> <p>今日训练目标：十公里，配速 <code class="language-plaintext highlighter-rouge">5:00</code>。</p> <p>是否达标：否。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">169</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/c7b546a3f7225c118e8eb182cc6a685c.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241110160334.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-9">2024-11-9</h2> <p>今日训练目标：二点五公里，配速 <code class="language-plaintext highlighter-rouge">4:20</code>。</p> <p>是否达标：是。</p> <p>平均心率：<code class="language-plaintext highlighter-rouge">155</code>。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/c544afcbd6cf1a406b518a0fdfa52af2.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241110160201.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-11">2024-11-11</h2> <p>今日训练目标：十公里，配速 <code class="language-plaintext highlighter-rouge">5:40</code>。</p> <p>是否达标：是。</p> <p>平均心率：160。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/d3861a2348fa6482833449446c20fc54.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241115200901.png" alt="" class="img-fluid"/></p> <h2 id="2024-11-15">2024-11-15</h2> <p>今日训练目标：五公里。</p> <p>是否达标：是。</p> <p>平均心率：152。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/eaf0041e189b89f6f6de280fe88b246f.jpeg" alt="" class="img-fluid"/></p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20241115200839.png" alt="" class="img-fluid"/></p>]]></content><author><name></name></author><category term="Potpourri"/><summary type="html"><![CDATA[本文主要用于实时记录自己马拉松破 4:00:00 的准备过程。 个人情况介绍 基本信息 项目 详情 性别 男 年龄 23 身高 178cm 体重 71kg 跑步相关经历 2016-2017：16 年年初开始运动 (以俯卧撑、引体向上等徒手训练为主)，一直坚持到年底，期间跑过 四五次 1~3km 距离的中长跑。 2017-2018：坚持徒手训练。跑过几次 3km。 2018-2019：徒手训练断断续续进行。秋天进行了一到两个月的跑步，每次距离在 3km 左右，当时配速 5:00，这段时间获得本人 1km 最好成绩：3:40。 2019-2020：断断续续徒手训练，秋天进行一个月左右的跑步，每次跑 3km，配速 5:00。年底办了健身房 的卡, 一年期限，开始徒手和器械结合训练。 2020-2021：到健身卡过期之前一直进行徒手和器械结合训练。秋天进行一个月左右的跑步，每次跑 3.5km， 配速 5:00。 2021-2022：很少进行力量训练，秋天进行一个月左右的跑步，每次跑 3km，配速 5:00。 2022-2023：几乎无运动经历。 2023-2024：23 年九月份之前几乎无运动经历，九月开始进行徒手力量训练。 2024-2025：24 年二月分之前一直进行徒手训练，二月至七月无运动经历。八月开始骑车，每次距离 30-100km 不等。八月底开始跑步，第一次的时候跑了 3.6km，配速 7:22。后面跑步固定一周五次，周一到周四每次 6km， 周五不低于 10km，周六骑行 100km，跑步配速不低于 6:00，骑车均速一般不低于 25km/h。 近期跑步成绩 项目 详情 最好 1km 成绩 3:59 最好 3km 成绩 13:37 最好 5km 成绩 23:32 最好 10km 成绩 49:16 最远距离 15km 最远距离耗时 1:15:06 注意：以上成绩产生于 2024-8-20 ~ 2024-10-13 期间。 训练记录 2024-10-14 今日训练目标：十公里慢跑，配速 6:00。 是否达标：是。 平均心率：157。 2024-10-15 今日训练目标：\(4 \times 3km\)，配速 5:20。 是否达标：是。 平均心率： 第一组：159。 第二组：165。 第三组：164。 第四组：162。 2024-10-16 今日训练目标：十公里慢跑，配速 6:00。 是否达标：是。 平均功率：155。 2024-10-17 今日训练目标：十公里慢跑，配速 6:00。 是否达标：是。 平均心率：156。 2024-10-18 今日训练目标：十公里慢跑，配速 6:00。 是否达标：是。 平均心率：161。 2024-10-19 今日训练目标：六公里节奏跑，配速 5:40。 是否达标：是。 平均心率：150。 2024-10-20 今日训练目标：半马，配速 5:40。 是否达标：是。 平均心率：162。 2024-10-21 今日训练目标：六公里慢跑，配速 6:00。 是否达标：是。 平均心率：154。 2024-10-22 今日训练目标：一公里热身，\(6 \times 1km\)，配速 4:45，每个一公里后小跑 500m 休息，总共 10km。 是否达标：是。 平均心率：167。 2024-10-23 今日训练目标：十公里慢跑，配速 6:00。 是否达标：是。 平均心率：160。 2024-10-24 今日训练目标：六公里慢跑，配速 5:40。 是否达标：是。 平均心率：168。 2024-10-25 今日训练目标：马拉松，配速 5:40。 是否达标：否。 平均心率：156。 2024-10-28 今日训练目标：六公里，配速 5:40。 是否达标：是。 平均心率：166。 2024-10-29 今日训练目标：一公里热身，\(6 \times 1km\)，配速 4:45，每个一公里后小跑 500m 休息，总共 10km。 是否达标：是。 平均心率：162。 2024-10-30 今日训练目标：六公里。 是否达标：是。 平均心率：143。 2024-10-31 今日训练目标：六公里，配速：5:40。 是否达标：是。 平均心率：154。 2024-11-1 今日训练目标：十五公里，配速 5:40 是否达标：是。 平均心率：157。 2024-11-3 今日训练目标：二十五公里，配速 6:10。 是否达标：是。 平均心率：162。 2024-11-5 今日训练目标：五公里，配速 4:20。 是否达标：否。 平均心率：167。 2024-11-6 今日训练目标：十公里，配速 4:50。 是否达标：是。 平均心率：175。 2024-11-7 今日训练目标：五公里，配速 4:30。 是否达标：是。 平均心率：169。 2024-11-8 今日训练目标：十公里，配速 5:00。 是否达标：否。 平均心率：169。 2024-11-9 今日训练目标：二点五公里，配速 4:20。 是否达标：是。 平均心率：155。 2024-11-11 今日训练目标：十公里，配速 5:40。 是否达标：是。 平均心率：160。 2024-11-15 今日训练目标：五公里。 是否达标：是。 平均心率：152。]]></summary></entry><entry><title type="html">ssh 端口转发简介</title><link href="https://kaiser-yang.github.io/blog/2024/ssh-port-forwarding/" rel="alternate" type="text/html" title="ssh 端口转发简介"/><published>2024-09-27T11:42:56+00:00</published><updated>2024-09-27T11:42:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/ssh-port-forwarding</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/ssh-port-forwarding/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">ssh</code> 一共支持三种类型的端口转发：本地转发、远程转发和动态转发。</p> <p><strong>注意</strong>：由于本地和远程是一个相对的概念， 本文中提到的本地如果没有特殊说明可以理解成没有公网 <code class="language-plaintext highlighter-rouge">ip</code> 的主机， 而提到的远程如果没有特殊说明可以理解成有公网 <code class="language-plaintext highlighter-rouge">ip</code> 的主机。</p> <h1 id="本地转发">本地转发</h1> <p>本地转发指的是将本地端口通过某个跳板机转发到目的主机的某个端口上。</p> <p>先介绍一个最常见的使用例子，如果你正在使用 <code class="language-plaintext highlighter-rouge">VSCode</code> 通过 <code class="language-plaintext highlighter-rouge">ssh-remote</code> 连接到每个远程的主机上进行开发， 并且在 <code class="language-plaintext highlighter-rouge">VSCode</code> 中启动了一个 <code class="language-plaintext highlighter-rouge">web</code> 服务，那么 <code class="language-plaintext highlighter-rouge">VSCode</code> 会自动为你开启一个端口转发， 这样你可以在浏览器中通过 <code class="language-plaintext highlighter-rouge">localhost</code> 来访问你远程服务器的 <code class="language-plaintext highlighter-rouge">web</code> 服务。 我没有去研究过 <code class="language-plaintext highlighter-rouge">VSCode</code> 的端口转发是否是通过 <code class="language-plaintext highlighter-rouge">ssh</code> 命令实现的，但是我知道 <code class="language-plaintext highlighter-rouge">ssh</code> 命令是可以实现这个功能的。</p> <h2 id="两个主机之间的本地转发">两个主机之间的本地转发</h2> <p>上面提到的 <code class="language-plaintext highlighter-rouge">VSCode</code> 的例子就是一个两个主机之间的端口转发。我们可以通过以下命令实现 (命令在本地执行)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-L</span> 8080:localhost:80 user@remote-host
<span class="c"># or</span>
ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-L</span> 8080:remote-host:80 user@remote-host
</code></pre></div></div> <p>上面的 <code class="language-plaintext highlighter-rouge">remote-host</code> 指的是公网 <code class="language-plaintext highlighter-rouge">ip</code>，上面两条命令等价是因为第一条命令的 <code class="language-plaintext highlighter-rouge">localhost</code> 是相对于 <code class="language-plaintext highlighter-rouge">remote-host</code> 而言的。</p> <p>上面的命令的意思是将本地的 <code class="language-plaintext highlighter-rouge">8080</code> 端口通过 <code class="language-plaintext highlighter-rouge">remote-host</code> 转发到 <code class="language-plaintext highlighter-rouge">remote-host</code> (或 <code class="language-plaintext highlighter-rouge">localhost</code>) 的 <code class="language-plaintext highlighter-rouge">80</code> 端口上。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-f</code> 选项表示后台运行。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-N</code> 选项表示不执行远程命令。</p> <p><strong>注意</strong>：你需要保证本地能够和 <code class="language-plaintext highlighter-rouge">user@remote-host</code> 建立 <code class="language-plaintext highlighter-rouge">ssh</code> 连接。</p> <p><strong>注意</strong>：假设你的本地也有公网 <code class="language-plaintext highlighter-rouge">ip</code>，那么本地转发默认是不会放行其他主机访问的。 如果你想要其他主机访问你的本地转发，你可以使用 <code class="language-plaintext highlighter-rouge">-g</code> 选项， 或者在配置中开启 <code class="language-plaintext highlighter-rouge">GatewayPorts</code> (<code class="language-plaintext highlighter-rouge">/etc/ssh/ssh_config</code>) 选项， 或者使用 <code class="language-plaintext highlighter-rouge">*:8080:localhost:80</code> 或 <code class="language-plaintext highlighter-rouge">:8080:localhost:80</code> 来指定本地转发， 后面的 <a href="#gatewayports">GatewayPorts</a> 会进行详细介绍。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">*:8080:localhost:80</code> 与 <code class="language-plaintext highlighter-rouge">:8080:localhost:80</code> 是等价的，<code class="language-plaintext highlighter-rouge">man ssh</code> 中有这样一句话：</p> <blockquote> <p>The bind_address of “localhost” indicates that the listening port be bound for use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces.</p> </blockquote> <h2 id="三个主机之间的本地转发">三个主机之间的本地转发</h2> <p>在上一部分我对命令的解释中提到了：</p> <blockquote> <p>将本地的 <code class="language-plaintext highlighter-rouge">8080</code> 端口 <strong>通过</strong> <code class="language-plaintext highlighter-rouge">remote-host</code> 转发到 <code class="language-plaintext highlighter-rouge">remote-host</code> 的 <code class="language-plaintext highlighter-rouge">80</code> 端口上。</p> </blockquote> <p>所以当上面命令的 <code class="language-plaintext highlighter-rouge">8080:remote-host:08</code> 中的 <code class="language-plaintext highlighter-rouge">remote-host</code> 为第三个主机的 <code class="language-plaintext highlighter-rouge">ip</code> 地址时， 就是三个主机之间的本地转发。例如 (依然在本地执行)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-L</span> 8080:2.2.2.2:80 user@1.1.1.1
</code></pre></div></div> <p>上述命令的意思是将本地的 <code class="language-plaintext highlighter-rouge">8080</code> 端口通过 <code class="language-plaintext highlighter-rouge">user@1.1.1.1</code> 转发到 <code class="language-plaintext highlighter-rouge">2.2.2.2</code> 的 <code class="language-plaintext highlighter-rouge">80</code> 端口上。 这条命令执行之前需要保证 <code class="language-plaintext highlighter-rouge">1.1.1.1</code> 可以访问 <code class="language-plaintext highlighter-rouge">2.2.2.2</code> 的 <code class="language-plaintext highlighter-rouge">80</code> 端口。</p> <p>这种情况我能想到的一个例子便是代理服务器。当在公司外部需要访问公司内部的资源的时候，为了保证安全性， 可以使用 <code class="language-plaintext highlighter-rouge">ssh</code> 的本地端口转发功能。 这样经过外网部分的数据包将被 <code class="language-plaintext highlighter-rouge">ssh</code> 加密 (上面例子中的 <code class="language-plaintext highlighter-rouge">localhost</code> &lt;–&gt; <code class="language-plaintext highlighter-rouge">1.1.1.1</code> 部分)。</p> <p><strong>注意</strong>：你需要保证本地能够和 <code class="language-plaintext highlighter-rouge">user@1.1.1.1</code> 建立 <code class="language-plaintext highlighter-rouge">ssh</code> 连接。</p> <h1 id="远程转发">远程转发</h1> <p>远程转发指的是将远程主机的某个端口通过本机作为跳板转发到目的主机的某个端口上。</p> <p>远程转发的一个常见的使用场景是内网穿透。如果你的公司只有一个公网 <code class="language-plaintext highlighter-rouge">ip</code>， 你不可能把所有的服务全部部署在这一个拥有公网 <code class="language-plaintext highlighter-rouge">ip</code> 的主机上。 这时候你可以在没有公网 <code class="language-plaintext highlighter-rouge">ip</code> 的主机上面部署各种不同的服务， 然后通过远程转发将这些服务映射到拥有公网 <code class="language-plaintext highlighter-rouge">ip</code> 的主机上。</p> <h2 id="两个主机之间的远程转发">两个主机之间的远程转发</h2> <p>我们依然从最简单的部分开始，两个主机之间的远程转发。例如 (在本地执行)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-R</span> 80:localhost:8080 user@remote-host
</code></pre></div></div> <p>上面的命令依然可以使用 <code class="language-plaintext highlighter-rouge">localhost</code>，因为此时 <code class="language-plaintext highlighter-rouge">localhost</code> 是相对与本地主机而言的 (实际上两者都是在相对跳板机而言的)。 上面的命令的意思是将 <code class="language-plaintext highlighter-rouge">remote-host</code> 的 <code class="language-plaintext highlighter-rouge">80</code> 端口通过本地端转发到 <code class="language-plaintext highlighter-rouge">localhost</code> 的 <code class="language-plaintext highlighter-rouge">8080</code> 端口上。</p> <h3 id="三个主机之间的远程转发">三个主机之间的远程转发</h3> <p>当上面的命令中的 <code class="language-plaintext highlighter-rouge">80:localhost:8080</code> 中的 <code class="language-plaintext highlighter-rouge">localhost</code> 变成第三台主机的 <code class="language-plaintext highlighter-rouge">ip</code> 地址时， 就是三个主机之间的远程转发。例如 (在本地执行)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-R</span> 80:198.168.0.2:8080 user@remote-host
</code></pre></div></div> <p>上面的命令的意思是将 <code class="language-plaintext highlighter-rouge">remote-host</code> 的 <code class="language-plaintext highlighter-rouge">80</code> 端口通过本地端转发到 <code class="language-plaintext highlighter-rouge">198.168.0.2</code> 的 <code class="language-plaintext highlighter-rouge">8080</code> 端口上。</p> <h2 id="题外话">题外话</h2> <p>通过远程转发你可以完成一些有趣的东西。例如你的本地的电脑性能非常强悍，但是没有公网 <code class="language-plaintext highlighter-rouge">ip</code>， 你想要部署一个可以支持很多人访问的网站，那么你可以租一个很便宜的云服务器， 然后通过远程转发将云服务器的 <code class="language-plaintext highlighter-rouge">80</code> 端口转发到你本地的某个端口上，并把你的网站部署在本地。</p> <p><strong>注意</strong>：要实现这个功能，你可能需要了解 <code class="language-plaintext highlighter-rouge">GatewayPorts</code>，可以查看后文的 <a href="#gatewayports">GatewayPorts</a>。</p> <h1 id="动态转发">动态转发</h1> <p>前面介绍的本地 (远程) 转发都是将本地 (远程) 的某个端口转发到某个固定的目的主机的某个端口上。 而动态转发则是可以实现转发到不同的位置。</p> <p>我想到关于动态转发的一个例子依然是代理服务器。例如下面的命令 (在本地执行)：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-f</span> <span class="nt">-N</span> <span class="nt">-D</span> 1234 user@remote-host
</code></pre></div></div> <p>上面的命令会让所有到达本地 <code class="language-plaintext highlighter-rouge">1234</code> 端口的数据包都通过 <code class="language-plaintext highlighter-rouge">remote-host</code> 转发到目的主机上。 这样你就可以在执行上述命令后，设置代理地址为 <code class="language-plaintext highlighter-rouge">socks5://localhost:1234</code>， 这样所有的网络请求都会通过 <code class="language-plaintext highlighter-rouge">remote-host</code> 转发到目的主机上。</p> <p>例如在完成动态转发的设置后 <code class="language-plaintext highlighter-rouge">curl --proxy socks5://localhost:8080 http://www.google.com</code> 就会通过 <code class="language-plaintext highlighter-rouge">remote-host</code> 访问 <code class="language-plaintext highlighter-rouge">google</code>。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-D</code> 选项后面的端口号可以设置为任意空闲的非特权 (特权端口需要 <code class="language-plaintext highlighter-rouge">root</code> 权限) 端口。</p> <p><strong>注意</strong>：需要保证本机可以访问 <code class="language-plaintext highlighter-rouge">remote-host</code>；<code class="language-plaintext highlighter-rouge">remote-host</code> 可以访问目的主机。</p> <p><strong>注意</strong>：动态转发实际上也是对本地的端口进行转发。</p> <h1 id="gatewayports"><code class="language-plaintext highlighter-rouge">GatewayPorts</code></h1> <p><code class="language-plaintext highlighter-rouge">GatewayPorts</code> 在 <code class="language-plaintext highlighter-rouge">ssh-client</code> (<code class="language-plaintext highlighter-rouge">/etc/ssh/ssh_config</code>) 和 <code class="language-plaintext highlighter-rouge">ssh-server</code> (<code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code>) 中 有不同的含义。</p> <h2 id="ssh-client"><code class="language-plaintext highlighter-rouge">ssh-client</code></h2> <p>通过 <code class="language-plaintext highlighter-rouge">man ssh_config</code> 我们可以看到 <code class="language-plaintext highlighter-rouge">GatewayPorts</code> 在 <code class="language-plaintext highlighter-rouge">ssh-client</code> 中的含义：</p> <blockquote> <p>By default, <code class="language-plaintext highlighter-rouge">ssh</code> binds local port forwardings to the loopback address. This prevents other remote hosts from connecting to forwarded ports. <code class="language-plaintext highlighter-rouge">GatewayPorts</code> can be used to specify that <code class="language-plaintext highlighter-rouge">ssh</code> should bind local port forwardings to the wildcard address, thus allowing remote hosts to connect to forwarded ports. The argument must be <code class="language-plaintext highlighter-rouge">yes</code> or <code class="language-plaintext highlighter-rouge">no</code> (the default).</p> </blockquote> <p>也就是说对于动态转发和本地转发，当设置 <code class="language-plaintext highlighter-rouge">GatewayPorts yes</code> 时，使用 <code class="language-plaintext highlighter-rouge">8080:localhost:80</code> 会被解析成 <code class="language-plaintext highlighter-rouge">*:8080:localhost:80</code> 而当设置成 <code class="language-plaintext highlighter-rouge">GatewayPorts no</code> 时， 使用 <code class="language-plaintext highlighter-rouge">8080:localhost:80</code> 会被解析成 <code class="language-plaintext highlighter-rouge">localhost:8080:localhost:80</code>，也就是是否使用 <code class="language-plaintext highlighter-rouge">-g</code> 选项的区别。 但是不管设置成 <code class="language-plaintext highlighter-rouge">yes</code> 还是 <code class="language-plaintext highlighter-rouge">no</code>，都可以通过手动指定 <code class="language-plaintext highlighter-rouge">*:8080:localhost:80</code> 来实现允许所有主机访问本地端口转发。</p> <p>在 <code class="language-plaintext highlighter-rouge">man ssh</code> 中有这样一句话：</p> <blockquote> <p>Specifying a remote bind_address will only succeed if the server’s <code class="language-plaintext highlighter-rouge">GatewayPorts</code> option is enabled.</p> </blockquote> <p>也就是对于远程转发，如果我们想使用类似 <code class="language-plaintext highlighter-rouge">*:80:localhost:8080</code> 这样的的转发， 我们必须开启 <code class="language-plaintext highlighter-rouge">remote-host</code> 的 <code class="language-plaintext highlighter-rouge">GatewayPorts</code> 选项而不是像本地转发一样可以直接使用。这也是很合理的， 因为远程转发是由 <code class="language-plaintext highlighter-rouge">remote-host</code> 进行转发，所以应该由 <code class="language-plaintext highlighter-rouge">remote-host</code> 来决定是否为其他主机访问进行转发， 而不是由本地来决定。</p> <h2 id="ssh-server"><code class="language-plaintext highlighter-rouge">ssh-server</code></h2> <p>在 <code class="language-plaintext highlighter-rouge">man sshd_config</code> 中写到了 <code class="language-plaintext highlighter-rouge">GatewayPorts</code> 的配置方式：</p> <blockquote> <p>Specifies whether remote hosts are allowed to connect to ports forwarded for the client. By default, <code class="language-plaintext highlighter-rouge">sshd</code> binds remote port forwardings to the loopback address. This prevents other remote hosts from connecting to forwarded ports. <code class="language-plaintext highlighter-rouge">GatewayPorts</code> can be used to specify that <code class="language-plaintext highlighter-rouge">sshd</code> should allow remote port forwardings to bind to non-loopback addresses, thus allowing other hosts to connect. The argument may be <code class="language-plaintext highlighter-rouge">no</code> to force remote port forwardings to be available to the local host only, <code class="language-plaintext highlighter-rouge">yes</code> to force remote port forwardings to bind to the wildcard address, or <code class="language-plaintext highlighter-rouge">clientspecified</code> to the client to select the address to which the forwarding is bound. The default is <code class="language-plaintext highlighter-rouge">no</code>.</p> </blockquote> <p>简单总结一下：</p> <ul> <li><code class="language-plaintext highlighter-rouge">no</code>：默认值，只允许本地 (这里指远端的本地，也就是远端) 访问转发的端口。</li> <li><code class="language-plaintext highlighter-rouge">yes</code>：允许其他主机访问转发的端口。</li> <li><code class="language-plaintext highlighter-rouge">clientspecified</code>：由客户端决定是否允许其他主机访问转发，只有当设置成 <code class="language-plaintext highlighter-rouge">clientspecified</code> 时， 客户端才能通过 <code class="language-plaintext highlighter-rouge">*:80:localhost:8080</code> (也可以替换 <code class="language-plaintext highlighter-rouge">*</code> 为其他想要允许的地址) 的方式来设置转发。</li> </ul> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://linuxize.com/post/how-to-setup-ssh-tunneling/">How to Set up SSH Tunneling (Port Forwarding)</a></li> <li><a href="https://www.golinuxcloud.com/setup-ssh-port-forwarding/">SSH port forwarding | SSH Tunnel (Forward &amp; Reverse)</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Unix/Linux"/><summary type="html"><![CDATA[ssh 一共支持三种类型的端口转发：本地转发、远程转发和动态转发。 注意：由于本地和远程是一个相对的概念， 本文中提到的本地如果没有特殊说明可以理解成没有公网 ip 的主机， 而提到的远程如果没有特殊说明可以理解成有公网 ip 的主机。 本地转发 本地转发指的是将本地端口通过某个跳板机转发到目的主机的某个端口上。 先介绍一个最常见的使用例子，如果你正在使用 VSCode 通过 ssh-remote 连接到每个远程的主机上进行开发， 并且在 VSCode 中启动了一个 web 服务，那么 VSCode 会自动为你开启一个端口转发， 这样你可以在浏览器中通过 localhost 来访问你远程服务器的 web 服务。 我没有去研究过 VSCode 的端口转发是否是通过 ssh 命令实现的，但是我知道 ssh 命令是可以实现这个功能的。 两个主机之间的本地转发 上面提到的 VSCode 的例子就是一个两个主机之间的端口转发。我们可以通过以下命令实现 (命令在本地执行)： ssh -f -N -L 8080:localhost:80 user@remote-host # or ssh -f -N -L 8080:remote-host:80 user@remote-host 上面的 remote-host 指的是公网 ip，上面两条命令等价是因为第一条命令的 localhost 是相对于 remote-host 而言的。 上面的命令的意思是将本地的 8080 端口通过 remote-host 转发到 remote-host (或 localhost) 的 80 端口上。 注意：-f 选项表示后台运行。 注意：-N 选项表示不执行远程命令。 注意：你需要保证本地能够和 user@remote-host 建立 ssh 连接。 注意：假设你的本地也有公网 ip，那么本地转发默认是不会放行其他主机访问的。 如果你想要其他主机访问你的本地转发，你可以使用 -g 选项， 或者在配置中开启 GatewayPorts (/etc/ssh/ssh_config) 选项， 或者使用 *:8080:localhost:80 或 :8080:localhost:80 来指定本地转发， 后面的 GatewayPorts 会进行详细介绍。 注意：*:8080:localhost:80 与 :8080:localhost:80 是等价的，man ssh 中有这样一句话： The bind_address of “localhost” indicates that the listening port be bound for use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces. 三个主机之间的本地转发 在上一部分我对命令的解释中提到了： 将本地的 8080 端口 通过 remote-host 转发到 remote-host 的 80 端口上。 所以当上面命令的 8080:remote-host:08 中的 remote-host 为第三个主机的 ip 地址时， 就是三个主机之间的本地转发。例如 (依然在本地执行)： ssh -f -N -L 8080:2.2.2.2:80 user@1.1.1.1 上述命令的意思是将本地的 8080 端口通过 user@1.1.1.1 转发到 2.2.2.2 的 80 端口上。 这条命令执行之前需要保证 1.1.1.1 可以访问 2.2.2.2 的 80 端口。 这种情况我能想到的一个例子便是代理服务器。当在公司外部需要访问公司内部的资源的时候，为了保证安全性， 可以使用 ssh 的本地端口转发功能。 这样经过外网部分的数据包将被 ssh 加密 (上面例子中的 localhost &lt;–&gt; 1.1.1.1 部分)。 注意：你需要保证本地能够和 user@1.1.1.1 建立 ssh 连接。 远程转发 远程转发指的是将远程主机的某个端口通过本机作为跳板转发到目的主机的某个端口上。 远程转发的一个常见的使用场景是内网穿透。如果你的公司只有一个公网 ip， 你不可能把所有的服务全部部署在这一个拥有公网 ip 的主机上。 这时候你可以在没有公网 ip 的主机上面部署各种不同的服务， 然后通过远程转发将这些服务映射到拥有公网 ip 的主机上。 两个主机之间的远程转发 我们依然从最简单的部分开始，两个主机之间的远程转发。例如 (在本地执行)： ssh -f -N -R 80:localhost:8080 user@remote-host 上面的命令依然可以使用 localhost，因为此时 localhost 是相对与本地主机而言的 (实际上两者都是在相对跳板机而言的)。 上面的命令的意思是将 remote-host 的 80 端口通过本地端转发到 localhost 的 8080 端口上。 三个主机之间的远程转发 当上面的命令中的 80:localhost:8080 中的 localhost 变成第三台主机的 ip 地址时， 就是三个主机之间的远程转发。例如 (在本地执行)： ssh -f -N -R 80:198.168.0.2:8080 user@remote-host 上面的命令的意思是将 remote-host 的 80 端口通过本地端转发到 198.168.0.2 的 8080 端口上。 题外话 通过远程转发你可以完成一些有趣的东西。例如你的本地的电脑性能非常强悍，但是没有公网 ip， 你想要部署一个可以支持很多人访问的网站，那么你可以租一个很便宜的云服务器， 然后通过远程转发将云服务器的 80 端口转发到你本地的某个端口上，并把你的网站部署在本地。 注意：要实现这个功能，你可能需要了解 GatewayPorts，可以查看后文的 GatewayPorts。 动态转发 前面介绍的本地 (远程) 转发都是将本地 (远程) 的某个端口转发到某个固定的目的主机的某个端口上。 而动态转发则是可以实现转发到不同的位置。 我想到关于动态转发的一个例子依然是代理服务器。例如下面的命令 (在本地执行)： ssh -f -N -D 1234 user@remote-host 上面的命令会让所有到达本地 1234 端口的数据包都通过 remote-host 转发到目的主机上。 这样你就可以在执行上述命令后，设置代理地址为 socks5://localhost:1234， 这样所有的网络请求都会通过 remote-host 转发到目的主机上。 例如在完成动态转发的设置后 curl --proxy socks5://localhost:8080 http://www.google.com 就会通过 remote-host 访问 google。 注意：-D 选项后面的端口号可以设置为任意空闲的非特权 (特权端口需要 root 权限) 端口。 注意：需要保证本机可以访问 remote-host；remote-host 可以访问目的主机。 注意：动态转发实际上也是对本地的端口进行转发。 GatewayPorts GatewayPorts 在 ssh-client (/etc/ssh/ssh_config) 和 ssh-server (/etc/ssh/sshd_config) 中 有不同的含义。 ssh-client 通过 man ssh_config 我们可以看到 GatewayPorts 在 ssh-client 中的含义： By default, ssh binds local port forwardings to the loopback address. This prevents other remote hosts from connecting to forwarded ports. GatewayPorts can be used to specify that ssh should bind local port forwardings to the wildcard address, thus allowing remote hosts to connect to forwarded ports. The argument must be yes or no (the default). 也就是说对于动态转发和本地转发，当设置 GatewayPorts yes 时，使用 8080:localhost:80 会被解析成 *:8080:localhost:80 而当设置成 GatewayPorts no 时， 使用 8080:localhost:80 会被解析成 localhost:8080:localhost:80，也就是是否使用 -g 选项的区别。 但是不管设置成 yes 还是 no，都可以通过手动指定 *:8080:localhost:80 来实现允许所有主机访问本地端口转发。 在 man ssh 中有这样一句话： Specifying a remote bind_address will only succeed if the server’s GatewayPorts option is enabled. 也就是对于远程转发，如果我们想使用类似 *:80:localhost:8080 这样的的转发， 我们必须开启 remote-host 的 GatewayPorts 选项而不是像本地转发一样可以直接使用。这也是很合理的， 因为远程转发是由 remote-host 进行转发，所以应该由 remote-host 来决定是否为其他主机访问进行转发， 而不是由本地来决定。 ssh-server 在 man sshd_config 中写到了 GatewayPorts 的配置方式： Specifies whether remote hosts are allowed to connect to ports forwarded for the client. By default, sshd binds remote port forwardings to the loopback address. This prevents other remote hosts from connecting to forwarded ports. GatewayPorts can be used to specify that sshd should allow remote port forwardings to bind to non-loopback addresses, thus allowing other hosts to connect. The argument may be no to force remote port forwardings to be available to the local host only, yes to force remote port forwardings to bind to the wildcard address, or clientspecified to the client to select the address to which the forwarding is bound. The default is no. 简单总结一下： no：默认值，只允许本地 (这里指远端的本地，也就是远端) 访问转发的端口。 yes：允许其他主机访问转发的端口。 clientspecified：由客户端决定是否允许其他主机访问转发，只有当设置成 clientspecified 时， 客户端才能通过 *:80:localhost:8080 (也可以替换 * 为其他想要允许的地址) 的方式来设置转发。 巨人的肩膀 How to Set up SSH Tunneling (Port Forwarding) SSH port forwarding | SSH Tunnel (Forward &amp; Reverse)]]></summary></entry><entry><title type="html">服务器上创建 git 远程仓库</title><link href="https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server/" rel="alternate" type="text/html" title="服务器上创建 git 远程仓库"/><published>2024-09-23T03:12:56+00:00</published><updated>2024-09-23T03:12:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/create-git-remote-repository-on-server/"><![CDATA[<p>本篇文章将会介绍如何在服务器上创建一个 <code class="language-plaintext highlighter-rouge">git</code> 中央服务器并且配置 <code class="language-plaintext highlighter-rouge">ssh</code> 连接。</p> <h1 id="必要工具">必要工具</h1> <ul> <li><code class="language-plaintext highlighter-rouge">git</code></li> <li><code class="language-plaintext highlighter-rouge">ssh</code></li> </ul> <h1 id="创建-git-用户">创建 <code class="language-plaintext highlighter-rouge">git</code> 用户</h1> <p>我们一般不会使用 <code class="language-plaintext highlighter-rouge">root</code> 用户来管理 <code class="language-plaintext highlighter-rouge">git</code> 仓库，所以我们可以创建一个用户专门用来管理 <code class="language-plaintext highlighter-rouge">git</code> 仓库，通常 这个用户的名字叫 <code class="language-plaintext highlighter-rouge">git</code>。可以通过以下命令创建一个 <code class="language-plaintext highlighter-rouge">git</code> 用户：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -m 用于创建用户的家目录：/home/git</span>
useradd <span class="nt">-m</span> git
</code></pre></div></div> <p>创建成功后， 我们需要为 <code class="language-plaintext highlighter-rouge">git</code> 用户设置密码：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 第一次可能需要输入 `sudo` 的密码，然后输入两次新密码</span>
<span class="nb">sudo </span>passwd git
</code></pre></div></div> <h1 id="创建仓库">创建仓库</h1> <p>仓库的创建非常简单，我们首先通过以下命令切换到 <code class="language-plaintext highlighter-rouge">git</code> 用户：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 需要输入 `git` 用户的密码，或者可以使用 `sudo su git` 切换，此时需要输入 `sudo` 的密码</span>
su git
</code></pre></div></div> <p>然后我们可以通过以下命令创建一个仓库 <code class="language-plaintext highlighter-rouge">a</code>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 将仓库放置在 /home/git/a.git 目录下</span>
git init <span class="nt">--bare</span> /home/git/a.git
</code></pre></div></div> <h1 id="设置远程-ssh">设置远程 <code class="language-plaintext highlighter-rouge">ssh</code></h1> <p>我们需要为 <code class="language-plaintext highlighter-rouge">git</code> 用户设置 <code class="language-plaintext highlighter-rouge">ssh</code>，这样我们才能通过 <code class="language-plaintext highlighter-rouge">ssh</code> 连接到 <code class="language-plaintext highlighter-rouge">git</code> 服务器。</p> <p>我们只需要通过以下命令创建相应的目录即可：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 切换到 git 用户，以保证目录的权限正确</span>
su git
<span class="c"># ~/.ssh 目录的权限必须是 700，~/.ssh/authorized_keys 的权限必须是 600</span>
<span class="nb">cd</span> ~
<span class="nb">mkdir</span> .ssh <span class="o">&amp;&amp;</span> <span class="nb">chmod </span>700 .ssh
<span class="nb">touch</span> .ssh/authorized_keys <span class="o">&amp;&amp;</span> <span class="nb">chmod </span>600 .ssh/authorized_keys
</code></pre></div></div> <h1 id="上传公钥">上传公钥</h1> <p>我们需要将我们的公钥上传到 <code class="language-plaintext highlighter-rouge">git</code> 服务器，这样我们才能通过 <code class="language-plaintext highlighter-rouge">ssh</code> 连接到 <code class="language-plaintext highlighter-rouge">git</code> 服务器。</p> <p>公钥的创建这里不多介绍。我们只需要将本地的公钥内容全部追加到 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 文件中即可。</p> <h1 id="克隆仓库">克隆仓库</h1> <p>如果一切正常，假定服务器域名为 <code class="language-plaintext highlighter-rouge">1.1.1.1</code>，端口为 <code class="language-plaintext highlighter-rouge">123</code> 的情况下，用户为 <code class="language-plaintext highlighter-rouge">git</code>，仓库路径为 <code class="language-plaintext highlighter-rouge">~/a.git</code>， 我们可以通过以下命令克隆仓库：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 会在当前目录下创建一个 a 目录</span>
git clone ssh://git@1.1.1.1:123/~/a.git
</code></pre></div></div> <p>通过克隆命令获取的仓库，我们可以通过 <code class="language-plaintext highlighter-rouge">git remote -v</code> 查看远程仓库的地址。</p> <p>如果想要手动添加远程仓库，可以通过以下命令：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加一个名为 origin 的远程仓库</span>
git remote add origin ssh://git@1.1.1.1:123/~/a.git
</code></pre></div></div> <h1 id="配置-git-shell">配置 <code class="language-plaintext highlighter-rouge">git-shell</code></h1> <p>如果我们不希望 <code class="language-plaintext highlighter-rouge">git</code> 用户能够登录到服务器，我们可以将 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">shell</code> 设置为 <code class="language-plaintext highlighter-rouge">git-shell</code>，这样 <code class="language-plaintext highlighter-rouge">git</code> 用户只能通过 <code class="language-plaintext highlighter-rouge">git</code> 命令来操作仓库。</p> <p>首先查看 <code class="language-plaintext highlighter-rouge">/etc/shells</code> 中是否有 <code class="language-plaintext highlighter-rouge">git-shell</code>，如果没有，我们需要将 <code class="language-plaintext highlighter-rouge">git-shell</code> 添加到 <code class="language-plaintext highlighter-rouge">/etc/shells</code> 中：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 /etc/shells 中是否有 git-shell</span>
<span class="nb">cat</span> /etc/shells | <span class="nb">grep </span>git-shell
<span class="c"># 如果没有，我们需要将 git-shell 添加到 /etc/shells 中</span>
<span class="nb">echo</span> <span class="si">$(</span>which git-shell<span class="si">)</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/shells
</code></pre></div></div> <p>接下来，我们可以通过以下命令将 <code class="language-plaintext highlighter-rouge">git</code> 用户的 <code class="language-plaintext highlighter-rouge">shell</code> 设置为 <code class="language-plaintext highlighter-rouge">git-shell</code>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>chsh <span class="nt">-s</span> <span class="si">$(</span>which git-shell<span class="si">)</span> git
</code></pre></div></div> <p>设置完成后，<code class="language-plaintext highlighter-rouge">git</code> 用户将不能登录到服务器，只能通过 <code class="language-plaintext highlighter-rouge">git</code> 命令来操作仓库。</p> <h1 id="禁止转发">禁止转发</h1> <p>即使 <code class="language-plaintext highlighter-rouge">git</code> 用户目前不能登录，但是其依然可以执行一些端口转发的操作，我们可以通过在 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 对想要禁止的公钥添加 <code class="language-plaintext highlighter-rouge">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty</code> 来禁止转发。</p> <p>例如，对第一行的公钥进行禁止转发：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在第一行的前面添加后，内容可能如下：</span>
no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAAAA...
</code></pre></div></div> <h1 id="配置快速连接">配置快速连接</h1> <p>通常租用的服务器只有一个 <code class="language-plaintext highlighter-rouge">ip</code> 地址，没有相应的域名解析，不过我们可以通过 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件来配置 快速连接。</p> <p>以之前的例子为例，我们需要在本地的 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中添加以下内容：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host gitserver
  HostName 1.1.1.1
  User git
  Port 123
</code></pre></div></div> <p>这样操作后，我们的 <code class="language-plaintext highlighter-rouge">clone</code> 命令可以简化为：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 这个命令会获取 /home/git/a.git 仓库，因为 ssh 连接时默认路径为 ~</span>
git clone gitserver:a.git
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server">Git on the Server - Setting Up the Server</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="git"/><summary type="html"><![CDATA[本篇文章将会介绍如何在服务器上创建一个 git 中央服务器并且配置 ssh 连接。 必要工具 git ssh 创建 git 用户 我们一般不会使用 root 用户来管理 git 仓库，所以我们可以创建一个用户专门用来管理 git 仓库，通常 这个用户的名字叫 git。可以通过以下命令创建一个 git 用户： # -m 用于创建用户的家目录：/home/git useradd -m git 创建成功后， 我们需要为 git 用户设置密码： # 第一次可能需要输入 `sudo` 的密码，然后输入两次新密码 sudo passwd git 创建仓库 仓库的创建非常简单，我们首先通过以下命令切换到 git 用户： # 需要输入 `git` 用户的密码，或者可以使用 `sudo su git` 切换，此时需要输入 `sudo` 的密码 su git 然后我们可以通过以下命令创建一个仓库 a： # 将仓库放置在 /home/git/a.git 目录下 git init --bare /home/git/a.git 设置远程 ssh 我们需要为 git 用户设置 ssh，这样我们才能通过 ssh 连接到 git 服务器。 我们只需要通过以下命令创建相应的目录即可： # 切换到 git 用户，以保证目录的权限正确 su git # ~/.ssh 目录的权限必须是 700，~/.ssh/authorized_keys 的权限必须是 600 cd ~ mkdir .ssh &amp;&amp; chmod 700 .ssh touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys 上传公钥 我们需要将我们的公钥上传到 git 服务器，这样我们才能通过 ssh 连接到 git 服务器。 公钥的创建这里不多介绍。我们只需要将本地的公钥内容全部追加到 git 用户的 ~/.ssh/authorized_keys 文件中即可。 克隆仓库 如果一切正常，假定服务器域名为 1.1.1.1，端口为 123 的情况下，用户为 git，仓库路径为 ~/a.git， 我们可以通过以下命令克隆仓库： # 会在当前目录下创建一个 a 目录 git clone ssh://git@1.1.1.1:123/~/a.git 通过克隆命令获取的仓库，我们可以通过 git remote -v 查看远程仓库的地址。 如果想要手动添加远程仓库，可以通过以下命令： # 添加一个名为 origin 的远程仓库 git remote add origin ssh://git@1.1.1.1:123/~/a.git 配置 git-shell 如果我们不希望 git 用户能够登录到服务器，我们可以将 git 用户的 shell 设置为 git-shell，这样 git 用户只能通过 git 命令来操作仓库。 首先查看 /etc/shells 中是否有 git-shell，如果没有，我们需要将 git-shell 添加到 /etc/shells 中： # 查看 /etc/shells 中是否有 git-shell cat /etc/shells | grep git-shell # 如果没有，我们需要将 git-shell 添加到 /etc/shells 中 echo $(which git-shell) | sudo tee -a /etc/shells 接下来，我们可以通过以下命令将 git 用户的 shell 设置为 git-shell： sudo chsh -s $(which git-shell) git 设置完成后，git 用户将不能登录到服务器，只能通过 git 命令来操作仓库。 禁止转发 即使 git 用户目前不能登录，但是其依然可以执行一些端口转发的操作，我们可以通过在 ~/.ssh/authorized_keys 对想要禁止的公钥添加 no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty 来禁止转发。 例如，对第一行的公钥进行禁止转发： # 在第一行的前面添加后，内容可能如下： no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAAAA... 配置快速连接 通常租用的服务器只有一个 ip 地址，没有相应的域名解析，不过我们可以通过 ~/.ssh/config 文件来配置 快速连接。 以之前的例子为例，我们需要在本地的 ~/.ssh/config 中添加以下内容： Host gitserver HostName 1.1.1.1 User git Port 123 这样操作后，我们的 clone 命令可以简化为： # 这个命令会获取 /home/git/a.git 仓库，因为 ssh 连接时默认路径为 ~ git clone gitserver:a.git 巨人的肩膀 Git on the Server - Setting Up the Server]]></summary></entry><entry><title type="html">Spring Boot Test 自定义测试类顺序</title><link href="https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order/" rel="alternate" type="text/html" title="Spring Boot Test 自定义测试类顺序"/><published>2024-09-20T07:31:53+00:00</published><updated>2024-09-20T07:31:53+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-boot-test-custom-test-class-order/"><![CDATA[<h1 id="起因">起因</h1> <p>在开发一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目的过程中，我编写了三个测试类：<code class="language-plaintext highlighter-rouge">AuthenticationControllerTest</code>, <code class="language-plaintext highlighter-rouge">UserControllerTest</code> 以及 <code class="language-plaintext highlighter-rouge">RepositoryControllerTest</code>。我希望在我执行 <code class="language-plaintext highlighter-rouge">mvn test</code> 的时候能够控制这三个 测试类的执行顺序：</p> <ol> <li><code class="language-plaintext highlighter-rouge">AuthenticationControllerTest</code> 先执行以便获取后续操作的 <code class="language-plaintext highlighter-rouge">token</code></li> <li>接着执行 <code class="language-plaintext highlighter-rouge">RepositoryControllerTest</code> 进行创建仓库的测试以便后续的查询的仓库列表不为空</li> <li>最后执行 <code class="language-plaintext highlighter-rouge">UserControllerTest</code> 进行用户相关的测试</li> </ol> <p>我在网上查找了很多资料，发现大部分都是介绍的如何指定一个测试类中的测试方法的执行顺序，但是没有找到 如何指定多个测试类的执行顺序的资料。</p> <p>这里简单介绍一下如何指定同一个类中的 <code class="language-plaintext highlighter-rouge">@Test</code> 修饰的方法的执行顺序：</p> <ul> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</code> 并在测试方法上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 注解可以实现按照 <code class="language-plaintext highlighter-rouge">@Order</code> 中的值从小到大的顺序执行测试方法。</li> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.Random.class)</code> 可以实现随机执行测试方法。</li> <li>在测试类上添加 <code class="language-plaintext highlighter-rouge">@TestMethodOrder(MethodOrderer.DisplayName.class)</code> 可以实现按照测试方法的名称的 字典序执行测试方法。</li> </ul> <h1 id="蓦然回首">蓦然回首</h1> <p>找了很多网上的资料都没有找到解决方案，于是我决定去 <code class="language-plaintext highlighter-rouge">Junit5</code> 翻阅一下官方文档，我便在官方文档中找到了 这样一段话：</p> <blockquote> <p>To configure test class execution order globally for the entire test suite, use the <code class="language-plaintext highlighter-rouge">junit.jupiter.testclass.order.default</code> configuration parameter to specify the fully qualified class name of the ClassOrderer you would like to use. The supplied class must implement the <code class="language-plaintext highlighter-rouge">ClassOrderer</code> interface.</p> </blockquote> <p>随即在后文又提到了如何配置这个变量：</p> <blockquote> <p>For example, for the <code class="language-plaintext highlighter-rouge">@Order</code> annotation to be honored on test classes, you should configure the <code class="language-plaintext highlighter-rouge">ClassOrderer.OrderAnnotation</code> class orderer using the configuration parameter with the corresponding fully qualified class name (e.g., in <code class="language-plaintext highlighter-rouge">src/test/resources/junit-platform.properties</code>).</p> </blockquote> <p>也就是说如果在 <code class="language-plaintext highlighter-rouge">src/test/resources/junit-platform.properties</code> 中添加如下内容：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">junit.jupiter.testclass.order.default</span><span class="p">=</span><span class="s">org.junit.jupiter.api.ClassOrderer$OrderAnnotation</span>
</code></pre></div></div> <p>便可以通过在测试类上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 的方式控制测试类的执行顺序。</p> <p>这样一来这个问题也就解决了。但是我想每次都需要在测试类上添加 <code class="language-plaintext highlighter-rouge">@Order</code> 也是很麻烦的，于是我自定义了 一个 <code class="language-plaintext highlighter-rouge">SpringBootTestClassOrderer</code> 类，只需要按照顺序在 <code class="language-plaintext highlighter-rouge">classOrder</code> 中添加测试类即可以按照顺序执行：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringBootTestClassOrderer</span> <span class="kd">implements</span> <span class="nc">ClassOrderer</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classOrder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span>
        <span class="nc">AuthenticationControllerTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="nc">RepositoryControllerTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="nc">UserControllerTest</span><span class="o">.</span><span class="na">class</span>
    <span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">orderClasses</span><span class="o">(</span><span class="nc">ClassOrdererContext</span> <span class="n">classOrdererContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">classOrdererContext</span><span class="o">.</span><span class="na">getClassDescriptors</span><span class="o">().</span><span class="na">sort</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="nl">SpringBootTestClassOrderer:</span><span class="o">:</span><span class="n">getOrder</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nc">ClassDescriptor</span> <span class="n">classDescriptor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classOrder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">classDescriptor</span><span class="o">.</span><span class="na">getTestClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">classOrder</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>最后我的 <code class="language-plaintext highlighter-rouge">junit-platform.properties</code> 文件如下：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">junit.jupiter.testclass.order.default</span><span class="p">=</span><span class="s">edu.cmipt.gcs.SpringBootTestClassOrderer</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes">Junit 5 Class Order</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot Test"/><category term="Junit"/><summary type="html"><![CDATA[起因 在开发一个 Spring Boot 项目的过程中，我编写了三个测试类：AuthenticationControllerTest, UserControllerTest 以及 RepositoryControllerTest。我希望在我执行 mvn test 的时候能够控制这三个 测试类的执行顺序： AuthenticationControllerTest 先执行以便获取后续操作的 token 接着执行 RepositoryControllerTest 进行创建仓库的测试以便后续的查询的仓库列表不为空 最后执行 UserControllerTest 进行用户相关的测试 我在网上查找了很多资料，发现大部分都是介绍的如何指定一个测试类中的测试方法的执行顺序，但是没有找到 如何指定多个测试类的执行顺序的资料。 这里简单介绍一下如何指定同一个类中的 @Test 修饰的方法的执行顺序： 在测试类上添加 @TestMethodOrder(MethodOrderer.OrderAnnotation.class) 并在测试方法上添加 @Order 注解可以实现按照 @Order 中的值从小到大的顺序执行测试方法。 在测试类上添加 @TestMethodOrder(MethodOrderer.Random.class) 可以实现随机执行测试方法。 在测试类上添加 @TestMethodOrder(MethodOrderer.DisplayName.class) 可以实现按照测试方法的名称的 字典序执行测试方法。 蓦然回首 找了很多网上的资料都没有找到解决方案，于是我决定去 Junit5 翻阅一下官方文档，我便在官方文档中找到了 这样一段话： To configure test class execution order globally for the entire test suite, use the junit.jupiter.testclass.order.default configuration parameter to specify the fully qualified class name of the ClassOrderer you would like to use. The supplied class must implement the ClassOrderer interface. 随即在后文又提到了如何配置这个变量： For example, for the @Order annotation to be honored on test classes, you should configure the ClassOrderer.OrderAnnotation class orderer using the configuration parameter with the corresponding fully qualified class name (e.g., in src/test/resources/junit-platform.properties). 也就是说如果在 src/test/resources/junit-platform.properties 中添加如下内容： junit.jupiter.testclass.order.default=org.junit.jupiter.api.ClassOrderer$OrderAnnotation 便可以通过在测试类上添加 @Order 的方式控制测试类的执行顺序。 这样一来这个问题也就解决了。但是我想每次都需要在测试类上添加 @Order 也是很麻烦的，于是我自定义了 一个 SpringBootTestClassOrderer 类，只需要按照顺序在 classOrder 中添加测试类即可以按照顺序执行： public class SpringBootTestClassOrderer implements ClassOrderer { private static final Class&lt;?&gt;[] classOrder=new Class[] { AuthenticationControllerTest.class, RepositoryControllerTest.class, UserControllerTest.class }; @Override public void orderClasses(ClassOrdererContext classOrdererContext) { classOrdererContext.getClassDescriptors().sort(Comparator.comparingInt(SpringBootTestClassOrderer::getOrder)); } private static int getOrder(ClassDescriptor classDescriptor) { for (int i=0; i &lt; classOrder.length; i++) { if (classDescriptor.getTestClass().equals(classOrder[i])) { return i; } } return Integer.MAX_VALUE; } } 最后我的 junit-platform.properties 文件如下： junit.jupiter.testclass.order.default=edu.cmipt.gcs.SpringBootTestClassOrderer 巨人的肩膀 Junit 5 Class Order]]></summary></entry><entry><title type="html">Spring 多次读取请求体</title><link href="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/" rel="alternate" type="text/html" title="Spring 多次读取请求体"/><published>2024-09-19T02:47:47+00:00</published><updated>2024-09-19T02:47:47+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/"><![CDATA[<h1 id="起因">起因</h1> <p>在某次项目中，我需要在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">request</code> 的 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容以检验数据是否符合要求。 但当我在 <code class="language-plaintext highlighter-rouge">Filter</code> 添加通过 <code class="language-plaintext highlighter-rouge">request.getReader()</code> 获取 <code class="language-plaintext highlighter-rouge">body</code> 的代码后，进行测试时，抛出了异常，异常 信息显式 <code class="language-plaintext highlighter-rouge">getReader() has already been called for this request stack</code>。</p> <h1 id="问题分析">问题分析</h1> <p>对于一个流而言，其通常只能被读取一次，当我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行第一次读取后，后续到 <code class="language-plaintext highlighter-rouge">Controller</code> 部分 时，由于有 <code class="language-plaintext highlighter-rouge">@RequestBody</code> 注释的对象，此时会再次读取 <code class="language-plaintext highlighter-rouge">body</code> 部分，这时就会抛出异常。</p> <h1 id="解决方案">解决方案</h1> <p>解决方案也很简单，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletReqeust</code> 继承 <code class="language-plaintext highlighter-rouge">HttpServletRequestWrapper</code>， 在其中缓存 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容，然后在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">body</code> 时，直接从缓存中获取即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyHttpServletRequest</span> <span class="kd">extends</span> <span class="nc">HttpServletRequestWrapper</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyServletInputStream</span> <span class="kd">extends</span> <span class="nc">ServletInputStream</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">InputStream</span> <span class="n">cacheBodyInputStream</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cacheBodyInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">cacheBody</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFinished</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isReady</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setReadListener</span><span class="o">(</span><span class="nc">ReadListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="nc">InputStream</span> <span class="n">requestInputStream</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span> <span class="o">=</span> <span class="nc">StreamUtils</span><span class="o">.</span><span class="na">copyToByteArray</span><span class="o">(</span><span class="n">requestInputStream</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">ServletInputStream</span> <span class="nf">getInputStream</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BufferedReader</span> <span class="nf">getReader</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BufferedReader</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行处理的时候需要创建一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletRequest</code> 对象，然后将其传递给 <code class="language-plaintext highlighter-rouge">FilterChain</code> 的 <code class="language-plaintext highlighter-rouge">doFilter</code> 方法即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span>
        <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">CachedBodyHttpServletRequest</span> <span class="n">cachedRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="c1">// do something</span>
    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">cachedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://dev.to/cynavi/reading-request-body-multiple-times-in-javaspring-boot-1j53">Reading Request Body Multiple Times in Java/Spring Boot</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><summary type="html"><![CDATA[起因 在某次项目中，我需要在 Filter 中获取 request 的 body 部分的内容以检验数据是否符合要求。 但当我在 Filter 添加通过 request.getReader() 获取 body 的代码后，进行测试时，抛出了异常，异常 信息显式 getReader() has already been called for this request stack。 问题分析 对于一个流而言，其通常只能被读取一次，当我们在 Filter 中进行第一次读取后，后续到 Controller 部分 时，由于有 @RequestBody 注释的对象，此时会再次读取 body 部分，这时就会抛出异常。 解决方案 解决方案也很简单，我们只需要自定义一个 CachedBodyHttpServletReqeust 继承 HttpServletRequestWrapper， 在其中缓存 body 部分的内容，然后在 Filter 中获取 body 时，直接从缓存中获取即可： private class CachedBodyHttpServletRequest extends HttpServletRequestWrapper { private class CachedBodyServletInputStream extends ServletInputStream { private final InputStream cacheBodyInputStream; public CachedBodyServletInputStream(byte[] cacheBody) { this.cacheBodyInputStream = new ByteArrayInputStream(cacheBody); } @Override public boolean isFinished() { try { return cacheBodyInputStream.available() == 0; } catch (IOException e) { return true; } } @Override public boolean isReady() { return true; } @Override public void setReadListener(ReadListener listener) { throw new UnsupportedOperationException(); } @Override public int read() throws IOException { return cacheBodyInputStream.read(); } } private final byte[] cacheBody; public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException { super(request); InputStream requestInputStream=request.getInputStream(); this.cacheBody = StreamUtils.copyToByteArray(requestInputStream); } @Override public ServletInputStream getInputStream() { return new CachedBodyServletInputStream(this.cacheBody); } @Override public BufferedReader getReader() { return new BufferedReader( new InputStreamReader(new ByteArrayInputStream(this.cacheBody))); } } 这样我们在 Filter 中进行处理的时候需要创建一个 CachedBodyHttpServletRequest 对象，然后将其传递给 FilterChain 的 doFilter 方法即可： @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CachedBodyHttpServletRequest cachedRequest=new CachedBodyHttpServletRequest(request); // do something filterChain.doFilter(cachedRequest, response); } 巨人的肩膀 Reading Request Body Multiple Times in Java/Spring Boot]]></summary></entry><entry><title type="html">Long 在 Swagger 中精度丢失</title><link href="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/" rel="alternate" type="text/html" title="Long 在 Swagger 中精度丢失"/><published>2024-09-19T02:06:08+00:00</published><updated>2024-09-19T02:06:08+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/"><![CDATA[<h1 id="起因">起因</h1> <p>某次通过 <code class="language-plaintext highlighter-rouge">Swagger</code> 在项目中进行测试的时候，发现响应体中返回的 <code class="language-plaintext highlighter-rouge">id</code> (<code class="language-plaintext highlighter-rouge">Long</code> 类型，由雪花算法生成) 与 数据库中存储的 <code class="language-plaintext highlighter-rouge">id</code> 始终差那么一点点。</p> <h1 id="排查">排查</h1> <p>起先我认为是后端传得数据本身就有问题，于是我在 <code class="language-plaintext highlighter-rouge">Controller</code> 中进行返回数据的时候，将 <code class="language-plaintext highlighter-rouge">id</code> 的值 打印出来，发现 <code class="language-plaintext highlighter-rouge">id</code> 的值是正确的。于是我又在终端中单独执行了 <code class="language-plaintext highlighter-rouge">curl</code> 命令去获取数据，发现 <code class="language-plaintext highlighter-rouge">id</code> 的 值也是正确的。这时候我就很疑惑了，为什么在 <code class="language-plaintext highlighter-rouge">Swagger</code> 中获取的数据会有问题呢？</p> <p>接着我猜测是出现了精度丢失的问题，我猜想 <code class="language-plaintext highlighter-rouge">Long</code> 类型可能不能完全在 <code class="language-plaintext highlighter-rouge">js</code> 中表示，于是 <code class="language-plaintext highlighter-rouge">Swagger</code> 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 <code class="language-plaintext highlighter-rouge">Long 精度丢失</code> 便找到了相关的内容：</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">JavaScript</code> 的 <code class="language-plaintext highlighter-rouge">Number</code> 类型是基于 <code class="language-plaintext highlighter-rouge">IEEE 754</code> 标准的双精度浮点数格式，只能安全地表示 <code class="language-plaintext highlighter-rouge">53</code> 位 二进制数字，也就是 <code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code> 的值 <code class="language-plaintext highlighter-rouge">9007199254740991</code>。</p> </blockquote> <h1 id="解决方法">解决方法</h1> <p>网上的解决方法有很多，例如可以通过在类中 <code class="language-plaintext highlighter-rouge">Long</code> 字段上添加 <code class="language-plaintext highlighter-rouge">@JsonsSerialize(using = ToStringSerializer.class)</code> 注解，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。</p> <p>我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象和发送给前端的 <code class="language-plaintext highlighter-rouge">VO</code> 对象中的 <code class="language-plaintext highlighter-rouge">id</code> 字段更改成 <code class="language-plaintext highlighter-rouge">String</code> 类型，然后在从 <code class="language-plaintext highlighter-rouge">DTO</code> 类型构造 <code class="language-plaintext highlighter-rouge">PO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">String</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">Long</code> 类型，在从 <code class="language-plaintext highlighter-rouge">PO</code> 对象构造 <code class="language-plaintext highlighter-rouge">VO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。这样的好处在于，对于前端而言，<code class="language-plaintext highlighter-rouge">id</code> 确确 实实是一个 <code class="language-plaintext highlighter-rouge">String</code> 类型的字段，前端并不会知道 <code class="language-plaintext highlighter-rouge">id</code> 实际上是以 <code class="language-plaintext highlighter-rouge">Long</code> 类型进行存储的。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通过 UserPO 构造 UserVO</span>
<span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 通过 UserDTO 构造 UserPO</span>
<span class="kd">public</span> <span class="nf">UserPO</span><span class="o">(</span><span class="nc">UserDTO</span> <span class="n">userDTO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">userDTO</span><span class="o">.</span><span class="na">id</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://cloud.tencent.com/developer/article/2445079">长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring-Doc"/><category term="OpenAPI"/><summary type="html"><![CDATA[起因 某次通过 Swagger 在项目中进行测试的时候，发现响应体中返回的 id (Long 类型，由雪花算法生成) 与 数据库中存储的 id 始终差那么一点点。 排查 起先我认为是后端传得数据本身就有问题，于是我在 Controller 中进行返回数据的时候，将 id 的值 打印出来，发现 id 的值是正确的。于是我又在终端中单独执行了 curl 命令去获取数据，发现 id 的 值也是正确的。这时候我就很疑惑了，为什么在 Swagger 中获取的数据会有问题呢？ 接着我猜测是出现了精度丢失的问题，我猜想 Long 类型可能不能完全在 js 中表示，于是 Swagger 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 Long 精度丢失 便找到了相关的内容： JavaScript 的 Number 类型是基于 IEEE 754 标准的双精度浮点数格式，只能安全地表示 53 位 二进制数字，也就是 Number.MAX_SAFE_INTEGER 的值 9007199254740991。 解决方法 网上的解决方法有很多，例如可以通过在类中 Long 字段上添加 @JsonsSerialize(using = ToStringSerializer.class) 注解，将 Long 类型转换为 String 类型。 我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 DTO 对象和发送给前端的 VO 对象中的 id 字段更改成 String 类型，然后在从 DTO 类型构造 PO 对象的时候，将 String 类型的 id 字段转换为 Long 类型，在从 PO 对象构造 VO 对象的时候，将 Long 类型的 id 字段转换为 String 类型。这样的好处在于，对于前端而言，id 确确 实实是一个 String 类型的字段，前端并不会知道 id 实际上是以 Long 类型进行存储的。 // 通过 UserPO 构造 UserVO public UserVO(UserPO userPO) { this(userPO.getId().toString()); } // 通过 UserDTO 构造 UserPO public UserPO(UserDTO userDTO) { try { this.id = Long.valueOf(userDTO.id()); } catch (NumberFormatException e) { this.id = null; } } 巨人的肩膀 长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅]]></summary></entry><entry><title type="html">Spring Validation 路径变量与请求参数校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/" rel="alternate" type="text/html" title="Spring Validation 路径变量与请求参数校验"/><published>2024-09-18T12:43:30+00:00</published><updated>2024-09-18T12:43:30+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 从请求路径中 获取或者通过 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 从请求参数中获取。本文将介绍如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@ReqeustParam</code> 获取的基本类型参数进行校验。</p> <h1 id="validated"><code class="language-plaintext highlighter-rouge">@Validated</code></h1> <p>要对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 获取的参数进行校验，我们必须要在控制器类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。该注解由 <code class="language-plaintext highlighter-rouge">Spring</code> 提供以实现比 <code class="language-plaintext highlighter-rouge">JSR-303</code> 更加灵活的功能。</p> <p>在 <code class="language-plaintext highlighter-rouge">@Validated</code> 官方的文档中，有这样一句话：</p> <blockquote> <p>Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with.</p> </blockquote> <p>简单来说就是当 <code class="language-plaintext highlighter-rouge">@Validated</code> 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。</p> <p>完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Validated</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_CHECK_EMAIL_VALIDITY_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkEmailValidity</span><span class="o">(</span>
            <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
            <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
            <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"email"</span><span class="o">)</span>
            <span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"email"</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">EMAIL_ALREADY_EXISTS</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样操作后，当请求到达 <code class="language-plaintext highlighter-rouge">checkEmailValidity</code> 方法时，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动对 <code class="language-plaintext highlighter-rouge">email</code> 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 <code class="language-plaintext highlighter-rouge">ConstraintViolationException</code> 而不是 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code>。我们可以通过以下的方式进行全局异常处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">ConstraintViolationException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleConstraintViolationException</span><span class="o">(</span>
            <span class="nc">ConstraintViolationException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// do something</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://reflectoring.io/bean-validation-with-spring-boot/#validating-path-variables-and-request-parameters">Validation with Spring Boot - the Complete Guide</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring Validation 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 @PathVariable 从请求路径中 获取或者通过 @RequestParam 从请求参数中获取。本文将介绍如何使用 Spring Validation 对通过 @PathVariable 和 @ReqeustParam 获取的基本类型参数进行校验。 @Validated 要对通过 @PathVariable 和 @RequestParam 获取的参数进行校验，我们必须要在控制器类上添加 @Validated 注解。该注解由 Spring 提供以实现比 JSR-303 更加灵活的功能。 在 @Validated 官方的文档中，有这样一句话： Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with. 简单来说就是当 @Validated 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 @Validated 注解。 完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如： @Validated @RestController public class UserController { @Autowired private UserService userService; @GetMapping(ApiPathConstant.USER_CHECK_EMAIL_VALIDITY_API_PATH) public void checkEmailValidity( @Email(message = "USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank(message = "USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") @RequestParam("email") String email) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("email", email); if (userService.exists(wrapper)) { throw new GenericException(ErrorCodeEnum.EMAIL_ALREADY_EXISTS, email); } } } 这样操作后，当请求到达 checkEmailValidity 方法时，Spring 会自动对 email 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 ConstraintViolationException 而不是 MethodArgumentNotValidException。我们可以通过以下的方式进行全局异常处理： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ConstraintViolationException.class) public ResponseEntity&lt;ErrorVO&gt; handleConstraintViolationException( ConstraintViolationException e, HttpServletRequest request) { // do something } } 巨人的肩膀 Validation with Spring Boot - the Complete Guide]]></summary></entry><entry><title type="html">Linux 大杂烩</title><link href="https://kaiser-yang.github.io/blog/2024/linux-potpourri/" rel="alternate" type="text/html" title="Linux 大杂烩"/><published>2024-09-10T12:30:06+00:00</published><updated>2024-09-10T12:30:06+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/linux-potpourri</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/linux-potpourri/"><![CDATA[<h1 id="wildcards-in-linux">Wildcards in Linux</h1> <p>这里的 <code class="language-plaintext highlighter-rouge">wildcards</code> 指的是能够被 <code class="language-plaintext highlighter-rouge">shell</code> 扩展的符号。 如果在执行的命令中出现这些符号，<code class="language-plaintext highlighter-rouge">shell</code> 会对这些进行解析，解析完成后再传入需要执行的命令。 也就是说只要 <code class="language-plaintext highlighter-rouge">shell</code> 支持，这些 <code class="language-plaintext highlighter-rouge">wildcards</code> 是可以在任意命令中使用的。</p> <p>常见的 <code class="language-plaintext highlighter-rouge">wildcards</code> 有以下几种：</p> <ul> <li><code class="language-plaintext highlighter-rouge">*</code>：匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符。</li> <li><code class="language-plaintext highlighter-rouge">**</code>：递归匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符。</li> <li><code class="language-plaintext highlighter-rouge">?</code>：匹配单个任意字符。</li> <li><code class="language-plaintext highlighter-rouge">[]</code>：匹配出现在中括号中的某个符号。 在中括号中可以使用 <code class="language-plaintext highlighter-rouge">-</code> 来表示范围，<code class="language-plaintext highlighter-rouge">!</code> (或 <code class="language-plaintext highlighter-rouge">~</code>)来表示取反，例如 <code class="language-plaintext highlighter-rouge">[!0-9]</code> 表示匹配不是数字的字符， <code class="language-plaintext highlighter-rouge">[~ab]</code> 表示不是 <code class="language-plaintext highlighter-rouge">a</code> 也不是 <code class="language-plaintext highlighter-rouge">b</code> 的字符。</li> <li><code class="language-plaintext highlighter-rouge">{}</code>：中间内容使用 <code class="language-plaintext highlighter-rouge">,</code> 分隔，表示多个匹配，例如 <code class="language-plaintext highlighter-rouge">a{b,c}d</code> 表示匹配 <code class="language-plaintext highlighter-rouge">abd</code> 或者 <code class="language-plaintext highlighter-rouge">acd</code>。 该通配符会将一个字符串转换成多个字符串，例如 <code class="language-plaintext highlighter-rouge">mv file_{old,new}</code> 会被解析成 <code class="language-plaintext highlighter-rouge">mv file_old file_new</code>。 该通配符还可以进行嵌套，例如 <code class="language-plaintext highlighter-rouge">echo a{b{c,d},e}f</code> 会被解析成 <code class="language-plaintext highlighter-rouge">echo abcf abdf aef</code>。 该通配符中如果要表示范围，需要使用 <code class="language-plaintext highlighter-rouge">..</code>，例如 <code class="language-plaintext highlighter-rouge">echo {a..z}</code> 会被解析成 <code class="language-plaintext highlighter-rouge">echo a b c ... z</code>。</li> </ul> <p>上面的通配符并不是所有的 <code class="language-plaintext highlighter-rouge">shell</code> 都支持的，但是在 <code class="language-plaintext highlighter-rouge">bash</code> 中是支持的。例如在 <code class="language-plaintext highlighter-rouge">fish shell</code> 中，只有 <code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">**</code> 以及 <code class="language-plaintext highlighter-rouge">?</code> 是支持的，其中 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 不会匹配 <code class="language-plaintext highlighter-rouge">/</code>，而 <code class="language-plaintext highlighter-rouge">**</code> 会匹配 <code class="language-plaintext highlighter-rouge">/</code> ，也就是说 <code class="language-plaintext highlighter-rouge">**</code> 是 递归匹配。</p> <p><strong>注意</strong>：在正则表达式的语法中，<code class="language-plaintext highlighter-rouge">*</code> 表示匹配前面的字符 0 次或者多次， <code class="language-plaintext highlighter-rouge">?</code> 表示匹配前面的字符 0 次或者 1 次，<code class="language-plaintext highlighter-rouge">[]</code> 表示匹配中括号中的任意一个字符， <code class="language-plaintext highlighter-rouge">-</code> 表示范围，<code class="language-plaintext highlighter-rouge">^</code> 表示取反。</p> <h1 id="常用命令-cheat-sheet">常用命令 <code class="language-plaintext highlighter-rouge">Cheat Sheet</code></h1> <h2 id="cat"><code class="language-plaintext highlighter-rouge">cat</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>显示非空行的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>合并多个空行为一个空行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">^</code> 和 <code class="language-plaintext highlighter-rouge">M-</code> 显示不可打印字符，换行和制表符除外</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>在每行的结尾显示 <code class="language-plaintext highlighter-rouge">$</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-T</code></td> <td>将制表符显示为 <code class="language-plaintext highlighter-rouge">^I</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-</code></td> <td>从标准输入读取内容</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">cat</code> 可以直接创建带有内容的文件或者追加内容到文件中，例如 <code class="language-plaintext highlighter-rouge">cat &gt; file</code> 会等待输入， 当输入完成后，使用 <code class="language-plaintext highlighter-rouge">^D</code> (EOF, end of file) 来结束输入。 如果要追加内容到文件中，可以使用 <code class="language-plaintext highlighter-rouge">cat &gt;&gt; file</code>。</p> <p><code class="language-plaintext highlighter-rouge">-</code> 可以出现在多个文件的任意位置， 例如 <code class="language-plaintext highlighter-rouge">cat file1 - file2</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间， 而 <code class="language-plaintext highlighter-rouge">cat file1 - file2 - file3</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间、 <code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间。需要注意的是，此时会要求输入两次，第一次输入完成后，使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束， 然后输入第二次，再次使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，第一次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间， 第二次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间。</p> <p>补充：<code class="language-plaintext highlighter-rouge">tac</code> 可以将文件内容逆序输出 (优先输出最后一行)，<code class="language-plaintext highlighter-rouge">tac</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">cat</code> 的逆序。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">cat</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">concatenate</code>，即连接的意思，其可以将多个文件的内容拼接在一起。</p> <h2 id="grep"><code class="language-plaintext highlighter-rouge">grep</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归搜索目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--include "*.py"</code></td> <td>搜索指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude "test*"</code></td> <td>排除指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude-dir "test*"</code></td> <td>排除指定目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--color=auto,always,never</code></td> <td>何时进行高亮</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示所在文件中的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>只显示包含匹配项的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>只显示不包含任何匹配的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>反向匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>显示匹配次数</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>只显示匹配的部分</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>指定最大匹配的次数</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>从文件中读取模式。文件中每行一个模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>指定匹配模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>只匹配完整单词</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>只匹配整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A 2</code></td> <td>显示匹配行的后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-B 2</code></td> <td>显示匹配行的前两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C 2</code></td> <td>显示匹配行的前两行和后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>使用扩展正则表达式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>强制显示文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>强制不显示文件名</td> </tr> </tbody> </table> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">grep</code> 中，完整单词指的是前后均不是字母、数字或者下划线的部分。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-m 1</code> 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">grep</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">g/re/p</code>，其中 <code class="language-plaintext highlighter-rouge">g</code> 表示 <code class="language-plaintext highlighter-rouge">global</code>，<code class="language-plaintext highlighter-rouge">re</code> 表示 <code class="language-plaintext highlighter-rouge">regular expression</code>， <code class="language-plaintext highlighter-rouge">p</code> 表示 <code class="language-plaintext highlighter-rouge">print</code>，直译即全局正则表达式打印。</p> <h2 id="sort"><code class="language-plaintext highlighter-rouge">sort</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>逆序排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>按照数字排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>按照某一列排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>去重</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>忽略大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>人类可读的排序。例如 <code class="language-plaintext highlighter-rouge">1K</code> 会被排序到 <code class="language-plaintext highlighter-rouge">512</code> 的前面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-M</code></td> <td>按照月份排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=-</code></td> <td>从标准输入读取以 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=filename</code></td> <td>从某个文件中读取 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查文件是否已经排序</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-k</code> 可以指定多个列，例如 <code class="language-plaintext highlighter-rouge">-k2,2 -k1,1</code> 表示先按照第二列排序，然后再按照第一列排序。 <code class="language-plaintext highlighter-rouge">-k</code> 也可以按照某列的部分进行排序，例如 <code class="language-plaintext highlighter-rouge">-k2.2,2.3</code> 表示按照第二列的第二个字符到第三个字符进行排序。 <code class="language-plaintext highlighter-rouge">-k</code> 还可以指定列的类型，例如 <code class="language-plaintext highlighter-rouge">-k2n,2</code> 表示按照第二列的数字进行排序。 <code class="language-plaintext highlighter-rouge">-r</code> 选项也可以指定到 <code class="language-plaintext highlighter-rouge">-k</code> 选项中，例如 <code class="language-plaintext highlighter-rouge">-k2r,2</code> 表示按照第二列逆序排序。</p> <h2 id="awk"><code class="language-plaintext highlighter-rouge">awk</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>指定输入的分隔符。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">awk</code> 脚本文件。</td> </tr> </tbody> </table> <h3 id="打印列">打印列</h3> <ul> <li><code class="language-plaintext highlighter-rouge">$0</code>: 所有列。</li> <li><code class="language-plaintext highlighter-rouge">$1</code>: 第一列。</li> <li><code class="language-plaintext highlighter-rouge">...</code></li> <li><code class="language-plaintext highlighter-rouge">$NF</code>: 最后一列。</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}'</code> 打印出每行的第一列、第二列和最后一列。</p> <h3 id="分隔符">分隔符</h3> <p>可以通过 <code class="language-plaintext highlighter-rouge">OFS=</code> (Output Field Separator) 来指定输出的分隔符，例如 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}' OFS=","</code> 表示使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。也可以在 <code class="language-plaintext highlighter-rouge">BEGIN</code> 模式串中指定 <code class="language-plaintext highlighter-rouge">OFS</code>，例如 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {OFS=","} {print $1,$2,$NF}'</code>。</p> <p>除了 <code class="language-plaintext highlighter-rouge">OFS</code> 以外，还有 <code class="language-plaintext highlighter-rouge">FS</code> 用于指定输入文件的分隔符。</p> <h3 id="预定义变量">预定义变量</h3> <p>除了之前提到的 <code class="language-plaintext highlighter-rouge">OFS</code>, <code class="language-plaintext highlighter-rouge">FS</code> 之外，还有一些预定义变量：</p> <ul> <li><code class="language-plaintext highlighter-rouge">NR</code>: 当前行的行号。</li> <li><code class="language-plaintext highlighter-rouge">NF</code>: 当前行的列数。</li> <li><code class="language-plaintext highlighter-rouge">RS</code>：记录分隔符，默认是换行符，也就是每一行作为一条记录。</li> <li><code class="language-plaintext highlighter-rouge">ORS</code>：输出的记录分隔符，默认是换行符。</li> <li><code class="language-plaintext highlighter-rouge">FILENAME</code>：当前文件的文件名。</li> <li><code class="language-plaintext highlighter-rouge">FNR</code>：当前文件的行号，当时用多个文件的时候，<code class="language-plaintext highlighter-rouge">NR</code> 记录的是当前的总行号， <code class="language-plaintext highlighter-rouge">FNR</code> 记录的是当前文件的行号。</li> </ul> <p>我们可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1'</code> 从第二行开始打印，也可以使用 <code class="language-plaintext highlighter-rouge">awk 'NF &gt; 0'</code> 打印列数大于 <code class="language-plaintext highlighter-rouge">0</code> 的行 (即移除空行)。</p> <p>如果要打印第一行到第四行，我们可以通过 <code class="language-plaintext highlighter-rouge">awk 'NR == 1, NR == 4'</code> 来实现。 我们也可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt;= 1 &amp;&amp; NR &lt;= 4'</code> 来实现。</p> <h3 id="模式">模式</h3> <p><code class="language-plaintext highlighter-rouge">BEGIN</code> 和 <code class="language-plaintext highlighter-rouge">END</code> 模式串：</p> <ul> <li><code class="language-plaintext highlighter-rouge">BEGIN</code>: 在处理输入之前执行。</li> <li><code class="language-plaintext highlighter-rouge">END</code>: 在处理输入之后执行。</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {print "Start"} {print} END {print "End"}'</code> 在处理输入之前和之后打印出 <code class="language-plaintext highlighter-rouge">Start</code> 和 <code class="language-plaintext highlighter-rouge">End</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中可以使用模式来过滤行， 例如 <code class="language-plaintext highlighter-rouge">awk '$1 &gt; 10'</code> 表示只打印第一列大于 <code class="language-plaintext highlighter-rouge">10</code> 的行 (当不书写动作时，默认动作是打印整行)。 也可以使用搜索模式，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern/'</code> 表示只打印包含 <code class="language-plaintext highlighter-rouge">pattern</code> 的行，搜索模式支持正则表达式。</p> <p><code class="language-plaintext highlighter-rouge">,</code> 也可以和搜索模式一起使用， 例如 <code class="language-plaintext highlighter-rouge">awk '/pattern1/,/pattern2/'</code> 表示打印找到的 <code class="language-plaintext highlighter-rouge">pattern1</code> 到 <code class="language-plaintext highlighter-rouge">pattern2</code> 的行。</p> <p><code class="language-plaintext highlighter-rouge">~</code> 可以用来表示是否与搜索模式匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 ~ /pattern/'</code> 表示第一列是否包含 <code class="language-plaintext highlighter-rouge">pattern</code>。 <code class="language-plaintext highlighter-rouge">!~</code> 可以用来表示是否不匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 !~ /pattern/'</code> 表示第一列是否不包含 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h3 id="awk-脚本"><code class="language-plaintext highlighter-rouge">awk</code> 脚本</h3> <p>我们也可以书写 <code class="language-plaintext highlighter-rouge">awk</code> 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#! /usr/bin/awk -f</span>

<span class="kr">BEGIN</span> <span class="p">{</span>
    <span class="c1"># 设置输入和输出的分隔符</span>
    <span class="kc">FS</span><span class="o">=</span><span class="s2">":"</span>
    <span class="kc">OFS</span><span class="o">=</span><span class="s2">" "</span>
    <span class="nx">tot_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="kc">NF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">words</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="o">++</span>
        <span class="nx">tot_count</span><span class="o">++</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">END</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s2">"Total words:"</span><span class="p">,</span> <span class="nx">tot_count</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">word</span> <span class="o">in</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="nx">word</span><span class="p">,</span> <span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：由于在 <code class="language-plaintext highlighter-rouge">awk '{print}' file</code> 的意思是对某个文件的内容进行处理， 所以要用 <code class="language-plaintext highlighter-rouge">awk -f file</code> 来表示将文件作为脚本执行。</p> <h3 id="内置函数">内置函数</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中还有一些内置函数，例如 <code class="language-plaintext highlighter-rouge">length</code> 函数可以返回字符串的长度，<code class="language-plaintext highlighter-rouge">substr</code> 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">awk</span> <span class="err">'</span><span class="kc">NR</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">printf</span> <span class="s2">"%s"</span><span class="p">,</span><span class="nv">$NF</span><span class="s2">"+"</span> <span class="p">}</span><span class="err">'</span> <span class="kc">OFS</span><span class="o">=</span><span class="s2">""</span> <span class="o">|</span> <span class="nx">awk</span> <span class="err">'</span><span class="p">{</span> <span class="k">print</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="err">'</span> <span class="o">|</span> <span class="nx">bc</span>
</code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中，<code class="language-plaintext highlighter-rouge">print</code> 会在输出的字符串后面自动添加换行符，而 <code class="language-plaintext highlighter-rouge">printf</code> 可以进行格式化输出， 上面的例子中我们通过 <code class="language-plaintext highlighter-rouge">printf</code> 来输出不带换行符的字符串。在 <code class="language-plaintext highlighter-rouge">awk</code> 中字符串是可以直接拼接的， 例如 <code class="language-plaintext highlighter-rouge">printf "%s", $NF"+"</code> 表示将最后一列的值和 <code class="language-plaintext highlighter-rouge">+</code> 拼接在一起。</p> <p><code class="language-plaintext highlighter-rouge">printf</code> 的格式化方法与 <code class="language-plaintext highlighter-rouge">C/C++</code> 中的类似，这里不再进行详细介绍。</p> <p>当然要实现同样的功能有更简单的命令：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">awk</span> <span class="err">'</span><span class="kc">NR</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="nx">sum</span><span class="o">+=</span><span class="nv">$NF</span> <span class="p">}</span> <span class="kr">END</span> <span class="p">{</span> <span class="k">print</span> <span class="nx">sum</span> <span class="p">}</span><span class="err">'</span>
<span class="c1"># or</span>
<span class="nx">awk</span> <span class="err">'</span><span class="kc">NR</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">print</span> <span class="nx">sep</span> <span class="nv">$NF</span><span class="p">;</span> <span class="nx">sep</span><span class="o">=</span><span class="s2">"+"</span> <span class="p">}</span><span class="err">'</span> <span class="kc">OFS</span><span class="o">=</span><span class="s2">""</span> <span class="kc">ORS</span><span class="o">=</span><span class="s2">""</span> <span class="o">|</span> <span class="nx">bc</span>
</code></pre></div></div> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">awk</code> 中，下标是从 <code class="language-plaintext highlighter-rouge">1</code> 开始的，而不是从 <code class="language-plaintext highlighter-rouge">0</code> 开始的，且区间是闭区间。</p> <p>这里再列出一些常用的内置函数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tolower</code>：将字符串转换为小写。</li> <li><code class="language-plaintext highlighter-rouge">toupper</code>：将字符串转换为大写。</li> <li><code class="language-plaintext highlighter-rouge">split</code>：将字符串按照某个分隔符分割为数组。接收三个参数，第一个参数是要分割的字符串， 第二个参数是数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式， 例如 <code class="language-plaintext highlighter-rouge">split($0, words, /:+/)</code> 表示将当前行按照 <code class="language-plaintext highlighter-rouge">:</code> (或者多个连续的 <code class="language-plaintext highlighter-rouge">:</code>) 分割为数组。</li> <li><code class="language-plaintext highlighter-rouge">gsub</code>：全局替换。接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串， 第三个参数要替换的文本。 例如 <code class="language-plaintext highlighter-rouge">gsub(/pattern/, "replace", $0)</code> 表示将当前行中的 <code class="language-plaintext highlighter-rouge">pattern</code> 替换为 <code class="language-plaintext highlighter-rouge">replace</code>。</li> <li><code class="language-plaintext highlighter-rouge">system</code>：执行系统命令。例如 <code class="language-plaintext highlighter-rouge">system("ls")</code> 会执行 <code class="language-plaintext highlighter-rouge">ls</code> 命令并将结果输出到标准输出。</li> </ul> <h3 id="改变分隔符">改变分隔符</h3> <p>前面介绍到 <code class="language-plaintext highlighter-rouge">FS</code> 和 <code class="language-plaintext highlighter-rouge">OFS</code> 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出， 我们可能会写出 <code class="language-plaintext highlighter-rouge">awk '{print}' FS=':' OFS=' '</code> 这样的命令，试图将 <code class="language-plaintext highlighter-rouge">:</code> 改成空格。 但是这样并不能正确工作， 在 <code class="language-plaintext highlighter-rouge">awk</code> 中只有当列被修改后 (或者在 <code class="language-plaintext highlighter-rouge">print</code> 中打印多个 <code class="language-plaintext highlighter-rouge">fields</code> 的时候) 才会使用新的输出分隔符， 所以我们可以通过 <code class="language-plaintext highlighter-rouge">awk '($1=$1) || 1' FS=':' OFS=' '</code> 来实现 (这里省略了动作，因此会打印一整行)。</p> <p>这里的 <code class="language-plaintext highlighter-rouge">($1=$1) || 1</code> 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 <code class="language-plaintext highlighter-rouge">awk</code> 中被当作 <code class="language-plaintext highlighter-rouge">false</code>，所以我们需要通过 <code class="language-plaintext highlighter-rouge">|| 1</code> 来保证输出。这里的括号是必须的，如果没有括号， <code class="language-plaintext highlighter-rouge">$1=$1 || 1</code> 会被解释为 <code class="language-plaintext highlighter-rouge">$1=($1 || 1)</code>，这样会将 <code class="language-plaintext highlighter-rouge">$1</code> 赋值为 <code class="language-plaintext highlighter-rouge">1</code>，而不是保留原来的值。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">awk</code> 的名字来源于三个创始人的名字 <code class="language-plaintext highlighter-rouge">Alfred Aho</code>、<code class="language-plaintext highlighter-rouge">Peter Weinberger</code> 和 <code class="language-plaintext highlighter-rouge">Brian Kernighan</code> 的首字母。</p> <h3 id="posix-字符类"><code class="language-plaintext highlighter-rouge">POSIX</code> 字符类</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中支持 <code class="language-plaintext highlighter-rouge">POSIX</code> 字符类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">[:alnum:]</code>：字母和数字。</li> <li><code class="language-plaintext highlighter-rouge">[:alpha:]</code>：字母。</li> <li><code class="language-plaintext highlighter-rouge">[:blank:]</code>：空格和制表符。</li> <li><code class="language-plaintext highlighter-rouge">[:cntrl:]</code>：控制字符。</li> <li><code class="language-plaintext highlighter-rouge">[:digit:]</code>：数字。</li> <li><code class="language-plaintext highlighter-rouge">[:graph:]</code>：可打印字符，不包括空格。</li> <li><code class="language-plaintext highlighter-rouge">[:lower:]</code>：小写字母。</li> <li><code class="language-plaintext highlighter-rouge">[:print:]</code>：可打印字符，包括空格。</li> <li><code class="language-plaintext highlighter-rouge">[:punct:]</code>：标点符号。</li> <li><code class="language-plaintext highlighter-rouge">[:space:]</code>：空白字符。</li> <li><code class="language-plaintext highlighter-rouge">[:upper:]</code>：大写字母。</li> <li><code class="language-plaintext highlighter-rouge">[:xdigit:]</code>：十六进制数字。</li> </ul> <p>例如，我们可以使用 <code class="language-plaintext highlighter-rouge">awk '/[[:digit:]]/'</code> 来匹配包含数字的行。当然也可以写成 <code class="language-plaintext highlighter-rouge">awk '/[0-9]/'</code>。</p> <h2 id="find"><code class="language-plaintext highlighter-rouge">find</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-type</code></td> <td>指定文件类型。<code class="language-plaintext highlighter-rouge">f</code> 表示普通文件，<code class="language-plaintext highlighter-rouge">d</code> 表示目录，<code class="language-plaintext highlighter-rouge">l</code> 表示符号链接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-readable</code></td> <td>查找当前用户可读文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-writable</code></td> <td>查找当前用户可写文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-executable</code></td> <td>查找当前用户可执行文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-name</code></td> <td>指定文件名。可以使用 <code class="language-plaintext highlighter-rouge">wildcads</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-path</code></td> <td>指定路径。可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iname</code></td> <td>忽略大小写的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ipath</code></td> <td>忽略大小写的路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-empty</code></td> <td>查找空文件或者空目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-perm 644</code></td> <td>查找权限为 <code class="language-plaintext highlighter-rouge">644</code> 的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mtime +1</code></td> <td>修改时间在一天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-atime +1</code></td> <td>访问时间在一天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ctime +1</code></td> <td>创建时间在一天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mmin +1</code></td> <td>修改时间在一分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-amin +1</code></td> <td>访问时间在一分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-cmin +1</code></td> <td>创建时间在一分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-user</code></td> <td>指定拥有者</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-group</code></td> <td>指定所属组</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-delete</code></td> <td>删除查找到的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-maxdepth</code></td> <td>指定查找的最大深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mindepth</code></td> <td>指定查找的最小深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-and</code></td> <td>逻辑与</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-or</code></td> <td>逻辑或</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-not</code></td> <td>逻辑非</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>不跟踪符号链接 (默认行为)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>跟踪符号链接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>只跟踪指定的路径或文件的符号链接。例如 <code class="language-plaintext highlighter-rouge">-H .</code> 只对 <code class="language-plaintext highlighter-rouge">.</code> 目录下的符号链接进行跟踪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-print0</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-regex</code></td> <td>使用正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iregex</code></td> <td>使用忽略大小写的正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-samefile</code></td> <td>指定文件的硬链接。例如 <code class="language-plaintext highlighter-rouge">find . -samefile file</code> 表示查找和 <code class="language-plaintext highlighter-rouge">file</code> 硬链接的文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-links</code></td> <td>指定文件的硬链接数。例如 <code class="language-plaintext highlighter-rouge">find . -links 2</code> 表示查找硬链接数为 <code class="language-plaintext highlighter-rouge">2</code> 的文件，<code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 可以用来表示大于和小于</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">-type</code> 还可以以下类型有：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块设备文件</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字符设备文件</li> <li><code class="language-plaintext highlighter-rouge">p</code>：管道文件</li> <li><code class="language-plaintext highlighter-rouge">s</code>：套接字文件</li> </ul> <p><strong>注意</strong>：使用正则表达式匹配含有某个串的文件名时，需要使用 <code class="language-plaintext highlighter-rouge">.*</code> 来表示任意数量的字符， 例如 <code class="language-plaintext highlighter-rouge">find . -regex ".*pattern.*"</code>，而不能直接使用 <code class="language-plaintext highlighter-rouge">find . -regex "pattern"</code>。</p> <p><strong>注意</strong>：如果要使用复杂的逻辑表达式，需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来分组， 例如 <code class="language-plaintext highlighter-rouge">find . \( -name "*.txt" -or -name "*.md" \)</code> 表示查找所有 <code class="language-plaintext highlighter-rouge">txt</code> 或者 <code class="language-plaintext highlighter-rouge">md</code> 文件， 其中的括号需要进行转义，这是因为 <code class="language-plaintext highlighter-rouge">Shell</code> 往往会对括号进行特殊处理。</p> <h3 id="指定文件大小">指定文件大小</h3> <p><code class="language-plaintext highlighter-rouge">-size</code> 参数有以下几种单位：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块，取决于文件系统，默认是 <code class="language-plaintext highlighter-rouge">512</code> 字节</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字节</li> <li><code class="language-plaintext highlighter-rouge">k</code>：千字节 (1024 字节)</li> <li><code class="language-plaintext highlighter-rouge">M</code>：兆字节 (1024 千字节)</li> <li><code class="language-plaintext highlighter-rouge">G</code>：吉字节 (1024 兆字节)</li> </ul> <p>知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可， 例如 <code class="language-plaintext highlighter-rouge">find . -size 1M</code> 表示查找大小为 <code class="language-plaintext highlighter-rouge">1</code> 兆字节的文件。</p> <p>但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 来表示大于和小于， 例如 <code class="language-plaintext highlighter-rouge">find . -size +1M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件，<code class="language-plaintext highlighter-rouge">find . -size -1M</code> 表示查找小于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件。 这两者也可以结合使用，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M -size -2M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 且小于 <code class="language-plaintext highlighter-rouge">2MB</code> 的文件。</p> <h3 id="对查找到的文件执行操作">对查找到的文件执行操作</h3> <p><code class="language-plaintext highlighter-rouge">-exec</code> 可以对查找到的文件执行操作， 例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec cat {} \;</code> 表示查找当前目录下的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并将其内容输出到标准输出。 <code class="language-plaintext highlighter-rouge">{}</code> 会被替换为查找到的文件名，<code class="language-plaintext highlighter-rouge">\;</code> 表示结束，分号需要进行转义，防止被 <code class="language-plaintext highlighter-rouge">Shell</code> 解释。</p> <p>也可以使用 <code class="language-plaintext highlighter-rouge">grep</code> 命令过滤查找到的文件， 例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec grep "pattern" {} \;</code> 表示查找当前目录下的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并在其中查找 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h2 id="tar"><code class="language-plaintext highlighter-rouge">tar</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>创建文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-z</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">gzip</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-j</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">bzip2</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-J</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">xz</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>提取文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>指定提取的目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>列出文档内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--wildcards</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 匹配文件。例如 <code class="language-plaintext highlighter-rouge">tar -xf a.tar --wildcards '*.txt'</code> 可以提取 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--delete</code></td> <td>删除文档中的文件。例如 <code class="language-plaintext highlighter-rouge">tar -f a.tar --delete '*.txt'</code> 可以删除 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude=</code></td> <td>排除文件。例如 <code class="language-plaintext highlighter-rouge">tar -cf a.tar --exclude=*.txt .</code> 可以创建 <code class="language-plaintext highlighter-rouge">a.tar</code> 时排除所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>向文档中追加文件。例如 <code class="language-plaintext highlighter-rouge">tar -rf a.tar b.txt</code> 可以将 <code class="language-plaintext highlighter-rouge">b.txt</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>向文档中追加另一个文档。例如 <code class="language-plaintext highlighter-rouge">tar -Af a.tar b.tar</code> 可以将 <code class="language-plaintext highlighter-rouge">b.tar</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-W</code></td> <td>检验文档。例如 <code class="language-plaintext highlighter-rouge">tar -Wf a.tar</code> 可以检验 <code class="language-plaintext highlighter-rouge">a.tar</code> 的完整性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>更新文档。例如 <code class="language-plaintext highlighter-rouge">tar -uf a.tar b.txt</code> 可以更新 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的 <code class="language-plaintext highlighter-rouge">b.txt</code> 文件</td> </tr> </tbody> </table> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">--exclude</code> 时必须使用 <code class="language-plaintext highlighter-rouge">=</code> 进行连接，且 <code class="language-plaintext highlighter-rouge">--exclude</code> 要出现在待打包文件或目录之前， <code class="language-plaintext highlighter-rouge">tar -cf a.tar . --exclude=*.txt</code> 是错误用法。</p> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">-u</code> 的时候，并不会覆盖旧的文件，而是直接追加新的文件， 这样 <code class="language-plaintext highlighter-rouge">tar</code> 文件中可能会有多个同名的文件，目前我并没有找到如何提取旧文件的方法。</p> <h2 id="ln"><code class="language-plaintext highlighter-rouge">ln</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>创建软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>强制创建。如果软连接已经存在，会覆盖原有的软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定连接的目标目录。<code class="language-plaintext highlighter-rouge">ln -t dir target</code> 与 <code class="language-plaintext highlighter-rouge">ln target dir</code> 效果相同</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">ln target link_name</code> 创建的时候如果 <code class="language-plaintext highlighter-rouge">link_name</code> 是一个目录，那么会在目录下创建一个名为 <code class="language-plaintext highlighter-rouge">target</code> 的文件。</p> <p><code class="language-plaintext highlighter-rouge">ln</code> 默认创建硬连接。</p> <p>使用 <code class="language-plaintext highlighter-rouge">rm</code> 和 <code class="language-plaintext highlighter-rouge">unlink</code> 命令均可以删除软连接或者硬连接。 但是 <code class="language-plaintext highlighter-rouge">unlink</code> 一次只能删除一个文件，而 <code class="language-plaintext highlighter-rouge">rm</code> 可以删除多个文件。</p> <h3 id="硬连接与软连接">硬连接与软连接</h3> <p><code class="language-plaintext highlighter-rouge">ln</code> 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 <code class="language-plaintext highlighter-rouge">inode</code>， 而软连接是指一个文件指向另一个文件。除此之外，硬连接和软连接还有以下区别：</p> <ul> <li>软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件。</li> <li>软连接可以指向目录，而硬连接不能指向目录。</li> <li>源文件被删除的时候，硬连接不会受到影响，而软连接会失效。</li> </ul> <p>在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，可以通过 <code class="language-plaintext highlighter-rouge">ls -l</code> 命令查看文件的硬连接数 (第二列为硬连接数)， 硬连接数为 <code class="language-plaintext highlighter-rouge">1</code> 表示只有一个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>，而硬连接数大于 <code class="language-plaintext highlighter-rouge">1</code> 表示有多个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>。</p> <h2 id="ssh-相关命令"><code class="language-plaintext highlighter-rouge">ssh</code> 相关命令</h2> <h3 id="ssh"><code class="language-plaintext highlighter-rouge">ssh</code></h3> <p><code class="language-plaintext highlighter-rouge">ssh</code> 分为 <code class="language-plaintext highlighter-rouge">client</code> 和 <code class="language-plaintext highlighter-rouge">server</code> 两部分，<code class="language-plaintext highlighter-rouge">client</code> 用于连接远程主机，<code class="language-plaintext highlighter-rouge">server</code> 用于接收远程主机的连接。 <code class="language-plaintext highlighter-rouge">openssh-client</code> 和 <code class="language-plaintext highlighter-rouge">openssh-server</code> 是 <code class="language-plaintext highlighter-rouge">ssh</code> 的两个主要组件。</p> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>指定端口。默认端口是 <code class="language-plaintext highlighter-rouge">22</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>指定密钥文件。默认情况下，<code class="language-plaintext highlighter-rouge">ssh</code> 使用 <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code> 作为密钥文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>指定用户名。默认情况下，<code class="language-plaintext highlighter-rouge">ssh</code> 使用当前用户名作为登录用户名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-q</code></td> <td>静默模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>强制分配终端</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息。可以使用多个 <code class="language-plaintext highlighter-rouge">v</code> 来显示更多的信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>压缩传输。使用 <code class="language-plaintext highlighter-rouge">-C</code> 可以压缩传输的数据</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-X</code></td> <td>启用 <code class="language-plaintext highlighter-rouge">X11</code> 受限转发。可以在本地显式远程主机的 <code class="language-plaintext highlighter-rouge">X11</code> 程序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-Y</code></td> <td>启用 <code class="language-plaintext highlighter-rouge">X11</code> 信赖转发</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>后台运行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-N</code></td> <td>不执行远程命令。通常在端口转发时使用</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>本地端口转发</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-R</code></td> <td>远程端口转发</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-D</code></td> <td>动态端口转发</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>指定配置选项</td> </tr> </tbody> </table> <p><strong>注意</strong>：对于 <code class="language-plaintext highlighter-rouge">-l</code> 选项，也可以不使用 <code class="language-plaintext highlighter-rouge">-l</code> 而是使用 <code class="language-plaintext highlighter-rouge">user@host</code> 的形式来指定用户名。</p> <p><strong>注意</strong>：关于端口转发可以查看 <a href="/blog/2024/ssh-port-forwarding"><code class="language-plaintext highlighter-rouge">ssh</code> 端口转发简介</a>。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-o</code> 选项常常用于覆盖 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件中的配置。 例如 <code class="language-plaintext highlighter-rouge">ssh -o "Port=2222" host_name</code> 将会使用 <code class="language-plaintext highlighter-rouge">2222</code> 端口连接 <code class="language-plaintext highlighter-rouge">host_name</code>，其余配置不变。</p> <h3 id="ssh-keygen"><code class="language-plaintext highlighter-rouge">ssh-keygen</code></h3> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>指定迭代次数。越高则生成的密钥越安全，但是验证的时候也会越慢</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定密钥类型</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>指定密钥长度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>添加注释</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>修改密钥的注释</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定密钥路经以及文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>指定密钥的密码</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>修改密钥的密码</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>显示密钥的指纹</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>对 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件进行哈希处理</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-R</code></td> <td>从 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件中删除指定主机的密钥</td> </tr> </tbody> </table> <p><strong>注意</strong>：从 <code class="language-plaintext highlighter-rouge">open_ssh 9.5</code> 开始默认生成的密钥是 <code class="language-plaintext highlighter-rouge">ed25519</code>，而不是 <code class="language-plaintext highlighter-rouge">rsa</code>。 <code class="language-plaintext highlighter-rouge">ed25519</code> 相较与 <code class="language-plaintext highlighter-rouge">rsa</code> 更加安全，且性能更好。</p> <h3 id="sshknown_hosts-文件"><code class="language-plaintext highlighter-rouge">~/.ssh/known_hosts</code> 文件</h3> <p><code class="language-plaintext highlighter-rouge">known_hosts</code> 文件存储了远程主机的公钥，当第一次连接远程主机的时候， <code class="language-plaintext highlighter-rouge">ssh</code> 会将远程主机的公钥存储到 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件中，下次连接远程主机的时候， <code class="language-plaintext highlighter-rouge">ssh</code> 会检查远程主机的公钥是否和 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件中的公钥一致， 如果一致则连接成功，否则会提示公钥不一致。</p> <p><code class="language-plaintext highlighter-rouge">known_hosts</code> 文件可以很好的防止 <code class="language-plaintext highlighter-rouge">Man-in-the-middle</code> 攻击。</p> <p>而默认情况下，<code class="language-plaintext highlighter-rouge">known_hosts</code> 文件的远程地址部分是以明文的形式存储的， 这样当 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件泄露的时候，攻击者可以直接获取到远程主机的地址与对应的公钥， 而使用 <code class="language-plaintext highlighter-rouge">ssh-keygen -H</code> 可以对 <code class="language-plaintext highlighter-rouge">known_hosts</code> 的远程地址进行哈希处理， 这样在 <code class="language-plaintext highlighter-rouge">known_hosts</code> 文件泄露的时候，攻击者无法直接获取到远程主机的地址与公钥的对应关系。</p> <h3 id="sshconfig-文件"><code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件</h3> <p><code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件可以用来配置 <code class="language-plaintext highlighter-rouge">ssh</code> 的一些选项，例如：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host host_name
    HostName host_ip
    Port port
    User user_name
    IdentityFile ~/.ssh/id_rsa

Host <span class="k">*</span>
    ServerAliveInterval 60
    ServerAliveCountMax 3
    Compression <span class="nb">yes
    </span>CompressionLevel 9
    ForwardAgent <span class="nb">yes
    </span>ForwardX11 <span class="nb">yes
    </span>ForwardX11Trusted <span class="nb">yes
    </span>TCPKeepAlive <span class="nb">yes
    </span>ControlMaster auto
    ControlPath ~/.ssh/master-%r@%h:%p
    ControlPersist 600
    UserKnownHostsFile ~/.ssh/known_hosts
    StrictHostKeyChecking <span class="nb">yes
    </span>HashKnownHosts <span class="nb">yes
    </span>GSSAPIAuthentication <span class="nb">yes
    </span>GSSAPIDelegateCredentials <span class="nb">yes
    </span>GSSAPITrustDNS <span class="nb">yes
    </span>PasswordAuthentication no
    PubkeyAuthentication <span class="nb">yes
    </span>PreferredAuthentications publickey
    KexAlgorithms
    ProxyCommand ssh <span class="nt">-W</span> %h:%p proxy_address
</code></pre></div></div> <p>当你拥有上面的配置后，你可以通过 <code class="language-plaintext highlighter-rouge">ssh host_name</code> 来连接远程主机， 而不需要指定远程主机的 <code class="language-plaintext highlighter-rouge">ip</code>、<code class="language-plaintext highlighter-rouge">port</code>、<code class="language-plaintext highlighter-rouge">user</code> 和 <code class="language-plaintext highlighter-rouge">identity file</code>。</p> <p>使用 <code class="language-plaintext highlighter-rouge">*</code> 可以对所有主机生效，可以达到修改默认配置的目的。</p> <p><code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中也支持通配符：</p> <ul> <li><code class="language-plaintext highlighter-rouge">*</code>：匹配所有主机</li> <li><code class="language-plaintext highlighter-rouge">?</code>：匹配一个字符</li> <li><code class="language-plaintext highlighter-rouge">!</code>：排除主机</li> </ul> <h3 id="ssh-copy-id"><code class="language-plaintext highlighter-rouge">ssh-copy-id</code></h3> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>指定密钥文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>指定端口</td> </tr> </tbody> </table> <h3 id="ssh-agent"><code class="language-plaintext highlighter-rouge">ssh-agent</code></h3> <p><code class="language-plaintext highlighter-rouge">ssh-agent</code> 用来管理用户的密钥，如果密钥被添加到 <code class="language-plaintext highlighter-rouge">ssh-agent</code> 后， 用户在后续登录过程中可以不输入密钥的密码。</p> <p>要在当前的 <code class="language-plaintext highlighter-rouge">shell</code> 中启动 <code class="language-plaintext highlighter-rouge">ssh-agent</code>，可以使用 <code class="language-plaintext highlighter-rouge">eval $(ssh-agent)</code>。</p> <h3 id="ssh-add"><code class="language-plaintext highlighter-rouge">ssh-add</code></h3> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>列出所有已加载密钥的指纹</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>列出所有已加载密钥的公钥</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-d</code></td> <td>删除某个密钥</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-D</code></td> <td>删除所有密钥</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>锁定 <code class="language-plaintext highlighter-rouge">ssh-agent</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-X</code></td> <td>解锁 <code class="language-plaintext highlighter-rouge">ssh-agent</code></td> </tr> </tbody> </table> <p><strong>注意</strong>：如果命令执行过程中提示 <code class="language-plaintext highlighter-rouge">Could not open a connection to your authentication agent</code>， 那么可能是因为没有启动 <code class="language-plaintext highlighter-rouge">ssh-agent</code>，可以使用 <code class="language-plaintext highlighter-rouge">eval $(ssh-agent)</code> 启动 <code class="language-plaintext highlighter-rouge">ssh-agent</code>。</p> <h3 id="sftp"><code class="language-plaintext highlighter-rouge">sftp</code></h3> <p><code class="language-plaintext highlighter-rouge">sftp</code> 是一个交互式的文件传输工具，其通过 <code class="language-plaintext highlighter-rouge">ssh</code> 保证文件传输的安全性。</p> <p><code class="language-plaintext highlighter-rouge">sftp</code> 的启动与 <code class="language-plaintext highlighter-rouge">ssh</code> 类似，例如 <code class="language-plaintext highlighter-rouge">sftp user@host</code>。 启动后我们可以通过 <code class="language-plaintext highlighter-rouge">help</code> 或者 <code class="language-plaintext highlighter-rouge">?</code> 列出可以使用的命令。大多 <code class="language-plaintext highlighter-rouge">Linux</code> 的命令都可以在 <code class="language-plaintext highlighter-rouge">sftp</code> 中使用。 除此之外，我们在通常的命令前面增加 <code class="language-plaintext highlighter-rouge">l</code> (或 <code class="language-plaintext highlighter-rouge">!</code>) 表示在本定执行， 例如 <code class="language-plaintext highlighter-rouge">pwd</code> 可以查看远程主机的当前目录， 而 <code class="language-plaintext highlighter-rouge">lpwd</code> 可以查看本地主机的当前目录；<code class="language-plaintext highlighter-rouge">cd</code> 可以切换远程主机的目录， 而 <code class="language-plaintext highlighter-rouge">lcd</code> 可以切换本地主机的目录。</p> <p>如果你需要多次在本地执行某修操作，你可以使用 <code class="language-plaintext highlighter-rouge">!</code> 来切换到本地的 <code class="language-plaintext highlighter-rouge">shell</code>， 这样就可以不用在命令前面加 <code class="language-plaintext highlighter-rouge">l</code> 了。执行完本地操作后想要回到 <code class="language-plaintext highlighter-rouge">sftp</code> 中，只需要执行 <code class="language-plaintext highlighter-rouge">exit</code> 即可。</p> <p>使用 <code class="language-plaintext highlighter-rouge">get</code> 命令可以下载文件，例如 <code class="language-plaintext highlighter-rouge">get file</code> 表示下载 <code class="language-plaintext highlighter-rouge">file</code> 文件到本地主机， 而 <code class="language-plaintext highlighter-rouge">put</code> 命令可以上传文件，例如 <code class="language-plaintext highlighter-rouge">put file</code> 表示上传 <code class="language-plaintext highlighter-rouge">file</code> 文件到远程主机。 两个命令的使用方式与 <code class="language-plaintext highlighter-rouge">cp</code> 类似，对于目录需要增加 <code class="language-plaintext highlighter-rouge">-r</code> 选项。</p> <h3 id="sshfs"><code class="language-plaintext highlighter-rouge">sshfs</code></h3> <p>直接使用 <code class="language-plaintext highlighter-rouge">sftp</code> 可以完成一些简单的文件传输，但是如果我们并不只是希望直接传输远程的文件， 而且还需要对远程文件进行修改，例如我们希望直接使用我们本地配置丰富的编辑器来编辑远程文件， 那么此时我们就可以使用 <code class="language-plaintext highlighter-rouge">sshfs</code> 来实现。</p> <p><code class="language-plaintext highlighter-rouge">sshfs</code> 的原理就是利用 <code class="language-plaintext highlighter-rouge">sftp</code> 协议将远程主机的文件挂载到本地主机上， 相信使用过类似于 <code class="language-plaintext highlighter-rouge">NFS</code> 的用户对这种操作并不陌生。</p> <p>使用 <code class="language-plaintext highlighter-rouge">sshfs</code> 进行挂载：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sshfs user@host:/path/to/dir /path/to/mount_point
</code></pre></div></div> <p><strong>注意</strong>：挂载点的拥有者必须是当前用户。</p> <p>如果要进行卸载，可以使用 <code class="language-plaintext highlighter-rouge">fusermount -u /path/to/mount_point</code> 或者 <code class="language-plaintext highlighter-rouge">umount /path/to/mount_point</code>。</p> <p><strong>注意</strong>：不建议将挂载放入到 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 中，因为当网络不稳定时可能会进行很长时间的重试， 这样会导致系统启动时间非常漫长。</p> <h3 id="scp"><code class="language-plaintext highlighter-rouge">scp</code></h3> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归复制</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>指定端口</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>保留文件属性 (例如修改时间等)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-q</code></td> <td>静默模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息。可以使用多个 <code class="language-plaintext highlighter-rouge">-v</code> 来显示更多的信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>压缩传输</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>指定密钥文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>限制带宽, 单位是 <code class="language-plaintext highlighter-rouge">Kb/s</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-3</code></td> <td>通过本机在两个远端之间传输文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-4</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv4</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-6</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv6</code></td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">scp</code> 的时候，如果在 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中配置了主机信息，可以直接使用主机名进行传输， 例如 <code class="language-plaintext highlighter-rouge">scp file host_name:/path/to/file</code>。</p> <p><code class="language-plaintext highlighter-rouge">scp</code> 可以一次拷贝多个文件，例如 <code class="language-plaintext highlighter-rouge">scp file1 file2 host_name:/path/to/</code>。</p> <h2 id="apropos"><code class="language-plaintext highlighter-rouge">apropos</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>逻辑与。可用于匹配多个关键字，例如 <code class="language-plaintext highlighter-rouge">apropos -a keyword1 keyword2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>精确匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>匹配带有 <code class="language-plaintext highlighter-rouge">Shell</code> 支持的通配符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>使用正则表达式匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>不依照终端宽度进行裁剪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">man</code> 手册的节。例如 <code class="language-plaintext highlighter-rouge">apropos -s 3 keyword</code> 表示查找第 <code class="language-plaintext highlighter-rouge">3</code> 节的手册</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">man</code> 手册的节有以下几个：</p> <ul> <li><code class="language-plaintext highlighter-rouge">1</code>：命令或程序。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：系统调用。</li> <li><code class="language-plaintext highlighter-rouge">3</code>：库函数。</li> <li><code class="language-plaintext highlighter-rouge">4</code>：特殊文件。</li> <li><code class="language-plaintext highlighter-rouge">5</code>：文件格式和约定。</li> <li><code class="language-plaintext highlighter-rouge">6</code>：游戏。</li> <li><code class="language-plaintext highlighter-rouge">7</code>：杂项。</li> <li><code class="language-plaintext highlighter-rouge">8</code>：系统管理命令。</li> <li><code class="language-plaintext highlighter-rouge">9</code>：内核相关。</li> </ul> <h2 id="tee"><code class="language-plaintext highlighter-rouge">tee</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>追加</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略中断信号</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">tee</code> 的作用是将标准输入的内容输出到标准输出和文件，其通常在管道中使用： 管道在进行传递的时候可能会遇到需要 <code class="language-plaintext highlighter-rouge">root</code> 权限的时候， 这时候就需要使用 <code class="language-plaintext highlighter-rouge">sudo tee</code> 从管道中读取信息并写入到文件中。 例如 <code class="language-plaintext highlighter-rouge">echo "content" | sudo tee file</code>。</p> <h2 id="usermod"><code class="language-plaintext highlighter-rouge">usermod</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>修改用户名。例如 <code class="language-plaintext highlighter-rouge">usermod -l new_name old_name</code> 表示将 <code class="language-plaintext highlighter-rouge">old_name</code> 修改为 <code class="language-plaintext highlighter-rouge">new_name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>修改用户 <code class="language-plaintext highlighter-rouge">UID</code>。例如 <code class="language-plaintext highlighter-rouge">usermod -u 1000 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的 <code class="language-plaintext highlighter-rouge">UID</code> 修改为 <code class="language-plaintext highlighter-rouge">1000</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>允许重复的 <code class="language-plaintext highlighter-rouge">UID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-g</code></td> <td>修改基本用户组。例如 <code class="language-plaintext highlighter-rouge">usermod -g group user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的基本用户组修改为 <code class="language-plaintext highlighter-rouge">group</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-G</code></td> <td>修改附加用户组。例如 <code class="language-plaintext highlighter-rouge">usermod -G group1,group2 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的附加用户组修改为 <code class="language-plaintext highlighter-rouge">group1</code> 和 <code class="language-plaintext highlighter-rouge">group2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>与 <code class="language-plaintext highlighter-rouge">-G</code> 同时使用，表示追加附加用户组</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>修改用户描述</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-d</code></td> <td>修改用户主目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>与 <code class="language-plaintext highlighter-rouge">-d</code> 同时使用，表示同时移动用户主目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>修改用户登录 <code class="language-plaintext highlighter-rouge">shell</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>修改用户过期时间。例如 <code class="language-plaintext highlighter-rouge">usermod -e 2025-12-31 user</code> 表示将 <code class="language-plaintext highlighter-rouge">user</code> 的过期时间修改为 <code class="language-plaintext highlighter-rouge">2025-12-31</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>设置新的密码。注意新的密码应该是加密后的密码，可以使用 <code class="language-plaintext highlighter-rouge">openssl passwd</code> 来生成加密后的密码，更加推荐使用 <code class="language-plaintext highlighter-rouge">passwd</code> 命令进行密码修改</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>锁定用户。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-U</code></td> <td>解锁用户。</td> </tr> </tbody> </table> <p><strong>注意</strong>：创建出来的用户默认是不会过期的。如果设置了过期时间后，可以通过 <code class="language-plaintext highlighter-rouge">chmod -e ""</code> 来取消。 当用户过期后，用户将无法登录，但是用户依然存在，<code class="language-plaintext highlighter-rouge">root</code> 可以解锁用户。</p> <h2 id="su"><code class="language-plaintext highlighter-rouge">su</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>以登录状态切换用户</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>执行命令。例如 <code class="language-plaintext highlighter-rouge">su -c command user</code> 表示以 <code class="language-plaintext highlighter-rouge">user</code> 用户的身份执行 <code class="language-plaintext highlighter-rouge">command</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">shell</code>。例如 <code class="language-plaintext highlighter-rouge">su -s /bin/bash user</code> 表示以 <code class="language-plaintext highlighter-rouge">user</code> 用户的身份使用 <code class="language-plaintext highlighter-rouge">bash</code> <code class="language-plaintext highlighter-rouge">shell</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>保留 <code class="language-plaintext highlighter-rouge">HOME</code>, <code class="language-plaintext highlighter-rouge">SHELL</code>, <code class="language-plaintext highlighter-rouge">USER</code>, <code class="language-plaintext highlighter-rouge">LOGNAME</code> 环境变量</td> </tr> </tbody> </table> <p><strong>注意</strong>：使用 <code class="language-plaintext highlighter-rouge">su</code> 切换用户时，如果不指定用户，会默认切换到 <code class="language-plaintext highlighter-rouge">root</code> 用户。</p> <p><strong>注意</strong>：如果不使用 <code class="language-plaintext highlighter-rouge">-l</code> 选项，<code class="language-plaintext highlighter-rouge">su</code> 不会切换用户的环境变量，而使用 <code class="language-plaintext highlighter-rouge">-l</code> 的时候，以下会被依次执行：</p> <blockquote> <ol> <li>clears all the environment variables except <code class="language-plaintext highlighter-rouge">TERM</code> and variables specified by <code class="language-plaintext highlighter-rouge">--whitelist-environment</code></li> <li>initializes the environment variables <code class="language-plaintext highlighter-rouge">HOME</code>, <code class="language-plaintext highlighter-rouge">SHELL</code>, <code class="language-plaintext highlighter-rouge">USER</code>, <code class="language-plaintext highlighter-rouge">LOGNAME</code>, and <code class="language-plaintext highlighter-rouge">PATH</code></li> <li>changes to the target user’s home directory</li> <li>sets <code class="language-plaintext highlighter-rouge">argv[0]</code> of the shell to <code class="language-plaintext highlighter-rouge">-</code> in order to make the shell a login shell</li> </ol> </blockquote> <h2 id="sudo"><code class="language-plaintext highlighter-rouge">sudo</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>列出用户可以执行的命令。可以使用 <code class="language-plaintext highlighter-rouge">sudo -l command</code> 来检查是否可以执行某个命令</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-U</code></td> <td>与 <code class="language-plaintext highlighter-rouge">-l</code> 一同使用，指定列出的用户而不是执行 <code class="language-plaintext highlighter-rouge">sudo</code> 的用户</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>指定用户执行命令。例如 <code class="language-plaintext highlighter-rouge">sudo -u user command</code> 表示以 <code class="language-plaintext highlighter-rouge">user</code> 用户的身份执行 <code class="language-plaintext highlighter-rouge">command</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-g</code></td> <td>指定用户组。例如 <code class="language-plaintext highlighter-rouge">sudo -g group command</code> 表示以 <code class="language-plaintext highlighter-rouge">group</code> 用户组的身份执行 <code class="language-plaintext highlighter-rouge">command</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">shell</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>删除缓存的密码</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>更新记住密码时间的时间戳为当前时刻</td> </tr> </tbody> </table> <h3 id="etcsudoers-文件"><code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件</h3> <p><code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件用于配置 <code class="language-plaintext highlighter-rouge">sudo</code> 的权限，只有拥有 <code class="language-plaintext highlighter-rouge">root</code> 权限的用户可以修改这个文件。</p> <p><code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件的格式如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 配置某个用户</span>
user <span class="nv">host</span><span class="o">=(</span>runas[:runasgroup]<span class="o">)</span> <span class="o">[</span>NOPASSWD:] <span class="nb">command</span>
<span class="c"># 配置某个组下的所有用户</span>
%group <span class="nv">host</span><span class="o">=(</span>runas[:runasgroup]<span class="o">)</span> <span class="o">[</span>NOPASSWD:] <span class="nb">command</span>
<span class="c"># 引入目录中的所有文件</span>
@includedir <span class="nb">dirname</span>
</code></pre></div></div> <p>对于上述的规则，方括号中代表可选项，这里给出几个实例：</p> <ul> <li><code class="language-plaintext highlighter-rouge">user ALL=(ALL) ALL</code>：允许 <code class="language-plaintext highlighter-rouge">user</code> 用户在任何主机上以任何用户的身份执行任何命令。</li> <li><code class="language-plaintext highlighter-rouge">%group ALL=(ALL) NOPASSWD: ALL</code>：允许 <code class="language-plaintext highlighter-rouge">group</code> 组下的所有用户在任何主机上以任何用户的身份执行任何命令， 且不需要输入密码。</li> <li><code class="language-plaintext highlighter-rouge">@includedir /etc/sudoers.d</code> 表示引入 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> 目录下的所有文件，这是默认添加的配置， 这意味着我们对于其他用户的配置可以放在 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> 目录下，并以用户名命名文件方便管理。</li> </ul> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">@includedir</code> 目录下的文件不能以 <code class="language-plaintext highlighter-rouge">~</code> 结尾并且不能含有 <code class="language-plaintext highlighter-rouge">.</code>。 这是在 <code class="language-plaintext highlighter-rouge">/etc/sudoers.d/README</code> 中明确指出的：</p> <blockquote> <p>This will cause <code class="language-plaintext highlighter-rouge">sudo</code> to read and parse any files in the <code class="language-plaintext highlighter-rouge">/etc/sudoers.d</code> directory that do not end in <code class="language-plaintext highlighter-rouge">~</code> or contain a <code class="language-plaintext highlighter-rouge">.</code> character.</p> </blockquote> <p><strong>注意</strong>：如果要配置多条命令应该使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。</p> <h2 id="visudo"><code class="language-plaintext highlighter-rouge">visudo</code></h2> <p>推荐使用 <code class="language-plaintext highlighter-rouge">visudo</code> 对 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code> 文件进行修改 (即通过命令 <code class="language-plaintext highlighter-rouge">sudo visudo</code>)， <code class="language-plaintext highlighter-rouge">visudo</code> 会在修改后检查是否存在语法错误。</p> <p><code class="language-plaintext highlighter-rouge">visudo</code> 还有一些选项：</p> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查语法错误</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件</td> </tr> </tbody> </table> <h2 id="mount"><code class="language-plaintext highlighter-rouge">mount</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>挂载所有在 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 中配置的文件系统</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定文件系统类型</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>指定挂载选项</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>以只读模式挂载</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>以读写模式挂载</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--move</code></td> <td>移动挂载点。例如 <code class="language-plaintext highlighter-rouge">mount --move /mnt1 /mnt2</code> 表示将 <code class="language-plaintext highlighter-rouge">/mnt1</code> 移动到 <code class="language-plaintext highlighter-rouge">/mnt2</code> 上</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--fake</code></td> <td>模拟挂载</td> </tr> </tbody> </table> <p>常见的文件系统类型：</p> <ul> <li><code class="language-plaintext highlighter-rouge">ext4</code>：<code class="language-plaintext highlighter-rouge">Linux</code> 文件系统。</li> <li><code class="language-plaintext highlighter-rouge">ntfs</code>：<code class="language-plaintext highlighter-rouge">Windows</code> 文件系统, 使用 <code class="language-plaintext highlighter-rouge">mount -t ntfs-3g</code> 进行挂载。</li> <li><code class="language-plaintext highlighter-rouge">FAT32</code>：<code class="language-plaintext highlighter-rouge">FAT32</code> 文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t vfat</code> 进行挂载。</li> <li><code class="language-plaintext highlighter-rouge">exFAT</code>：需要安装 <code class="language-plaintext highlighter-rouge">exfat-fuse</code> 和 <code class="language-plaintext highlighter-rouge">exfat-utils</code> 包，使用 <code class="language-plaintext highlighter-rouge">mount -t exfat</code> 进行挂载。</li> <li><code class="language-plaintext highlighter-rouge">ISO</code>：<code class="language-plaintext highlighter-rouge">ISO</code> 文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t iso9660</code> 进行挂载。</li> <li><code class="language-plaintext highlighter-rouge">nfs</code>：网络文件系统，使用 <code class="language-plaintext highlighter-rouge">mount -t nfs -o vers=num</code> 可以指定版本。</li> </ul> <p><strong>注意</strong>：直接使用 <code class="language-plaintext highlighter-rouge">mount</code> 可以列出所有已经挂载的文件系统。 也可以使用 <code class="language-plaintext highlighter-rouge">mount -t type</code> 来列出指定类型的文件系统。</p> <h3 id="获取设备的文件系统类型及-uuid">获取设备的文件系统类型及 <code class="language-plaintext highlighter-rouge">UUID</code></h3> <p>可以使用 <code class="language-plaintext highlighter-rouge">blkid</code> 命令来获取设备的文件系统类型及 <code class="language-plaintext highlighter-rouge">UUID</code>，例如 <code class="language-plaintext highlighter-rouge">blkid /dev/sda1</code>。</p> <h3 id="etcfstab-文件"><code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件</h3> <p>直接通过 <code class="language-plaintext highlighter-rouge">mount</code> 命令挂载的文件系统在系统重启后会失效，为了让文件系统在系统重启后自动挂载， 我们可以将文件系统的信息写入 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件中。<code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件的格式如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># device &lt;mount_point&gt;   &lt;type&gt;  &lt;options&gt;     &lt;dump&gt;  &lt;pass&gt;
/dev/sda1       /mnt      ext4    defaults       0       2
</code></pre></div></div> <p>其中各个字段的含义如下：</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;device&gt;</code>：设备文件。</li> <li><code class="language-plaintext highlighter-rouge">&lt;mount_point&gt;</code>：挂载点。</li> <li><code class="language-plaintext highlighter-rouge">&lt;type&gt;</code>：文件系统类型。</li> <li><code class="language-plaintext highlighter-rouge">&lt;options&gt;</code>：挂载选项，多个选项通过 <code class="language-plaintext highlighter-rouge">,</code> 进行分隔。</li> <li><code class="language-plaintext highlighter-rouge">&lt;dump&gt;</code>：备份标志。<code class="language-plaintext highlighter-rouge">0</code> 表示不备份，<code class="language-plaintext highlighter-rouge">1</code> 表示备份 (需要 <code class="language-plaintext highlighter-rouge">dump</code> 工具，通常设置为 <code class="language-plaintext highlighter-rouge">0</code>)。</li> <li><code class="language-plaintext highlighter-rouge">&lt;pass&gt;</code>：文件系统检查顺序。<code class="language-plaintext highlighter-rouge">0</code> 表示不检查，<code class="language-plaintext highlighter-rouge">1</code> 表示第一个检查， <code class="language-plaintext highlighter-rouge">2</code> 表示第二个检查 (根文件系统通常设置为 <code class="language-plaintext highlighter-rouge">1</code>，其他文件系统设置为 <code class="language-plaintext highlighter-rouge">2</code>)。</li> </ul> <h2 id="umount"><code class="language-plaintext highlighter-rouge">umount</code></h2> <p><code class="language-plaintext highlighter-rouge">umount</code> 用于卸载文件系统，使用方式为 <code class="language-plaintext highlighter-rouge">umount &lt;mount_point&gt;</code>，例如 <code class="language-plaintext highlighter-rouge">umount /mnt</code>。</p> <p><strong>注意</strong>：卸载文件系统的时候，如果文件系统正在被使用，会提示 <code class="language-plaintext highlighter-rouge">device is busy</code>， 这时候可以使用 <code class="language-plaintext highlighter-rouge">lsof &lt;mount_point&gt;</code> 来查看哪些进程在使用这个文件系统， 然后选择是否通过 <code class="language-plaintext highlighter-rouge">kill</code> 命令杀死这些进程。 也可以使用 <code class="language-plaintext highlighter-rouge">umount -l &lt;mount_point&gt;</code> 在空闲时自动卸载或者使用 <code class="language-plaintext highlighter-rouge">umount -f &lt;mount_point&gt;</code> 强制卸载。</p> <h2 id="lsof"><code class="language-plaintext highlighter-rouge">lsof</code></h2> <p><code class="language-plaintext highlighter-rouge">lsof</code> 是 <code class="language-plaintext highlighter-rouge">list open files</code> 的缩写，用于列出系统中打开的文件。<code class="language-plaintext highlighter-rouge">lsof</code> 的输出包含如下几项：</p> <ul> <li><code class="language-plaintext highlighter-rouge">COMMAND</code>：打开文件所使用的命令。</li> <li><code class="language-plaintext highlighter-rouge">PID</code>：进程 <code class="language-plaintext highlighter-rouge">ID</code>。</li> <li><code class="language-plaintext highlighter-rouge">USER</code>：进程的用户。</li> <li><code class="language-plaintext highlighter-rouge">FD</code>：文件描述符。</li> <li><code class="language-plaintext highlighter-rouge">TYPE</code>：文件类型，常见的有 <code class="language-plaintext highlighter-rouge">REG</code>、<code class="language-plaintext highlighter-rouge">DIR</code>、<code class="language-plaintext highlighter-rouge">CHR</code>、<code class="language-plaintext highlighter-rouge">FIFO</code>、<code class="language-plaintext highlighter-rouge">SOCK</code>、<code class="language-plaintext highlighter-rouge">LINK</code>，分别代表普通文件、目录、 字符设备、管道、套接字、符号链接。</li> <li><code class="language-plaintext highlighter-rouge">DEVICE</code>：设备。</li> <li><code class="language-plaintext highlighter-rouge">SIZE/OFF</code>：文件大小或者偏移量。</li> <li><code class="language-plaintext highlighter-rouge">NODE</code>：<code class="language-plaintext highlighter-rouge">inode</code> 号。</li> <li><code class="language-plaintext highlighter-rouge">NAME</code>：打开的文件名。</li> </ul> <p><code class="language-plaintext highlighter-rouge">lsof</code> 的可用选项如下：</p> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>指定用户</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>指定命令开头</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>避免获取结果时调用可能会阻塞的内核函数</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">+D</code></td> <td>指定目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>查看网络连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>禁止显示域名，域名全部显示为 <code class="language-plaintext highlighter-rouge">IP</code> 地址</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>禁止将端口号转换为服务名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>指定进程 <code class="language-plaintext highlighter-rouge">ID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-U</code></td> <td>列出 <code class="language-plaintext highlighter-rouge">UNIX</code> 域套接字。<code class="language-plaintext highlighter-rouge">TYPE</code> 为 <code class="language-plaintext highlighter-rouge">unix</code> 的文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-R</code></td> <td>同时列出父进程 <code class="language-plaintext highlighter-rouge">ID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>显示用户的 <code class="language-plaintext highlighter-rouge">ID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>只输出打开文件的进程 <code class="language-plaintext highlighter-rouge">ID</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>逻辑与。例如 <code class="language-plaintext highlighter-rouge">lsof -u user -a -c command</code> 表示查找用户为 <code class="language-plaintext highlighter-rouge">user</code> 且命令开头为 <code class="language-plaintext highlighter-rouge">command</code> 的进程</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-d</code></td> <td>指定文件描述符。例如 <code class="language-plaintext highlighter-rouge">lsof -d 1</code> 表示查找文件描述符为 <code class="language-plaintext highlighter-rouge">1</code> 的文件</td> </tr> </tbody> </table> <p><strong>注意</strong>：使用某些选项时可以使用 <code class="language-plaintext highlighter-rouge">^</code> 来表示排除某个用户，例如 <code class="language-plaintext highlighter-rouge">lsof -u ^root</code> 表示排除 <code class="language-plaintext highlighter-rouge">root</code> 用户。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-i</code> 的完整格式为：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-i</span><span class="o">[</span>46][protocol][@hostname|@hostaddr][:service|:port]，
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">protocol</code> 可以是 <code class="language-plaintext highlighter-rouge">TCP</code>、<code class="language-plaintext highlighter-rouge">UDP</code>、<code class="language-plaintext highlighter-rouge">TCP:UDP</code>，<code class="language-plaintext highlighter-rouge">hostname</code> 可以是主机名、<code class="language-plaintext highlighter-rouge">IPv4</code> 地址、<code class="language-plaintext highlighter-rouge">IPv6</code> 地址， <code class="language-plaintext highlighter-rouge">service</code> 可以是服务名、端口号。</p> <h1 id="git"><code class="language-plaintext highlighter-rouge">git</code></h1> <h2 id="gitignore-文件"><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件</h2> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件用于指定不需要被 <code class="language-plaintext highlighter-rouge">git</code> 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 来指定不需要被追踪的文件或目录。</p> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件还可以用于防止后续的修改被提交，例如某个文件已经被提交到版本库中， 但是后续不希望这个文件被追踪，可以将这个文件加入到 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中。 这种方式常常用于设置 <code class="language-plaintext highlighter-rouge">DEBUG</code> 相关文件。</p> <h3 id="wildcards"><code class="language-plaintext highlighter-rouge">wildcards</code></h3> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 中的 <code class="language-plaintext highlighter-rouge">wildcards</code> 与 <code class="language-plaintext highlighter-rouge">bash</code> 中基本一致， 可以查看 <a href="#wildcards-in-linux">Wildcards in Linux</a> 来了解更多关于 <code class="language-plaintext highlighter-rouge">wildcards</code> 的内容。</p> <h3 id="基本用法">基本用法</h3> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会进行递归的忽略，如果不想进行递归忽略， 可以在条目前加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只对当前目录生效。例如 <code class="language-plaintext highlighter-rouge">/foo</code> 表示只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录， 而 <code class="language-plaintext highlighter-rouge">foo</code> 表示忽略所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会匹配目录和文件， 如果只想匹配目录则可以在条目末尾加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只匹配目录。例如 <code class="language-plaintext highlighter-rouge">foo/</code> 表示只匹配目录 <code class="language-plaintext highlighter-rouge">foo</code>， 而 <code class="language-plaintext highlighter-rouge">foo</code> 表示匹配所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录。你可能会有疑惑：</p> <blockquote> <p>在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？</p> </blockquote> <p>其实如果不进行递归匹配，确实是没有意义的，但是 <code class="language-plaintext highlighter-rouge">build/</code> 和 <code class="language-plaintext highlighter-rouge">build</code> 表示的意义是不同的， 前者表示忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 目录，而后者表示忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 文件或目录。 前者可以保留某个子目录下面的名为 <code class="language-plaintext highlighter-rouge">build</code> 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 <code class="language-plaintext highlighter-rouge">/build/</code> 只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">build</code> 目录。</p> <h3 id="全局忽略">全局忽略</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中可以配置全局忽略文件，通常使用 <code class="language-plaintext highlighter-rouge">.git</code> 管理的仓库不需要追踪一些特定的文件， 例如 <code class="language-plaintext highlighter-rouge">*.pyc</code>、<code class="language-plaintext highlighter-rouge">*.o</code> 等，这时候我们可以配置全局忽略文件。 全局忽略文件的配置文件是 <code class="language-plaintext highlighter-rouge">~/.config/git/ignore</code>。</p> <h3 id="忽略文件优先级">忽略文件优先级</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中任何一个目录下都可以有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，这个文件会对当前目录下的文件和目录生效。 如果在父目录下有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会对当前目录下的文件和目录生效， 但是如果当前目录下有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会覆盖父目录下的文件。 也就是说，<code class="language-plaintext highlighter-rouge">.gitignore</code> 文件的优先级是从子目录到父目录逐渐降低的。全局忽略文件的优先级最低。</p> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://www.tecmint.com/use-wildcards-to-match-filenames-in-linux/">10 Practical Examples Using Wildcards to Match Filenames in Linux</a></li> <li><a href="https://fishshell.com/docs/current/fish_for_bash_users.html#wildcards-globs">fish shell wildcards</a></li> <li><a href="https://ryanstutorials.net/linuxtutorial/cheatsheetgrep.php">Linux Tutorial - Cheat Sheet - grep</a></li> <li><a href="https://www.golinuxcloud.com/grep-command-in-linux/">20 grep command examples in Linux</a></li> <li><a href="https://linuxhandbook.com/sort-command/">Linux Handbook: sort Command Examples</a></li> <li><a href="https://www.golinuxcloud.com/linux-sort-files/#1_Sort_by_name">15+ Tips to PROPERLY sort files in Linux</a></li> <li><a href="https://shapeshed.com/unix-sort/">Linux and Unix sort command tutorial with examples</a></li> <li><a href="https://www.baeldung.com/linux/sort-command">Linux sort Command</a></li> <li><a href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/">How to Use the awk Command on Linux</a></li> <li><a href="https://www.golinuxcloud.com/awk-examples-with-command-tutorial-unix-linux/">30+ awk examples for beginners / awk command tutorial in Linux/Unix</a></li> <li><a href="https://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/">8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR</a></li> <li><a href="https://linuxhandbook.com/awk-command-tutorial/">Getting Started With AWK Command</a></li> <li><a href="https://www.golinuxcloud.com/find-command-in-linux/">25+ most used find commands in Linux</a></li> <li><a href="https://onecompiler.com/cheatsheets/find">find Linux Command Cheatsheet</a></li> <li><a href="https://linuxtutorials.org/linux-find-cheatsheet/">Linux Find Cheatsheet</a></li> <li><a href="https://opensource.com/article/21/9/linux-find-command">Find files and directories on Linux with the find command</a></li> <li><a href="https://www.redhat.com/sysadmin/linux-find-command">10 ways to use the Linux find command</a></li> <li><a href="https://quickref.me/find">Find cheatsheet</a></li> <li><a href="https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files">Ignoring files</a></li> <li><a href="https://www.golinuxcloud.com/cat-command-examples/">cat command examples for beginners</a></li> <li><a href="https://linux-audit.com/cheat-sheets/tar/">Linux Audit: tar cheat sheet</a></li> <li><a href="https://www.golinuxcloud.com/tar-command-in-linux/">15+ tar command examples in Linux</a></li> <li><a href="https://www.golinuxcloud.com/create-symbolic-link-linux/">10+ practical examples to create symbolic link in Linux</a></li> <li><a href="https://www.golinuxcloud.com/scp-command-in-linux/">15+ scp command examples in Linux</a></li> <li><a href="https://phoenixnap.com/kb/apropos-linux">apropos Linux Command Explained</a></li> <li><a href="https://www.golinuxcloud.com/tee-command-in-linux/">10 tee command examples in Linux</a></li> <li><a href="https://raspberrytips.com/sudo-linux-command/">How To Use ‘sudo’: The Complete Linux Command Guide</a></li> <li><a href="https://www.computerhope.com/unix/visudo.htm">Linux visudo command</a></li> <li><a href="https://www.golinuxcloud.com/usermod-command-in-linux/">15 usermod command examples in Linux</a></li> <li><a href="https://www.golinuxcloud.com/linux-mount-command-iso-usb-network-drive/">Linux mount command to access filesystems, iso image, usb, network drives</a></li> <li><a href="https://linuxsimply.com/mount-command-in-linux/">The “mount” Command in Linux</a></li> <li><a href="https://www.golinuxcloud.com/su-command-in-linux/">9 su command examples in Linux</a></li> <li><a href="https://www.golinuxcloud.com/ssh-command-in-linux/">15+ SSH command examples in Linux</a></li> <li><a href="https://www.golinuxcloud.com/lsof-command-in-linux/">15+ lsof command examples in Linux</a></li> <li><a href="https://stilia-johny.medium.com/openssh-9-5-a-user-friendly-guide-to-the-latest-update-840a09886a5a">OpenSSH 9.5: A User-Friendly Guide to the Latest Update</a></li> <li><a href="https://linuxconfig.org/how-to-generate-and-manage-ssh-keys-on-linux">How to generate and manage ssh keys on Linux</a></li> <li><a href="https://www.golinuxcloud.com/generate-ssh-key-linux/">10 examples to generate SSH key in Linux (ssh-keygen)</a></li> <li><a href="https://thelinuxcode.com/ssh-config-file/">The Complete Guide to SSH Config Files</a></li> <li><a href="https://www.golinuxcloud.com/ssh-config/">Beginners guide to use ssh config file with examples</a></li> <li><a href="https://commandmasters.com/commands/ssh-add-common/">How to use the command <code class="language-plaintext highlighter-rouge">ssh-add</code> (with examples)</a></li> <li><a href="https://linux.101hacks.com/unix/ssh-add/">5 Unix / Linux ssh-add Command Examples to Add SSH Key to Agent</a></li> <li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server">How To Use SFTP to Securely Transfer Files with a Remote Server</a></li> <li><a href="https://github.com/libfuse/sshfs">libfuse/sshfs</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Linux"/><category term="CLI"/><summary type="html"><![CDATA[Wildcards in Linux 这里的 wildcards 指的是能够被 shell 扩展的符号。 如果在执行的命令中出现这些符号，shell 会对这些进行解析，解析完成后再传入需要执行的命令。 也就是说只要 shell 支持，这些 wildcards 是可以在任意命令中使用的。 常见的 wildcards 有以下几种： *：匹配任意数量( 包含 0 个 )的字符。 **：递归匹配任意数量( 包含 0 个 )的字符。 ?：匹配单个任意字符。 []：匹配出现在中括号中的某个符号。 在中括号中可以使用 - 来表示范围，! (或 ~)来表示取反，例如 [!0-9] 表示匹配不是数字的字符， [~ab] 表示不是 a 也不是 b 的字符。 {}：中间内容使用 , 分隔，表示多个匹配，例如 a{b,c}d 表示匹配 abd 或者 acd。 该通配符会将一个字符串转换成多个字符串，例如 mv file_{old,new} 会被解析成 mv file_old file_new。 该通配符还可以进行嵌套，例如 echo a{b{c,d},e}f 会被解析成 echo abcf abdf aef。 该通配符中如果要表示范围，需要使用 ..，例如 echo {a..z} 会被解析成 echo a b c ... z。 上面的通配符并不是所有的 shell 都支持的，但是在 bash 中是支持的。例如在 fish shell 中，只有 *、** 以及 ? 是支持的，其中 * 和 ? 不会匹配 /，而 ** 会匹配 / ，也就是说 ** 是 递归匹配。 注意：在正则表达式的语法中，* 表示匹配前面的字符 0 次或者多次， ? 表示匹配前面的字符 0 次或者 1 次，[] 表示匹配中括号中的任意一个字符， - 表示范围，^ 表示取反。 常用命令 Cheat Sheet cat 选项 说明 -n 显示行号 -b 显示非空行的行号 -s 合并多个空行为一个空行 -v 使用 ^ 和 M- 显示不可打印字符，换行和制表符除外 -E 在每行的结尾显示 $ -T 将制表符显示为 ^I -A 等价于 -v -E -T -e 等价于 -v -E -t 等价于 -v -T - 从标准输入读取内容 使用 cat 可以直接创建带有内容的文件或者追加内容到文件中，例如 cat &gt; file 会等待输入， 当输入完成后，使用 ^D (EOF, end of file) 来结束输入。 如果要追加内容到文件中，可以使用 cat &gt;&gt; file。 - 可以出现在多个文件的任意位置， 例如 cat file1 - file2 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间， 而 cat file1 - file2 - file3 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间、 file2 和 file3 的内容之间。需要注意的是，此时会要求输入两次，第一次输入完成后，使用 ^D 结束， 然后输入第二次，再次使用 ^D 结束，第一次输入的内容会放置在 file1 和 file2 的内容之间， 第二次输入的内容会放置在 file2 和 file3 的内容之间。 补充：tac 可以将文件内容逆序输出 (优先输出最后一行)，tac 的名字来源于 cat 的逆序。 题外话：cat 的名字来源于 concatenate，即连接的意思，其可以将多个文件的内容拼接在一起。 grep 选项 说明 -r 递归搜索目录 --include "*.py" 搜索指定文件 --exclude "test*" 排除指定文件 --exclude-dir "test*" 排除指定目录 --color=auto,always,never 何时进行高亮 -n 显示所在文件中的行号 -l 只显示包含匹配项的文件名 -L 只显示不包含任何匹配的文件名 -i 忽略大小写 -v 反向匹配 -c 显示匹配次数 -o 只显示匹配的部分 -m 指定最大匹配的次数 -f 从文件中读取模式。文件中每行一个模式 -e 指定匹配模式 -w 只匹配完整单词 -x 只匹配整行 -A 2 显示匹配行的后两行 -B 2 显示匹配行的前两行 -C 2 显示匹配行的前两行和后两行 -E 使用扩展正则表达式 -F 使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待 -H 强制显示文件名 -h 强制不显示文件名 注意：在 grep 中，完整单词指的是前后均不是字母、数字或者下划线的部分。 注意：-m 1 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。 题外话：grep 的名字来源于 g/re/p，其中 g 表示 global，re 表示 regular expression， p 表示 print，直译即全局正则表达式打印。 sort 选项 说明 -r 逆序排序 -n 按照数字排序 -k 按照某一列排序 -u 去重 -t 指定分隔符 -f 忽略大小写 -h 人类可读的排序。例如 1K 会被排序到 512 的前面 -M 按照月份排序 --files0-form=- 从标准输入读取以 NUL 作为文件名分隔符的多个文件内容 --files0-form=filename 从某个文件中读取 NUL 作为文件名分隔符的多个文件内容 -c 检查文件是否已经排序 注意：-k 可以指定多个列，例如 -k2,2 -k1,1 表示先按照第二列排序，然后再按照第一列排序。 -k 也可以按照某列的部分进行排序，例如 -k2.2,2.3 表示按照第二列的第二个字符到第三个字符进行排序。 -k 还可以指定列的类型，例如 -k2n,2 表示按照第二列的数字进行排序。 -r 选项也可以指定到 -k 选项中，例如 -k2r,2 表示按照第二列逆序排序。 awk 选项 说明 -F 指定输入的分隔符。 -f 指定 awk 脚本文件。 打印列 $0: 所有列。 $1: 第一列。 ... $NF: 最后一列。 例如可以使用 awk '{print $1,$2,$NF}' 打印出每行的第一列、第二列和最后一列。 分隔符 可以通过 OFS=(Output Field Separator) 来指定输出的分隔符，例如 awk '{print $1,$2,$NF}' OFS="," 表示使用 , 作为分隔符。也可以在 BEGIN 模式串中指定 OFS，例如 awk 'BEGIN {OFS=","} {print $1,$2,$NF}'。 除了 OFS 以外，还有 FS 用于指定输入文件的分隔符。 预定义变量 除了之前提到的 OFS, FS 之外，还有一些预定义变量： NR: 当前行的行号。 NF: 当前行的列数。 RS：记录分隔符，默认是换行符，也就是每一行作为一条记录。 ORS：输出的记录分隔符，默认是换行符。 FILENAME：当前文件的文件名。 FNR：当前文件的行号，当时用多个文件的时候，NR 记录的是当前的总行号， FNR 记录的是当前文件的行号。 我们可以使用 awk 'NR &gt; 1' 从第二行开始打印，也可以使用 awk 'NF &gt; 0' 打印列数大于 0 的行 (即移除空行)。 如果要打印第一行到第四行，我们可以通过 awk 'NR == 1, NR== 4' 来实现。 我们也可以使用 awk 'NR &gt;= 1 &amp;&amp; NR &lt;= 4' 来实现。 模式 BEGIN 和 END 模式串： BEGIN: 在处理输入之前执行。 END: 在处理输入之后执行。 例如可以使用 awk 'BEGIN {print "Start"} {print} END {print "End"}' 在处理输入之前和之后打印出 Start 和 End。 在 awk 中可以使用模式来过滤行， 例如 awk '$1 &gt; 10' 表示只打印第一列大于 10 的行 (当不书写动作时，默认动作是打印整行)。 也可以使用搜索模式，例如 awk '/pattern/' 表示只打印包含 pattern 的行，搜索模式支持正则表达式。 , 也可以和搜索模式一起使用， 例如 awk '/pattern1/,/pattern2/' 表示打印找到的 pattern1 到 pattern2 的行。 ~ 可以用来表示是否与搜索模式匹配，例如 awk '$1 ~ /pattern/' 表示第一列是否包含 pattern。 !~ 可以用来表示是否不匹配，例如 awk '$1 !~ /pattern/' 表示第一列是否不包含 pattern。 awk 脚本 我们也可以书写 awk 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数： #! /usr/bin/awk -f BEGIN { # 设置输入和输出的分隔符 FS=":" OFS=" " tot_count=0 } { for (i = 1; i &lt;= NF; i++) { words[$i]++ tot_count++ } } END { print "Total words:", tot_count for (word in words) { print word, words[word] } } 注意：由于在 awk '{print}' file 的意思是对某个文件的内容进行处理， 所以要用 awk -f file 来表示将文件作为脚本执行。 内置函数 awk 中还有一些内置函数，例如 length 函数可以返回字符串的长度，substr 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc 在 awk 中，print 会在输出的字符串后面自动添加换行符，而 printf 可以进行格式化输出， 上面的例子中我们通过 printf 来输出不带换行符的字符串。在 awk 中字符串是可以直接拼接的， 例如 printf "%s", $NF"+" 表示将最后一列的值和 + 拼接在一起。 printf 的格式化方法与 C/C++ 中的类似，这里不再进行详细介绍。 当然要实现同样的功能有更简单的命令： awk 'NR &gt; 1 { sum+=$NF } END { print sum }' # or awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS="" | bc 注意：在 awk 中，下标是从 1 开始的，而不是从 0 开始的，且区间是闭区间。 这里再列出一些常用的内置函数： tolower：将字符串转换为小写。 toupper：将字符串转换为大写。 split：将字符串按照某个分隔符分割为数组。接收三个参数，第一个参数是要分割的字符串， 第二个参数是数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式， 例如 split($0, words, /:+/) 表示将当前行按照 : (或者多个连续的 :) 分割为数组。 gsub：全局替换。接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串， 第三个参数要替换的文本。 例如 gsub(/pattern/, "replace", $0) 表示将当前行中的 pattern 替换为 replace。 system：执行系统命令。例如 system("ls") 会执行 ls 命令并将结果输出到标准输出。 改变分隔符 前面介绍到 FS 和 OFS 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出， 我们可能会写出 awk '{print}' FS=':' OFS=' ' 这样的命令，试图将 : 改成空格。 但是这样并不能正确工作， 在 awk 中只有当列被修改后 (或者在 print 中打印多个 fields 的时候) 才会使用新的输出分隔符， 所以我们可以通过 awk '($1=$1) || 1' FS=':' OFS=' ' 来实现 (这里省略了动作，因此会打印一整行)。 这里的 ($1=$1) || 1 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 awk 中被当作 false，所以我们需要通过 || 1 来保证输出。这里的括号是必须的，如果没有括号， $1=$1 || 1 会被解释为 $1=($1 || 1)，这样会将 $1 赋值为 1，而不是保留原来的值。 题外话：awk 的名字来源于三个创始人的名字 Alfred Aho、Peter Weinberger 和 Brian Kernighan 的首字母。 POSIX 字符类 awk 中支持 POSIX 字符类： [:alnum:]：字母和数字。 [:alpha:]：字母。 [:blank:]：空格和制表符。 [:cntrl:]：控制字符。 [:digit:]：数字。 [:graph:]：可打印字符，不包括空格。 [:lower:]：小写字母。 [:print:]：可打印字符，包括空格。 [:punct:]：标点符号。 [:space:]：空白字符。 [:upper:]：大写字母。 [:xdigit:]：十六进制数字。 例如，我们可以使用 awk '/[[:digit:]]/' 来匹配包含数字的行。当然也可以写成 awk '/[0-9]/'。 find 选项 说明 -type 指定文件类型。f 表示普通文件，d 表示目录，l 表示符号链接 -readable 查找当前用户可读文件或目录 -writable 查找当前用户可写文件或目录 -executable 查找当前用户可执行文件或目录 -name 指定文件名。可以使用 wildcads -path 指定路径。可以使用 wildcards -iname 忽略大小写的文件名 -ipath 忽略大小写的路径 -empty 查找空文件或者空目录 -perm 644 查找权限为 644 的文件或目录 -mtime +1 修改时间在一天前的文件或目录 -atime +1 访问时间在一天前的文件或目录 -ctime +1 创建时间在一天前的文件或目录 -mmin +1 修改时间在一分钟前的文件或目录 -amin +1 访问时间在一分钟前的文件或目录 -cmin +1 创建时间在一分钟前的文件或目录 -user 指定拥有者 -group 指定所属组 -delete 删除查找到的文件或目录 -maxdepth 指定查找的最大深度 -mindepth 指定查找的最小深度 -and 逻辑与 -or 逻辑或 -not 逻辑非 -P 不跟踪符号链接 (默认行为) -L 跟踪符号链接 -H 只跟踪指定的路径或文件的符号链接。例如 -H . 只对 . 目录下的符号链接进行跟踪 -print0 使用 NUL 作为文件名分隔符 -regex 使用正则表达式匹配文件名 -iregex 使用忽略大小写的正则表达式匹配文件名 -samefile 指定文件的硬链接。例如 find . -samefile file 表示查找和 file 硬链接的文件 -links 指定文件的硬链接数。例如 find . -links 2 表示查找硬链接数为 2 的文件，+ 和 - 可以用来表示大于和小于 -type 还可以以下类型有： b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 注意：使用正则表达式匹配含有某个串的文件名时，需要使用 .* 来表示任意数量的字符， 例如 find . -regex ".*pattern.*"，而不能直接使用 find . -regex "pattern"。 注意：如果要使用复杂的逻辑表达式，需要使用 () 来分组， 例如 find . \( -name "*.txt" -or -name "*.md" \) 表示查找所有 txt 或者 md 文件， 其中的括号需要进行转义，这是因为 Shell 往往会对括号进行特殊处理。 指定文件大小 -size 参数有以下几种单位： b：块，取决于文件系统，默认是 512 字节 c：字节 k：千字节 (1024 字节) M：兆字节 (1024 千字节) G：吉字节 (1024 兆字节) 知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可， 例如 find . -size 1M 表示查找大小为 1 兆字节的文件。 但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 + 和 - 来表示大于和小于， 例如 find . -size +1M 表示查找大于 1MB 的文件，find . -size -1M 表示查找小于 1MB 的文件。 这两者也可以结合使用，例如 find . -size +1M -size -2M 表示查找大于 1MB 且小于 2MB 的文件。 对查找到的文件执行操作 -exec 可以对查找到的文件执行操作， 例如 find . -name "*.txt" -exec cat {} \; 表示查找当前目录下的所有 txt 文件并将其内容输出到标准输出。 {} 会被替换为查找到的文件名，\; 表示结束，分号需要进行转义，防止被 Shell 解释。 也可以使用 grep 命令过滤查找到的文件， 例如 find . -name "*.txt" -exec grep "pattern" {} \; 表示查找当前目录下的所有 txt 文件并在其中查找 pattern。 tar 选项 说明 -c 创建文档 -f 指定文件名 -v 显示详细信息 -z 使用 gzip 压缩或解压 -j 使用 bzip2 压缩或解压 -J 使用 xz 压缩或解压 -x 提取文档 -C 指定提取的目录 -t 列出文档内容 --wildcards 使用 wildcards 匹配文件。例如 tar -xf a.tar --wildcards '*.txt' 可以提取 a.tar 中的所有 txt 文件 --delete 删除文档中的文件。例如 tar -f a.tar --delete '*.txt' 可以删除 a.tar 中的所有 txt 文件 --exclude= 排除文件。例如 tar -cf a.tar --exclude=*.txt . 可以创建 a.tar 时排除所有 txt 文件 -r 向文档中追加文件。例如 tar -rf a.tar b.txt 可以将 b.txt 追加到 a.tar 中 -A 向文档中追加另一个文档。例如 tar -Af a.tar b.tar 可以将 b.tar 追加到 a.tar 中 -W 检验文档。例如 tar -Wf a.tar 可以检验 a.tar 的完整性 -u 更新文档。例如 tar -uf a.tar b.txt 可以更新 a.tar 中的 b.txt 文件 注意：在使用 --exclude 时必须使用 = 进行连接，且 --exclude 要出现在待打包文件或目录之前， tar -cf a.tar . --exclude=*.txt 是错误用法。 注意：在使用 -u 的时候，并不会覆盖旧的文件，而是直接追加新的文件， 这样 tar 文件中可能会有多个同名的文件，目前我并没有找到如何提取旧文件的方法。 ln 选项 说明 -s 创建软连接 -f 强制创建。如果软连接已经存在，会覆盖原有的软连接 -t 指定连接的目标目录。ln -t dir target 与 ln target dir 效果相同 使用 ln target link_name 创建的时候如果 link_name 是一个目录，那么会在目录下创建一个名为 target 的文件。 ln 默认创建硬连接。 使用 rm 和 unlink 命令均可以删除软连接或者硬连接。 但是 unlink 一次只能删除一个文件，而 rm 可以删除多个文件。 硬连接与软连接 ln 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 inode， 而软连接是指一个文件指向另一个文件。除此之外，硬连接和软连接还有以下区别： 软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件。 软连接可以指向目录，而硬连接不能指向目录。 源文件被删除的时候，硬连接不会受到影响，而软连接会失效。 在 Linux 中，可以通过 ls -l 命令查看文件的硬连接数 (第二列为硬连接数)， 硬连接数为 1 表示只有一个文件指向该 inode，而硬连接数大于 1 表示有多个文件指向该 inode。 ssh 相关命令 ssh ssh 分为 client 和 server 两部分，client 用于连接远程主机，server 用于接收远程主机的连接。 openssh-client 和 openssh-server 是 ssh 的两个主要组件。 选项 说明 -p 指定端口。默认端口是 22 -i 指定密钥文件。默认情况下，ssh 使用 ~/.ssh/id_rsa 作为密钥文件 -l 指定用户名。默认情况下，ssh 使用当前用户名作为登录用户名 -q 静默模式 -t 强制分配终端 -v 显示详细信息。可以使用多个 v 来显示更多的信息 -C 压缩传输。使用 -C 可以压缩传输的数据 -X 启用 X11 受限转发。可以在本地显式远程主机的 X11 程序 -Y 启用 X11 信赖转发 -f 后台运行 -N 不执行远程命令。通常在端口转发时使用 -L 本地端口转发 -R 远程端口转发 -D 动态端口转发 -o 指定配置选项 注意：对于 -l 选项，也可以不使用 -l 而是使用 user@host 的形式来指定用户名。 注意：关于端口转发可以查看 ssh 端口转发简介。 注意：-o 选项常常用于覆盖 ~/.ssh/config 文件中的配置。 例如 ssh -o "Port=2222" host_name 将会使用 2222 端口连接 host_name，其余配置不变。 ssh-keygen 选项 说明 -a 指定迭代次数。越高则生成的密钥越安全，但是验证的时候也会越慢 -t 指定密钥类型 -b 指定密钥长度 -C 添加注释 -c 修改密钥的注释 -f 指定密钥路经以及文件名 -P 指定密钥的密码 -p 修改密钥的密码 -l 显示密钥的指纹 -H 对 known_hosts 文件进行哈希处理 -R 从 known_hosts 文件中删除指定主机的密钥 注意：从 open_ssh 9.5 开始默认生成的密钥是 ed25519，而不是 rsa。 ed25519 相较与 rsa 更加安全，且性能更好。 ~/.ssh/known_hosts 文件 known_hosts 文件存储了远程主机的公钥，当第一次连接远程主机的时候， ssh 会将远程主机的公钥存储到 known_hosts 文件中，下次连接远程主机的时候， ssh 会检查远程主机的公钥是否和 known_hosts 文件中的公钥一致， 如果一致则连接成功，否则会提示公钥不一致。 known_hosts 文件可以很好的防止 Man-in-the-middle 攻击。 而默认情况下，known_hosts 文件的远程地址部分是以明文的形式存储的， 这样当 known_hosts 文件泄露的时候，攻击者可以直接获取到远程主机的地址与对应的公钥， 而使用 ssh-keygen -H 可以对 known_hosts 的远程地址进行哈希处理， 这样在 known_hosts 文件泄露的时候，攻击者无法直接获取到远程主机的地址与公钥的对应关系。 ~/.ssh/config 文件 ~/.ssh/config 文件可以用来配置 ssh 的一些选项，例如： Host host_name HostName host_ip Port port User user_name IdentityFile ~/.ssh/id_rsa Host * ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes CompressionLevel 9 ForwardAgent yes ForwardX11 yes ForwardX11Trusted yes TCPKeepAlive yes ControlMaster auto ControlPath ~/.ssh/master-%r@%h:%p ControlPersist 600 UserKnownHostsFile ~/.ssh/known_hosts StrictHostKeyChecking yes HashKnownHosts yes GSSAPIAuthentication yes GSSAPIDelegateCredentials yes GSSAPITrustDNS yes PasswordAuthentication no PubkeyAuthentication yes PreferredAuthentications publickey KexAlgorithms ProxyCommand ssh -W %h:%p proxy_address 当你拥有上面的配置后，你可以通过 ssh host_name 来连接远程主机， 而不需要指定远程主机的 ip、port、user 和 identity file。 使用 * 可以对所有主机生效，可以达到修改默认配置的目的。 ~/.ssh/config 中也支持通配符： *：匹配所有主机 ?：匹配一个字符 !：排除主机 ssh-copy-id 选项 说明 -i 指定密钥文件 -p 指定端口 ssh-agent ssh-agent 用来管理用户的密钥，如果密钥被添加到 ssh-agent 后， 用户在后续登录过程中可以不输入密钥的密码。 要在当前的 shell 中启动 ssh-agent，可以使用 eval $(ssh-agent)。 ssh-add 选项 说明 -l 列出所有已加载密钥的指纹 -L 列出所有已加载密钥的公钥 -d 删除某个密钥 -D 删除所有密钥 -x 锁定 ssh-agent -X 解锁 ssh-agent 注意：如果命令执行过程中提示 Could not open a connection to your authentication agent， 那么可能是因为没有启动 ssh-agent，可以使用 eval $(ssh-agent) 启动 ssh-agent。 sftp sftp 是一个交互式的文件传输工具，其通过 ssh 保证文件传输的安全性。 sftp 的启动与 ssh 类似，例如 sftp user@host。 启动后我们可以通过 help 或者 ? 列出可以使用的命令。大多 Linux 的命令都可以在 sftp 中使用。 除此之外，我们在通常的命令前面增加 l (或 !) 表示在本定执行， 例如 pwd 可以查看远程主机的当前目录， 而 lpwd 可以查看本地主机的当前目录；cd 可以切换远程主机的目录， 而 lcd 可以切换本地主机的目录。 如果你需要多次在本地执行某修操作，你可以使用 ! 来切换到本地的 shell， 这样就可以不用在命令前面加 l 了。执行完本地操作后想要回到 sftp 中，只需要执行 exit 即可。 使用 get 命令可以下载文件，例如 get file 表示下载 file 文件到本地主机， 而 put 命令可以上传文件，例如 put file 表示上传 file 文件到远程主机。 两个命令的使用方式与 cp 类似，对于目录需要增加 -r 选项。 sshfs 直接使用 sftp 可以完成一些简单的文件传输，但是如果我们并不只是希望直接传输远程的文件， 而且还需要对远程文件进行修改，例如我们希望直接使用我们本地配置丰富的编辑器来编辑远程文件， 那么此时我们就可以使用 sshfs 来实现。 sshfs 的原理就是利用 sftp 协议将远程主机的文件挂载到本地主机上， 相信使用过类似于 NFS 的用户对这种操作并不陌生。 使用 sshfs 进行挂载： sshfs user@host:/path/to/dir /path/to/mount_point 注意：挂载点的拥有者必须是当前用户。 如果要进行卸载，可以使用 fusermount -u /path/to/mount_point 或者 umount /path/to/mount_point。 注意：不建议将挂载放入到 /etc/fstab 中，因为当网络不稳定时可能会进行很长时间的重试， 这样会导致系统启动时间非常漫长。 scp 选项 说明 -r 递归复制 -P 指定端口 -p 保留文件属性 (例如修改时间等) -q 静默模式 -v 显示详细信息。可以使用多个 -v 来显示更多的信息 -C 压缩传输 -i 指定密钥文件 -l 限制带宽, 单位是 Kb/s -3 通过本机在两个远端之间传输文件 -4 强制使用 IPv4 -6 强制使用 IPv6 使用 scp 的时候，如果在 ~/.ssh/config 中配置了主机信息，可以直接使用主机名进行传输， 例如 scp file host_name:/path/to/file。 scp 可以一次拷贝多个文件，例如 scp file1 file2 host_name:/path/to/。 apropos 选项 说明 -a 逻辑与。可用于匹配多个关键字，例如 apropos -a keyword1 keyword2 -e 精确匹配 -w 匹配带有 Shell 支持的通配符 -r 使用正则表达式匹配 -l 不依照终端宽度进行裁剪 -s 指定 man 手册的节。例如 apropos -s 3 keyword 表示查找第 3 节的手册 man 手册的节有以下几个： 1：命令或程序。 2：系统调用。 3：库函数。 4：特殊文件。 5：文件格式和约定。 6：游戏。 7：杂项。 8：系统管理命令。 9：内核相关。 tee 选项 说明 -a 追加 -i 忽略中断信号 tee 的作用是将标准输入的内容输出到标准输出和文件，其通常在管道中使用： 管道在进行传递的时候可能会遇到需要 root 权限的时候， 这时候就需要使用 sudo tee 从管道中读取信息并写入到文件中。 例如 echo "content" | sudo tee file。 usermod 选项 说明 -l 修改用户名。例如 usermod -l new_name old_name 表示将 old_name 修改为 new_name -u 修改用户 UID。例如 usermod -u 1000 user 表示将 user 的 UID 修改为 1000 -o 允许重复的 UID -g 修改基本用户组。例如 usermod -g group user 表示将 user 的基本用户组修改为 group -G 修改附加用户组。例如 usermod -G group1,group2 user 表示将 user 的附加用户组修改为 group1 和 group2 -a 与 -G 同时使用，表示追加附加用户组 -c 修改用户描述 -d 修改用户主目录 -m 与 -d 同时使用，表示同时移动用户主目录 -s 修改用户登录 shell -e 修改用户过期时间。例如 usermod -e 2025-12-31 user 表示将 user 的过期时间修改为 2025-12-31 -p 设置新的密码。注意新的密码应该是加密后的密码，可以使用 openssl passwd 来生成加密后的密码，更加推荐使用 passwd 命令进行密码修改 -L 锁定用户。 -U 解锁用户。 注意：创建出来的用户默认是不会过期的。如果设置了过期时间后，可以通过 chmod -e "" 来取消。 当用户过期后，用户将无法登录，但是用户依然存在，root 可以解锁用户。 su 选项 说明 -l 以登录状态切换用户 -c 执行命令。例如 su -c command user 表示以 user 用户的身份执行 command -s 指定 shell。例如 su -s /bin/bash user 表示以 user 用户的身份使用 bash shell -p 保留 HOME, SHELL, USER, LOGNAME 环境变量 注意：使用 su 切换用户时，如果不指定用户，会默认切换到 root 用户。 注意：如果不使用 -l 选项，su 不会切换用户的环境变量，而使用 -l 的时候，以下会被依次执行： clears all the environment variables except TERM and variables specified by --whitelist-environment initializes the environment variables HOME, SHELL, USER, LOGNAME, and PATH changes to the target user’s home directory sets argv[0] of the shell to - in order to make the shell a login shell sudo 选项 说明 -l 列出用户可以执行的命令。可以使用 sudo -l command 来检查是否可以执行某个命令 -U 与 -l 一同使用，指定列出的用户而不是执行 sudo 的用户 -u 指定用户执行命令。例如 sudo -u user command 表示以 user 用户的身份执行 command -g 指定用户组。例如 sudo -g group command 表示以 group 用户组的身份执行 command -s 指定 shell -k 删除缓存的密码 -v 更新记住密码时间的时间戳为当前时刻 /etc/sudoers 文件 /etc/sudoers 文件用于配置 sudo 的权限，只有拥有 root 权限的用户可以修改这个文件。 /etc/sudoers 文件的格式如下： # 配置某个用户 user host=(runas[:runasgroup]) [NOPASSWD:] command # 配置某个组下的所有用户 %group host=(runas[:runasgroup]) [NOPASSWD:] command # 引入目录中的所有文件 @includedir dirname 对于上述的规则，方括号中代表可选项，这里给出几个实例： user ALL=(ALL) ALL：允许 user 用户在任何主机上以任何用户的身份执行任何命令。 %group ALL=(ALL) NOPASSWD: ALL：允许 group 组下的所有用户在任何主机上以任何用户的身份执行任何命令， 且不需要输入密码。 @includedir /etc/sudoers.d 表示引入 /etc/sudoers.d 目录下的所有文件，这是默认添加的配置， 这意味着我们对于其他用户的配置可以放在 /etc/sudoers.d 目录下，并以用户名命名文件方便管理。 注意：在 @includedir 目录下的文件不能以 ~ 结尾并且不能含有 .。 这是在 /etc/sudoers.d/README 中明确指出的： This will cause sudo to read and parse any files in the /etc/sudoers.d directory that do not end in ~ or contain a . character. 注意：如果要配置多条命令应该使用 , 作为分隔符。 visudo 推荐使用 visudo 对 /etc/sudoers 文件进行修改 (即通过命令 sudo visudo)， visudo 会在修改后检查是否存在语法错误。 visudo 还有一些选项： 选项 说明 -c 检查语法错误 -f 指定文件 mount 选项 说明 -a 挂载所有在 /etc/fstab 中配置的文件系统 -t 指定文件系统类型 -o 指定挂载选项 -r 以只读模式挂载 -w 以读写模式挂载 --move 移动挂载点。例如 mount --move /mnt1 /mnt2 表示将 /mnt1 移动到 /mnt2 上 --fake 模拟挂载 常见的文件系统类型： ext4：Linux 文件系统。 ntfs：Windows 文件系统, 使用 mount -t ntfs-3g 进行挂载。 FAT32：FAT32 文件系统，使用 mount -t vfat 进行挂载。 exFAT：需要安装 exfat-fuse 和 exfat-utils 包，使用 mount -t exfat 进行挂载。 ISO：ISO 文件系统，使用 mount -t iso9660 进行挂载。 nfs：网络文件系统，使用 mount -t nfs -o vers=num 可以指定版本。 注意：直接使用 mount 可以列出所有已经挂载的文件系统。 也可以使用 mount -t type 来列出指定类型的文件系统。 获取设备的文件系统类型及 UUID 可以使用 blkid 命令来获取设备的文件系统类型及 UUID，例如 blkid /dev/sda1。 /etc/fstab 文件 直接通过 mount 命令挂载的文件系统在系统重启后会失效，为了让文件系统在系统重启后自动挂载， 我们可以将文件系统的信息写入 /etc/fstab 文件中。/etc/fstab 文件的格式如下： # device &lt;mount_point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; /dev/sda1 /mnt ext4 defaults 0 2 其中各个字段的含义如下： &lt;device&gt;：设备文件。 &lt;mount_point&gt;：挂载点。 &lt;type&gt;：文件系统类型。 &lt;options&gt;：挂载选项，多个选项通过 , 进行分隔。 &lt;dump&gt;：备份标志。0 表示不备份，1 表示备份 (需要 dump 工具，通常设置为 0)。 &lt;pass&gt;：文件系统检查顺序。0 表示不检查，1 表示第一个检查， 2 表示第二个检查 (根文件系统通常设置为 1，其他文件系统设置为 2)。 umount umount 用于卸载文件系统，使用方式为 umount &lt;mount_point&gt;，例如 umount /mnt。 注意：卸载文件系统的时候，如果文件系统正在被使用，会提示 device is busy， 这时候可以使用 lsof &lt;mount_point&gt; 来查看哪些进程在使用这个文件系统， 然后选择是否通过 kill 命令杀死这些进程。 也可以使用 umount -l &lt;mount_point&gt; 在空闲时自动卸载或者使用 umount -f &lt;mount_point&gt; 强制卸载。 lsof lsof 是 list open files 的缩写，用于列出系统中打开的文件。lsof 的输出包含如下几项： COMMAND：打开文件所使用的命令。 PID：进程 ID。 USER：进程的用户。 FD：文件描述符。 TYPE：文件类型，常见的有 REG、DIR、CHR、FIFO、SOCK、LINK，分别代表普通文件、目录、 字符设备、管道、套接字、符号链接。 DEVICE：设备。 SIZE/OFF：文件大小或者偏移量。 NODE：inode 号。 NAME：打开的文件名。 lsof 的可用选项如下： 选项 说明 -u 指定用户 -c 指定命令开头 -b 避免获取结果时调用可能会阻塞的内核函数 +D 指定目录 -i 查看网络连接 -n 禁止显示域名，域名全部显示为 IP 地址 -P 禁止将端口号转换为服务名 -p 指定进程 ID -U 列出 UNIX 域套接字。TYPE 为 unix 的文件 -R 同时列出父进程 ID -l 显示用户的 ID -t 只输出打开文件的进程 ID -a 逻辑与。例如 lsof -u user -a -c command 表示查找用户为 user 且命令开头为 command 的进程 -d 指定文件描述符。例如 lsof -d 1 表示查找文件描述符为 1 的文件 注意：使用某些选项时可以使用 ^ 来表示排除某个用户，例如 lsof -u ^root 表示排除 root 用户。 注意：-i 的完整格式为： -i[46][protocol][@hostname|@hostaddr][:service|:port]， 其中 protocol 可以是 TCP、UDP、TCP:UDP，hostname 可以是主机名、IPv4 地址、IPv6 地址， service 可以是服务名、端口号。 git .gitignore 文件 .gitignore 文件用于指定不需要被 git 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 .gitignore 文件中可以使用 wildcards 来指定不需要被追踪的文件或目录。 .gitignore 文件还可以用于防止后续的修改被提交，例如某个文件已经被提交到版本库中， 但是后续不希望这个文件被追踪，可以将这个文件加入到 .gitignore 文件中。 这种方式常常用于设置 DEBUG 相关文件。 wildcards .gitignore 中的 wildcards 与 bash 中基本一致， 可以查看 Wildcards in Linux 来了解更多关于 wildcards 的内容。 基本用法 默认情况下，.gitignore 中的条目会进行递归的忽略，如果不想进行递归忽略， 可以在条目前加上 / 表示只对当前目录生效。例如 /foo 表示只忽略当前目录下的 foo 文件或目录， 而 foo 表示忽略所有的 foo 文件或目录。 默认情况下，.gitignore 中的条目会匹配目录和文件， 如果只想匹配目录则可以在条目末尾加上 / 表示只匹配目录。例如 foo/ 表示只匹配目录 foo， 而 foo 表示匹配所有的 foo 文件或目录。你可能会有疑惑： 在 Linux 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？ 其实如果不进行递归匹配，确实是没有意义的，但是 build/ 和 build 表示的意义是不同的， 前者表示忽略所有 build 目录，而后者表示忽略所有 build 文件或目录。 前者可以保留某个子目录下面的名为 build 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 /build/ 只忽略当前目录下的 build 目录。 全局忽略 在 git 中可以配置全局忽略文件，通常使用 .git 管理的仓库不需要追踪一些特定的文件， 例如 *.pyc、*.o 等，这时候我们可以配置全局忽略文件。 全局忽略文件的配置文件是 ~/.config/git/ignore。 忽略文件优先级 在 git 中任何一个目录下都可以有一个 .gitignore 文件，这个文件会对当前目录下的文件和目录生效。 如果在父目录下有一个 .gitignore 文件，那么这个文件会对当前目录下的文件和目录生效， 但是如果当前目录下有一个 .gitignore 文件，那么这个文件会覆盖父目录下的文件。 也就是说，.gitignore 文件的优先级是从子目录到父目录逐渐降低的。全局忽略文件的优先级最低。 巨人的肩膀 10 Practical Examples Using Wildcards to Match Filenames in Linux fish shell wildcards Linux Tutorial - Cheat Sheet - grep 20 grep command examples in Linux Linux Handbook: sort Command Examples 15+ Tips to PROPERLY sort files in Linux Linux and Unix sort command tutorial with examples Linux sort Command How to Use the awk Command on Linux 30+ awk examples for beginners / awk command tutorial in Linux/Unix 8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR Getting Started With AWK Command 25+ most used find commands in Linux find Linux Command Cheatsheet Linux Find Cheatsheet Find files and directories on Linux with the find command 10 ways to use the Linux find command Find cheatsheet Ignoring files cat command examples for beginners Linux Audit: tar cheat sheet 15+ tar command examples in Linux 10+ practical examples to create symbolic link in Linux 15+ scp command examples in Linux apropos Linux Command Explained 10 tee command examples in Linux How To Use ‘sudo’: The Complete Linux Command Guide Linux visudo command 15 usermod command examples in Linux Linux mount command to access filesystems, iso image, usb, network drives The “mount” Command in Linux 9 su command examples in Linux 15+ SSH command examples in Linux 15+ lsof command examples in Linux OpenSSH 9.5: A User-Friendly Guide to the Latest Update How to generate and manage ssh keys on Linux 10 examples to generate SSH key in Linux (ssh-keygen) The Complete Guide to SSH Config Files Beginners guide to use ssh config file with examples How to use the command ssh-add (with examples) 5 Unix / Linux ssh-add Command Examples to Add SSH Key to Agent How To Use SFTP to Securely Transfer Files with a Remote Server libfuse/sshfs]]></summary></entry><entry><title type="html">Spring-Validation 自定义错误代码</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/" rel="alternate" type="text/html" title="Spring-Validation 自定义错误代码"/><published>2024-08-29T02:38:09+00:00</published><updated>2024-08-29T02:38:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 做了简单的介绍。但是只使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 就很难实现了，我们往往需要自定义代码的 实现逻辑。</p> <p>而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。</p> <p>而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。</p> <h1 id="返回信息">返回信息</h1> <p>我们的基本要求是对于错误信息返回如下的 <code class="language-plaintext highlighter-rouge">JSON</code> 数据：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User id must be null when creating a new user"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NOTNULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"4"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"5"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"6"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_EMAIL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"7"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"8"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"9"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"10"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"11"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERNAME_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"12"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EMAIL_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"13"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WRONG_SIGN_IN_INFORMATION"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"14"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INVALID_TOKEN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"15"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ACCESS_DENIED"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MESSAGE_CONVERSION_ERROR"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>对于这样的数据，前端开发者可以很容易将其定义成一个 <code class="language-plaintext highlighter-rouge">enum</code> 类型，这样就可以很方便的进行错误码的比较。</p> <h1 id="自定义校验逻辑">自定义校验逻辑</h1> <p>对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了如何设置全局异常处理器。</p> <h2 id="自定义错误码">自定义错误码</h2> <p>当然，我们首先需要有错误码的信息，我们可以定义如下的 <code class="language-plaintext highlighter-rouge">enum</code> 类型：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ErrorCodeEnum</span> <span class="o">{</span>
    <span class="c1">// This should be ignored, this is to make the ordinal of the enum start from 1</span>
    <span class="no">ZERO_PLACEHOLDER</span><span class="o">,</span>

    <span class="no">USERDTO_ID_NULL</span><span class="o">(</span><span class="s">"UserDTO.id.Null"</span><span class="o">),</span>
    <span class="no">USERDTO_ID_NOTNULL</span><span class="o">(</span><span class="s">"UserDTO.id.NotNull"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_SIZE</span><span class="o">(</span><span class="s">"UserDTO.username.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.email.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_EMAIL</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_SIZE</span><span class="o">(</span><span class="s">"UserDTO.userPassword.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERSIGNINDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERSIGNINDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERNAME_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"USERNAME_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">EMAIL_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"EMAIL_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">WRONG_SIGN_IN_INFORMATION</span><span class="o">(</span><span class="s">"WRONG_SIGN_IN_INFORMATION"</span><span class="o">),</span>

    <span class="no">INVALID_TOKEN</span><span class="o">(</span><span class="s">"INVALID_TOKEN"</span><span class="o">),</span>
    <span class="no">ACCESS_DENIED</span><span class="o">(</span><span class="s">"ACCESS_DENIED"</span><span class="o">),</span>

    <span class="no">MESSAGE_CONVERSION_ERROR</span><span class="o">(</span><span class="s">"MESSAGE_CONVERSION_ERROR"</span><span class="o">);</span>

    <span class="c1">// code means the error code in the message.properties</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">code</span><span class="o">;</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(){}</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">code</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通常 <code class="language-plaintext highlighter-rouge">0</code> 代表执行成功，所以我们在上面的 <code class="language-plaintext highlighter-rouge">enum</code> 类型中加入了一个 <code class="language-plaintext highlighter-rouge">ZERO_PLACEHOLDER</code>，这样我们的错误码 就可以从 <code class="language-plaintext highlighter-rouge">1</code> 开始了。</p> <p>为了能够让自己定义的错误也能使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国际化处理，我们通过在 <code class="language-plaintext highlighter-rouge">enum</code> 中定义 <code class="language-plaintext highlighter-rouge">code</code> 将其 与 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码进行对应。这样我们只需要在 <code class="language-plaintext highlighter-rouge">message.properties</code> 添加对应的错误码即可：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.id.Null</span><span class="p">=</span><span class="s">User id must be null when creating a new user</span>
<span class="py">UserDTO.id.NotNull</span><span class="p">=</span><span class="s">User id cannot be null</span>
<span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
<span class="py">UserDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="c"># UserSignInDTO validation messages
</span><span class="py">UserSignInDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserSignInDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="py">USERNAME_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Username already exists: {}</span>
<span class="py">EMAIL_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Email already exists: {}</span>
<span class="py">WRONG_SIGN_IN_INFORMATION</span><span class="p">=</span><span class="s">Wrong sign in information</span>

<span class="py">INVALID_TOKEN</span><span class="p">=</span><span class="s">Invalid token: {}</span>
<span class="py">ACCESS_DENIED</span><span class="p">=</span><span class="s">Operation without privileges</span>

<span class="py">MESSAGE_CONVERSION_ERROR</span><span class="p">=</span><span class="s">Error occurs while converting message</span>
</code></pre></div></div> <p>当然我们需要一个工具类来获取错误码的信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">args</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ignore</span>
        <span class="o">}</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>之前我们在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了 <code class="language-plaintext highlighter-rouge">{min}</code> 、<code class="language-plaintext highlighter-rouge">{max}</code> 等不能通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行替换的参数，所以在这个工具类中，我们先尝试通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 获取信息，如果获取失败，我们就通过正则表达式进行替换。</p> <p>最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然我们需要定义 <code class="language-plaintext highlighter-rouge">ErrorVO</code> 对象用于返回错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">errorCodeEnum</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">errorCodeEnum</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">GenericException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleGenericException</span><span class="o">(</span>
        <span class="nc">GenericException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error caused by {}:\n {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">INVALID_TOKEN:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">case</span> <span class="nl">ACCESS_DENIED:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="spring-validation">Spring Validation</h1> <p>在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> + <code class="language-plaintext highlighter-rouge">Spring Validation</code> 的时候，我们是通过 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "{UserDTO.username.NotBlank}")</code> 来获取 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码的， <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 的语法是由 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。</p> <p>众所周知，<code class="language-plaintext highlighter-rouge">enum</code> 对于的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法可以通过名称来创建对应的 <code class="language-plaintext highlighter-rouge">enum</code> 对象，例如 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK")</code> 与 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK</code> 是等价的， 而在 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 中只会对 <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 进行解析，而其他的部分将会保持不变，例如 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}")</code> 解析后获取到的 错误信息是 <code class="language-plaintext highlighter-rouge">USERDTO_USERNAME_NOTBLANK Username cannot be blank</code>。这也就意味着我们只需要在使用注解的 地方多增加一个 <code class="language-plaintext highlighter-rouge">enum</code> 的名称即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">UserDTO</span><span class="o">(</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NULL {UserDTO.id.Null}"</span><span class="o">)</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NOTNULL {UserDTO.id.NotNull}"</span><span class="o">)</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_SIZE {UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">username</span><span class="o">,</span>
    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">email</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">userPassword</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p>当然着还没完，我们需要在全局异常处理器中对这种错误进行处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span>
        <span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// we only handle one validation message</span>
    <span class="nc">String</span> <span class="n">codeAndMessage</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getFieldError</span><span class="o">().</span><span class="na">getDefaultMessage</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">firstSpaceIndex</span> <span class="o">=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
    <span class="c1">// There must be a space and not at the end of the message</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">var</span> <span class="n">exception</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericException</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">firstSpaceIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
    <span class="n">exception</span><span class="o">.</span><span class="na">setCode</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">firstSpaceIndex</span><span class="o">)));</span>
    <span class="k">return</span> <span class="nf">handleGenericException</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>再上面的处理中，我们提取到错误码后创建相应的 <code class="language-plaintext highlighter-rouge">GenericException</code> 对象，然后交给 <code class="language-plaintext highlighter-rouge">handleGenericException</code> 进行统一处理。</p> <p>通过上面的操作后，我们已经成功对自定义校验逻辑以及 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行了统一处理，而且我们还可以 通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。</p> <h1 id="返回错误码信息">返回错误码信息</h1> <p>我们只需要定义以下的 <code class="language-plaintext highlighter-rouge">controller</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="c1">// 标记只有在开发环境下才会被加载</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">DEV_PROFILE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errorCodeConstant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑</span>
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span> <span class="o">:</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">ZERO_PLACEHOLDER</span><span class="o">)</span> <span class="o">{</span> <span class="k">continue</span><span class="o">;</span> <span class="o">}</span>
            <span class="n">errorCodeConstant</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">code</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getErrorMessage</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">errorCodeConstant</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="最后">最后</h1> <p>上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring-Validation 做了简单的介绍。但是只使用 Spring-Validation 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 Spring-Validation 就很难实现了，我们往往需要自定义代码的 实现逻辑。 而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。 而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。 返回信息 我们的基本要求是对于错误信息返回如下的 JSON 数据： { "code": 1, "message": "User id must be null when creating a new user" } 除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式： { "1": "USERDTO_ID_NULL", "2": "USERDTO_ID_NOTNULL", "3": "USERDTO_USERNAME_SIZE", "4": "USERDTO_USERNAME_NOTBLANK", "5": "USERDTO_EMAIL_NOTBLANK", "6": "USERDTO_EMAIL_EMAIL", "7": "USERDTO_USERPASSWORD_SIZE", "8": "USERDTO_USERPASSWORD_NOTBLANK", "9": "USERSIGNINDTO_USERNAME_NOTBLANK", "10": "USERSIGNINDTO_USERPASSWORD_NOTBLANK", "11": "USERNAME_ALREADY_EXISTS", "12": "EMAIL_ALREADY_EXISTS", "13": "WRONG_SIGN_IN_INFORMATION", "14": "INVALID_TOKEN", "15": "ACCESS_DENIED", "16": "MESSAGE_CONVERSION_ERROR" } 对于这样的数据，前端开发者可以很容易将其定义成一个 enum 类型，这样就可以很方便的进行错误码的比较。 自定义校验逻辑 对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 使用 Spring-Validation 进行参数校验 中介绍了如何设置全局异常处理器。 自定义错误码 当然，我们首先需要有错误码的信息，我们可以定义如下的 enum 类型： public enum ErrorCodeEnum { // This should be ignored, this is to make the ordinal of the enum start from 1 ZERO_PLACEHOLDER, USERDTO_ID_NULL("UserDTO.id.Null"), USERDTO_ID_NOTNULL("UserDTO.id.NotNull"), USERDTO_USERNAME_SIZE("UserDTO.username.Size"), USERDTO_USERNAME_NOTBLANK("UserDTO.username.NotBlank"), USERDTO_EMAIL_NOTBLANK("UserDTO.email.NotBlank"), USERDTO_EMAIL_EMAIL("UserDTO.email.Email"), USERDTO_USERPASSWORD_SIZE("UserDTO.userPassword.Size"), USERDTO_USERPASSWORD_NOTBLANK("UserDTO.userPassword.NotBlank"), USERSIGNINDTO_USERNAME_NOTBLANK("UserSignInDTO.username.NotBlank"), USERSIGNINDTO_USERPASSWORD_NOTBLANK("UserSignInDTO.userPassword.NotBlank"), USERNAME_ALREADY_EXISTS("USERNAME_ALREADY_EXISTS"), EMAIL_ALREADY_EXISTS("EMAIL_ALREADY_EXISTS"), WRONG_SIGN_IN_INFORMATION("WRONG_SIGN_IN_INFORMATION"), INVALID_TOKEN("INVALID_TOKEN"), ACCESS_DENIED("ACCESS_DENIED"), MESSAGE_CONVERSION_ERROR("MESSAGE_CONVERSION_ERROR"); // code means the error code in the message.properties private String code; ErrorCodeEnum(){} ErrorCodeEnum(String code) { this.code = code; } public String getCode() { return code; } } 通常 0 代表执行成功，所以我们在上面的 enum 类型中加入了一个 ZERO_PLACEHOLDER，这样我们的错误码 就可以从 1 开始了。 为了能够让自己定义的错误也能使用 MessageSource 进行国际化处理，我们通过在 enum 中定义 code 将其 与 message.properties 中的错误码进行对应。这样我们只需要在 message.properties 添加对应的错误码即可： # UserDTO validation messages UserDTO.id.Null=User id must be null when creating a new user UserDTO.id.NotNull=User id cannot be null UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.username.NotBlank=Username cannot be blank UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters UserDTO.userPassword.NotBlank=Password cannot be blank # UserSignInDTO validation messages UserSignInDTO.username.NotBlank=Username cannot be blank UserSignInDTO.userPassword.NotBlank=Password cannot be blank USERNAME_ALREADY_EXISTS=Username already exists: {} EMAIL_ALREADY_EXISTS=Email already exists: {} WRONG_SIGN_IN_INFORMATION=Wrong sign in information INVALID_TOKEN=Invalid token: {} ACCESS_DENIED=Operation without privileges MESSAGE_CONVERSION_ERROR=Error occurs while converting message 当然我们需要一个工具类来获取错误码的信息： // 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入 @Component public class MessageSourceUtil { private static MessageSource messageSource; MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(ErrorCodeEnum code, Object... args) { try { return messageSource.getMessage(code.getCode(), args, LocaleContextHolder.getLocale()); } catch (Exception e) { // ignore } String message=messageSource.getMessage(code.getCode(), null, LocaleContextHolder.getLocale()); Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 之前我们在 使用 Spring-Validation 进行参数校验 中介绍了 {min} 、{max} 等不能通过 MessageSource 进行替换的参数，所以在这个工具类中，我们先尝试通过 MessageSource 获取信息，如果获取失败，我们就通过正则表达式进行替换。 最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理： @Getter @Setter public class GenericException extends RuntimeException { private ErrorCodeEnum code; public GenericException(String message) { super(message); } public GenericException(ErrorCodeEnum code, Object... args) { super(MessageSourceUtil.getMessage(code, args)); this.code = code; } } 当然我们需要定义 ErrorVO 对象用于返回错误信息： public record ErrorVO(Integer code, String message) { public ErrorVO(ErrorCodeEnum errorCodeEnum, String message) { this(errorCodeEnum.ordinal(), message); } } 经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了： @ExceptionHandler(GenericException.class) public ResponseEntity&lt;ErrorVO&gt; handleGenericException( GenericException e, HttpServletRequest request) { logger.error("Error caused by {}:\n {}", request.getRemoteAddr(), e.getMessage()); switch (e.getCode()) { case INVALID_TOKEN: return ResponseEntity.status(HttpStatus.UNAUTHORIZED) .body(new ErrorVO(e.getCode(), e.getMessage())); case ACCESS_DENIED: return ResponseEntity.status(HttpStatus.FORBIDDEN) .body(new ErrorVO(e.getCode(), e.getMessage())); default: return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(new ErrorVO(e.getCode(), e.getMessage())); } } Spring Validation 在使用 MessageSource + Spring Validation 的时候，我们是通过 @NotBlank(message = "{UserDTO.username.NotBlank}") 来获取 message.properties 中的错误码的， {xxx.xxx.xxx} 的语法是由 Spring Validation 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。 众所周知，enum 对于的 valueOf 方法可以通过名称来创建对应的 enum 对象，例如 ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK") 与 ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK 是等价的， 而在 Spring Validation 中只会对 {xxx.xxx.xxx} 进行解析，而其他的部分将会保持不变，例如 @NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") 解析后获取到的 错误信息是 USERDTO_USERNAME_NOTBLANK Username cannot be blank。这也就意味着我们只需要在使用注解的 地方多增加一个 enum 的名称即可： public record UserDTO( @Null(groups = CreateGroup.class, message="USERDTO_ID_NULL {UserDTO.id.Null}") @NotNull(groups = UpdateGroup.class, message="USERDTO_ID_NOTNULL {UserDTO.id.NotNull}") Long id, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_USERNAME_LENGTH, max=ValidationConstant.MAX_USERNAME_LENGTH, message="USERDTO_USERNAME_SIZE {UserDTO.username.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") String username, @Email( groups={CreateGroup.class}, message="USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") String email, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_PASSWORD_LENGTH, max=ValidationConstant.MAX_PASSWORD_LENGTH, message="USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}") String userPassword) {} 当然着还没完，我们需要在全局异常处理器中对这种错误进行处理： @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity&lt;ErrorVO&gt; handleMethodArgumentNotValidException( MethodArgumentNotValidException e, HttpServletRequest request) { // we only handle one validation message String codeAndMessage=e.getFieldError().getDefaultMessage(); int firstSpaceIndex=codeAndMessage.indexOf(" "); // There must be a space and not at the end of the message assert firstSpaceIndex != -1; assert firstSpaceIndex != codeAndMessage.length() - 1; var exception=new GenericException(codeAndMessage.substring(firstSpaceIndex + 1)); exception.setCode(ErrorCodeEnum.valueOf(codeAndMessage.substring(0, firstSpaceIndex))); return handleGenericException(exception, request); } 再上面的处理中，我们提取到错误码后创建相应的 GenericException 对象，然后交给 handleGenericException 进行统一处理。 通过上面的操作后，我们已经成功对自定义校验逻辑以及 Spring Validation 进行了统一处理，而且我们还可以 通过 MessageSource 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。 返回错误码信息 我们只需要定义以下的 controller 即可： @RestController // 标记只有在开发环境下才会被加载 @Profile(ApplicationConstant.DEV_PROFILE) public class DevelopmentController { private Map&lt;Integer, String&gt; errorCodeConstant=new HashMap&lt;&gt;(); // 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑 @PostConstruct public void init() { for (ErrorCodeEnum code : ErrorCodeEnum.values()) { if (code == ErrorCodeEnum.ZERO_PLACEHOLDER) { continue; } errorCodeConstant.put(code.ordinal(), code.name()); } } @GetMapping(ApiPathConstant.DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH) public Map&lt;Integer, String&gt; getErrorMessage() { return errorCodeConstant; } } 最后 上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。]]></summary></entry></feed>