<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2026-01-29T14:02:55+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>Sharing everything I know. </subtitle><entry><title type="html">nvim 学习</title><link href="https://kaiser-yang.github.io/blog/2026/nvim-skills/" rel="alternate" type="text/html" title="nvim 学习"/><published>2026-01-29T14:01:37+00:00</published><updated>2026-01-29T14:01:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2026/nvim-skills</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2026/nvim-skills/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">nrformats</code> 决定了 <code class="language-plaintext highlighter-rouge">CTRL-A</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-X</code> 增减数字时所识别的数字格式，其默认值为 <code class="language-plaintext highlighter-rouge">bin,hex</code> 表示会将 <code class="language-plaintext highlighter-rouge">0b</code> 和 <code class="language-plaintext highlighter-rouge">0B</code> 开头的数字识别成二进制，<code class="language-plaintext highlighter-rouge">0x</code> 和 <code class="language-plaintext highlighter-rouge">0X</code> 开头的数字识别成十六进制。也可以增加 <code class="language-plaintext highlighter-rouge">octal</code> 来识别 <code class="language-plaintext highlighter-rouge">0</code> 开头的八进制数字。</p> <p>可视模式下可以通过 <code class="language-plaintext highlighter-rouge">[N]g_CTRL-A</code> 来格式化 <code class="language-plaintext highlighter-rouge">Markdown</code> 中的列表。选择多行时，每一行将会比上一行多加 <code class="language-plaintext highlighter-rouge">N</code>。例如：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.
1.
1.
1.
</code></pre></div></div> <p>如果选择后三行并按下 <code class="language-plaintext highlighter-rouge">g_CTRL-A</code>，则会变成：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.
2.
3.
4.
</code></pre></div></div> <p>如果要给一段文字的每一行进行编号，可以使用 <code class="language-plaintext highlighter-rouge">Vip</code> 进入可视模式并选择整段文字，然后再使用 <code class="language-plaintext highlighter-rouge">:norm I0. </code> 给每一行的开头插入 <code class="language-plaintext highlighter-rouge">0. </code>，接着使用 <code class="language-plaintext highlighter-rouge">gv</code> 重新选择刚刚的内容，最后用 <code class="language-plaintext highlighter-rouge">g_CTRL-A</code> 进行编号。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-K {cahr1} {char2}</code> 可以插入一个特殊字符，其中 <code class="language-plaintext highlighter-rouge">{char1}</code> 和 <code class="language-plaintext highlighter-rouge">{char2}</code> 是该特殊字符的两个字母缩写。例如 <code class="language-plaintext highlighter-rouge">CTRL-K &lt;&lt;</code> 会插入 <code class="language-plaintext highlighter-rouge">«</code> 字符，<code class="language-plaintext highlighter-rouge">CTRL-K &gt;&gt;</code> 会插入 <code class="language-plaintext highlighter-rouge">»</code> 字符。可以通过 <code class="language-plaintext highlighter-rouge">:help digraphs-table</code> 来查看所有可用的字符缩写。</p> <hr/> <p>普通模式下 <code class="language-plaintext highlighter-rouge">ga</code> 可以查看光标下字符的编码值，格式如下：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;}&gt;  125,  Hex 7d,  Oct 175, Digr !)
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">&lt;}&gt;</code> 是该字符本身，<code class="language-plaintext highlighter-rouge">125</code> 是该字符的十进制编码值，<code class="language-plaintext highlighter-rouge">Hex 7d</code> 是十六进制编码值，<code class="language-plaintext highlighter-rouge">Oct 175</code> 是八进制编码值，<code class="language-plaintext highlighter-rouge">Digr !)</code> 表示在插入模式下输入该字符可以使用 <code class="language-plaintext highlighter-rouge">CTRL-K_!)</code>。</p> <hr/> <p>以下的功能键可以实现快速删除：</p> <table> <thead> <tr> <th>按键</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-H</code></td> <td>删除光标前的一个字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-U</code></td> <td>删除光标前的整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-W</code></td> <td>删除光标前的一个单词</td> </tr> </tbody> </table> <hr/> <p>可视模式下可以使用 <code class="language-plaintext highlighter-rouge">o</code> 键在选区的起始位置和结束位置之间切换光标。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Up</code> 和 <code class="language-plaintext highlighter-rouge">Down</code> 可以查找命令历史，如果已经输入了一部分命令，使用 <code class="language-plaintext highlighter-rouge">Up</code> 和 <code class="language-plaintext highlighter-rouge">Down</code> 则会过滤以输入内容开头历史命令。</p> <p><code class="language-plaintext highlighter-rouge">CTRL-P</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-N</code> 在没有补全项被触发时功能和 <code class="language-plaintext highlighter-rouge">Up</code> 和 <code class="language-plaintext highlighter-rouge">Down</code> 一样；有补全项被触发（通过需要使用 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 来触发）<code class="language-plaintext highlighter-rouge">CTRL-P</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-N</code> 则会在补全项中进行选择。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-G</code> 在普通模式下可以用来打印当前文件的文件名、总行数以及当前行占总行数的百分比；其还可在可视模式下和选择模式下进行切换。</p> <p>选择模式往往是用于实现 <code class="language-plaintext highlighter-rouge">Snippets</code> 相关功能，实际使用中不太需要自己主动进入选择模式。</p> <p>选择模式和可视模式的一个主要区别是：在选择模式下输入的内容会替换选中的文本，而在可视模式下如果要替换文本需要先使用 <code class="language-plaintext highlighter-rouge">c</code> 进入插入模式。</p> <hr/> <p>当使用 <code class="language-plaintext highlighter-rouge">:e {file}</code> 打开一个不存在目录下的文件时，<code class="language-plaintext highlighter-rouge">nvim</code> 会给出报错但是依然会打开文件供我们编辑，只是在使用 <code class="language-plaintext highlighter-rouge">:w</code> 命令进行保存时会提示无法保存，这时我们先可以使用 <code class="language-plaintext highlighter-rouge">:!mkdir -p %:h</code> 来保证目录全部被创建，再使用 <code class="language-plaintext highlighter-rouge">:w</code> 即可正常保存文件；也可以直接使用 <code class="language-plaintext highlighter-rouge">:w ++p</code> 在保存时自动创建目录。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">:w</code> 命令可能会遇到需要 <code class="language-plaintext highlighter-rouge">root</code> 权限的情况，这时可以直接使用 <code class="language-plaintext highlighter-rouge">:w !sudo tee % &gt; /dev/null</code> 来进行保存。</p> <hr/> <p>下列的按键可以重复一些操作：</p> <ul> <li><code class="language-plaintext highlighter-rouge">@:</code> 可以重复执行上一次在命令行模式下的命令；</li> <li><code class="language-plaintext highlighter-rouge">&amp;</code> 可以重复执行上一次 <code class="language-plaintext highlighter-rouge">:s</code> 命令，默认被绑定到了 <code class="language-plaintext highlighter-rouge">:&amp;&amp;</code>，其只会对当前行进进行替换</li> <li><code class="language-plaintext highlighter-rouge">g&amp;</code> 可以重复执行上一次 <code class="language-plaintext highlighter-rouge">:s</code> 命令，和 <code class="language-plaintext highlighter-rouge">:%s//~/&amp;</code> 是等价的；</li> <li><code class="language-plaintext highlighter-rouge">@@</code> 可以重复执行上一次在普通模式下使用 <code class="language-plaintext highlighter-rouge">@{0-9a-z":*}</code> 执行的宏命令。</li> </ul> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">:&amp;&amp;</code> 中的 <code class="language-plaintext highlighter-rouge">:&amp;</code> 代表 <code class="language-plaintext highlighter-rouge">:s</code>，末尾的 <code class="language-plaintext highlighter-rouge">&amp;</code> 代表上一次的替换使用的标志，而 <code class="language-plaintext highlighter-rouge">:%s//~/&amp;</code> 中的 <code class="language-plaintext highlighter-rouge">~</code> 代表上一次使用的替换串。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">gr</code> 和 <code class="language-plaintext highlighter-rouge">gR</code> （单字符和连续替换）可以进入 <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式。<code class="language-plaintext highlighter-rouge">Virtual Replace</code> 和 <code class="language-plaintext highlighter-rouge">Replace</code> 模式的主要区别在于：<code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式是按照屏幕上显示宽度进行替换，<code class="language-plaintext highlighter-rouge">Replace</code> 模式是按照实际字符进行替换的。这在替换包含制表符的文本时非常有用，例如在 <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式下，如果当前位置是一个显示宽度为多个空格的制表符，那么输入的字符会插入到制表符之前，当输入的字符数量达到制表符的显示宽度时，制表符才会被替换掉。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-R {register}</code> 在插入模式和命令行模式下可以插入寄存器中的内容；<code class="language-plaintext highlighter-rouge">CTRL-R CTRL-P {register}</code> 也可以实现类似的功能，且它会自动调整缩进；<code class="language-plaintext highlighter-rouge">CTRL-R =</code> 则可以在插入模式或者命令行模式下插入一个表达式的计算结果。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-V {digit}</code> 可以用来插入特殊字符：</p> <table> <thead> <tr> <th>按键组合</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V {digit}</code></td> <td>以十进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V u{digit}</code></td> <td>以十六进制插入 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V U{digit}</code></td> <td>以十六进制插入 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V o{digit}</code></td> <td>以八进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V O{digit}</code></td> <td>以八进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V x{digit}</code></td> <td>以十六进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V X{digit}</code></td> <td>以十六进制插入字符</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">CTRL-V</code> 后面可以跟一个非数字字符来插入对应的控制字符，例如 <code class="language-plaintext highlighter-rouge">CTRL-V CTRL-M</code> 可以插入回车符。</p> <hr/> <p>使用 <code class="language-plaintext highlighter-rouge">/</code> 或者 <code class="language-plaintext highlighter-rouge">?</code> 进行搜索的时候，我们其实是需要在输入一个模式串后还需要输入 <code class="language-plaintext highlighter-rouge">/</code> 或者 <code class="language-plaintext highlighter-rouge">?</code> 来进行结尾的，只是在大部分的时候它们可以被省略，但是在我们使用 <code class="language-plaintext highlighter-rouge">:norm</code> 命令进行操作的时候它们往往不能被省略。当然我们也可以使用类似 <code class="language-plaintext highlighter-rouge">/word/e</code> 的方式来指定搜索结果的光标位置，这与 <code class="language-plaintext highlighter-rouge">/word\zs</code> 会有所不同，后者不会高亮整个匹配的内容。</p> <p>如果我们在向后搜索的时候需要搜索 <code class="language-plaintext highlighter-rouge">/</code> 则需要使用 <code class="language-plaintext highlighter-rouge">\</code> 来进行转义，而在向前搜索的时候想要搜索 <code class="language-plaintext highlighter-rouge">?</code> 则需要使用 <code class="language-plaintext highlighter-rouge">\</code> 来进行转义。如果我们使用 <code class="language-plaintext highlighter-rouge">/</code> 向后搜索我们可以使用 <code class="language-plaintext highlighter-rouge">\?</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 来表示 <code class="language-plaintext highlighter-rouge">?</code> 的两种意思，但使用 <code class="language-plaintext highlighter-rouge">?</code> 向前搜索的时候我们只能通过 <code class="language-plaintext highlighter-rouge">\?</code> 来表示 <code class="language-plaintext highlighter-rouge">?</code> 的一种意思，不过 <code class="language-plaintext highlighter-rouge">=</code> 或 <code class="language-plaintext highlighter-rouge">\=</code> 也可以表示匹配 <code class="language-plaintext highlighter-rouge">0</code> 次或者 <code class="language-plaintext highlighter-rouge">1</code> 次。</p> <hr/> <p>一些常用的命令：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]d [x]</code></td> <td>删除指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]y [x]</code></td> <td>复制指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[l]pu [x]</code></td> <td>在指定行之后粘贴寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中的内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[l]pu! [x]</code></td> <td>在指定行之前粘贴寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中的内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]t {addr}</code></td> <td>复制指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]m {addr}</code></td> <td>移动指定范围的行到目标地址处</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]j</code></td> <td>将指定范围的行连接成一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]norm {cmd}</code></td> <td>对指定范围的行执行普通模式下的命令</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]s/{p}/{s}/[flags]</code></td> <td>对指定范围的行执行替换操作</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[r]g/{p}/[cmd]</code></td> <td>对指定范围内匹配模式的行执行 <code class="language-plaintext highlighter-rouge">Ex</code> 命令</td> </tr> </tbody> </table> <p><strong>注意</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">[r]</code> 表示可选的范围，可以是行号、搜索模式等，默认当前行。</li> <li><code class="language-plaintext highlighter-rouge">[l]</code> 表示可选的行号，默认是当前行。</li> <li><code class="language-plaintext highlighter-rouge">[x]</code> 表示可选的寄存器名称，默认是匿名寄存器。</li> <li><code class="language-plaintext highlighter-rouge">{addr}</code> 表示目标地址，可以是行号、搜索模式等。</li> <li><code class="language-plaintext highlighter-rouge">{cmd}</code> 表示要执行的命令。</li> <li><code class="language-plaintext highlighter-rouge">{p}</code> 表示搜索模式。</li> <li><code class="language-plaintext highlighter-rouge">{s}</code> 表示替换字符串。</li> <li><code class="language-plaintext highlighter-rouge">[flags]</code> 表示替换标志： <ul> <li><code class="language-plaintext highlighter-rouge">g</code> 表示全局替换；</li> <li><code class="language-plaintext highlighter-rouge">c</code> 表示替换前需要确认；</li> <li><code class="language-plaintext highlighter-rouge">e</code> 表示忽略错误；</li> <li><code class="language-plaintext highlighter-rouge">n</code> 表示只显示替换的数量；</li> <li><code class="language-plaintext highlighter-rouge">i</code> 表示忽略大小写；</li> <li><code class="language-plaintext highlighter-rouge">I</code> 表示区分大小写；</li> </ul> </li> </ul> <p>常用的地址表示方法：</p> <table> <thead> <tr> <th>地址</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">1</code></td> <td>第一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">$</code></td> <td>最后一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">0</code></td> <td>虚拟行，位于第一行之前</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">.</code></td> <td>当前行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">%</code></td> <td>当前文件的所有行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">N</code></td> <td>第 <code class="language-plaintext highlighter-rouge">N</code> 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">+N</code></td> <td>当前行向下 <code class="language-plaintext highlighter-rouge">N</code> 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-N</code></td> <td>当前行向上 <code class="language-plaintext highlighter-rouge">N</code> 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">/pattern/</code></td> <td>向下搜索匹配模式的行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">?pattern?</code></td> <td>向上搜索匹配模式的行</td> </tr> </tbody> </table> <p>对于搜索的范围可以写出 <code class="language-plaintext highlighter-rouge">/&lt;html&gt;/,/&lt;\/html&gt;/</code> 来表示从第一个 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 标签所在行到第一个 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签所在行的范围。</p> <p>搜索范围可以和 <code class="language-plaintext highlighter-rouge">+N</code> 、<code class="language-plaintext highlighter-rouge">-N</code> 结合使用，例如：<code class="language-plaintext highlighter-rouge">:/&lt;html&gt;/+1,/&lt;\/html&gt;/-1d</code> 表示删除从第一个 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 标签下一行到第一个 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签上一行的内容。</p> <p>对于这些命令我们也可以在 <code class="language-plaintext highlighter-rouge">Visual</code> 模式下选中内容后使用 <code class="language-plaintext highlighter-rouge">:</code> 进入命令行模式，此时命令行中会自动插入 <code class="language-plaintext highlighter-rouge">'&lt;,'&gt;</code> 来表示选中的范围，我们只需要在后面添加命令即可。</p> <p>这里再给出几个例子：</p> <ul> <li><code class="language-plaintext highlighter-rouge">:%norm A;</code> 在每一行的末尾添加分号</li> <li><code class="language-plaintext highlighter-rouge">:%norm I//</code> 在每一行的开头添加注释符号 <code class="language-plaintext highlighter-rouge">//</code></li> </ul> <hr/> <p>可以使用下面的命令来操作缓冲区：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:ls</code></td> <td>列出当前打开的所有缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:b {bufnum}</code></td> <td>切换到指定编号的缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bp</code></td> <td>切换到上一个缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bn</code></td> <td>切换到下一个缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bf</code></td> <td>切换到第一个缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bl</code></td> <td>切换到最后一个缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bd</code></td> <td><code class="language-plaintext highlighter-rouge">unload</code> 一个缓冲区并将其从缓冲区列表中移除</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bun</code></td> <td><code class="language-plaintext highlighter-rouge">unload</code> 一个缓冲区但不将其从缓冲区列表中移除</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:bufdo {cmd}</code></td> <td>对所有缓冲区依次执行指定的命令</td> </tr> </tbody> </table> <p>列出的缓冲区中 <code class="language-plaintext highlighter-rouge">%</code> 符号表示当前缓冲区，<code class="language-plaintext highlighter-rouge">#</code> 符号表示轮换文件。开头的数字则表示缓冲区的编号。<code class="language-plaintext highlighter-rouge">CTRL-^</code> 可以在当前文件和轮换文件之间切换。</p> <p>轮换文件：在一个窗口打开一个新的缓冲区时，当前缓冲区就对应的文件就成为了轮换文件，如果使用 <code class="language-plaintext highlighter-rouge">:bd</code> 将一个轮换文件对应的缓冲区从缓冲区列表中移除，那么当前窗口就没有对应的轮换文件了，轮换文件是相对于每个窗口独立的。</p> <hr/> <p>可以使用下面的命令来操作一批文件：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:ar</code></td> <td>查看参数列表</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:ar {arglist}</code></td> <td>重新设置参数列表</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:n</code></td> <td>切换到上一个文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:prev</code></td> <td>切换到下一个文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:arga</code></td> <td>向参数列表中添加一个文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:argd</code></td> <td>从参数列表中删除指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:argdo {cmd}</code></td> <td>对所有文件依次执行指定的命令</td> </tr> </tbody> </table> <p>例如 <code class="language-plaintext highlighter-rouge">:args *.js</code> 会将当前目录下的所有 <code class="language-plaintext highlighter-rouge">js</code> 文件添加到参数列表中，然后可以通过 <code class="language-plaintext highlighter-rouge">:next</code> 和 <code class="language-plaintext highlighter-rouge">:prev</code> 来切换这些文件。</p> <p>我们可以使用反引号来将命令的输出作为参数列表，例如：</p> <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">args</span> `<span class="k">find</span> <span class="p">.</span> <span class="p">-</span>name <span class="s1">'*.js'</span>`
</code></pre></div></div> <hr/> <p>在使用 <code class="language-plaintext highlighter-rouge">:argdo {cmd}</code> 或者 <code class="language-plaintext highlighter-rouge">:bufdo {cmd}</code> 时，其会按照如下的逻辑进行执行：</p> <ul> <li><code class="language-plaintext highlighter-rouge">:first</code> 或者 <code class="language-plaintext highlighter-rouge">:bf</code></li> <li><code class="language-plaintext highlighter-rouge">:{cmd}</code></li> <li><code class="language-plaintext highlighter-rouge">:next</code> 或者 <code class="language-plaintext highlighter-rouge">:bn</code></li> <li><code class="language-plaintext highlighter-rouge">:{cmd}</code></li> <li>……</li> </ul> <p>当执行过程中 <code class="language-plaintext highlighter-rouge">:{cmd}</code> 进行了修改但是没有保存的时候，<code class="language-plaintext highlighter-rouge">:next</code> 和 <code class="language-plaintext highlighter-rouge">:bn</code> 就会执行失败，我们可以通过设置 <code class="language-plaintext highlighter-rouge">hidden</code> 选项（默认开启）来允许切换未保存修改的缓冲区。</p> <p>当然我们也可以在 <code class="language-plaintext highlighter-rouge">:{cmd}</code> 结尾加上 <code class="language-plaintext highlighter-rouge">| update</code> 来保存修改，例如：<code class="language-plaintext highlighter-rouge">:bufdo %s/var/let/g | update</code> 会对所有缓冲区进行替换并保存修改。</p> <hr/> <p>下面的一些命令可以用来处理有修改的缓冲区：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:w</code></td> <td>保存当前缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:wa</code></td> <td>保存所有缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:e</code></td> <td>重新加载当前缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:qa</code></td> <td>关闭所有缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:up</code></td> <td>保存当前缓冲区（如果有修改）</td> </tr> </tbody> </table> <p>上面的命令都可以在结尾加上 <code class="language-plaintext highlighter-rouge">!</code> 来强制执行，例如 <code class="language-plaintext highlighter-rouge">:qa!</code> 会强制关闭所有缓冲区而不保存修改。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">q:</code>、<code class="language-plaintext highlighter-rouge">q/</code> 和 <code class="language-plaintext highlighter-rouge">q?</code> 可以打开命令行窗口，它们分别用于打开命令历史、向下搜索历史和向上搜索历史。</p> <p>在命令行窗口中，我们可以像编辑普通文件一样编辑命令历史，当你在任意一行上按下 <code class="language-plaintext highlighter-rouge">&lt;Enter&gt;</code> 的时候，该行命令将会被执行；<code class="language-plaintext highlighter-rouge">CTRL-C</code> 会返回到命令行模式；<code class="language-plaintext highlighter-rouge">:q</code> 则可以关闭命令行窗口。</p> <p>如果你当前处在命令行模式下，可以直接按下 <code class="language-plaintext highlighter-rouge">CTRL-F</code> 来打开对应的命令行窗口。</p> <hr/> <p>输入的时候可以使用 <code class="language-plaintext highlighter-rouge">SHIFT-LEFT</code>（或 <code class="language-plaintext highlighter-rouge">CTRL-LEFT</code>）和 <code class="language-plaintext highlighter-rouge">SHIFT-RIGHT</code>（或 <code class="language-plaintext highlighter-rouge">CTRL-RIGHT</code>）将光标按照单词进行移动，类似于普通模式下的 <code class="language-plaintext highlighter-rouge">b</code> 和 <code class="language-plaintext highlighter-rouge">w</code> 按键。</p> <hr/> <p>命令行模式下可以用 <code class="language-plaintext highlighter-rouge">|</code> 来连接多个命令，例如：<code class="language-plaintext highlighter-rouge">:w | !gcc % -o %&lt;; ./%&lt;</code> 会先保存当前文件，然后编译该文件并运行生成的可执行文件。</p> <p>在执行 <code class="language-plaintext highlighter-rouge">SHELL</code> 命令的时候，<code class="language-plaintext highlighter-rouge">%</code> 会被解析成当前文件名，<code class="language-plaintext highlighter-rouge">%&lt;</code> 解析成当前文件名去掉扩展名后的名称。可以通过 <code class="language-plaintext highlighter-rouge">:h cmdline-special</code> 来查看所有可用的特殊符号。</p> <hr/> <p>可以通过 <code class="language-plaintext highlighter-rouge">:!{cmd}</code> 的方式来执行外部命令，当直接运行 <code class="language-plaintext highlighter-rouge">:!ls</code> 时，会回显命令的输出，当命令的输出比较长时，可以用 <code class="language-plaintext highlighter-rouge">:r !{cmd}</code> 的方式来将命令的输出读取到当前光标所在位置。</p> <p>当然我们也可以通过 <code class="language-plaintext highlighter-rouge">:enew | r !{cmd}</code> 的方式来在一个新的缓冲区中读取命令的输出。</p> <p><code class="language-plaintext highlighter-rouge">:[range]w !{cmd}</code> 则做相反的操作，它会将当前缓冲区的指定内容通过管道传递给外部命令 <code class="language-plaintext highlighter-rouge">cmd</code> 的标准输入。如果不指定范围则默认是整个缓冲区的内容。</p> <hr/> <p>窗口大小调整相关的命令：</p> <table> <thead> <tr> <th>命令</th> <th>快捷键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:winc =</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_=</code></td> <td>使所有窗口大小相等</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc _</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W__</code></td> <td>最大化当前窗口的高度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc |</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_|</code></td> <td>最大化当前窗口的宽度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc [N]</code></td> <td><code class="language-plaintext highlighter-rouge">[N]CTRL-W__</code></td> <td>将当前窗口高度设置成 <code class="language-plaintext highlighter-rouge">N</code> 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc [N]|</code></td> <td><code class="language-plaintext highlighter-rouge">[N]CTRL-W_|</code></td> <td>将当前窗口宽度设置成 <code class="language-plaintext highlighter-rouge">N</code> 列</td> </tr> </tbody> </table> <p>窗口移动相关的命令：</p> <table> <thead> <tr> <th>命令</th> <th>快捷键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:winc r</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_r</code></td> <td>旋转窗口位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc R</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_R</code></td> <td>反向旋转窗口位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc x</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_x</code></td> <td>交换当前窗口和下一个窗口</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc K</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_K</code></td> <td>将当前窗口移动到最上面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc J</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_J</code></td> <td>将当前窗口移动到最下面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc H</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_H</code></td> <td>将当前窗口移动到最左边</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc L</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_L</code></td> <td>将当前窗口移动到最右边</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:winc T</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_T</code></td> <td>将当前窗口移动到一个新标签页</td> </tr> </tbody> </table> <p>窗口控制相关的命令：</p> <table> <thead> <tr> <th>命令</th> <th>快捷键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:clo</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_c</code></td> <td>关闭当前窗口</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:on</code></td> <td><code class="language-plaintext highlighter-rouge">CTRL-W_o</code></td> <td>关闭其他窗口只保留当前窗口</td> </tr> </tbody> </table> <hr/> <p>每个窗口有自己的工作目录，可以合用 <code class="language-plaintext highlighter-rouge">:pwd</code> 来查看当前窗口的工作目录。使用 <code class="language-plaintext highlighter-rouge">:cd {path}</code> 可以全局改变工作目录，而使用 <code class="language-plaintext highlighter-rouge">:lcd {path}</code> 则只会改变当前窗口的工作目录。</p> <hr/> <p>与 <code class="language-plaintext highlighter-rouge">:argdo</code> 和 <code class="language-plaintext highlighter-rouge">:bufdo</code> 类似，<code class="language-plaintext highlighter-rouge">:windo {cmd}</code> 可以对所有窗口执行指定的命令。</p> <hr/> <p>使用下面的命令来管理标签页：</p> <table> <thead> <tr> <th>命令</th> <th>快捷键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:tabe</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>在新标签页中打开一个文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabn</code></td> <td><code class="language-plaintext highlighter-rouge">gt</code></td> <td>切换到下一个标签页</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabp</code></td> <td><code class="language-plaintext highlighter-rouge">gT</code></td> <td>切换到上一个标签页</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabn {N}</code></td> <td><code class="language-plaintext highlighter-rouge">{N}gt</code></td> <td>切换到 <code class="language-plaintext highlighter-rouge">N</code> 号标签页</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabc</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>关闭当前标签页</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabo</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>关闭其他标签页只保留当前标签页</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabm [N]</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>移动当前标签页到 <code class="language-plaintext highlighter-rouge">N</code> 号后，默认为<code class="language-plaintext highlighter-rouge">$</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabm -[N]</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>将当前标签页向左移动 <code class="language-plaintext highlighter-rouge">N</code> 个位置，默认为 <code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:tabm +[N]</code></td> <td><code class="language-plaintext highlighter-rouge">N/A</code></td> <td>将当前标签页向右移动 <code class="language-plaintext highlighter-rouge">N</code> 个位置，默认为 <code class="language-plaintext highlighter-rouge">1</code></td> </tr> </tbody> </table> <hr/> <p>在命令行模式下可以进行下列展开：</p> <table> <thead> <tr> <th>符号</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">%</code></td> <td>当前文件的完整路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">#</code></td> <td>轮换文件的完整路径</td> </tr> </tbody> </table> <p>在进行展开的时候可以使用下面的修饰符：</p> <table> <thead> <tr> <th>符号</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:p</code></td> <td>转换成完整路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:~</code></td> <td>用 <code class="language-plaintext highlighter-rouge">~</code> 代替用户主目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:.</code></td> <td>用当前工作目录代替路径前缀</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:h</code></td> <td>去掉文件名，保留目录路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:t</code></td> <td>去掉目录路径，保留文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:r</code></td> <td>去掉文件扩展名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:e</code></td> <td>只保留文件扩展名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:s?p?s?</code></td> <td>替换路径中的第一个匹配模式 <code class="language-plaintext highlighter-rouge">p</code> 为 <code class="language-plaintext highlighter-rouge">s</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:gs?p?s?</code></td> <td>替换路径中所有匹配模式 <code class="language-plaintext highlighter-rouge">p</code> 为 <code class="language-plaintext highlighter-rouge">s</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:S</code></td> <td>对路径进行 <code class="language-plaintext highlighter-rouge">shell</code> 转义</td> </tr> </tbody> </table> <p>在上面的 <code class="language-plaintext highlighter-rouge">:s?p?s?</code> 和 <code class="language-plaintext highlighter-rouge">:gs?p?s?</code> 中，<code class="language-plaintext highlighter-rouge">?</code> 可以替换成任意未在 <code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">s</code> 中出现的字符。</p> <hr/> <p>可以使用 <code class="language-plaintext highlighter-rouge">m{a-zA-Z}</code> 来创建一个标记，小写字母的标记是每个缓冲区局部可见的，而大写字母的标记则是全局可见的。我们可以使用 <code class="language-plaintext highlighter-rouge">'{mark}</code> 来跳转到 <code class="language-plaintext highlighter-rouge">{mark}</code> 所在行的第一个非空字符上，使用 <code class="language-plaintext highlighter-rouge">`{mark}</code> 则会跳转到定义 <code class="language-plaintext highlighter-rouge">{mark}</code> 的精确位置。</p> <p>下面给出一些自带的位置标记：</p> <table> <thead> <tr> <th>标记</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">`</code></td> <td>上次跳转位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">.</code></td> <td>上次修改位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">"</code></td> <td>上次退出文件位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">^</code></td> <td>上次插入位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[</code></td> <td>上次修改或复制的开始位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">]</code></td> <td>上次修改或复制的结束位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;</code></td> <td>可视模式下选区的开始位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;</code></td> <td>可视模式下选区的结束位置</td> </tr> </tbody> </table> <p>在使用与 <code class="language-plaintext highlighter-rouge">quick-fix</code> 列表相关的命令（如 <code class="language-plaintext highlighter-rouge">:grep</code>、<code class="language-plaintext highlighter-rouge">:vimgrep</code>、<code class="language-plaintext highlighter-rouge">:make</code>）或使用与缓冲区列表、参数列表有关的命令（如 <code class="language-plaintext highlighter-rouge">:args</code>、<code class="language-plaintext highlighter-rouge">:argdo</code>）前设置一个全局标记可以在操作后快速返回。</p> <p>可以使用 <code class="language-plaintext highlighter-rouge">gi</code> 命令跳转到上次插入的位置并进入插入模式。</p> <hr/> <p>可以使用以下的默认 <code class="language-plaintext highlighter-rouge">operator</code>：</p> <table> <thead> <tr> <th>按键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">~</code></td> <td>切换大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">g~</code></td> <td>切换大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">gu</code></td> <td>转换为小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">gU</code></td> <td>转换为大写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">!</code></td> <td>过滤</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">=</code></td> <td>自动缩进</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">zf</code></td> <td>创建折叠</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">g@</code></td> <td>调用用户设置的 <code class="language-plaintext highlighter-rouge">operatorfunc</code></td> </tr> </tbody> </table> <p>当使用各自最后一个按键时会对当前行进行操作，例如 <code class="language-plaintext highlighter-rouge">gUU</code> 会让当前行的字母全部变成大写。在可视模式下使用上述命令会作用于选择的内容。</p> <p>当 <code class="language-plaintext highlighter-rouge">tildeop</code> 选项关闭时（默认关闭），<code class="language-plaintext highlighter-rouge">~</code> 在普通模式下只会切换光标下字符的大小写；当开启时，<code class="language-plaintext highlighter-rouge">~</code> 在普通模式下和 <code class="language-plaintext highlighter-rouge">g~</code> 效果相同。</p> <p><code class="language-plaintext highlighter-rouge">u</code>、<code class="language-plaintext highlighter-rouge">U</code>、<code class="language-plaintext highlighter-rouge">~</code> 在可视模式下与 <code class="language-plaintext highlighter-rouge">gu</code>、<code class="language-plaintext highlighter-rouge">gU</code>、<code class="language-plaintext highlighter-rouge">g~</code> 效果相同。</p> <p>过滤是指将指定范围内的内容通过管道传递给外部命令 <code class="language-plaintext highlighter-rouge">{filter}</code> 的标准输入，并将外部命令的输出替换掉指定范围内的内容。例如输入 <code class="language-plaintext highlighter-rouge">!G</code> 后会进命令行模式且会自动填入 <code class="language-plaintext highlighter-rouge">:.,$!</code> 这个时候我们可以将其补充完整 <code class="language-plaintext highlighter-rouge">:.,$!sort -t',' -k2</code> 会对当前行到最后一行的内容按逗号分隔的第二列进行排序。</p> <p><code class="language-plaintext highlighter-rouge">word</code> 是由 <code class="language-plaintext highlighter-rouge">iskeyword</code> 中的字符组成，可以简单认为数字、下划线、字母属于单词的一部分。</p> <p><code class="language-plaintext highlighter-rouge">WORD</code> 则由非空字符组成。</p> <p><code class="language-plaintext highlighter-rouge">sentence</code> 则是以<code class="language-plaintext highlighter-rouge">.</code> 、<code class="language-plaintext highlighter-rouge">?</code> 和 <code class="language-plaintext highlighter-rouge">!</code> 结尾加上至少一个空白字符的文本块。在 <code class="language-plaintext highlighter-rouge">sentence</code> 的标点和空格之间可以有多个 <code class="language-plaintext highlighter-rouge">)</code>、<code class="language-plaintext highlighter-rouge">]</code>、<code class="language-plaintext highlighter-rouge">"</code> 和 <code class="language-plaintext highlighter-rouge">`</code>。需要注意的是 <code class="language-plaintext highlighter-rouge">paragraph</code> 和 <code class="language-plaintext highlighter-rouge">section</code> 的边界也是 <code class="language-plaintext highlighter-rouge">sentence</code> 的边界。</p> <p><code class="language-plaintext highlighter-rouge">paragraph</code> 则可以简单地认为是以一个或多个空行作为分隔符的文本块。需要注意的是 <code class="language-plaintext highlighter-rouge">section</code> 的边界也是 <code class="language-plaintext highlighter-rouge">paragraph</code> 的边界。</p> <p><code class="language-plaintext highlighter-rouge">section</code> 则必须以 <code class="language-plaintext highlighter-rouge">sections</code> 中定义的标记作为分隔符，这个概念平时用得不多，在写相关文档的时候可能会用到。</p> <p>下面是一些 <code class="language-plaintext highlighter-rouge">text-objects</code>：</p> <table> <thead> <tr> <th>按键</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">is</code></td> <td><code class="language-plaintext highlighter-rouge">inside sentence</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">as</code></td> <td><code class="language-plaintext highlighter-rouge">around sentence</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ip</code></td> <td><code class="language-plaintext highlighter-rouge">inside paragraph</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ap</code></td> <td><code class="language-plaintext highlighter-rouge">around paragraph</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">it</code></td> <td><code class="language-plaintext highlighter-rouge">inside tag</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">at</code></td> <td><code class="language-plaintext highlighter-rouge">around tag</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ib</code></td> <td><code class="language-plaintext highlighter-rouge">inside block</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ab</code></td> <td><code class="language-plaintext highlighter-rouge">around block</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">iB</code></td> <td><code class="language-plaintext highlighter-rouge">inside Block</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">aB</code></td> <td><code class="language-plaintext highlighter-rouge">around Block</code></td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">tag</code> 指的是成对出现的标签，例如 <code class="language-plaintext highlighter-rouge">&lt;div&gt;...&lt;/div&gt;</code>。<code class="language-plaintext highlighter-rouge">inside tag</code> 会选择标签内的内容，而 <code class="language-plaintext highlighter-rouge">around tag</code> 则会选择包括标签本身在内的内容。在 <code class="language-plaintext highlighter-rouge">HTML</code> 和 <code class="language-plaintext highlighter-rouge">XML</code> 文件中，<code class="language-plaintext highlighter-rouge">it</code> 和 <code class="language-plaintext highlighter-rouge">at</code> 非常有用。</p> <p><code class="language-plaintext highlighter-rouge">block</code> 是指 <code class="language-plaintext highlighter-rouge">()</code> 围成的区域，<code class="language-plaintext highlighter-rouge">Block</code> 则是指 <code class="language-plaintext highlighter-rouge">{}</code> 围成的区域。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">path</code> 变量会控制一些命令的查找路径，默认值为 <code class="language-plaintext highlighter-rouge">.,,</code> 其中的 <code class="language-plaintext highlighter-rouge">.</code> 代表当前文件所在目录，<code class="language-plaintext highlighter-rouge">,</code> 是分隔符，两个逗号一起表示增加一个空路径（当前工作目录）。</p> <p><code class="language-plaintext highlighter-rouge">subffixesadd</code> 变量则会控制一些命令在查找文件时所使用的后缀名列表。其往往会根据打开的文件类型被自动设置。</p> <hr/> <p>可以使用 <code class="language-plaintext highlighter-rouge">:ju</code> 来查看当前窗口的跳转列表，使用 <code class="language-plaintext highlighter-rouge">:cle</code> 可以清空当前窗口的跳转列表。</p> <p>跳转列表里面的每一项记录了一个跳转位置，可以使用 <code class="language-plaintext highlighter-rouge">CTRL-O</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-I</code> 来在跳转列表中向后和向前跳转。需要注意的是 <code class="language-plaintext highlighter-rouge">CTRL-I</code> 和 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 是等价的，这意味着你绑定 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 键为其他功能后将无法使用 <code class="language-plaintext highlighter-rouge">CTRL-I</code> 进行跳转。</p> <hr/> <p>可以使用 <code class="language-plaintext highlighter-rouge">:c</code> 来查看当前文件的修改列表。修改列表记录了每一次对文件的修改位置。<code class="language-plaintext highlighter-rouge">g;</code> 和 <code class="language-plaintext highlighter-rouge">g,</code> 则可以在修改列表中向后和向前跳转。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">d</code> 进行删除时会将删除的内容放入匿名寄存器中，如果想要在删除时不放入任何寄存器，则可以使用 <code class="language-plaintext highlighter-rouge">"_d</code> 来进行删除。</p> <p>我们有时候在使用 <code class="language-plaintext highlighter-rouge">p</code> 的时候可能会发现匿名寄存器中的内容已经被覆盖了，这个时候我们可以使用 <code class="language-plaintext highlighter-rouge">"0p</code> 来粘贴最近一次使用 <code class="language-plaintext highlighter-rouge">y</code> 进行复制的内容。<code class="language-plaintext highlighter-rouge">0</code> 寄存器专门用于保存最近一次复制的内容。</p> <p>下面给出一些寄存器的说明：</p> <table> <thead> <tr> <th>寄存器</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">%</code></td> <td>当前文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">#</code></td> <td>轮换文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">.</code></td> <td>上次插入的文本</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:</code></td> <td>上次命令行模式下的命令</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">/</code></td> <td>上次搜索的模式</td> </tr> </tbody> </table> <p>字母寄存器是不区分大小写的，我们只能使用小写字母来操作它们，当我们使用大写字母时则表示将内容追加到对应的小写字母寄存器中。比如我们使用 <code class="language-plaintext highlighter-rouge">qa</code> 给寄存器 <code class="language-plaintext highlighter-rouge">a</code> 录制一个宏，然后使用 <code class="language-plaintext highlighter-rouge">qA</code> 则会将后续录制的内容追加到寄存器 <code class="language-plaintext highlighter-rouge">a</code> 中。</p> <hr/> <p>可视模式使用 <code class="language-plaintext highlighter-rouge">p</code> 实际上会将选中的内容替换掉并将其放入匿名寄存器中，也正是因为这个特性我们可以使用如下的步骤来交换两段内容：</p> <ol> <li>选择第一段内容并使用 <code class="language-plaintext highlighter-rouge">d</code> 删除，使用 <code class="language-plaintext highlighter-rouge">mm</code> 来创建一个标记 <code class="language-plaintext highlighter-rouge">m</code> 记录删除位置</li> <li>选择第二段内容并使用 <code class="language-plaintext highlighter-rouge">p</code> 进行粘贴</li> <li>使用 <code class="language-plaintext highlighter-rouge">`m</code> 跳转到标记 <code class="language-plaintext highlighter-rouge">m</code> 处并使用 <code class="language-plaintext highlighter-rouge">p</code> 进行粘贴</li> </ol> <p>在可视模式中使用 <code class="language-plaintext highlighter-rouge">P</code> 则不会将选中的内容放入匿名寄存器中。不过这一点只对匿名寄存器有用，对命名寄存器不起作用。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">:vimgrep</code> 命令可以用来将所有的匹配项放入到 <code class="language-plaintext highlighter-rouge">quickfix</code> 列表中，例如 <code class="language-plaintext highlighter-rouge">:vimgrep /pattern/ **/*.js</code> 会在当前工作目录及其子目录下的所有 <code class="language-plaintext highlighter-rouge">js</code> 文件中搜索 <code class="language-plaintext highlighter-rouge">pattern</code> 并将所有的匹配项放入到 <code class="language-plaintext highlighter-rouge">quickfix</code> 列表中。使用 <code class="language-plaintext highlighter-rouge">:copen</code> 可以打开 <code class="language-plaintext highlighter-rouge">quickfix</code> 窗口查看所有的匹配项，使用 <code class="language-plaintext highlighter-rouge">:cnext</code> 和 <code class="language-plaintext highlighter-rouge">:cprev</code> 可以在匹配项之间进行跳转。</p> <hr/> <p>在使用 <code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">P</code> 的时候会将指针放置到拷贝内容的开头，而使用 <code class="language-plaintext highlighter-rouge">gp</code> 和 <code class="language-plaintext highlighter-rouge">gP</code> 可以将指针放置到拷贝内容的结尾。</p> <hr/> <p>我们有时候可能会需要频繁地在多行内依次使用 <code class="language-plaintext highlighter-rouge">;.</code>，我们可以按照以下的步骤来实现：</p> <ol> <li>通过 <code class="language-plaintext highlighter-rouge">qq;.q</code> 来录制一个宏到寄存器 <code class="language-plaintext highlighter-rouge">q</code> 中；</li> <li>在可视模型下选择需要执行的行；</li> <li>使用 <code class="language-plaintext highlighter-rouge">:normal @99q</code> 来对选中的每一行执行多次宏命令。</li> </ol> <p>当我们想要对一个宏进行修改的时候，我们可以在插入模式下通过 <code class="language-plaintext highlighter-rouge">CTRL-R_{reg}</code> 先读取出宏的内容到当前的位置进行修改，修改完成后我们可以直接使用 <code class="language-plaintext highlighter-rouge">"{reg}D</code> 来将修改后的内容重新保存到寄存器中。</p> <p>实际上宏里面存储的就是一个字符串，我们当然可以使用内置的函数对其进行修改，例如：</p> <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">let</span> @<span class="k">q</span> <span class="p">=</span> <span class="nb">substitute</span><span class="p">(</span>@<span class="k">q</span><span class="p">,</span> <span class="s1">';'</span><span class="p">,</span> <span class="s1">','</span><span class="p">,</span><span class="s1">'g'</span><span class="p">)</span>
</code></pre></div></div> <p>会将寄存器 <code class="language-plaintext highlighter-rouge">q</code> 中的所有分号替换成逗号。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">nvim -u NONE -N</code> 表示以不加载任何配置文件且设置 <code class="language-plaintext highlighter-rouge">nocompatible</code> 的方式启动。</p> <hr/> <p>即使我们设置了 <code class="language-plaintext highlighter-rouge">ignorecase</code> 和 <code class="language-plaintext highlighter-rouge">smartcase</code> 选项为特定的值，我们在搜索的时候还是可以使用 <code class="language-plaintext highlighter-rouge">\c</code> 和 <code class="language-plaintext highlighter-rouge">\C</code> 来忽略或者区分大小写，例如 <code class="language-plaintext highlighter-rouge">/pattern\C</code> 会区分大小写地搜索 <code class="language-plaintext highlighter-rouge">pattern</code>，而 <code class="language-plaintext highlighter-rouge">/pattern\c</code> 则会忽略大小写地搜索 <code class="language-plaintext highlighter-rouge">pattern</code>。<code class="language-plaintext highlighter-rouge">\c</code> 和 <code class="language-plaintext highlighter-rouge">\C</code> 可以出现在搜索模式的任意位置，也就是说我们输入到一半的时候突然想要切换大小写敏感性也是可以的。</p> <hr/> <p>搜索模式可以分为四种类型：</p> <ul> <li><code class="language-plaintext highlighter-rouge">magic</code>：这是开了 <code class="language-plaintext highlighter-rouge">magic</code>（默认开启）选项后的默认模式，也可以使用 <code class="language-plaintext highlighter-rouge">\m</code> 开头强制开启，<code class="language-plaintext highlighter-rouge">.^$*~\/</code> 有特殊含义；</li> <li><code class="language-plaintext highlighter-rouge">nomagic</code>：关闭 <code class="language-plaintext highlighter-rouge">magic</code> 后的默认模式，可以使用 <code class="language-plaintext highlighter-rouge">\M</code> 开头强制开启，这个模式很少使用，<code class="language-plaintext highlighter-rouge">^$\/</code> 有特殊含义；</li> <li><code class="language-plaintext highlighter-rouge">verymagic</code>：这是使用 <code class="language-plaintext highlighter-rouge">\v</code> 开头的模式，除了 <code class="language-plaintext highlighter-rouge">a-zA-Z0-9_</code> 之外的所有字符都有特殊含义；</li> <li><code class="language-plaintext highlighter-rouge">verynomagic</code>：这是使用 <code class="language-plaintext highlighter-rouge">\V</code> 开头的模式，只有 <code class="language-plaintext highlighter-rouge">\/</code> 有特殊含义。</li> </ul> <hr/> <p>在使用 <code class="language-plaintext highlighter-rouge">y</code>、<code class="language-plaintext highlighter-rouge">d</code> 和 <code class="language-plaintext highlighter-rouge">c</code> 进行相关操作的时候，内容往往会被放入匿名寄存器中，我们可以通过设置 <code class="language-plaintext highlighter-rouge">set clipboard+=unnamedplus</code> 来让这些操作将内容放入系统剪切板中。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-A</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-@</code>（这个和 <code class="language-plaintext highlighter-rouge">CTRL-&lt;Space&gt;</code> 是等价的）可以在插入模式下插入上一次在插入模式下插入的内容，其中 <code class="language-plaintext highlighter-rouge">CTRL-@</code> 在插入后会回到普通模式，而 <code class="language-plaintext highlighter-rouge">CTRL-A</code> 则会继续停留在插入模式。我们也可以使用 <code class="language-plaintext highlighter-rouge">CTRL-R_.</code> 来实现相同的功能。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">CTRL-D</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-T</code> 在插入模式下可以减少或增加当前行的缩进。</p> <p><code class="language-plaintext highlighter-rouge">0 CTRL-D</code> 和 <code class="language-plaintext highlighter-rouge">^ CTRL-D</code> 都可以删除当前行所有的缩进，不同的是 <code class="language-plaintext highlighter-rouge">^ CTRL-D</code> 会在按下回车的时候继承删除的缩进。</p>]]></content><author><name></name></author><category term="Vim/Neovim"/><category term="中文文章"/><summary type="html"><![CDATA[本文介绍自己学习到的一些好用的 nvim 技巧，其中大部分可以在 vim 中使用。]]></summary></entry><entry><title type="html">奇怪的知识增加了</title><link href="https://kaiser-yang.github.io/blog/2026/uncommon-knowledge/" rel="alternate" type="text/html" title="奇怪的知识增加了"/><published>2026-01-25T05:39:41+00:00</published><updated>2026-01-25T05:39:41+00:00</updated><id>https://kaiser-yang.github.io/blog/2026/uncommon-knowledge</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2026/uncommon-knowledge/"><![CDATA[<h2 id="汉语字词">汉语字词</h2> <p>氤氲（yīn yūn）</p> <p>释义：</p> <ul> <li>原指烟云、雾气等弥漫融合、混沌不清的样子（侧重“气”的流动与交织）；</li> <li>引申为气氛、气息等浓郁而弥漫的状态（如“诗意氤氲”“茶香氤氲”）。</li> </ul> <p>例句：</p> <ul> <li>清晨的西湖被薄雾氤氲着，远处的雷峰塔只露出半截塔尖，像浸在牛奶里的墨痕。</li> </ul> <hr/> <p>罹患（lí huàn）</p> <p>释义：</p> <ul> <li>书面语，指患病（多指患上比较严重或特定的疾病）。</li> </ul> <p>例句：</p> <ul> <li>这位老人晚年罹患阿尔茨海默症，记忆逐渐模糊，却始终记得年轻时教书的校园。</li> </ul> <hr/> <p>英亩（yīng mǔ）</p> <p>释义：</p> <ul> <li>英制面积单位，1英亩约等于4046.86平方米（或约6.07市亩），常用于计量土地面积。</li> </ul> <p>例句：</p> <ul> <li>这片家族农场拥有80英亩的麦田，每到丰收季便是一片金黄的海洋。</li> </ul> <hr/> <p>英里（yīng lǐ）</p> <p>释义：</p> <ul> <li>英制长度单位，1英里约等于1609.344米（或约1.609公里），常用于英美等国计量距离。</li> </ul> <p>例句：</p> <ul> <li>从伦敦市中心到希思罗机场的直线距离约为15英里，开车通常需要40分钟左右。</li> </ul> <hr/> <p>英尺（yīng chǐ）</p> <p>释义：</p> <ul> <li>英制长度单位，1英尺约等于0.3048米（或30.48厘米），常用于英美等国计量身高、家具尺寸等。</li> </ul> <p>例句：</p> <ul> <li>他的身高约为6英尺，换算成公制大约是183厘米。</li> </ul> <hr/> <p>英寸（yīng cùn）</p> <p>释义：</p> <ul> <li>英制长度单位，1英寸等于2.54厘米（常用于屏幕尺寸、管材直径）。</li> </ul> <p>例句：</p> <ul> <li>这款平板电脑屏幕为11英寸，便携性与视觉体验兼顾。</li> </ul> <hr/> <p>念兹在兹（niàn zī zài zī）</p> <p>释义：</p> <ul> <li>指念念不忘某件事，形容时刻牵挂于心（出自《尚书·大禹谟》“念兹在兹，释兹在兹”）。</li> </ul> <p>例句：</p> <ul> <li>海外游子念兹在兹的，始终是故乡老屋前那棵年年开花的桂树。</li> </ul> <hr/> <p>付梓（fù zǐ）</p> <p>释义：</p> <ul> <li>书面语，指把稿件交付印刷（“梓”原指印刷用的木版）。</li> </ul> <p>例句：</p> <ul> <li>这部凝聚作者十年心血的学术专著终于付梓，即将与读者见面。</li> </ul> <hr/> <p>迩来（ěr lái）</p> <p>释义：</p> <ul> <li>书面语，指近来、最近（“迩”意为近）。</li> </ul> <p>例句：</p> <ul> <li>迩来天气反常，昨日还暖阳高照，今日便飘起了小雪。</li> </ul> <hr/> <p>顾盼自雄（gù pàn zì xióng）</p> <p>释义：</p> <ul> <li>形容得意忘形、自以为了不起的样子（“顾盼”指左右张望）。</li> </ul> <p>例句：</p> <ul> <li>他刚升任部门主管便顾盼自雄，对老同事也呼来喝去，渐渐失了人心。</li> </ul> <hr/> <p>毋宁（wú nìng）</p> <p>释义：</p> <ul> <li>连词，表示选择关系，相当于“宁可、不如”。</li> </ul> <p>例句：</p> <ul> <li>与其在无效社交中消耗精力，毋宁独处读书充实自己。</li> </ul> <hr/> <p>巨细靡遗（jù xì mí yí）</p> <p>释义：</p> <ul> <li>指大小事情都详尽无遗，没有遗漏（“靡遗”即无遗漏）。</li> </ul> <p>例句：</p> <ul> <li>这份调查报告巨细靡遗，连现场每片落叶的位置都标注清晰。</li> </ul> <hr/> <p>稔（rěn）</p> <p>释义：</p> <ul> <li>庄稼成熟；</li> <li>熟悉（如“稔知”“素稔”）；</li> <li>年（如“丰稔”“三稔”）。</li> </ul> <p>例句：</p> <ul> <li>这片土地肥沃，稻子每年都能稔收，养活了村里几代人。（义项①）</li> <li>他在此地生活半生，对乡间小路稔熟得如同掌纹。（义项②）</li> </ul> <hr/> <p>囹圄（líng yǔ）</p> <p>释义：</p> <ul> <li>书面语，指监狱。</li> </ul> <p>例句：</p> <ul> <li>他曾因冤案身陷囹圄，平反后更珍惜自由的可贵。</li> </ul> <hr/> <p>商榷（shāng què）</p> <p>释义：</p> <ul> <li>书面语，指商量、讨论（多用于正式场合）。</li> </ul> <p>例句：</p> <ul> <li>这个方案涉及多方利益，还需进一步商榷细节。</li> </ul> <hr/> <p>戒荤茹素（jiè hūn rú sù）</p> <p>释义：</p> <ul> <li>戒除荤腥食物，改吃素食（多为健康、宗教或养生目的）。</li> </ul> <p>例句：</p> <ul> <li>为调理肠胃，他决定戒荤茹素三个月，只吃五谷蔬果。</li> </ul> <hr/> <p>不落窠臼（bù luò kē jiù）</p> <p>释义：</p> <ul> <li>比喻文章、艺术等有独创风格，不落俗套（“窠臼”指现成的格式、套路）。</li> </ul> <p>例句：</p> <ul> <li>这部话剧的叙事手法不落窠臼，用倒叙穿插时空，观众耳目一新。</li> </ul> <hr/> <p>潺湲（chán yuán）</p> <p>释义：</p> <ul> <li>水缓慢流动的样子（侧重动态舒缓）；</li> <li>书面语，形容流泪不止（表悲伤/思念）；</li> </ul> <p>例句：</p> <ul> <li>山涧溪水潺湲，如鸣佩环，洗去旅人一身疲惫。</li> <li>故园遥望隔重云，别后离情泪潺湲。</li> </ul> <hr/> <p>凛冽（lǐn liè）</p> <p>释义：</p> <ul> <li>寒冷刺骨（多形容风、气温）。</li> </ul> <p>例句：</p> <ul> <li>北风凛冽的冬夜，街灯在雪幕里晕开昏黄的光圈。</li> </ul> <hr/> <p>冷冽（lěng liè）</p> <p>释义：</p> <ul> <li>寒冷刺骨（同“凛冽”，多形容空气、水等）。</li> </ul> <p>例句：</p> <ul> <li>冷冽的山泉从石缝涌出，捧一口顿觉神清气爽。</li> </ul> <hr/> <p>泠洌（líng liè）</p> <p>释义：</p> <ul> <li>同“冷冽”，形容清凉、寒冷（书面语色彩更浓）。</li> </ul> <p>例句：</p> <ul> <li>深山古寺的井水泠洌甘甜，僧人晨起必饮一瓢。</li> </ul> <hr/> <p>掴（guó）</p> <p>释义：</p> <ul> <li>动词，用手掌打（口语中常说“掴耳光”）。</li> </ul> <p>例句：</p> <ul> <li>他被这突如其来的真相震惊得忘了反驳，只觉脸上重重一掴。</li> </ul> <hr/> <p>舌灿莲花（shé càn lián huā）</p> <p>释义：</p> <ul> <li>形容人口才好，言辞生动精彩。</li> </ul> <p>例句：</p> <ul> <li>辩论赛上，她舌灿莲花，引经据典驳得对方哑口无言。</li> </ul> <hr/> <p>不分轩轾（bù fēn xuān zhì）</p> <p>释义：</p> <ul> <li>不分高下、优劣（“轩轾”指车前高后低为轩，前低后高为轾，喻高低）。</li> </ul> <p>例句：</p> <ul> <li>两位画家的作品风格迥异，艺术价值却不分轩轾。</li> </ul> <hr/> <p>杪（miǎo）</p> <p>释义：</p> <ul> <li>末端，末尾。</li> </ul> <p>例句：</p> <ul> <li>夏杪的荷塘褪去繁华，只剩残叶在风中诉说秋意。</li> </ul> <hr/> <p>丘阜（qiū fù）</p> <p>释义：</p> <ul> <li>低矮的小土山（“阜”指土山）。</li> </ul> <p>例句：</p> <ul> <li>丘陵地带散布着零星丘阜，登高可眺望整片稻田。</li> </ul> <hr/> <p>隈隩（wēi yù）</p> <p>释义：</p> <ul> <li>书面语，指山水弯曲隐蔽之处（“隈”：角落；“隩”：水岸内曲处）。</li> </ul> <p>例句：</p> <ul> <li>渔舟泊于隈隩，船娘哼着吴歌，惊起几只白鹭。</li> </ul> <hr/> <p>踽踽独行（jǔ jǔ dú xíng）</p> <p>释义：</p> <ul> <li>形容独自走路孤零零的样子（“踽踽”：孤独的样子）。</li> </ul> <p>例句：</p> <ul> <li>暮色中，老人踽踽独行在老街上，背影被夕阳拉得很长。</li> </ul> <hr/> <p>薄馔（bó zhuàn）</p> <p>释义：</p> <ul> <li>书面语，指简单粗陋的饭食（“馔”：饭食）。</li> </ul> <p>例句：</p> <ul> <li>山寺僧人以薄馔相待，一碗青菜豆腐汤却暖透客心。</li> </ul> <hr/> <p>大书特书（dà shū tè shū）</p> <p>释义：</p> <ul> <li>指对重要的事情着重书写或宣扬。</li> </ul> <p>例句：</p> <ul> <li>抗疫英雄的逆行壮举，值得历史大书特书。</li> </ul> <hr/> <p>形而上（xíng ér shàng）</p> <p>释义：</p> <ul> <li>出自《易经·系辞》”形而上者谓之道，形而下者谓之器”，指超越有形事物的本体性存在。</li> </ul> <p>例句：</p> <ul> <li>他对宇宙起源的思考偏向形而上学，试图探寻存在的终极意义。</li> </ul> <hr/> <p>箭镞（jiàn zú）</p> <p>释义：</p> <ul> <li>箭头（金属或骨质制成的尖锐部分）。</li> </ul> <p>例句：</p> <ul> <li>考古队在遗址中发现数枚青铜箭镞，印证了古战场的存在。</li> </ul> <hr/> <p>岿然不动（kuī rán bù dòng）</p> <p>释义：</p> <ul> <li>形容高大稳固，毫不动摇（“岿然”：高峻独立的样子）。</li> </ul> <p>例句：</p> <ul> <li>面对狂风暴雨，那座千年古塔依然岿然不动。</li> </ul> <hr/> <p>筚路蓝缕，以启山林（bì lù lán lǚ yǐ qǐ shān lín）</p> <p>释义：</p> <ul> <li>筚路：柴车；蓝缕：破衣服。驾着简陋的车，穿着破烂的衣服去开辟山林。形容创业的艰苦。</li> </ul> <hr/> <p>淅沥（xī lì）</p> <p>释义：</p> <ul> <li>象声词，形容轻微的风雨声（如小雨、落叶声）。</li> </ul> <p>例句：</p> <ul> <li>窗外细雨淅沥，屋内茶香袅袅，正是读书好时节。</li> </ul> <hr/> <p>阙如（quē rú）</p> <p>释义：</p> <ul> <li>“阙”本义指皇宫门前两边供瞭望的楼，后引申为空缺、欠缺。该词出自《论语·子路篇第十三》“君子于其所不知，盖阙如也”，指对未知事物应存疑不书；后《后汉书·孝和皇帝纪》“礼仪制度阙如也”用以描述制度缺失状态。</li> </ul> <hr/> <p>波谲云诡（bō jué yún guǐ）</p> <p>释义：</p> <ul> <li>形容事态变化多端，难以预料（“波谲”“云诡”均指变幻莫测）。</li> </ul> <p>例句：</p> <ul> <li>国际局势波谲云诡，外交官需时刻保持敏锐判断。</li> </ul> <hr/> <p>扬基人（yáng jī rén）</p> <p>释义：</p> <ul> <li>对美国人的俗称（“扬基”音译自英语“Yankee”）。</li> </ul> <p>例句：</p> <ul> <li>这位扬基人画家痴迷中国水墨，作品融合了东西方技法。</li> </ul> <hr/> <p>不无裨益（bù wú bì yì）</p> <p>释义：</p> <ul> <li>指有一定的益处，并非毫无好处（“不无”表示“不是没有”，“裨益”指益处）。</li> </ul> <p>例句：</p> <ul> <li>每天坚持晨读半小时，对培养语感和积累词汇不无裨益。</li> </ul> <h2 id="主义">主义</h2> <p>超验主义</p> <p>超验主义可以归纳为如下三个假设：</p> <ol> <li>词语是自然现象的表征； <ul> <li>这句话否定了语言的任意性，认为词语不是人为创造的符号，而是对自然现象的直接映射。超验主义者相信，语言的根源在自然之中，一个词语的意义，源于它所对应的自然事物的特质，比如“流水”一词，不只是指代水的流动形态，更承载着自然本身的动态属性。</li> </ul> </li> <li>特定的自然现象是特定的灵性现象的表征； <ul> <li>这是超验主义的核心逻辑，自然现象并非孤立的物质存在，而是灵性力量的外在显现。特定的自然事物对应特定的精神内涵，比如“橡树”的苍劲挺拔，是坚韧、不朽的灵性特质的具象化；“落日”的余晖，是生命圆满、归宿感的灵性象征，人可以通过观察自然现象，感知到背后的精神意义。</li> </ul> </li> <li>自然本身是灵性的表征。 <ul> <li>这是前两个假设的升华，将自然整体与终极灵性挂钩。超验主义眼中的自然不是零散事物的集合，而是终极灵性（可理解为“超灵” Oversoul）的载体和外在表现，整个自然世界就是一部灵性的“大书”，万物同源、同归于超灵，人融入自然，就是与终极灵性的连通。</li> </ul> </li> </ol> <p>超验主义这三个假设层层递进，构建了自然—语言—灵性三者的表征关联体系，核心是打破物质与精神的二元对立，强调万物背后共通的灵性本质。</p> <p>简单来说，这三句话的逻辑链条是：语言反映自然，自然反映灵性，自然整体就是灵性的化身，最终指向人可以通过自然与自身的灵性对话，实现精神的超越。</p> <h2 id="建筑风格">建筑风格</h2> <p>哥特式</p> <p>哥特式（Gothic）是一种起源于11世纪下半叶的文化艺术风格，内涵丰富，充斥神秘、恐怖、浪漫、阴郁等元素，常见于建筑、文学、音乐等不同领域 。以下是关于它的详细介绍 ：</p> <ul> <li>名称由来：原指代哥特人，是西欧日耳曼部族。文艺复兴时期，意大利理论家瓦萨里在其著作《名人传》中首次用“哥特”一词抨击尖拱式建筑风格，意为“野蛮、粗暴”。</li> <li>建筑风格：11世纪下半叶起源于法国，13-15世纪流行于欧洲。其基本构件是尖拱和肋架拱顶，整体风格高耸削瘦，常通过巨大的穹顶和支柱、精美的绘画、花窗和雕刻来营造神秘浓厚的宗教氛围。代表建筑有巴黎圣母院、科隆大教堂等。</li> <li>文学风格：1764年，贺拉斯·瓦尔浦尔的小说《奥特朗托城堡》标志着哥特小说的诞生。其内容大多充斥着诡异、神秘以及怪诞色彩，标志性元素包括恐怖、超自然、死亡、巫术、古堡等，偏爱黑暗凄凉的场景。代表作品有玛丽·雪莱的《弗兰肯斯坦》、爱伦·坡的《厄舍府的倒塌》等。</li> <li>音乐风格：20世纪80年代初，英国开启哥特文化运动，带动了哥特式音乐的发展。此类音乐从哥特式文学中的抒情诗、死亡主题等吸取灵感，通过舒缓而强劲的音效营造出不祥与悲伤之感，表现出人性中黑暗、阴沉等倾向。代表乐队有包豪斯乐队、Marilyn Manson乐队等。</li> <li>其他领域：在绘画、雕塑、影视、服饰等领域也有体现。哥特式绘画多为彩色玻璃镶嵌画等；哥特式服饰通常以黑色为主，搭配惨白的妆容和特色饰品，常见元素有十字架、骷髅等。</li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="中文文章"/><summary type="html"><![CDATA[一些不太常用的知识。]]></summary></entry><entry><title type="html">文学摘抄</title><link href="https://kaiser-yang.github.io/blog/2025/literature/" rel="alternate" type="text/html" title="文学摘抄"/><published>2025-12-11T06:18:12+00:00</published><updated>2025-12-11T06:18:12+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/literature</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/literature/"><![CDATA[<h2 id="诗词歌赋">诗词歌赋</h2> <blockquote> <p>洛阳春<br/> 岑参<br/> 人到洛阳花似锦，偏我来时不逢春。<br/> 谁道三冬无春色，冰山高处万里银。</p> </blockquote> <hr/> <blockquote> <p>离思五首·其四<br/> 元稹<br/> 曾经沧海难为水，除却巫山不是云。<br/> 取次花丛懒回顾，半缘修道半缘君。</p> </blockquote> <hr/> <blockquote> <p>金缕衣<br/> 佚名<br/> 劝君莫惜金缕衣，劝君惜取少年时。<br/> 花开堪折直须折，莫待无花空折枝。</p> </blockquote> <hr/> <blockquote> <p>梅岭三章·其一<br/> 陈毅<br/> 断头今日意如何？创业艰难百战多。<br/> 此去泉台招旧部，旌旗十万斩阎罗。</p> </blockquote> <hr/> <blockquote> <p>观书有感二首·其一<br/> 朱熹<br/> 半亩方塘一鉴开，天光云影共徘徊。<br/> 问渠那得清如许？为有源头活水来。</p> </blockquote> <hr/> <blockquote> <p>竹枝词九首·其二<br/> 刘禹锡<br/> 山桃红花满上头，蜀江春水拍山流。<br/> 花红易衰似郎意，水流无限似侬愁。</p> </blockquote> <hr/> <blockquote> <p>南乡子·登京口北固亭有怀<br/> 辛弃疾<br/> 何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。<br/> 年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</p> </blockquote> <hr/> <blockquote> <p>满江红·和郭沫若同志<br/> 毛泽东<br/> 小小寰球，有几个苍蝇碰壁。嗡嗡叫，几声凄厉，几声抽泣。蚂蚁缘槐夸大国，蚍蜉撼树谈何易。正西风落叶下长安，飞鸣镝。<br/> 多少事，从来急；天地转，光阴迫。一万年太久，只争朝夕。四海翻腾云水怒，五洲震荡风雷激。要扫除一切害人虫，全无敌。</p> </blockquote> <hr/> <blockquote> <p>清平乐·六盘山<br/> 毛泽东<br/> 天高云淡，望断南飞雁。不到长城非好汉，屈指行程二万。<br/> 六盘山上高峰，红旗漫卷西风。今日长缨在手，何时缚住苍龙？</p> </blockquote> <h2 id="历史">历史</h2> <blockquote> <p>忠言逆耳利于行，毒药苦口利于病。<br/> ——《史记》</p> </blockquote> <hr/> <blockquote> <p>智者千虑，必有一失；愚者千虑，必有一得。<br/> ——《史记》</p> </blockquote> <hr/> <blockquote> <p>今释弗取，后必悔之。<br/> ——《史记》</p> </blockquote> <hr/> <blockquote> <p>王子比干者，亦纣之亲戚也。见箕子谏不听而为奴，则曰：“君有过而不以死争，则百姓何辜！”乃直言谏纣。纣怒曰：“吾闻圣人之心有七窍，信有诸乎？”乃遂杀王子比干，刳视其心。<br/> ——《史记》</p> </blockquote> <hr/> <blockquote> <p>举大事不细谨，盛德不辞让，而公不为若更言。<br/> ——《史记》</p> </blockquote> <hr/> <blockquote> <p>纣作炮烙之刑。王子比干曰：“主暴不谏，非忠也；畏死不言，非勇也。见过即谏，不用即死，忠之至也。”遂谏，三日不去朝，纣囚杀之。诗曰：“昊天大怃，予慎无辜！”<br/> ——《韩诗外传》</p> </blockquote> <hr/> <blockquote> <p>季康子问政于孔子曰：“如杀无道以就有道，何如？”<br/> 孔子对曰：“子为政，焉用杀？子欲善而民善矣。君子之德风，小人之德草，草上之风必偃。”<br/> ——《论语》</p> </blockquote> <hr/> <blockquote> <p>丘也闻有国有家者，不患寡而患不均，不患贫而患不安。盖均无贫，和无寡，安无倾。夫如是，故远人不服，则修文德以来之。既来之，则安之。<br/> ——《论语》</p> </blockquote> <h2 id="文学">文学</h2> <blockquote> <p>侯非侯，王非王，千乘万骑归邙山！狡兔死，良弓藏；我之后，君复伤！一曲《广陵散》，再奏待芸娘。<br/> ——《大明王朝1566》</p> </blockquote>]]></content><author><name></name></author><category term="Potpourri"/><category term="中文文章"/><category term="Literature"/><summary type="html"><![CDATA[本文收集了一些我喜欢的文学作品中的摘抄。]]></summary></entry><entry><title type="html">Go 学习笔记</title><link href="https://kaiser-yang.github.io/blog/2025/go-learning/" rel="alternate" type="text/html" title="Go 学习笔记"/><published>2025-12-09T11:44:38+00:00</published><updated>2025-12-09T11:44:38+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/go-learning</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/go-learning/"><![CDATA[<p>使用 <code class="language-plaintext highlighter-rouge">fmt.Printf</code> 时可能涉及到相关的格式化动词，以下是一些常用的格式化动词及其含义：</p> <table> <thead> <tr> <th>动词</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td>%v</td> <td>默认格式</td> </tr> <tr> <td>%+v</td> <td>带字段名的结构体格式</td> </tr> <tr> <td>%#v</td> <td>Go 语法表示的值</td> </tr> <tr> <td>%T</td> <td>类型信息</td> </tr> <tr> <td>%t</td> <td>布尔值</td> </tr> <tr> <td>%c</td> <td>对应的 Unicode 字符</td> </tr> <tr> <td>%U</td> <td>Unicode 格式的字符</td> </tr> <tr> <td>%%</td> <td>字符 ‘%’</td> </tr> <tr> <td>%s</td> <td>字符串</td> </tr> <tr> <td>%q</td> <td>带双引号的字符串</td> </tr> <tr> <td>%p</td> <td>指针地址</td> </tr> <tr> <td>%b</td> <td>二进制</td> </tr> <tr> <td>%o/%O</td> <td>八进制（是否带 <code class="language-plaintext highlighter-rouge">0o</code> 前缀）</td> </tr> <tr> <td>%x/%X</td> <td>十六进制（大小写）</td> </tr> <tr> <td>%d/%i</td> <td>十进制整数</td> </tr> <tr> <td>%f</td> <td>十进制浮点数</td> </tr> <tr> <td>%g</td> <td>最简洁的十进制或科学计数法</td> </tr> <tr> <td>%e/%E</td> <td>科学计数法（大小写）</td> </tr> <tr> <td>%w</td> <td>用于错误包装</td> </tr> </tbody> </table> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 中的语句后面通常都不需要使用 <code class="language-plaintext highlighter-rouge">;</code> 来结尾， 并且在条件分支和循环分支中也不需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来包裹条件表达式。 除此之外，在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的条件分支中可以添加一条初始化语句，这条语句会在条件判断之前执行， 并且其作用域仅限于该条件分支内。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">doSomething</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="c">// 处理错误</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c">// 正常处理</span>
<span class="p">}</span>
<span class="c">// err 在这里不可见</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">switch</code> 语句会自动在每个 <code class="language-plaintext highlighter-rouge">case</code> 分支后面添加一个隐式的 <code class="language-plaintext highlighter-rouge">break</code>， 因此不需要显式地使用 <code class="language-plaintext highlighter-rouge">break</code> 语句来终止分支。 如果想要在某个 <code class="language-plaintext highlighter-rouge">case</code> 分支中继续执行下一个分支，可以使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 关键字。</p> <p><code class="language-plaintext highlighter-rouge">fallthrough</code> 的作用是强制执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支的代码，而不进行条件判断。 如果想在执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 后继续执行下下个 <code class="language-plaintext highlighter-rouge">case</code>， 则需要在下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支中再次使用 <code class="language-plaintext highlighter-rouge">fallthrough</code>。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">type</code> 关键字来定义新类型或者给已有的类型取别名。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span>
  <span class="n">MyInt</span> <span class="kt">int</span>              <span class="c">// 定义新类型 MyInt，底层类型为 int</span>
  <span class="n">YourInt</span> <span class="o">=</span> <span class="kt">int</span>          <span class="c">// 给 int 类型取别名 YourInt</span>
<span class="p">)</span>
</code></pre></div></div> <p>别名类型和原类型是完全相同的类型，可以互相赋值和转换。 而新类型和原类型是不同的类型，往往需要进行显式的转换。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">var</code>、<code class="language-plaintext highlighter-rouge">const</code>、<code class="language-plaintext highlighter-rouge">type</code>、<code class="language-plaintext highlighter-rouge">import</code> 等关键字都可以使用块语法来声明多个变量、常量或类型。 块语法使用 <code class="language-plaintext highlighter-rouge">()</code> 将多个声明包裹在一起。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
  <span class="n">a</span> <span class="kt">int</span>
  <span class="n">b</span> <span class="kt">string</span>
  <span class="n">c</span> <span class="kt">bool</span>
<span class="p">)</span>
</code></pre></div></div> <p>这种方式可以使代码更加整洁，尤其是在需要声明多个相关变量时。</p> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中，后续的变量会重复使用前一个变量的表达式，除非显式地为其赋值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="m">1</span>
  <span class="n">B</span>        <span class="c">// B 的值为 1</span>
  <span class="n">C</span> <span class="o">=</span> <span class="m">2</span>
  <span class="n">D</span>        <span class="c">// D 的值为 2</span>
<span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中可以使用 <code class="language-plaintext highlighter-rouge">iota</code>，它的值是当前变量所在的偏移位置（从0开始计算）。 每当遇到一个新的 <code class="language-plaintext highlighter-rouge">const</code> 块时，<code class="language-plaintext highlighter-rouge">iota</code> 会被重置为0，并且在每一行中递增1。 也可以在 <code class="language-plaintext highlighter-rouge">const</code> 块中使用 <code class="language-plaintext highlighter-rouge">_</code> 来忽略某些值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="no">iota</span>           <span class="c">// A 的值为 0</span>
  <span class="n">B</span>                  <span class="c">// B 的值为 1</span>
  <span class="n">_</span>                  <span class="c">// 忽略该值，iota 递增到 2</span>
  <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="no">iota</span><span class="p">,</span> <span class="no">iota</span>  <span class="c">// C 和 D 的值均为 3</span>
<span class="p">)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以定义 <code class="language-plaintext highlighter-rouge">label</code>，<code class="language-plaintext highlighter-rouge">label</code> 可以用来进行 <code class="language-plaintext highlighter-rouge">continue</code> 或者 <code class="language-plaintext highlighter-rouge">break</code> 操作， 从而跳出多层循环或者指定跳出某个循环。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OuterLoop</span><span class="o">:</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="n">OuterLoop</span> <span class="c">// 跳出当前内层循环，进入下一次外层循环</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">2</span> <span class="p">{</span>
      <span class="k">break</span> <span class="n">OuterLoop</span> <span class="c">// 跳出外层循环</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i=%d, j=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用有显示名称的返回值， 这样只需要在函数体中对这些返回值进行赋值而不需要显式地使用 <code class="language-plaintext highlighter-rouge">return</code> 语句返回它们。 这样的写法在需要根据条件分支返回多个值时非常有用。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 使用有显示名称的返回值</span>
<span class="k">func</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">quotient</span> <span class="kt">int</span><span class="p">,</span> <span class="n">remainder</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">quotient</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
  <span class="k">return</span> <span class="c">// 直接返回命名的返回值，这里的 return 不能省略</span>
<span class="p">}</span>

<span class="c">// 使用无名称的返回值</span>
<span class="k">func</span> <span class="n">divide2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用变长参数来接收不定数量的参数。 变长参数使用 <code class="language-plaintext highlighter-rouge">t ...T</code> 语法来定义，表示可以传入任意数量的该类型参数。 在函数体内，变长参数会被视为一个切片。 变长参数可以匹配多个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数或者一个类型为 <code class="language-plaintext highlighter-rouge">[]T</code> 的参数，但是不能同时匹配两种形式：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">total</span> <span class="o">:=</span> <span class="m">0</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">result1</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>       <span class="c">// 传入多个 int 参数</span>
  <span class="n">result2</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">}</span><span class="o">...</span><span class="p">)</span> <span class="c">// 传入一个 []int 参数，注意要加上 ...</span>
  <span class="c">// result3 := sum(1, 2, []int{3, 4}...) // 错误，不能同时传入多种形式的参数</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span> <span class="c">// 输出: 10</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span> <span class="c">// 输出: 18</span>
<span class="p">}</span>
</code></pre></div></div> <p>不过上面的规则有个例外：在使用 <code class="language-plaintext highlighter-rouge">append</code> 将一个 <code class="language-plaintext highlighter-rouge">string</code> 变量追加到 <code class="language-plaintext highlighter-rouge">[]byte</code> 切片中的时候是可行的， 编译器会自动将 <code class="language-plaintext highlighter-rouge">string</code> 转换为 <code class="language-plaintext highlighter-rouge">[]byte</code>，然后再进行追加操作：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">"hello"</span><span class="o">...</span><span class="p">)</span> <span class="c">// OK</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">import</code> 进行包的导入，导入时可以给导入的包取别名， 也可以使用 <code class="language-plaintext highlighter-rouge">.</code> 来导入包中的所有标识符。</p> <p>通常而言，在 <code class="language-plaintext highlighter-rouge">Go</code> 导入的包必须要被使用，否则会导致编译错误。 但是可以给包取别名为 <code class="language-plaintext highlighter-rouge">_</code>，这种方式仅执行包的 <code class="language-plaintext highlighter-rouge">init</code> 函数。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
  <span class="n">fmt</span> <span class="s">"fmt"</span>      <span class="c">// 给包取别名 fmt</span>
  <span class="o">.</span> <span class="s">"math"</span>       <span class="c">// 导入包中的所有标识符</span>
  <span class="n">_</span> <span class="s">"net/http"</span>   <span class="c">// 给包取别名 _，仅执行其 init 函数</span>
<span class="p">)</span>
</code></pre></div></div> <p>当两个同名的包（通常指路径中的最后一段相同）导入时就需要使用别名来区分它们。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中有各种字面量可以使用，同时对于数字字面量还支持使用下划线 <code class="language-plaintext highlighter-rouge">_</code> 来分隔数字以提高可读性。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">53</span><span class="n">_700</span>        <span class="c">// 十进制</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">0</span><span class="n">_700</span>         <span class="c">// 0前缀表示八进制</span>
<span class="n">c1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">x_aa_bb_cc</span>
<span class="n">c2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">X_dd_ee_ff</span>  <span class="c">// 0x或0X前缀表示十六进制</span>
<span class="n">d1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">b_1000_0001</span>
<span class="n">d2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">B_1000_0001</span> <span class="c">// 0b或0B前缀表示二进制</span>
<span class="n">e</span> <span class="o">:=</span> <span class="m">.15</span>           <span class="c">// 浮点数，可以省略整数部分的0</span>
<span class="n">f</span> <span class="o">:=</span> <span class="m">82.</span>           <span class="c">// 浮点数，可以省略小数部分的0</span>
<span class="n">g1</span> <span class="o">:=</span> <span class="m">1.5e2</span>        <span class="c">// 科学计数法表示</span>
<span class="n">g2</span> <span class="o">:=</span> <span class="m">1.5E3</span>        <span class="c">// 科学计数法表示</span>
<span class="n">h1</span> <span class="o">:=</span> <span class="m">0x2</span><span class="o">.</span><span class="n">p10</span>      <span class="c">// 十六进制浮点数</span>
<span class="n">h2</span> <span class="o">:=</span> <span class="m">0X1</span><span class="o">.</span><span class="n">Fp0</span>      <span class="c">// 十六进制浮点数</span>

<span class="n">ch1</span> <span class="o">:=</span> <span class="sc">'\u4e2d'</span>     <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch2</span> <span class="o">:=</span> <span class="sc">'\U00004e2d'</span> <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch3</span> <span class="o">:=</span> <span class="sc">'\x27'</span>       <span class="c">// 字符字面量，表示单引号字符 `'`</span>
<span class="n">ch4</span> <span class="o">:=</span> <span class="sc">'\047'</span>       <span class="c">// 字符字面量，八进制表示的字符 `'`</span>

<span class="n">s1</span> <span class="o">:=</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span>                <span class="c">// 字符串字面量，包含转义字符</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\u4e2d\u6587</span><span class="s">"</span>         <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\U00004e2d\U00006587</span><span class="s">"</span> <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s4</span> <span class="o">:=</span> <span class="s">`This is a raw string.
This is the second line.
This is the third line.
\n will not be interpreted.`</span> <span class="c">// 原始字符串字面量</span>

<span class="n">arr1</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr2</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">5</span><span class="o">:</span> <span class="m">5</span> <span class="p">}</span> <span class="c">// 数组字面量，长度均为 6</span>

<span class="n">sp1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// 切片字面量</span>

<span class="n">mp1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="s">"a"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"b"</span><span class="o">:</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// map 字面量</span>
</code></pre></div></div> <p>在使用十六进制的科学计数法进行表示的时候，<code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">P</code> 表示幂运算的底数是 <code class="language-plaintext highlighter-rouge">2</code>。 需要注意的是有效数字的整数部分和小数部分用十六进制来表示，而指数部分用十进制来表示。</p> <p>如果想要在 <code class="language-plaintext highlighter-rouge">raw string</code> 中包含反引号，则可以使用 <code class="language-plaintext highlighter-rouge">+</code> 进行字符串的拼接来实现。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">len</code> 来获取字符串、数组、切片、<code class="language-plaintext highlighter-rouge">map</code> 和通道的长度。</p> <ul> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取字符串的长度时，返回的是字符串的字节数而不是字符数；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取数组时，返回的是数组的元素个数；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取切片时，返回的是切片的长度；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取 <code class="language-plaintext highlighter-rouge">map</code> 时，返回的是 <code class="language-plaintext highlighter-rouge">map</code> 中键值对的数量；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取无缓冲通道时，返回的是 <code class="language-plaintext highlighter-rouge">0</code>；</li> <li>当使用 <code class="language-plaintext highlighter-rouge">len</code> 获取有缓冲通道时，返回的是通道中当前存储的元素个数。</li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">array[low:high:max]</code> 来基于一个已经存在的数组创建一个切片。 当省略 <code class="language-plaintext highlighter-rouge">max</code> 时，默认 <code class="language-plaintext highlighter-rouge">max</code> 的值为数组的长度。 这个切片的长度是 <code class="language-plaintext highlighter-rouge">high - low</code>，容量是 <code class="language-plaintext highlighter-rouge">max - low</code>。 这也表明 <code class="language-plaintext highlighter-rouge">[low, high)</code> 和 <code class="language-plaintext highlighter-rouge">[low, max)</code> 都是左闭右开区间。</p> <p>需要注意的是基于数组创建的切片的底层是原数组，所以对切片的修改往往会直接影响原数组。 不过在切片发生扩容的时候会创建一个新的底层数组，此时对切片的修改就不会影响原数组了。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
<span class="n">s1</span> <span class="o">:=</span> <span class="n">arr</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>              <span class="c">// 创建切片 s1，包含 arr[1], arr[2], arr[3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>               <span class="c">// 输出: [1 2 3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// 输出: 3 4</span>
<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>                    <span class="c">// 修改切片 s1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>              <span class="c">// 输出: [0 10 2 3 4]，arr 也被修改了</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span>      <span class="c">// 切片 s1 发生扩容，创建了新的底层数组</span>
<span class="n">s2</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">30</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// 输出: [0 10 2 3 4]，arr 不受影响</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// 输出: [30 2 3 20 30]</span>
</code></pre></div></div> <p>可以使用 <code class="language-plaintext highlighter-rouge">len</code> 和 <code class="language-plaintext highlighter-rouge">cap</code> 函数来获取切片的长度和容量。 但是对于 <code class="language-plaintext highlighter-rouge">map</code> 而言则只能使用 <code class="language-plaintext highlighter-rouge">len</code> 函数来获取其长度。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中通过下标运算符去获取一个 <code class="language-plaintext highlighter-rouge">map</code> 中不存在的键时会返回该类型的零值。 为了区分一个键是不存在还是其值就是类型的零值，可以使用双赋值的形式来获取键对应的值和一个布尔值， 该布尔值表示该键是否存在于 <code class="language-plaintext highlighter-rouge">map</code> 中。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s">"key"</span><span class="p">]</span> <span class="c">// 如果 "key" 不存在，v 为 0，ok 为 false</span>
<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
<span class="c">// 处理键不存在的情况</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c">// 使用 v 进行后续操作</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">map</code> 是基于 <code class="language-plaintext highlighter-rouge">hash</code> 的，对其进行遍历时的顺序是随机的。 <code class="language-plaintext highlighter-rouge">Go</code> 为了让开发者不依赖于 <code class="language-plaintext highlighter-rouge">map</code> 的遍历顺序，特意设计成每次遍历的顺序都有可能不一样。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串、字节切片、<code class="language-plaintext highlighter-rouge">rune</code> 切片之间可以方便地进行相互转换。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为字节切片</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[]</span><span class="kt">rune</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为 rune 切片</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>          <span class="c">// 字节切片转换为字符串</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>          <span class="c">// rune 切片转换为字符串</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串是通过 <code class="language-plaintext highlighter-rouge">UTF-8</code> 编码进行存储的，因此可以直接存储和处理多字节的 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">len</code> 获取的字符串的字节数而不是字符数，如果要获取字符数可以使用 <code class="language-plaintext highlighter-rouge">utf8.RuneCountInString</code> 函数。同理通过下标访问字符串时获取的是字节而不是字符。 不过 <code class="language-plaintext highlighter-rouge">for range</code> 遍历时获取的是字符。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="n">lengthInBytes</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                    <span class="c">// 获取字符串的字节数</span>
<span class="n">lengthInRunes</span> <span class="o">:=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 获取字符串的字符数</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>                      <span class="c">// 遍历字符串中的字符</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Character %d: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
  <span class="c">// i 是字符的起始字节索引，r 是对应的 rune 值</span>
  <span class="c">// Character 5: 世</span>
  <span class="c">// Character 8: 界</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Byte %d: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>      <span class="c">// 访问字符串中的字节</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的结构体中可以使用嵌入字段来实现类似于继承的效果。 嵌入字段是指在结构体中直接包含另一个结构体类型，而不需要为其指定字段名。 这样可以直接访问嵌入结构体的字段和方法。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Person</span>  <span class="c">// 嵌入 Person 结构体</span>
  <span class="n">ID</span>      <span class="kt">string</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">emp</span> <span class="n">Employee</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"Alice"</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="m">30</span>  <span class="c">// 直接访问嵌入结构体的字段</span>
</code></pre></div></div> <p>嵌入按照嵌入类型可以分为以下几种：</p> <ul> <li>接口中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> <li>结构体中嵌入结构体（可以是 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code>）</li> <li>结构体中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> </ul> <p>这里重点介绍一下在一个结构体中嵌入接口的情况。 在结构体中嵌入接口后，这个结构体类型就实现了该接口。 但是我们必须在使用接口中的方法前，为嵌入的接口字段赋值，否则会导致运行时错误：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M1</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">S</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M2</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M2 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I</span> <span class="c">// T 中嵌入接口 I</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span> <span class="c">// 为嵌入的接口字段赋值，否则会导致运行时错误</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们也可以自己在 <code class="language-plaintext highlighter-rouge">T</code> 中实现接口 <code class="language-plaintext highlighter-rouge">I</code> 的方法，当接口变量被赋值且 <code class="language-plaintext highlighter-rouge">T</code> 实现了接口的方法时， <code class="language-plaintext highlighter-rouge">T</code> 实现的方法会优先被调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"T's M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span> <span class="c">// 调用 T 实现的 M1 方法</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span> <span class="c">// 调用 S 实现的 M2 方法</span>
<span class="p">}</span>
</code></pre></div></div> <p>在结构体内嵌入多个接口时，如果这些接口中有同名的方法：</p> <ul> <li>若同名方法的签名不同，则编译时会报错，提示方法冲突。</li> <li>若同名方法的签名相同，则必须在结构体中实现该方法，否则调用时编译器会报错。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I1</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M1</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">I2</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I1</span>
  <span class="n">I2</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="p">(</span><span class="s">"T.M"</span><span class="p">)</span> <span class="p">}</span> <span class="c">// 必须实现 M 方法，否则 t.M() 会导致编译错误</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不可以在结构类型 <code class="language-plaintext highlighter-rouge">T</code> 中定义类型为 <code class="language-plaintext highlighter-rouge">T</code> 的字段，也不可以递归定义， 但是可以包含<code class="language-plaintext highlighter-rouge">*T</code>、<code class="language-plaintext highlighter-rouge">[]T</code>、<code class="language-plaintext highlighter-rouge">map[type]T</code> 等类型的字段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// F T         // 错误，不能包含类型为 T 的字段</span>
  <span class="n">F</span> <span class="o">*</span><span class="n">T</span>           <span class="c">// 正确，可以包含类型为 *T 的字段</span>
  <span class="n">G</span> <span class="p">[]</span><span class="n">T</span>          <span class="c">// 正确，可以包含类型为 []T 的字段</span>
  <span class="n">H</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">T</span> <span class="c">// 正确，可以包含类型为 map[type]T 的字段</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T1</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t2</span> <span class="n">T2</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T2</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t1</span> <span class="n">T1</span>  <span class="c">// 错误，不能递归定义</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中主要有多种方法可以对自定义类型进行初始化。以下面的自定义类型为例。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Book</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Title</span>  <span class="kt">string</span>
  <span class="n">Author</span> <span class="n">Person</span>
<span class="p">}</span>
</code></pre></div></div> <p>一是可以按照顺序对结构体的字段进行赋值，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b1</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>但是这样的弊端也很明显：如果结构体的字段顺序发生变化，那么初始化的代码也需要进行相应的修改。 且当结构体的字段较多时，代码的可读性也会变差。这就引出了第二种初始化的方式：使用字段名进行赋值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p2</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b2</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="n">Title</span><span class="o">:</span> <span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Author</span><span class="o">:</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>除此之外还可以自定义方法来根据传入的参数进行初始化，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="n">age</span><span class="p">}</span>
<span class="p">}</span>
<span class="c">// or</span>
<span class="c">// func NewPerson(name string, age int) Person {</span>
<span class="c">//   return Person{Name: name, Age: age}</span>
<span class="c">// }</span>

<span class="n">p3</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// p3 在这里是 *Person 类型</span>
</code></pre></div></div> <p>不过官方推荐使用一种名为 <code class="language-plaintext highlighter-rouge">WithOption</code> 的设计模式来进行复杂类型的初始化， 这种方式可以通过传入不同的选项函数来灵活地配置初始化参数。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">PersonOption</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">Person</span><span class="p">)</span>
<span class="k">func</span> <span class="n">WithName</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="n">name</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">WithAge</span><span class="p">(</span><span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="n">age</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">opts</span> <span class="o">...</span><span class="n">PersonOption</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span>
    <span class="n">Name</span><span class="o">:</span> <span class="s">"Unknown"</span><span class="p">,</span>
    <span class="n">Age</span><span class="o">:</span>  <span class="m">0</span><span class="p">,</span> <span class="c">// 默认值</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">opts</span> <span class="p">{</span>
    <span class="n">opt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>
<span class="n">p4</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">WithName</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">),</span> <span class="n">WithAge</span><span class="p">(</span><span class="m">30</span><span class="p">))</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言可以对底层类型相同的元素进行隐式转换，编译器会保证这种转换的安全。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">var</span> <span class="n">a</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="m">10</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">10</span>
<span class="n">c</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="c">// 隐式转换，MyInt 和 int 可以进行运算</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不能给接口或者指针类型定义方法：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="o">*</span><span class="kt">int</span>
<span class="c">// CE: invalid receiver type MyInt (MyInt is a pointer type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyInt</span><span class="p">)</span> <span class="n">IsNil</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">MyReader</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span>
<span class="c">// CE: invalid receiver type MyReader (MyReader is an interface type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyReader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言对接口的实现是通过 <code class="language-plaintext highlighter-rouge">iface</code> 和 <code class="language-plaintext highlighter-rouge">eface</code> 两种内部数据结构来实现的。 <code class="language-plaintext highlighter-rouge">iface</code> 用于存储非空接口类型的变量，而 <code class="language-plaintext highlighter-rouge">eface</code> 用于存储空接口类型的变量。</p> <p>空接口是指接口中没有任何方法的接口类型，表示可以存储任意类型的值。 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">any</code> 类型实际上就是空接口类型的别名。 非空接口是指除了空接口之外的所有接口类型。</p> <p>在 <code class="language-plaintext highlighter-rouge">eface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">_type</code>：表示具体的类型信息。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>而在 <code class="language-plaintext highlighter-rouge">iface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tab</code>：表示类型信息和方法集合的表。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>接口的比较是基于这两个字段的。</p> <p>不管是空接口还是非空接口只有当其两个字段均为 <code class="language-plaintext highlighter-rouge">nil</code> 时才表示接口变量为 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a1</span> <span class="n">any</span>
<span class="k">var</span> <span class="n">a2</span> <span class="n">any</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">e1</span> <span class="kt">error</span>
<span class="k">var</span> <span class="n">e2</span> <span class="kt">error</span> <span class="o">=</span> <span class="no">nil</span>
</code></pre></div></div> <p>上面的四个变量和 <code class="language-plaintext highlighter-rouge">nil</code> 进行比较时均为 <code class="language-plaintext highlighter-rouge">true</code>。 因为上面的四个变量都为 <code class="language-plaintext highlighter-rouge">nil</code> 所以他们在通过 <code class="language-plaintext highlighter-rouge">==</code> 互相比较时都会返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>一旦两个字段中的任意一个不为 <code class="language-plaintext highlighter-rouge">nil</code>，那么接口变量就不再等于 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">i</span> <span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">m</span> <span class="o">*</span><span class="n">MyError</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">a</span> <span class="n">any</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">var</span> <span class="n">e</span> <span class="kt">error</span> <span class="o">=</span> <span class="n">m</span>
</code></pre></div></div> <p>上面例子中的 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">e</code> 都不等于 <code class="language-plaintext highlighter-rouge">nil</code>，因为他们的 <code class="language-plaintext highlighter-rouge">data</code> 字段虽然为 <code class="language-plaintext highlighter-rouge">nil</code>， 但是 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code> ）字段不为 <code class="language-plaintext highlighter-rouge">nil</code>。</p> <p>在接口变量之间进行比较时：</p> <ul> <li>当比较的两个接口变量是空接口（<code class="language-plaintext highlighter-rouge">eface</code>）或两个接口变量是非空接口时， 当且仅当其 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code>）字段相等、<code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> <li>当比较的两个接口变量一个是空接口（<code class="language-plaintext highlighter-rouge">eface</code>），另一个是非空接口（<code class="language-plaintext highlighter-rouge">iface</code>）时， 当且仅当空接口的 <code class="language-plaintext highlighter-rouge">_type</code> 字段等于非空接口的 <code class="language-plaintext highlighter-rouge">tab</code> 字段中的 <code class="language-plaintext highlighter-rouge">_type</code>字段、 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> </ul> <p>这里的 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致指的是：</p> <ul> <li>如果接口与指针类型绑定，那么比较的是指针的值是否相等。</li> <li>如果接口与非指针类型绑定，那么比较的是值的内容是否相等。</li> </ul> <p><strong>NOTE</strong>：<code class="language-plaintext highlighter-rouge">iface</code> 代表的是 <code class="language-plaintext highlighter-rouge">interface</code> 的意思，而 <code class="language-plaintext highlighter-rouge">eface</code> 代表的是 <code class="language-plaintext highlighter-rouge">empty interface</code> 的意思。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的方法集合是指某个类型所拥有的方法的集合。 其主要作用是用于判断一个类型是否实现了某个接口。 类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 的方法组成的集合。 类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code> 的方法组成的集合。 如果一个类型的方法集合是一个接口的超集，那么该类型就实现了该接口。</p> <p>这里解释一下为什么会是这样的定义。 关键在于 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的接口的实现方式。<code class="language-plaintext highlighter-rouge">Go</code> 语言的接口中保存了两部分内容：</p> <ul> <li>具体的类型信息</li> <li>对应的实例数据</li> </ul> <p>当一个非指针类型的变量被赋值给一个接口变量的时候，这个变量的实例数据是原对象的拷贝。 而将一个指针类型的变量赋值给一个接口变量的时候，接口变量数据部分保存的是该指针的值。 这也就意味着，如果真的可以通过一个非指针变量去调用接收者为指针的方法的话， 那么这个方法中对接收者的任何修改都不会反应到原对象上。为了禁止这样反直觉的行为， <code class="language-plaintext highlighter-rouge">Go</code> 语言就采用了上面所说的方法集合的定义。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Animal</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Grow</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Dog</span> <span class="k">struct</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Dog</span><span class="p">)</span> <span class="n">Grow</span><span class="p">()</span> <span class="p">{</span>
 <span class="c">// some code will change Dog instance</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="n">Animal</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="n">Dog</span><span class="p">{}</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">d</span>
  <span class="n">a</span><span class="o">.</span><span class="n">Grow</span><span class="p">()</span> <span class="c">// 假设这里可以通过编译，d 的状态也不会改变</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果理解了上述的规则我们不难得出嵌套类型的方法集合：</p> <ul> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">U</code> 的方法集合。</li> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">*U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> <li>不论嵌入类型是 <code class="language-plaintext highlighter-rouge">U</code> 还是 <code class="language-plaintext highlighter-rouge">*U</code>，类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合都包含了 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> </ul> <p>需要注意的是一个变量的类型对应的方法集合中没有的方法并不意味着该变量不能调用。 对于可寻址的对象，<code class="language-plaintext highlighter-rouge">Go</code> 语言会自动将其取地址从而调用接收者为指针的方法。 同样地，对于指针类型的变量，<code class="language-plaintext highlighter-rouge">Go</code> 语言也会自动解引用从而调用接收者为非指针的方法。</p> <p>当我们使用 <code class="language-plaintext highlighter-rouge">type</code> 给一个变量取别名或者基于已有的类型定义新的类型时，方法集合会根据原类型而有所不同。</p> <ul> <li>取别名不会改变原类型的方法集合；</li> <li>基于接口类型创建的新类型，其方法集合与原接口类型一致；</li> <li>而基于非接口类型创建的新类型，其方法集合为空。</li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中，<code class="language-plaintext highlighter-rouge">map</code> 存储的元素是不可寻址的，而切片中的元素确是可寻址的。 关于这样设计的原因主要有两个：</p> <ul> <li>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，其底层实现是基于哈希表的， 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么在 <code class="language-plaintext highlighter-rouge">map</code> 发生扩容或者重新哈希时， 这些寻址的指针就会变得无效，从而导致不可预期的行为，这里应该主要是考虑红黑树上节点变化的问题。</li> <li>对于切片而言，其底层实现是基于数组的，数组的元素在内存中是连续存储的， 因此允许对切片中的元素进行寻址是安全且高效的； 且即使切片在使用过程中发生了扩容，如果此时有指针指向原数组上的元素，原数组就不会被释放。</li> <li>在 <code class="language-plaintext highlighter-rouge">map</code> 中，如果一个值不存在，那么通过下标运算符获取该值时会返回该类型的零值。 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么对于不存在的键，其对应的值将无法寻址， 这会导致代码变得复杂且容易出错。</li> </ul> <p>正因为 <code class="language-plaintext highlighter-rouge">map</code> 不可寻址，如果 <code class="language-plaintext highlighter-rouge">map</code> 存储的 <code class="language-plaintext highlighter-rouge">value</code> 部分是非指针，我们是不能调用接收者为指针的方法的。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以通过类型断言来获取一个接口变量的具体类型和值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">10</span>
<span class="k">var</span> <span class="n">x</span> <span class="n">any</span> <span class="o">=</span> <span class="n">a</span>
<span class="c">// WARN:</span>
<span class="c">// 如果断言失败会引发 panic，所以推荐使用带 ok 变量的形式进行断言</span>
<span class="n">v1</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="n">v2</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c">// ok2 为 true，v2 的值为 10</span>
<span class="n">v3</span><span class="p">,</span> <span class="n">ok3</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="c">// ok3 为 false，v3 的值为 string 类型的零值 ""</span>
</code></pre></div></div> <p>需要注意的是，如果断言的类型是一个接口则语义变成了“变量是否实现了该接口”的判断。 如果断言成功，返回值的类型为实际类型而不是所实现的接口类型。</p> <hr/> <p>在对内置的函数进行 <code class="language-plaintext highlighter-rouge">defer</code> 操作的时候， <code class="language-plaintext highlighter-rouge">append</code>、<code class="language-plaintext highlighter-rouge">cap</code>、<code class="language-plaintext highlighter-rouge">len</code>、<code class="language-plaintext highlighter-rouge">make</code>、<code class="language-plaintext highlighter-rouge">new</code> 等并不能作为 <code class="language-plaintext highlighter-rouge">deferred</code> 函数调用。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中只能通过 <code class="language-plaintext highlighter-rouge">make</code> 来创建 <code class="language-plaintext highlighter-rouge">channel</code>，<code class="language-plaintext highlighter-rouge">make</code> 接收两个参数， 第一个是 <code class="language-plaintext highlighter-rouge">channel</code> 的类型，第二个是 <code class="language-plaintext highlighter-rouge">channel</code> 的缓冲区大小。 缓冲区大小默认为 <code class="language-plaintext highlighter-rouge">0</code>，表示无缓冲 <code class="language-plaintext highlighter-rouge">channel</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// 无缓冲 channel</span>
<span class="n">chBuf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c">// 有缓冲 channel，缓冲区大小为 5</span>
</code></pre></div></div> <p>在使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 的时候，发送方和接收方一定要放在两个不同的 <code class="language-plaintext highlighter-rouge">goroutine</code> 中， 这是因为如果放在同一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中，无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 在发送和接收时都会阻塞当前的 <code class="language-plaintext highlighter-rouge">goroutine</code>， 进而引发协程泄漏。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中使用 <code class="language-plaintext highlighter-rouge">channel</code> 的时候往往是由发送方来关闭， 这是因为接收主有安全的手段来检查 <code class="language-plaintext highlighter-rouge">channel</code> 是否已经关闭，而发送方并没有这样安全的手段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>     <span class="c">// 当 channel 关闭时，n 会被赋值为类型的零值</span>
<span class="n">m</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// ok 为 false 表示 channel 已经关闭</span>
<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="c">// 当 channel 关闭时，循环会自动结束</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">select</code> 原语，其可以一次监听多个 <code class="language-plaintext highlighter-rouge">channel</code> 的操作。 当其中某个 <code class="language-plaintext highlighter-rouge">channel</code> 准备好进行发送或接收操作时，<code class="language-plaintext highlighter-rouge">select</code> 会执行对应的 <code class="language-plaintext highlighter-rouge">case</code> 分支。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">msg1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Received message from ch1: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg1</span><span class="p">)</span>
<span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">msg2</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Sent message to ch2: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg2</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"No channel is ready"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>当没有使用 <code class="language-plaintext highlighter-rouge">default</code> 的时候，<code class="language-plaintext highlighter-rouge">select</code> 会一直阻塞直到某个 <code class="language-plaintext highlighter-rouge">case</code> 分支可以执行。</p> <p>下面三种是 <code class="language-plaintext highlighter-rouge">select</code> 原语常用的方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">default</code> 分支可以实现 <code class="language-plaintext highlighter-rouge">try</code> 语义。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包可以实现超时控制。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包的 <code class="language-plaintext highlighter-rouge">Ticker</code> 可以实现周期任务。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="n">TrySend</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">value</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">true</span> <span class="c">// 发送成功</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">false</span> <span class="c">// channel 未准备好，发送失败</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ReceiveWithTimeout</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="no">nil</span> <span class="c">// 成功接收数据</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"receive timeout"</span><span class="p">)</span> <span class="c">// 超时</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">PeriodicTask</span><span class="p">(</span><span class="n">interval</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">stopCh</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
  <span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">ticker</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">ticker</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="c">// 执行周期任务</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">stopCh</span><span class="o">:</span>
      <span class="k">return</span> <span class="c">// 停止任务</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>有一点需要注意的是，在实现超时控制的时候，如果使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 则可能出现协程泄漏的问题：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// do some work</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}</span>
<span class="p">}()</span>
<span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务完成！"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务超时!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，如果任务在 <code class="language-plaintext highlighter-rouge">2</code> 秒内没有完成， 那么超时分支会被执行，而任务协程仍然会继续运行并尝试向 <code class="language-plaintext highlighter-rouge">ch</code> 发送数据。 由于 <code class="language-plaintext highlighter-rouge">ch</code> 是一个无缓冲的 <code class="language-plaintext highlighter-rouge">channel</code>，如果没有其他协程在接收数据， 那么任务协程会一直阻塞在发送操作上，导致协程泄漏。 为了解决这个问题，可以使用有缓冲的 <code class="language-plaintext highlighter-rouge">channel</code> 或者使用 <code class="language-plaintext highlighter-rouge">context</code> 进行超时控制。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">type switch</code> 来方便的判断一个接口变量所属于的类型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="m">10</span>
<span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span> <span class="c">// 只能接口类型可以使用 type switch</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is int: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is of unknown type</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意 <code class="language-plaintext highlighter-rouge">case</code> 后面的类型必须是实现了该接口的类型，否则会导致编译错误。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的泛型不支持在类型里面内嵌泛型本身，也不支持在泛型方法中接着定义泛型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// T          // 错误，不能在泛型类型中内嵌泛型本身</span>
<span class="p">}</span>
<span class="c">// 错误，不能在泛型方法中接着定义泛型</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">MyMethod</span><span class="p">[</span><span class="n">U</span> <span class="n">any</span><span class="p">]()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的类型约束在有些情况下可以简写，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">a1</span><span class="p">[</span><span class="n">I</span> <span class="k">interface</span> <span class="p">{</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">}](</span><span class="n">param</span> <span class="n">I</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">func</span> <span class="n">a2</span><span class="p">[</span><span class="n">T</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span><span class="p">](</span><span class="n">param</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p><strong>注意</strong>：在类型约束中如果使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示只要底层类型是该类型即可， 而不使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示必须是该类型本身。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">panic</code> 表示程序发生了不可恢复的错误，通常会导致程序崩溃。 任意一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中发生的 <code class="language-plaintext highlighter-rouge">panic</code> 都会导致整个程序崩溃。 可以使用 <code class="language-plaintext highlighter-rouge">recover</code> 函数来捕获 <code class="language-plaintext highlighter-rouge">panic</code>，从而防止程序崩溃。 而 <code class="language-plaintext highlighter-rouge">recover</code> 函数只能在 <code class="language-plaintext highlighter-rouge">defer</code> 函数中调用。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">safeFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Recovered from panic:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c">// 可能引发 panic 的代码</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的包导入时可以在结尾增加版本信息，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"github.com/user/project/v2"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的包符合 <code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code> 版本规范，官方规定只有当 <code class="language-plaintext highlighter-rouge">Major</code> 变化时才会出现兼容性的问题。 在不书写版本号时，默认导入的是 <code class="language-plaintext highlighter-rouge">v0</code> 或 <code class="language-plaintext highlighter-rouge">v1</code> 版本的包。可以使用 <code class="language-plaintext highlighter-rouge">go list -m -versions &lt;package_name&gt;</code> 来查看某个包的所有可用版本。</p> <p>如果想要移除一个依赖，需要使用 <code class="language-plaintext highlighter-rouge">go get &lt;package_name&gt;</code> 的形式在版本部分添加 <code class="language-plaintext highlighter-rouge">@none</code>， 例如 <code class="language-plaintext highlighter-rouge">go get github.com/go-redis/redis/v8@none</code> 会移除已经添加的 <code class="language-plaintext highlighter-rouge">go-redis v8</code> 依赖。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中命名的一些规范：</p> <ul> <li>循环和条件变量多采用单个字母命名。</li> <li>函数/方法的参数和返回值以单个单词或字母为主。</li> <li>方法的命名以单个单词为主。</li> <li>函数/类型多以多个单词的复合形式命名。</li> <li>变量中不携带类型信息。</li> <li>包名往往由单个单词进行命名，且尽量与导入路径的最后一个路径分段一致。</li> <li><code class="language-plaintext highlighter-rouge">Go</code> 中如果接口类型只有一个方法，则接口往往命名为该方法名加上 <code class="language-plaintext highlighter-rouge">-er</code> 后缀。 比如 <code class="language-plaintext highlighter-rouge">Read</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Reader</code>，<code class="language-plaintext highlighter-rouge">Write</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Writer</code>。</li> </ul> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言中零值可用是非常重要的概念，比如对于一个指向 <code class="language-plaintext highlighter-rouge">net.TCPAddr</code> 的指针， 如果我们使用 <code class="language-plaintext highlighter-rouge">fmt.Print</code> 对其进行输出则会调用 <code class="language-plaintext highlighter-rouge">func (*TCPAddr) String() string</code> 方法， 在该方法中，其检查了调用的实例是不是一个空指针，并对于空指针直接返回了 <code class="language-plaintext highlighter-rouge">&lt;nil&gt;</code> 字符串。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的参数传递是值传递的，对于一个数组参数其在进行参数传递的时候会对整个数组进行拷贝。 而因为切片、字典等对象实际存储的是指针，所以其在作为参数进行传递时开销会小很多。 除此之外，<code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">for i, v := range x</code> 中的 <code class="language-plaintext highlighter-rouge">v</code> 变量也会有一次拷贝， 即使 <code class="language-plaintext highlighter-rouge">x</code> 的类型是切片这样的类型，修改 <code class="language-plaintext highlighter-rouge">v</code> 也不会作用在原切片上。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="c">// CE: declared and not used: v</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">r</span> <span class="p">{</span>
  <span class="n">v</span> <span class="o">=</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的例子中我们尝试通过修改 <code class="language-plaintext highlighter-rouge">v</code> 来实现修改 <code class="language-plaintext highlighter-rouge">r</code> 的目的，但是实际上是不可能的， 因为我们只是对 <code class="language-plaintext highlighter-rouge">v</code> 进行了赋值，<code class="language-plaintext highlighter-rouge">Go</code> 编译器认为我们没有使用 <code class="language-plaintext highlighter-rouge">v</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span> <span class="p">{</span>
<span class="c">// for i, v := range &amp;a {</span>
<span class="c">// for i, v := range a[:] {</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// 注意这里我们改的是还没有遍历到的数据</span>
    <span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="m">12</span>
    <span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="m">13</span>
    <span class="c">// 不管是使用哪种形式的 for range</span>
    <span class="c">// 对当前遍历对象的修改都不会作用到 v 上</span>
    <span class="c">// 因为 v 已经是 a[0] 的拷贝了</span>
    <span class="c">// a[0] = 10</span>
  <span class="p">}</span>
  <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"r = "</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c">// r = [1 2 3 4 5]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a = "</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c">// a = [1 12 13 4 5]</span>
</code></pre></div></div> <p>由于在调用 <code class="language-plaintext highlighter-rouge">range</code> 的时候会将 <code class="language-plaintext highlighter-rouge">a</code> 进行一次拷贝， 即使我们第一次进行循环的时候修改了 <code class="language-plaintext highlighter-rouge">a[1]</code> 和 <code class="language-plaintext highlighter-rouge">a[2]</code>， 我们也不能看到修改的值。</p> <p>而如果我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range &amp;a</code> 拷贝的就是指针，此时编译器会帮我们解引用而因为是同一个地址， 所以 <code class="language-plaintext highlighter-rouge">v</code> 可以看到这样的影响。</p> <p>同理，当我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range a[:]</code> 拷贝的就是切片，而切片的底层数组是同一个， 所以 <code class="language-plaintext highlighter-rouge">v</code> 也可以看到这样的影响。</p> <p>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，如果在 <code class="language-plaintext highlighter-rouge">for</code> 过程中添加或者删除键值，则循环的次数是不确定的。 而对于切片而言，其循环次数在一开始就已经确定了。</p> <p>对于 <code class="language-plaintext highlighter-rouge">channel</code> 而言，<code class="language-plaintext highlighter-rouge">for range</code> 只有在 <code class="language-plaintext highlighter-rouge">channel</code> 被关闭后才会结束循环。 如果 <code class="language-plaintext highlighter-rouge">channel</code> 的变量是 <code class="language-plaintext highlighter-rouge">nil</code> 则循环将会永远被阻塞。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 版本之前，<code class="language-plaintext highlighter-rouge">for</code> 循环中变量只会被创建一次， 这会导致一些奇怪的现象：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Customer</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">ID</span>      <span class="kt">string</span>
  <span class="n">Balance</span> <span class="kt">float64</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Customers</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Store</span><span class="p">)</span> <span class="n">storeCustomers</span><span class="p">(</span><span class="n">customers</span> <span class="p">[]</span><span class="n">Customer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">customer</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">customers</span> <span class="p">{</span>
    <span class="c">// 在 go 1.22 之前需要这样写以避免问题，保证每次创建一个新的 customer 变量</span>
    <span class="c">// customer := customer</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Customers</span><span class="p">[</span><span class="n">customer</span><span class="o">.</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">customer</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="n">Store</span><span class="p">{</span><span class="n">Customers</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span><span class="p">)}</span>
  <span class="n">s</span><span class="o">.</span><span class="n">storeCustomers</span><span class="p">([]</span><span class="n">Customer</span><span class="p">{</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"1"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="o">-</span><span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"3"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">0</span><span class="p">},</span>
  <span class="p">})</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span><span class="o">.</span><span class="n">Customers</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"id=%s,customer=%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 之前会输出：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id=1, customer=&amp;main.Customer{ID:"3", Balance:0}
id=2, customer=&amp;main.Customer{ID:"3", Balance:0}
id=3, customer=&amp;main.Customer{ID:"3", Balance:0}
</code></pre></div></div> <p>这是因为在 <code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">customer</code> 只会被创建一次， 所以三次赋值都指向了同一个地址，从而导致最后的结果都是相同的。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 及之后的版本中，<code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">v</code> 会在每次循环时创建新的变量， 从而避免了上述的问题。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中除了常见的方法调用方式外，还可以通过 <code class="language-plaintext highlighter-rouge">Method Expression</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">t</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="c">// or</span>
<span class="n">T</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</code></pre></div></div> <p>除了 <code class="language-plaintext highlighter-rouge">Method Expression</code> 以外，还可以使用 <code class="language-plaintext highlighter-rouge">Method Value</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">getFunc</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Get</span>
<span class="n">setFunc</span> <span class="o">:=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span>
<span class="n">getFunc</span><span class="p">()</span>   <span class="c">// 等价于 t.Get()</span>
<span class="n">setFunc</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c">// 等价于 t.Set(10)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">select</code> 的执行过程分为求值阶段和选择阶段。</p> <p>在求值阶段，<code class="language-plaintext highlighter-rouge">select</code> 会在进入后按照从上到下、从左到右进行求值：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">getAChannel</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="n">computeValue1</span><span class="p">()</span><span class="o">:</span>           <span class="c">// getAChannel() 和 computeValue1() 会被调用</span>
<span class="k">case</span> <span class="p">(</span><span class="n">getAStorageArray</span><span class="p">())[</span><span class="m">0</span><span class="p">]</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">getAChannel</span><span class="p">()</span><span class="o">:</span> <span class="c">// getAStorageArray() 不会被调用，getAChannel() 会被调用</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，会依次执行 <code class="language-plaintext highlighter-rouge">&lt;-</code> 左右两部分，但是在赋值语句中，赋值号左边的表达式不会被执行， 只有在其被选中时才会执行。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 从 <code class="language-plaintext highlighter-rouge">1.11</code> 开始会对一些简单的函数或者方法进行内联优化，这在调试过程中或者发生 <code class="language-plaintext highlighter-rouge">panic</code> 时会影响调用栈的展示。我们可以使用 <code class="language-plaintext highlighter-rouge">-gcflags="-l"</code> 来禁用内联优化，例如：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build <span class="nt">-gcflags</span><span class="o">=</span><span class="s2">"-l"</span> <span class="nt">-o</span> myapp main.go
go run <span class="nt">-gcflags</span><span class="o">=</span><span class="s2">"-l"</span> main.go
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中常用的测试方式有两种：</p> <ul> <li>包内测试；</li> <li>包外测试。</li> </ul> <p>无论是包内测试还是包外测试，测试文件通过都是以 <code class="language-plaintext highlighter-rouge">_test.go</code> 结尾命名的文件，且与被测试包相同的目录下。而包内测试的包名（也就是 <code class="language-plaintext highlighter-rouge">package</code> 关键字后面的名称）与被测试包相同，而包外测试的包名则是被测试包名加上 <code class="language-plaintext highlighter-rouge">_test</code> 后缀。</p> <p>由于包内测试的代码和被测的代码在同一个包中，所以包内测试可以访问被测试的包内所以符号，这也是为什么包内测试被叫做白盒测试。而包外测试由于和被测代码不在同一个包中，所以只能访问被测包导出的符号，这也是为什么包外测试被叫做黑盒测试。</p> <p>白盒测试的覆盖率通常会比墨盒测试高且白盒测试的灵活性比较高，这是因为其可以直接访问包内的非导出符号，从而进行更细粒度的测试。而黑盒测试则更接近于真实的使用场景，可以更好地模拟外部用户对包的使用方式。</p> <p>不过白盒测试有一个致命的缺陷，那就是包循环引用。比如在标准库的测试文件 <code class="language-plaintext highlighter-rouge">strings_test.go</code> 中会引用 <code class="language-plaintext highlighter-rouge">testing</code> 这个包，而 <code class="language-plaintext highlighter-rouge">testing.go</code> 文件中因为需要处理测试结果的输出，所以会引用 <code class="language-plaintext highlighter-rouge">strings</code> 包，如果这里使用包内测试就会导致包循环引用的问题，这是 <code class="language-plaintext highlighter-rouge">Go</code> 语言所不允许的。所以在标准库中使用了包外测试的方法来测试 <code class="language-plaintext highlighter-rouge">strings</code> 包。</p> <p>如果我们使用包外测试进行测试，可能会出现需要使用包内非导出符号的情况，对于这种情况，我们可以使用 <code class="language-plaintext highlighter-rouge">Go</code> 语言提供的 <code class="language-plaintext highlighter-rouge">export_test.go</code> 文件来解决。在测试一个包的过程中我们可以在包所在的目录下创建一个名为 <code class="language-plaintext highlighter-rouge">export_test.go</code> 的文件，该文件与被测试的包处在同一个包下，所有其可以访问包中未导出的符号，我们可以在该文件中将未导出的符号进行导出，该文件只有在测试阶段才会被编译，例如 <code class="language-plaintext highlighter-rouge">Go</code> 语言 <code class="language-plaintext highlighter-rouge">fmt</code> 包下的 <code class="language-plaintext highlighter-rouge">export_test.go</code> 中部分内容：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 标明和 fmt 包在同一个包下</span>
<span class="k">package</span> <span class="n">fmt</span>

<span class="k">var</span> <span class="n">IsSpace</span> <span class="o">=</span> <span class="n">isSpace</span>
<span class="k">var</span> <span class="n">Parsenum</span> <span class="o">=</span> <span class="n">parsenum</span>
</code></pre></div></div> <p>根据上面的对比我们可以发现，包外测试因为有 <code class="language-plaintext highlighter-rouge">export_test.go</code> 的支持，所以其解决了包内测试的硬伤，可以说包内测试可以完成的功能包外测试都可以完成，所以在实际开发中推荐使用包外测试的方式进行测试。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中我们可以使用 <code class="language-plaintext highlighter-rouge">go test -run=TestCompare -v .</code> 来指定只运行前缀为 <code class="language-plaintext highlighter-rouge">TestCompare</code> 的测试函数。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 在 <code class="language-plaintext highlighter-rouge">1.14</code> 之前如果我们要在测试的时候进行初始化和清理工作我们可以使用以下的方法：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">setup</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 初始化工作</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 清理工作</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestSomething</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">teardown</span> <span class="o">:=</span> <span class="n">setup</span><span class="p">()</span>
  <span class="k">defer</span> <span class="n">teardown</span><span class="p">()</span>
  <span class="c">// 测试代码</span>
<span class="p">}</span>
</code></pre></div></div> <p>从 <code class="language-plaintext highlighter-rouge">1.14</code> 开始我们可以使用 <code class="language-plaintext highlighter-rouge">testing.Cleanup</code> 方法来清理：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 初始化工作</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">cleanup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 清理工作</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestSomething</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 测试开始时调用</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">setup</span><span class="p">)</span>
  <span class="c">// 测试结束时调用</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Cleanup</span><span class="p">(</span><span class="n">cleanup</span><span class="p">)</span>
  <span class="c">// 测试代码</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言在 <code class="language-plaintext highlighter-rouge">1.4</code> 引入了 <code class="language-plaintext highlighter-rouge">TestMain</code> 函数来进行包级别的初始化和清理工作：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 其他的测试函数……</span>

<span class="k">func</span> <span class="n">pkgSetup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 包级别的初始化工作</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">pkgCleanup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 包级别的清理工作</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestMain</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">pkgSetup</span><span class="p">)</span>
  <span class="n">m</span><span class="o">.</span><span class="n">Cleanup</span><span class="p">(</span><span class="n">pkgCleanup</span><span class="p">)</span>
  <span class="c">// 初始化工作</span>
  <span class="n">code</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span> <span class="c">// 运行所有测试</span>
  <span class="c">// 清理工作</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中我们可以通过 <code class="language-plaintext highlighter-rouge">t.Run("", func)</code> 来给当前的测试用例添加子测试用例，最后测试用例之间将会以树形结构进行展示：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">testChild1</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 子测试用例 1 的代码</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">testChild2</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// 子测试用例 2 的代码</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">TestParent</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"Child_1"</span><span class="p">,</span> <span class="n">testchild1</span><span class="p">)</span>
  <span class="n">t</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">"Child_2"</span><span class="p">,</span> <span class="n">testchild2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Go"/><category term="中文文章"/><summary type="html"><![CDATA[本文记录了我在学习 Go 语言过程中的一些笔记和思考。]]></summary></entry><entry><title type="html">鞋带公式</title><link href="https://kaiser-yang.github.io/blog/2025/shoelace-formula/" rel="alternate" type="text/html" title="鞋带公式"/><published>2025-10-30T08:51:37+00:00</published><updated>2025-10-30T08:51:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/shoelace-formula</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/shoelace-formula/"><![CDATA[<p>简单多边形：如果一个多边形的任意两条边都不相交，则称该多边形为简单多边形。</p> <p>鞋带公式是用来求一个简单多边形面积的公式。</p> <p>鞋带公式要求按照顺时针或逆时针的顺序给出多边形的顶点坐标。</p> <p>这里我们定义 \(x_i, y_i\) 分别表示一个简单 \(n\) 边形的第 \(i\) 个顶点的横坐标和纵坐标， 这里选择下标从 \(0\) 开始编号。特别地，我们定义 \(x_n = x_0\)，\(y_n = y_0\)。</p> <p>鞋带公式的表达式为：</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \right|\] <h2 id="原理">原理</h2> <p>鞋带公式实际是通过计算多个梯形的代数面积来求解多边形的面积。 具体地，我们可以将多边形划分为多个梯形， 每个梯形的顶点分别是多边形的两个相邻顶点和 x 轴上的两个投影点。 通过计算每个梯形的面积并累加起来，我们可以得到整个多边形的面积。</p> <p>而上述的过程可以写成如下的方程:</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (y_i + y_{i+1}) (x_{i+1} - x_i) \right|\] <p>整理后就可以得到最开始给出的鞋带公式。</p> <h2 id="实现">实现</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="n">R</span> <span class="nf">polygon_area</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">R</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">R</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">area</span> <span class="o">-=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Shoelace Formula"/><summary type="html"><![CDATA[本文介绍鞋带公式的原理及其实现方式。]]></summary></entry><entry><title type="html">多重背包优化</title><link href="https://kaiser-yang.github.io/blog/2025/knapsack-problem/" rel="alternate" type="text/html" title="多重背包优化"/><published>2025-10-24T10:39:56+00:00</published><updated>2025-10-24T10:39:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/knapsack-problem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/knapsack-problem/"><![CDATA[<p>多重背包问题可以通过如下的转移方程来解决：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>其中，\(dp_{i,j}\) 表示前 \(i\) 种物品放入容量为 \(j\) 的背包所能获得的最大价值， \(w_i\) 和 \(v_i\) 分别表示第 \(i\) 种物品的重量和价值，\(c_i\) 表示第 \(i\) 种物品的数量。</p> <p>通过上面的方法进行转移时，时间复杂度为 \(O(N \cdot M \cdot C)\)， 其中 \(N\) 是物品种类数，\(M\) 是背包容量，\(C\) 是物品数量的最大值。 当 \(C\) 较大时，时间复杂度会变得非常高，这里介绍两种优化方法来降低时间复杂度。</p> <h2 id="二进制优化">二进制优化</h2> <p>对于第 \(i\) 件物品我们将其拆分成 \(1, 2, 4, \ldots, 2^k\) 件，使得 \(1 + 2 + 4 + \ldots + 2^k \leq c_i\)， 再加上剩余的 \(x := c_i - (1 + 2 + 4 + \ldots + 2^k)\) 件，其中的 \(k\) 满足 \(2^{k+1} &gt; c_i\)。</p> <p>经过上述的拆分后，我们可以将多重背包问题转化为 0-1 背包问题，从而将时间复杂度降低到 \(O(N \cdot M \cdot \log C)\)。</p> <p>转换的依据是 \(1, 2, 4, \ldots, 2^k\) 件物品可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1\) 件物品， 而加上剩余的 \(x\) 件物品后，可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1 + x = c_i\) 件物品。</p> <p>综上所述，这里使用 0-1 背包的方式进行转移依然可以覆盖所有的情况。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="单调栈优化">单调栈优化</h2> <p>我们回到最开始的转移方程：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>在上面的方程中我们可以发现 \(dp_{i, j}\) 只依赖于 \(dp_{i-1, j-k \cdot w_i}\)， 因此我们可以以 \(w_i\) 为步长将 \(j\) 分成若干组， 即 \(j \equiv r \text{mod} w_i\)，其中 \(0 \leq r &lt; w_i\)。</p> <p>对于每一组，我们可以将其转移方程改写为：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} + (k - k') \cdot v_i) \quad (0 \leq k - k' \leq c_i)\] <p>整理一下可以得到：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i) + k \cdot v_i \quad (0 \leq k - k' \leq c_i)\] <p>不难发现上面的 \(\max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i)\) 可以通过单调队列来进行优化， 从而将时间复杂度降低到 \(O(N \cdot M)\)。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ndp</span><span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            <span class="n">ndp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ndp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Knapsack Problem"/><summary type="html"><![CDATA[本文介绍多重背包问题的两种优化方法。]]></summary></entry><entry><title type="html">中国剩余定理及其扩展</title><link href="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/" rel="alternate" type="text/html" title="中国剩余定理及其扩展"/><published>2025-10-16T07:22:05+00:00</published><updated>2025-10-16T07:22:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/"><![CDATA[<h2 id="中国剩余定理">中国剩余定理</h2> <p>假如给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>其中 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>我们令 \(M = m_1 \cdot m_2 \cdots m_k\)，并且对于每个 \(i\)，定义 \(M_i = \frac{M}{m_i}\)。 由于 \(m_i\) 和 \(M_i\) 互质，可以知道 \(M_i\) 在模 \(m_i\) 意义下是有逆元的， 记为 \(M_i^{-1}\)。不难发现 \(M_i \cdot M_i^{-1} \equiv 1 \text{mod} m_i\) 和 \(M_i \cdot M_i^{-1} \equiv 0 \text{mod} m_j\)（\(j \neq i\)）都成立。 记 \(c_i = a_i \cdot M_i \cdot M_i^{-1}\)，则有：</p> \[\begin{cases} c_i \equiv a_i \text{mod} m_i \\ n_i \equiv 0 \text{mod} m_j \quad (j \neq i) \end{cases}\] <p>由同余的线性性质可知，\(x' = \sum_{i=1}^{k} c_i\) 即为一个特解。</p> <p>不难证明通解可以写成 \(x = x' + t \cdot M \quad (t \in \mathbb{Z})\)。</p> <p>注意在上述的过程中，我们要求解 \(M_i\) 在模 \(m_i\) 意义下的逆元， 只有在 \(m_i\) 两两互质的情况下才能保证每次求解的逆元存在。</p> <p>代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">l</span> <span class="o">*=</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span> <span class="o">*</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="扩展中国剩余定理">扩展中国剩余定理</h2> <p>扩展中国剩余定理是在中国剩余定理的基础上，放宽了对模数的互质要求。 假设给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>并不保证 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>不难发现，\(x = x' + t \cdot M \quad (t \in \mathbb{Z})\) 是同余方程 \(x \equiv x' \text{mod}{M}\) 的解。</p> <p>假设我们已经求出了前 \(i-1\) 个方程的解：</p> \[x = x_{i-1} + t \cdot M_{i-1} \quad (t \in \mathbb{Z}),\] <p>现在考虑如何求其与</p> \[x \equiv a_i \text{mod}{m_i}\] <p>的公共解。</p> <p>将当前的解代入上述方程，得到：</p> \[x_{i-1} + t \cdot M_{i-1} \equiv a_i \text{mod}{m_i},\] <p>即</p> \[t \cdot M_{i-1} \equiv a_i - x_{i-1} \text{mod}{m_i}.\] <p>设 \(d = \gcd(M_{i-1}, m_i)\)，则上式有解的<strong>充要条件</strong>是\(d \mid (a_i - x_{i-1})\)。</p> <p>如果有解，将上式两边同时除以 \(d\)，得到：</p> \[t \cdot \frac{M_{i-1}}{d} \equiv \frac{a_i - x_{i-1}}{d} \text{mod}{\frac{m_i}{d}}.\] <p>由于\(\frac{M_{i-1}}{d}\)和\(\frac{m_i}{d}\)互质， 可以用扩展欧几里得算法求该方程的一个特解 \(t_0\)，则通解可以表示为：</p> \[t = t_0 + k \cdot \frac{m_i}{d} \quad (k \in \mathbb{Z}).\] <p>将通解代入\(x = x_{i-1} + t \cdot M_{i-1}\)中，可以得到：</p> \[x = x_{i-1} + t_0 \cdot M_{i-1} + k \cdot \frac{m_i}{d} \cdot M_{i-1} \quad (k \in \mathbb{Z}).\] <p>因此，新的解可以表示为：</p> \[x = x_i + k \cdot M_i \quad (k \in \mathbb{Z}),\] <p>其中</p> \[\begin{cases} x_i = x_{i-1} + t_0 \cdot M_{i-1} \\ M_i = \frac{m_i}{d} \cdot M_{i-1} \end{cases}\] <p>特别地，我们可以增加一个方程 \(x \equiv 0 \text{mod} 1\) 作为初始条件， 此时 \(x_0 = 0\)，\(M_0 = 1\)。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ex_crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ex_gcd</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">%=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Chinese Remainder Theorem"/><summary type="html"><![CDATA[本文介绍中国剩余定理以及扩展中国剩余定理。]]></summary></entry><entry><title type="html">模逆元</title><link href="https://kaiser-yang.github.io/blog/2025/mod-inverse/" rel="alternate" type="text/html" title="模逆元"/><published>2025-10-15T13:34:31+00:00</published><updated>2025-10-15T13:34:31+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/mod-inverse</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/mod-inverse/"><![CDATA[<p>模逆元的定义如下：</p> <p>给定一个正整数 \(a\) 和一个正模数 \(p\) ，如果存在一个正整数 \(b\) 满足：</p> \[a \cdot b \equiv 1 \ (\text{mod} \ p), 1 \leq b \le p\] <p>则称 \(b\) 为 \(a\) 关于模数 \(p\) 的模逆元，记作 \(a^{-1} \ (\text{mod} \ p)\) 。</p> <h2 id="计算方法">计算方法</h2> <h3 id="单个数的模逆元">单个数的模逆元</h3> <p>对于模逆元的计算，其本质是在求解 \(ax + py = 1\) 这个不定方程的正整数解 \(x\)。</p> <p>由裴蜀定理可知，只有当 \(\gcd(a, p) = 1\) 时，方程才有整数解。</p> <p>所以我们可以使用扩展欧几里得算法来计算模逆元。</p> <p>这里给出计算代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">inverse_of</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ex_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>特别地，当 \(p\) 是质数时，由费马小定理可知：</p> \[a^{p-1} \equiv 1 \ (\text{mod} \ p)\] <p>因此，\(a^{p-2} \ (\text{mod} \ p)\) 即为 \(a\) 关于模数 \(p\) 的模逆元。</p> <h3 id="多个数的模逆元">多个数的模逆元</h3> <p>逆元存在一个重要的性质：对于 \(a\) 和 \(b\)，有</p> \[(a \cdot b)^{-1} \equiv a^{-1} \cdot b^{-1} (\text{mod} \ p)\] <p>有了这个性质，我们可以通过预处理前缀积来计算多个数的模逆元。</p> <p>具体地，我们用 \(prod_i\) 表示 \([1, i)\) 的前缀积取模后的结果，即：</p> \[prod_i = a_{i-1} \cdot prod_{i-1} \ (\text{mod} \ p)\] <p>那么就有 \(a^{-1}_i \equiv prod^{-1}_{i+1} \cdot prod_i \ (\text{mod} \ p)\)。</p> <p>我们只需要计算出 \(prod_n\) 的模逆元，然后从后往前依次计算出每个数的模逆元即可。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of each element in a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">prod</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">mod</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">inv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Modular Inverse"/><summary type="html"><![CDATA[本文介绍模逆元的定义及其计算方法。]]></summary></entry><entry><title type="html">扩展欧几里德算法</title><link href="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/" rel="alternate" type="text/html" title="扩展欧几里德算法"/><published>2025-10-14T10:42:49+00:00</published><updated>2025-10-14T10:42:49+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/"><![CDATA[<h2 id="前置知识">前置知识</h2> <p>裴蜀定理（Bézout’s Identity）： 对于任意两个整数 \(a\) 和 \(b\)，存在整数 \(x\) 和 \(y\) 使得 \(ax + by = \gcd(a, b)\) 成立。</p> <p>欧几里德算法：对于两个非负整数 \(a\) 和 \(b\)，其最大公约数可以通过以下递归关系计算：</p> \[gcd(a, b) = gcd(b, a \text{mod} b)\] <h2 id="线性丢番图方程">线性丢番图方程</h2> <p>线性丢番图方程是形如 \(ax + by = c\) 的不定方程， 其中 \(a\)、\(b\) 和 \(c\) 是已知整数，\(x\) 和 \(y\) 是未知整数。</p> <p>根据裴蜀定理，线性丢番图方程有整数解的充分必要条件是 \(\gcd(a, b)\) 整除 \(c\)。</p> <h2 id="扩展欧几里德算法">扩展欧几里德算法</h2> <p>扩展欧几里德算法是用来求解 \(ax + by = \gcd(a, b)\) 的一组特解。</p> <p>算法的基本思想是利用欧几里德算法的递归结构，同时在每一步记录下 \(x\) 和 \(y\) 的变化。</p> <p>考虑当我们已经知道 \(gcd(b, a \text{mod} b) = bx_1 + (a \text{mod} b)y_1\) 的解时， 如何求出 \(gcd(a, b) = ax + by\) 的解。</p> <p>我们记 \(a \text{mod} b = a - \lfloor \frac{a}{b} \rfloor \cdot b\)， 则有：</p> \[gcd(b, a \text{mod} b) = bx_1 + (a - \lfloor \frac{a}{b} \rfloor \cdot b)y_1\] <p>注意到 \(gcd(b, a \text{mod} b) = gcd(a, b)\)，我们可以将上式改写为：</p> \[gcd(a, b) = ay_1 + b(x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1) = ax + by\] <p>从而得到：</p> \[\left\{ \begin{array}{l} x = y_1 \\ y = x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1 \end{array} \right.\] <p>而不难发现当 \(b = 0\) 时，\(gcd(a, 0) = a\)，此时方程的解为 \((1, 0)\)。</p> <p>这样我们就可以通过递归的方式来求解 \(ax + by = \gcd(a, b)\)。</p> <p>对于 \(ax + by = c\) 的情况，我们只需要先求出 \(ax_0 + by_0 = \gcd(a, b)\) 的一组解， 此时 \(x = x_0 \cdot \frac{c}{\gcd(a, b)}\)，\(y = y_0 \cdot \frac{c}{\gcd(a, b)}\) 即为 \(ax + by = c\) 的一组特解。</p> <p>接下来我们考虑在知道一组解的情况下，如何求出通解。这里先给出结论：</p> <p>若 \((x_0, y_0)\) 是 \(ax + by = c\) 的一组解，则通解可以表示为：</p> \[\left\{ \begin{array}{l} x = x_0 + k \cdot \frac{b}{\gcd(a, b)} \\ y = y_0 - k \cdot \frac{a}{\gcd(a, b)} \end{array} \right.\] <p>容易证明上述形式的解都满足方程。我们接下来证明所有解都可以表示为上述形式。</p> <p>设 \((x_1, y_1)\) 也是方程的解，则有 \(a(x_1 - x_0) + b(y_1 - y_0) = 0\) 成立。</p> <p>由此可得</p> \[a(x_1 - x_0) = -b(y_1 - y_0)\] <p>两边同时除以 \(\gcd(a, b)\)，有</p> \[\frac{a}{\gcd(a, b)}(x_1 - x_0) = -\frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>可以知道</p> \[\frac{a}{\gcd(a, b)} \mid \frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>因为 \(\frac{a}{\gcd(a, b)}\) 和 \(\frac{b}{\gcd(a, b)}\) 互质，所以</p> \[\frac{a}{\gcd(a, b)} \mid y_1 - y_0\] <p>即存在整数 \(k\) 使得：</p> \[y_1 - y_0 = k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[y_1 = y_0 + k \cdot \frac{a}{\gcd(a, b)}\] <p>代入前面的等式，有：</p> \[a(x_1 - x_0) = -b \cdot k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[x_1 = x_0 - k \cdot \frac{b}{\gcd(a, b)}\] <p>综上所述，所有解可以表示为上述通解的形式。</p> <p>最后给出扩展欧几里德算法的代码实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the greatest common divisor of a and b,</span>
<span class="c1">// and find x and y such that ax + by = gcd(a, b)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">ex_gcd</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ex_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Extended Euclidean Algorithm"/><category term="gcd"/><summary type="html"><![CDATA[本文介绍扩展欧几里德算法的原理及应用。]]></summary></entry><entry><title type="html">Miller Rabin 素数测试</title><link href="https://kaiser-yang.github.io/blog/2025/miller-rabin/" rel="alternate" type="text/html" title="Miller Rabin 素数测试"/><published>2025-10-13T13:11:22+00:00</published><updated>2025-10-13T13:11:22+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/miller-rabin</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/miller-rabin/"><![CDATA[<h2 id="前置知识">前置知识</h2> <h3 id="费马小定理fermats-little-theorem">费马小定理（Fermat’s Little Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(a\) 不是 \(p\) 的倍数， 则 \(a^{p-1} \equiv 1 \text{mod} p\)。</p> <h3 id="二次探测定理quadratic-residue-theorem">二次探测定理（Quadratic Residue Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(x^2 \equiv 1 \text{mod} p\)， 则 \(x \equiv 1 \text{mod} p\) 或 \(x \equiv n - 1 \text{mod} p\)。</p> <h2 id="miller-rabin-素数测试原理">Miller Rabin 素数测试原理</h2> <p>我们可以发现，费马小定理和二次探测定理都给出了素数的必要条件， 但并不是充分条件。也就是说，如果一个数不满足这些条件， 那么它一定不是素数。</p> <p>Miller Rabin 素数测试是一种基于概率的素数测试算法， 它通过多次随机选择基数 \(a\) 来验证一个数是否为素数。</p> <p>对于一个奇数 \(n\) 而言其可以被写成 \(n - 1 = 2^s \cdot d\) 的形式， 其中 \(d\) 是奇数，\(s \geq 1\)。 根据费马小定理，如果 \(n\) 是素数， 则对于任意不是 \(p\) 倍数的 \(a\)，都有 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\)。 而由二次探测定理可知，我们可以对 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\) 执行开方的操作，其结果一定要是 \(1\) 或 \(n - 1\)。 同时当其结果为 \(1\) 时，则可以继续尝试开方操作，直到结果为 \(n - 1\) 或无法继续开方为止。 如果在某次开方的过程中，结果既不是 \(1\) 也不是 \(n - 1\)， 则 \(n\) 一定不是素数。</p> <p>根据上面的流程我们可以选择多个不同的 \(a\) 来进行测试， 如果所有的测试都通过了，则 \(n\) 很可能是素数。</p> <p>特别地，对于 64 位无符号整数，选择 \(2, 325, 9375, 28178, 450775, 9780504, 1795265022\) 可以保证不会出现误判。</p> <p>另外在实现的过程中，我们往往不会进行开方的操作，取而代之的是平方操作：</p> <ol> <li>将待测试的数 \(n\) 表示为 \(n - 1 = 2^s \cdot d\)，其中 \(d\) 是奇数，\(s \geq 1\)。</li> <li>选择一个基数 \(a\)。</li> <li>计算 \(x = a^d \text{mod} n\)。</li> <li>如果 \(x \equiv 1 \text{mod} n\) 或 \(x \equiv n - 1 \text{mod} n\)，此时进行平方的结果一定是 \(1\)， 所以可以直接认为通过本轮的测试。</li> <li>否则，重复以下步骤 \(s - 1\) 次： <ul> <li>计算 \(x \leftarrow x^2 \text{mod} n\)。</li> <li>如果 \(x \equiv n - 1 \text{mod} n\)，则通过本轮测试。</li> <li>如果在 \(s - 1\) 次操作中都没有出现 \(x \equiv n - 1 \text{mod} n\)，则本轮测试未通过。</li> </ul> </li> </ol> <p>在上述过程的5中，我们只检查了结果是否等于 \(n - 1\)，而没有检查结果是否等于 \(1\)。 这是因为如果当前的结果第一次等于 \(1\)，则说明在前一次平方操作中， 结果既不是 \(1\) 也不是 \(n - 1\)，这就违背了二次探测定理。</p> <p>最后给出Miller Rabin素数测试的代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">a</span> <span class="o">:</span> <span class="n">miller_rabin_test</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// calculate a^d % n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="中文文章"/><category term="Miller Rabin"/><category term="Primality Test"/><summary type="html"><![CDATA[本文介绍 Miller Rabin 素数测试的原理及其实现方式。]]></summary></entry></feed>