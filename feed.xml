<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2024-09-19T03:02:48+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>This homepage is for sharing everything I know. </subtitle><entry><title type="html">Spring 多次读取请求体</title><link href="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/" rel="alternate" type="text/html" title="Spring 多次读取请求体"/><published>2024-09-19T02:47:47+00:00</published><updated>2024-09-19T02:47:47+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-read-request-body-multiple-times/"><![CDATA[<h1 id="起因">起因</h1> <p>在某次项目中，我需要在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">request</code> 的 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容以检验数据是否符合要求。 但当我在 <code class="language-plaintext highlighter-rouge">Filter</code> 添加通过 <code class="language-plaintext highlighter-rouge">request.getReader()</code> 获取 <code class="language-plaintext highlighter-rouge">body</code> 的代码后，进行测试时，抛出了异常，异常 信息显式 <code class="language-plaintext highlighter-rouge">getReader() has already been called for this request stack</code>。</p> <h1 id="问题分析">问题分析</h1> <p>对于一个流而言，其通常只能被读取一次，当我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行第一次读取后，后续到 <code class="language-plaintext highlighter-rouge">Controller</code> 部分 时，由于有 <code class="language-plaintext highlighter-rouge">@RequestBody</code> 注释的对象，此时会再次读取 <code class="language-plaintext highlighter-rouge">body</code> 部分，这时就会抛出异常。</p> <h1 id="解决方案">解决方案</h1> <p>解决方案也很简单，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletReqeust</code> 继承 <code class="language-plaintext highlighter-rouge">HttpServletRequestWrapper</code>， 在其中缓存 <code class="language-plaintext highlighter-rouge">body</code> 部分的内容，然后在 <code class="language-plaintext highlighter-rouge">Filter</code> 中获取 <code class="language-plaintext highlighter-rouge">body</code> 时，直接从缓存中获取即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyHttpServletRequest</span> <span class="kd">extends</span> <span class="nc">HttpServletRequestWrapper</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">CachedBodyServletInputStream</span> <span class="kd">extends</span> <span class="nc">ServletInputStream</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">InputStream</span> <span class="n">cacheBodyInputStream</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cacheBodyInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">cacheBody</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFinished</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isReady</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setReadListener</span><span class="o">(</span><span class="nc">ReadListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">cacheBodyInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">cacheBody</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="nc">InputStream</span> <span class="n">requestInputStream</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span> <span class="o">=</span> <span class="nc">StreamUtils</span><span class="o">.</span><span class="na">copyToByteArray</span><span class="o">(</span><span class="n">requestInputStream</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">ServletInputStream</span> <span class="nf">getInputStream</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CachedBodyServletInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BufferedReader</span> <span class="nf">getReader</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BufferedReader</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cacheBody</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们在 <code class="language-plaintext highlighter-rouge">Filter</code> 中进行处理的时候需要创建一个 <code class="language-plaintext highlighter-rouge">CachedBodyHttpServletRequest</code> 对象，然后将其传递给 <code class="language-plaintext highlighter-rouge">FilterChain</code> 的 <code class="language-plaintext highlighter-rouge">doFilter</code> 方法即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span>
        <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">CachedBodyHttpServletRequest</span> <span class="n">cachedRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CachedBodyHttpServletRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="c1">// do something</span>
    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">cachedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://dev.to/cynavi/reading-request-body-multiple-times-in-javaspring-boot-1j53">Reading Request Body Multiple Times in Java/Spring Boot</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><summary type="html"><![CDATA[起因 在某次项目中，我需要在 Filter 中获取 request 的 body 部分的内容以检验数据是否符合要求。 但当我在 Filter 添加通过 request.getReader() 获取 body 的代码后，进行测试时，抛出了异常，异常 信息显式 getReader() has already been called for this request stack。 问题分析 对于一个流而言，其通常只能被读取一次，当我们在 Filter 中进行第一次读取后，后续到 Controller 部分 时，由于有 @RequestBody 注释的对象，此时会再次读取 body 部分，这时就会抛出异常。 解决方案 解决方案也很简单，我们只需要自定义一个 CachedBodyHttpServletReqeust 继承 HttpServletRequestWrapper， 在其中缓存 body 部分的内容，然后在 Filter 中获取 body 时，直接从缓存中获取即可： private class CachedBodyHttpServletRequest extends HttpServletRequestWrapper { private class CachedBodyServletInputStream extends ServletInputStream { private final InputStream cacheBodyInputStream; public CachedBodyServletInputStream(byte[] cacheBody) { this.cacheBodyInputStream = new ByteArrayInputStream(cacheBody); } @Override public boolean isFinished() { try { return cacheBodyInputStream.available() == 0; } catch (IOException e) { return true; } } @Override public boolean isReady() { return true; } @Override public void setReadListener(ReadListener listener) { throw new UnsupportedOperationException(); } @Override public int read() throws IOException { return cacheBodyInputStream.read(); } } private final byte[] cacheBody; public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException { super(request); InputStream requestInputStream=request.getInputStream(); this.cacheBody = StreamUtils.copyToByteArray(requestInputStream); } @Override public ServletInputStream getInputStream() { return new CachedBodyServletInputStream(this.cacheBody); } @Override public BufferedReader getReader() { return new BufferedReader( new InputStreamReader(new ByteArrayInputStream(this.cacheBody))); } } 这样我们在 Filter 中进行处理的时候需要创建一个 CachedBodyHttpServletRequest 对象，然后将其传递给 FilterChain 的 doFilter 方法即可： @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CachedBodyHttpServletRequest cachedRequest=new CachedBodyHttpServletRequest(request); // do something filterChain.doFilter(cachedRequest, response); } 巨人的肩膀 Reading Request Body Multiple Times in Java/Spring Boot]]></summary></entry><entry><title type="html">Long 在 Swagger 中精度丢失</title><link href="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/" rel="alternate" type="text/html" title="Long 在 Swagger 中精度丢失"/><published>2024-09-19T02:06:08+00:00</published><updated>2024-09-19T02:06:08+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/long-precision-lost-in-swagger/"><![CDATA[<h1 id="起因">起因</h1> <p>某次通过 <code class="language-plaintext highlighter-rouge">Swagger</code> 在项目中进行测试的时候，发现响应体中返回的 <code class="language-plaintext highlighter-rouge">id</code> (<code class="language-plaintext highlighter-rouge">Long</code> 类型，由雪花算法生成) 与 数据库中存储的 <code class="language-plaintext highlighter-rouge">id</code> 始终差那么一点点。</p> <h1 id="排查">排查</h1> <p>起先我认为是后端传得数据本身就有问题，于是我在 <code class="language-plaintext highlighter-rouge">Controller</code> 中进行返回数据的时候，将 <code class="language-plaintext highlighter-rouge">id</code> 的值 打印出来，发现 <code class="language-plaintext highlighter-rouge">id</code> 的值是正确的。于是我又在终端中单独执行了 <code class="language-plaintext highlighter-rouge">curl</code> 命令去获取数据，发现 <code class="language-plaintext highlighter-rouge">id</code> 的 值也是正确的。这时候我就很疑惑了，为什么在 <code class="language-plaintext highlighter-rouge">Swagger</code> 中获取的数据会有问题呢？</p> <p>接着我猜测是出现了精度丢失的问题，我猜想 <code class="language-plaintext highlighter-rouge">Long</code> 类型可能不能完全在 <code class="language-plaintext highlighter-rouge">js</code> 中表示，于是 <code class="language-plaintext highlighter-rouge">Swagger</code> 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 <code class="language-plaintext highlighter-rouge">Long 精度丢失</code> 便找到了相关的内容：</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">JavaScript</code> 的 <code class="language-plaintext highlighter-rouge">Number</code> 类型是基于 <code class="language-plaintext highlighter-rouge">IEEE 754</code> 标准的双精度浮点数格式，只能安全地表示 <code class="language-plaintext highlighter-rouge">53</code> 位 二进制数字，也就是 <code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code> 的值 <code class="language-plaintext highlighter-rouge">9007199254740991</code>。</p> </blockquote> <h1 id="解决方法">解决方法</h1> <p>网上的解决方法有很多，例如可以通过在类中 <code class="language-plaintext highlighter-rouge">Long</code> 字段上添加 <code class="language-plaintext highlighter-rouge">@JsonsSerialize(using = ToStringSerializer.class)</code> 注解，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。</p> <p>我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象和发送给前端的 <code class="language-plaintext highlighter-rouge">VO</code> 对象中的 <code class="language-plaintext highlighter-rouge">id</code> 字段更改成 <code class="language-plaintext highlighter-rouge">String</code> 类型，然后在从 <code class="language-plaintext highlighter-rouge">DTO</code> 类型构造 <code class="language-plaintext highlighter-rouge">PO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">String</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">Long</code> 类型，在从 <code class="language-plaintext highlighter-rouge">PO</code> 对象构造 <code class="language-plaintext highlighter-rouge">VO</code> 对象的时候，将 <code class="language-plaintext highlighter-rouge">Long</code> 类型的 <code class="language-plaintext highlighter-rouge">id</code> 字段转换为 <code class="language-plaintext highlighter-rouge">String</code> 类型。这样的好处在于，对于前端而言，<code class="language-plaintext highlighter-rouge">id</code> 确确 实实是一个 <code class="language-plaintext highlighter-rouge">String</code> 类型的字段，前端并不会知道 <code class="language-plaintext highlighter-rouge">id</code> 实际上是以 <code class="language-plaintext highlighter-rouge">Long</code> 类型进行存储的。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通过 UserPO 构造 UserVO</span>
<span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 通过 UserDTO 构造 UserPO</span>
<span class="kd">public</span> <span class="nf">UserPO</span><span class="o">(</span><span class="nc">UserDTO</span> <span class="n">userDTO</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">userDTO</span><span class="o">.</span><span class="na">id</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://cloud.tencent.com/developer/article/2445079">长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring-Doc"/><category term="OpenAPI"/><summary type="html"><![CDATA[起因 某次通过 Swagger 在项目中进行测试的时候，发现响应体中返回的 id (Long 类型，由雪花算法生成) 与 数据库中存储的 id 始终差那么一点点。 排查 起先我认为是后端传得数据本身就有问题，于是我在 Controller 中进行返回数据的时候，将 id 的值 打印出来，发现 id 的值是正确的。于是我又在终端中单独执行了 curl 命令去获取数据，发现 id 的 值也是正确的。这时候我就很疑惑了，为什么在 Swagger 中获取的数据会有问题呢？ 接着我猜测是出现了精度丢失的问题，我猜想 Long 类型可能不能完全在 js 中表示，于是 Swagger 在 对返回值进行解析的时候，不得不舍弃一部分。于是我通过关键字 Long 精度丢失 便找到了相关的内容： JavaScript 的 Number 类型是基于 IEEE 754 标准的双精度浮点数格式，只能安全地表示 53 位 二进制数字，也就是 Number.MAX_SAFE_INTEGER 的值 9007199254740991。 解决方法 网上的解决方法有很多，例如可以通过在类中 Long 字段上添加 @JsonsSerialize(using = ToStringSerializer.class) 注解，将 Long 类型转换为 String 类型。 我并没有采取这样的解决方法，主要是考虑到还需要从请求体中接收参数，为了方便前端发送，我决定直接将 在从前端接收的 DTO 对象和发送给前端的 VO 对象中的 id 字段更改成 String 类型，然后在从 DTO 类型构造 PO 对象的时候，将 String 类型的 id 字段转换为 Long 类型，在从 PO 对象构造 VO 对象的时候，将 Long 类型的 id 字段转换为 String 类型。这样的好处在于，对于前端而言，id 确确 实实是一个 String 类型的字段，前端并不会知道 id 实际上是以 Long 类型进行存储的。 // 通过 UserPO 构造 UserVO public UserVO(UserPO userPO) { this(userPO.getId().toString()); } // 通过 UserDTO 构造 UserPO public UserPO(UserDTO userDTO) { try { this.id = Long.valueOf(userDTO.id()); } catch (NumberFormatException e) { this.id = null; } } 巨人的肩膀 长得太长也是错？——后端 Long 型 ID 精度丢失的“奇妙”修复之旅]]></summary></entry><entry><title type="html">Spring Validation 路径变量与请求参数校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/" rel="alternate" type="text/html" title="Spring Validation 路径变量与请求参数校验"/><published>2024-09-18T12:43:30+00:00</published><updated>2024-09-18T12:43:30+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-path-variable-and-request-param/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 从请求路径中 获取或者通过 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 从请求参数中获取。本文将介绍如何使用 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@ReqeustParam</code> 获取的基本类型参数进行校验。</p> <h1 id="validated"><code class="language-plaintext highlighter-rouge">@Validated</code></h1> <p>要对通过 <code class="language-plaintext highlighter-rouge">@PathVariable</code> 和 <code class="language-plaintext highlighter-rouge">@RequestParam</code> 获取的参数进行校验，我们必须要在控制器类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。该注解由 <code class="language-plaintext highlighter-rouge">Spring</code> 提供以实现比 <code class="language-plaintext highlighter-rouge">JSR-303</code> 更加灵活的功能。</p> <p>在 <code class="language-plaintext highlighter-rouge">@Validated</code> 官方的文档中，有这样一句话：</p> <blockquote> <p>Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with.</p> </blockquote> <p>简单来说就是当 <code class="language-plaintext highlighter-rouge">@Validated</code> 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解。</p> <p>完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Validated</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_CHECK_EMAIL_VALIDITY_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkEmailValidity</span><span class="o">(</span>
            <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
            <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
            <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"email"</span><span class="o">)</span>
            <span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"email"</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">EMAIL_ALREADY_EXISTS</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样操作后，当请求到达 <code class="language-plaintext highlighter-rouge">checkEmailValidity</code> 方法时，<code class="language-plaintext highlighter-rouge">Spring</code> 会自动对 <code class="language-plaintext highlighter-rouge">email</code> 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 <code class="language-plaintext highlighter-rouge">ConstraintViolationException</code> 而不是 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code>。我们可以通过以下的方式进行全局异常处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">ConstraintViolationException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleConstraintViolationException</span><span class="o">(</span>
            <span class="nc">ConstraintViolationException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// do something</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://reflectoring.io/bean-validation-with-spring-boot/#validating-path-variables-and-request-parameters">Validation with Spring Boot - the Complete Guide</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring Validation 进行参数校验进行了介绍。但是其中只介绍了从请求体中获取的自定义参数如何进行校验， 并没有介绍对于一些基本类型的参数如何进行校验。这些基本类型参数往往通过 @PathVariable 从请求路径中 获取或者通过 @RequestParam 从请求参数中获取。本文将介绍如何使用 Spring Validation 对通过 @PathVariable 和 @ReqeustParam 获取的基本类型参数进行校验。 @Validated 要对通过 @PathVariable 和 @RequestParam 获取的参数进行校验，我们必须要在控制器类上添加 @Validated 注解。该注解由 Spring 提供以实现比 JSR-303 更加灵活的功能。 在 @Validated 官方的文档中，有这样一句话： Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with. 简单来说就是当 @Validated 在方法上的参数使用时，可以实现组校验，而如果要启用方法级别的校验，则必须 在类上添加 @Validated 注解。 完成了上面的准备工作后，我们就可以在控制器类中的方法参数上添加校验注解了。例如： @Validated @RestController public class UserController { @Autowired private UserService userService; @GetMapping(ApiPathConstant.USER_CHECK_EMAIL_VALIDITY_API_PATH) public void checkEmailValidity( @Email(message = "USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank(message = "USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") @RequestParam("email") String email) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("email", email); if (userService.exists(wrapper)) { throw new GenericException(ErrorCodeEnum.EMAIL_ALREADY_EXISTS, email); } } } 这样操作后，当请求到达 checkEmailValidity 方法时，Spring 会自动对 email 参数进行校验。需要注意 的是：此时如果检验没有通过会抛出 ConstraintViolationException 而不是 MethodArgumentNotValidException。我们可以通过以下的方式进行全局异常处理： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ConstraintViolationException.class) public ResponseEntity&lt;ErrorVO&gt; handleConstraintViolationException( ConstraintViolationException e, HttpServletRequest request) { // do something } } 巨人的肩膀 Validation with Spring Boot - the Complete Guide]]></summary></entry><entry><title type="html">Linux 大杂烩</title><link href="https://kaiser-yang.github.io/blog/2024/linux-potpourri/" rel="alternate" type="text/html" title="Linux 大杂烩"/><published>2024-09-10T12:30:06+00:00</published><updated>2024-09-10T12:30:06+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/linux-potpourri</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/linux-potpourri/"><![CDATA[<h1 id="wildcards-in-linux">Wildcards in Linux</h1> <p>这里的 <code class="language-plaintext highlighter-rouge">wildcards</code> 指的是能够被 <code class="language-plaintext highlighter-rouge">shell</code> 扩展的符号。如果在执行的命令中出现这些符号，<code class="language-plaintext highlighter-rouge">shell</code> 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 <code class="language-plaintext highlighter-rouge">shell</code> 支持，这些 <code class="language-plaintext highlighter-rouge">wildcards</code> 是可以在任意 命令中使用的。</p> <p>常见的 <code class="language-plaintext highlighter-rouge">wildcards</code> 有以下几种：</p> <ul> <li><code class="language-plaintext highlighter-rouge">*</code>：匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">**</code>：递归匹配任意数量( 包含 <code class="language-plaintext highlighter-rouge">0</code> 个 )的字符</li> <li><code class="language-plaintext highlighter-rouge">?</code>：匹配单个任意字符</li> <li><code class="language-plaintext highlighter-rouge">[]</code>：匹配出现在中括号中的某个符号，在中括号中可以使用 <code class="language-plaintext highlighter-rouge">-</code> 来表示范围，也可以使用 <code class="language-plaintext highlighter-rouge">!</code> 来表示取反， 例如 <code class="language-plaintext highlighter-rouge">[!0-9]</code> 表示匹配不是数字的字符，<code class="language-plaintext highlighter-rouge">[!ab]</code> 表示不是 <code class="language-plaintext highlighter-rouge">a</code> 也不是 <code class="language-plaintext highlighter-rouge">b</code> 的字符</li> </ul> <p>上面的通配符并不是所有的 <code class="language-plaintext highlighter-rouge">shell</code> 都支持的，但是在 <code class="language-plaintext highlighter-rouge">bash</code> 中是支持的。例如在 <code class="language-plaintext highlighter-rouge">fish shell</code> 中，只有 <code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">**</code> 以及 <code class="language-plaintext highlighter-rouge">?</code> 是支持的，其中 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 不会匹配 <code class="language-plaintext highlighter-rouge">/</code>，而 <code class="language-plaintext highlighter-rouge">**</code> 会匹配 <code class="language-plaintext highlighter-rouge">/</code> ，也就是说 <code class="language-plaintext highlighter-rouge">**</code> 是 递归匹配。</p> <p><strong>注意</strong>：在正则表达式的语法中，<code class="language-plaintext highlighter-rouge">*</code> 表示匹配前面的字符 0 次或者多次，<code class="language-plaintext highlighter-rouge">?</code> 表示匹配前面的字符 0 次或者 1 次， <code class="language-plaintext highlighter-rouge">[]</code> 表示匹配中括号中的任意一个字符，<code class="language-plaintext highlighter-rouge">-</code> 表示范围，<code class="language-plaintext highlighter-rouge">^</code> 表示取反。</p> <h1 id="常用命令-cheat-sheet">常用命令 <code class="language-plaintext highlighter-rouge">Cheat Sheet</code></h1> <h2 id="cat"><code class="language-plaintext highlighter-rouge">cat</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-b</code></td> <td>显示非空行的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>合并多个空行为一个空行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">^</code> 和 <code class="language-plaintext highlighter-rouge">M-</code> 显示不可打印字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>在每行的结尾显示 <code class="language-plaintext highlighter-rouge">$</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-T</code></td> <td>将制表符显示为 <code class="language-plaintext highlighter-rouge">^I</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -E</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>等价于 <code class="language-plaintext highlighter-rouge">-v -T</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-</code></td> <td>从标准输入读取内容</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">cat</code> 可以直接创建带有内容的文件或者追加内容到文件中，例如 <code class="language-plaintext highlighter-rouge">cat &gt; file</code> 会等待输入，当输入完成 后，使用 <code class="language-plaintext highlighter-rouge">^D</code> (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 <code class="language-plaintext highlighter-rouge">cat &gt;&gt; file</code>。</p> <p><code class="language-plaintext highlighter-rouge">-</code> 可以出现在多个文件的任意位置，例如 <code class="language-plaintext highlighter-rouge">cat file1 - file2</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，而 <code class="language-plaintext highlighter-rouge">cat file1 - file2 - file3</code> 表示将标准输入中读取到的内容放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容之间，<code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，然后输入第二次，再次使用 <code class="language-plaintext highlighter-rouge">^D</code> 结束，第一次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file1</code> 和 <code class="language-plaintext highlighter-rouge">file2</code> 的内容 之间，第二次输入的内容会放置在 <code class="language-plaintext highlighter-rouge">file2</code> 和 <code class="language-plaintext highlighter-rouge">file3</code> 的内容之间。</p> <p>补充：<code class="language-plaintext highlighter-rouge">tac</code> 可以将文件内容逆序输出 (优先输出最后一行)，<code class="language-plaintext highlighter-rouge">tac</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">cat</code> 的逆序。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">cat</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">concatenate</code>，即连接的意思，其可以将多个文件的内容拼接在一起。</p> <h2 id="grep"><code class="language-plaintext highlighter-rouge">grep</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归搜索目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--include "*.py"</code></td> <td>搜索指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude "test*"</code></td> <td>排除指定文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude-dir "test*"</code></td> <td>排除指定目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--color=auto,always,never</code></td> <td>何时进行高亮</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>显示行号。这里的行号指的是文件中的行号</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>只显示文件名。当对多个文件中的内容进行匹配时，使用 <code class="language-plaintext highlighter-rouge">-l</code> 会在匹配成功时只显示文件名，而不是文件中具体的位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>只显示不含有任何匹配的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>反向匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>显示匹配次数。使用 <code class="language-plaintext highlighter-rouge">-v</code> 时，显示反向匹配的数量</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-o</code></td> <td>只显示匹配的部分</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-m</code></td> <td>指定匹配的次数。例如 <code class="language-plaintext highlighter-rouge">-m 1</code> 表示当有多个匹配的时候只显示第一个匹配。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>从文件中读取模式。文件中每行一个模式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>指定模式。可以指定多个模式，例如 <code class="language-plaintext highlighter-rouge">grep -e pattern1 -e pattern2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>只匹配整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A 2</code></td> <td>显示匹配行的后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-B 2</code></td> <td>显示匹配行的前两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C 2</code></td> <td>显示匹配行的前两行和后两行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-E</code></td> <td>使用扩展正则表达式</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>显示文件名。默认情况下，当只有一个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 不会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-H</code> 可以强制显示文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>不显示文件名。默认情况下，当有多个文件时，<code class="language-plaintext highlighter-rouge">grep</code> 会显示文件名，而使用 <code class="language-plaintext highlighter-rouge">-h</code> 可以强制不显示文件名</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-m 1</code> 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。</p> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">grep</code> 的正则表达式是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的基本正则表达式，而 <code class="language-plaintext highlighter-rouge">egrep</code> 和 <code class="language-plaintext highlighter-rouge">grep -E</code> 是基于 <code class="language-plaintext highlighter-rouge">POSIX</code> 的扩展正则表达式。<code class="language-plaintext highlighter-rouge">grep</code> 和 <code class="language-plaintext highlighter-rouge">egrep</code> 的区别在于 <code class="language-plaintext highlighter-rouge">egrep</code> 默认使用扩展正则表达式，而 <code class="language-plaintext highlighter-rouge">grep</code> 默认使用基本 正则表达式。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">grep</code> 的名字来源于 <code class="language-plaintext highlighter-rouge">g/re/p</code>，其中 <code class="language-plaintext highlighter-rouge">g</code> 表示 <code class="language-plaintext highlighter-rouge">global</code>，<code class="language-plaintext highlighter-rouge">re</code> 表示 <code class="language-plaintext highlighter-rouge">regular expression</code>，<code class="language-plaintext highlighter-rouge">p</code> 表示 <code class="language-plaintext highlighter-rouge">print</code>，直译即全局正则表达式打印。</p> <h2 id="sort"><code class="language-plaintext highlighter-rouge">sort</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>逆序排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-n</code></td> <td>按照数字排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-k</code></td> <td>按照某一列排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>去重</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>忽略大小写。默认情况下，大写会在所有小写的前面，而使用 <code class="language-plaintext highlighter-rouge">-f</code> 可以让大小写混合在一起排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-h</code></td> <td>人类可读的排序。例如 <code class="language-plaintext highlighter-rouge">1K</code> 会被排序到 <code class="language-plaintext highlighter-rouge">512</code> 的前面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-M</code></td> <td>按照月份排序</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=-</code></td> <td>从标准输入读取以 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--files0-form=filename</code></td> <td>从某个文件中读取 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符的多个文件内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>检查文件是否已经排序</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">-k</code> 可以指定多个列，例如 <code class="language-plaintext highlighter-rouge">-k2,2 -k1,1</code> 表示先按照第二列排序，然后再按照第一列排序。<code class="language-plaintext highlighter-rouge">-k</code> 也 按照某列的部分进行排序，例如 <code class="language-plaintext highlighter-rouge">-k2.2,2.3</code> 表示按照第二列的第二个字符到第三个字符进行排序。<code class="language-plaintext highlighter-rouge">-k</code> 还可以 指定列的类型，例如 <code class="language-plaintext highlighter-rouge">-k2n,2</code> 表示按照第二列的数字进行排序。<code class="language-plaintext highlighter-rouge">-r</code> 选项也可以指定到 <code class="language-plaintext highlighter-rouge">-k</code> 选项中，例如 <code class="language-plaintext highlighter-rouge">-k2r,2</code> 表示按照第二列逆序排序。</p> <h2 id="awk"><code class="language-plaintext highlighter-rouge">awk</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-F</code></td> <td>指定输入的分隔符。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">awk</code> 脚本文件。</td> </tr> </tbody> </table> <h3 id="打印列">打印列</h3> <ul> <li><code class="language-plaintext highlighter-rouge">$0</code>: 整行</li> <li><code class="language-plaintext highlighter-rouge">$1</code>: 第一列</li> <li><code class="language-plaintext highlighter-rouge">...</code></li> <li><code class="language-plaintext highlighter-rouge">$NF</code>: 最后一列</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}'</code> 打印出每行的第一列、第二列和最后一列。</p> <h3 id="分隔符">分隔符</h3> <p>可以通过 <code class="language-plaintext highlighter-rouge">OFS=</code> (Output Field Separator) 来指定输出的分隔符，例如 <code class="language-plaintext highlighter-rouge">awk '{print $1,$2,$NF}' OFS=","</code> 表示使用 <code class="language-plaintext highlighter-rouge">,</code> 作为分隔符。也可以在 <code class="language-plaintext highlighter-rouge">BEGIN</code> 模式串中指定 <code class="language-plaintext highlighter-rouge">OFS</code>，例如 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {OFS=","} {print $1,$2,$NF}'</code>。</p> <p>除了 <code class="language-plaintext highlighter-rouge">OFS</code> 以外，还有 <code class="language-plaintext highlighter-rouge">FS</code> 用于指定输入文件的分隔符。</p> <h3 id="预定义变量">预定义变量</h3> <p>除了之前提到的 <code class="language-plaintext highlighter-rouge">OFS</code>, <code class="language-plaintext highlighter-rouge">FS</code> 之外，还有一些预定义变量：</p> <ul> <li><code class="language-plaintext highlighter-rouge">NR</code>: 当前行的行号</li> <li><code class="language-plaintext highlighter-rouge">NF</code>: 当前行的列数</li> <li><code class="language-plaintext highlighter-rouge">RS</code>：记录分隔符，默认是换行符，也就是每一行作为一条记录</li> <li><code class="language-plaintext highlighter-rouge">ORS</code>：输出的记录分隔符，默认是换行符</li> <li><code class="language-plaintext highlighter-rouge">FILENAME</code>：当前文件的文件名</li> <li><code class="language-plaintext highlighter-rouge">FNR</code>：当前文件的行号，当时用多个文件的时候，<code class="language-plaintext highlighter-rouge">NR</code> 记录的是当前的总行号，而 <code class="language-plaintext highlighter-rouge">FNR</code> 记录的是当前文件的行号</li> </ul> <p>我们可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1'</code> 从第二行开始打印，也可以使用 <code class="language-plaintext highlighter-rouge">awk 'NF &gt; 0'</code> 打印列数大于 <code class="language-plaintext highlighter-rouge">0</code> 的行 (也就是移除空行)。</p> <p>如果要打印第一行到第四行，我们可以通过 <code class="language-plaintext highlighter-rouge">awk 'NR == 1, NR == 4'</code> 来实现。其中的 <code class="language-plaintext highlighter-rouge">,</code> 表示范围，<code class="language-plaintext highlighter-rouge">NR == 1</code> 表示第一行，<code class="language-plaintext highlighter-rouge">NR == 4</code> 表示第四行。我们还可以使用 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 &amp;&amp; NR &lt; 5'</code> 来实现。</p> <h3 id="模式">模式</h3> <p><code class="language-plaintext highlighter-rouge">BEGIN</code> 和 <code class="language-plaintext highlighter-rouge">END</code> 模式串：</p> <ul> <li><code class="language-plaintext highlighter-rouge">BEGIN</code>: 在处理输入之前执行</li> <li><code class="language-plaintext highlighter-rouge">END</code>: 在处理输入之后执行</li> </ul> <p>例如可以使用 <code class="language-plaintext highlighter-rouge">awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}'</code> 来在处理输入之前和之后 打印出 <code class="language-plaintext highlighter-rouge">Start</code> 和 <code class="language-plaintext highlighter-rouge">End</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中可以使用模式来过滤行，例如 <code class="language-plaintext highlighter-rouge">awk '$1 &gt; 10'</code> 表示只打印第一列大于 <code class="language-plaintext highlighter-rouge">10</code> 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern/'</code> 表示只打印包含 <code class="language-plaintext highlighter-rouge">pattern</code> 的行，搜索 模式支持正则表达式。</p> <p><code class="language-plaintext highlighter-rouge">,</code> 也可以和搜索模式一起使用，例如 <code class="language-plaintext highlighter-rouge">awk '/pattern1/,/pattern2/'</code> 表示打印找到的 <code class="language-plaintext highlighter-rouge">pattern1</code> 到 <code class="language-plaintext highlighter-rouge">pattern2</code> 的行。</p> <p><code class="language-plaintext highlighter-rouge">~</code> 可以用来表示是否与搜索模式匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 ~ /pattern/'</code> 表示第一列是否包含 <code class="language-plaintext highlighter-rouge">pattern</code>。<code class="language-plaintext highlighter-rouge">!~</code> 可以 用来表示是否不匹配，例如 <code class="language-plaintext highlighter-rouge">awk '$1 !~ /pattern/'</code> 表示第一列是否不包含 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h3 id="awk-脚本"><code class="language-plaintext highlighter-rouge">awk</code> 脚本</h3> <p>我们也可以书写 <code class="language-plaintext highlighter-rouge">awk</code> 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数：</p> <div class="language-awk highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#! /usr/bin/awk -f</span>

<span class="kr">BEGIN</span> <span class="p">{</span>
    <span class="c1"># 设置输入和输出的分隔符</span>
    <span class="kc">FS</span><span class="o">=</span><span class="s2">":"</span>
    <span class="kc">OFS</span><span class="o">=</span><span class="s2">" "</span>
    <span class="nx">tot_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="kc">NF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">words</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="o">++</span>
        <span class="nx">tot_count</span><span class="o">++</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">END</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s2">"Total words:"</span><span class="p">,</span> <span class="nx">tot_count</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">word</span> <span class="o">in</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="nx">word</span><span class="p">,</span> <span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：由于在 <code class="language-plaintext highlighter-rouge">awk file</code> 的意思是对某个文件的内容进行处理，所以要用 <code class="language-plaintext highlighter-rouge">awk -f file</code> 来表示将文件作为 脚本执行。</p> <h3 id="内置函数">内置函数</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中还有一些内置函数，例如 <code class="language-plaintext highlighter-rouge">length</code> 函数可以返回字符串的长度，<code class="language-plaintext highlighter-rouge">substr</code> 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc</code>。</p> <p>在 <code class="language-plaintext highlighter-rouge">awk</code> 中，<code class="language-plaintext highlighter-rouge">print</code> 会在输出的字符串后面自动添加换行符，而 <code class="language-plaintext highlighter-rouge">printf</code> 可以进行格式化输出，上面的例子中 我们通过 <code class="language-plaintext highlighter-rouge">printf</code> 来输出不带换行符的字符串。在 <code class="language-plaintext highlighter-rouge">awk</code> 中字符串是可以直接拼接的，例如 <code class="language-plaintext highlighter-rouge">printf "%s", $NF"+"</code> 表示将最后一列的值和 <code class="language-plaintext highlighter-rouge">+</code> 拼接在一起。</p> <p><code class="language-plaintext highlighter-rouge">printf</code> 的格式化方法与 <code class="language-plaintext highlighter-rouge">C/C++</code> 中的类似，这里不再进行详细介绍。</p> <p>当然要实现同样的功能有更简单的命令：<code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { sum+=$NF } END { print sum }'</code> 或者 <code class="language-plaintext highlighter-rouge">awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""</code>。</p> <p><strong>注意</strong>：在 <code class="language-plaintext highlighter-rouge">awk</code> 中，下标是从 <code class="language-plaintext highlighter-rouge">1</code> 开始的，而不是从 <code class="language-plaintext highlighter-rouge">0</code> 开始的，且区间是闭区间。</p> <p>这里再列出一些常用的内置函数：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tolower</code>：将字符串转换为小写</li> <li><code class="language-plaintext highlighter-rouge">toupper</code>：将字符串转换为大写</li> <li><code class="language-plaintext highlighter-rouge">split</code>：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 <code class="language-plaintext highlighter-rouge">split($0, words, /:+/)</code> 表示 将当前行按照 <code class="language-plaintext highlighter-rouge">:</code> (或者多个连续的 <code class="language-plaintext highlighter-rouge">:</code>) 分割为数组。</li> <li><code class="language-plaintext highlighter-rouge">gsub</code>：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 <code class="language-plaintext highlighter-rouge">gsub(/pattern/, "replace", $0)</code> 表示将当前行中的 <code class="language-plaintext highlighter-rouge">pattern</code> 替换为 <code class="language-plaintext highlighter-rouge">replace</code>。</li> <li><code class="language-plaintext highlighter-rouge">system</code>：执行系统命令，例如 <code class="language-plaintext highlighter-rouge">system("ls")</code> 会执行 <code class="language-plaintext highlighter-rouge">ls</code> 命令并将结果输出到标准输出。</li> </ul> <h3 id="改变分隔符">改变分隔符</h3> <p>前面介绍到 <code class="language-plaintext highlighter-rouge">FS</code> 和 <code class="language-plaintext highlighter-rouge">OFS</code> 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 <code class="language-plaintext highlighter-rouge">awk '{print}' FS=':' OFS=' '</code> 这样的命令，试图将 <code class="language-plaintext highlighter-rouge">:</code> 改成空格。但是这样并不能正确工作，在 <code class="language-plaintext highlighter-rouge">awk</code> 中 只有当列被修改后 (或者在 <code class="language-plaintext highlighter-rouge">print</code> 中打印多个 <code class="language-plaintext highlighter-rouge">fields</code> 的时候) 才会使用新的输出分隔符，所以我们可以通过 <code class="language-plaintext highlighter-rouge">awk '($1=$1) || 1' FS=':' OFS=' '</code> 来实现 (这里省略了动作，因此会打印一整行)。</p> <p>这里的 <code class="language-plaintext highlighter-rouge">($1=$1) || 1</code> 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 <code class="language-plaintext highlighter-rouge">awk</code> 中被当作 <code class="language-plaintext highlighter-rouge">false</code>，所以我们需要通过 <code class="language-plaintext highlighter-rouge">|| 1</code> 来保证输出。这里的括号是必须的，如果没有括号， <code class="language-plaintext highlighter-rouge">$1=$1 || 1</code> 会被解释为 <code class="language-plaintext highlighter-rouge">$1=($1 || 1)</code>，这样会将 <code class="language-plaintext highlighter-rouge">$1</code> 赋值为 <code class="language-plaintext highlighter-rouge">1</code>，而不是保留原来的值。</p> <p>题外话：<code class="language-plaintext highlighter-rouge">awk</code> 的名字来源于三个创始人的名字 <code class="language-plaintext highlighter-rouge">Alfred Aho</code>、<code class="language-plaintext highlighter-rouge">Peter Weinberger</code> 和 <code class="language-plaintext highlighter-rouge">Brian Kernighan</code> 的 首字母。</p> <h3 id="posix-字符类"><code class="language-plaintext highlighter-rouge">POSIX</code> 字符类</h3> <p><code class="language-plaintext highlighter-rouge">awk</code> 中支持 <code class="language-plaintext highlighter-rouge">POSIX</code> 字符类：</p> <ul> <li><code class="language-plaintext highlighter-rouge">[:alnum:]</code>：字母和数字</li> <li><code class="language-plaintext highlighter-rouge">[:alpha:]</code>：字母</li> <li><code class="language-plaintext highlighter-rouge">[:blank:]</code>：空格和制表符</li> <li><code class="language-plaintext highlighter-rouge">[:cntrl:]</code>：控制字符</li> <li><code class="language-plaintext highlighter-rouge">[:digit:]</code>：数字</li> <li><code class="language-plaintext highlighter-rouge">[:graph:]</code>：可打印字符，不包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:lower:]</code>：小写字母</li> <li><code class="language-plaintext highlighter-rouge">[:print:]</code>：可打印字符，包括空格</li> <li><code class="language-plaintext highlighter-rouge">[:punct:]</code>：标点符号</li> <li><code class="language-plaintext highlighter-rouge">[:space:]</code>：空白字符</li> <li><code class="language-plaintext highlighter-rouge">[:upper:]</code>：大写字母</li> <li><code class="language-plaintext highlighter-rouge">[:xdigit:]</code>：十六进制数字</li> </ul> <p>例如，我们可以使用 <code class="language-plaintext highlighter-rouge">awk '/[[:digit:]]/'</code> 来匹配包含数字的行。当然也可以写成 <code class="language-plaintext highlighter-rouge">awk '/[0-9]/'</code>。</p> <h2 id="find"><code class="language-plaintext highlighter-rouge">find</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-type</code></td> <td>指定文件类型。<code class="language-plaintext highlighter-rouge">f</code> 表示普通文件，<code class="language-plaintext highlighter-rouge">d</code> 表示目录，<code class="language-plaintext highlighter-rouge">l</code> 表示符号链接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-readable</code></td> <td>查找可读文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-writable</code></td> <td>查找可写文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-executable</code></td> <td>查找可执行文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-name</code></td> <td>指定文件名。可以使用 <code class="language-plaintext highlighter-rouge">wildcads</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-path</code></td> <td>指定路径。可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iname</code></td> <td>忽略大小写的文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ipath</code></td> <td>忽略大小写的路径</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-empty</code></td> <td>查找空文件或者空目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-perm</code></td> <td>指定权限。例如 <code class="language-plaintext highlighter-rouge">-perm 644</code> 表示查找权限为 <code class="language-plaintext highlighter-rouge">644</code> 的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mtime</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mtime +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-atime</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-atime +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-ctime</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-ctime +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 天前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mmin</code></td> <td>指定修改时间。例如 <code class="language-plaintext highlighter-rouge">-mmin +1</code> 表示查找修改时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-amin</code></td> <td>指定访问时间。例如 <code class="language-plaintext highlighter-rouge">-amin +1</code> 表示查找访问时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-cmin</code></td> <td>指定创建时间。例如 <code class="language-plaintext highlighter-rouge">-cmin +1</code> 表示查找创建时间在 <code class="language-plaintext highlighter-rouge">1</code> 分钟前的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-user</code></td> <td>指定拥有者</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-group</code></td> <td>指定所属组</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-delete</code></td> <td>删除查找到的文件或目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-maxdepth</code></td> <td>指定查找的最大深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-mindepth</code></td> <td>指定查找的最小深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-and</code></td> <td>逻辑与。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-or</code></td> <td>逻辑或。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-not</code></td> <td>逻辑非。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>不跟踪符号链接。默认行为。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-L</code></td> <td>跟踪符号链接。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-H</code></td> <td>只对命令行参数进行跟踪。例如 <code class="language-plaintext highlighter-rouge">find -H /path/to/file -name filename</code> 只对 <code class="language-plaintext highlighter-rouge">/path/to/file</code> 进行跟踪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-print0</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">NUL</code> 作为文件名分隔符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-regex</code></td> <td>使用正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-iregex</code></td> <td>使用忽略大小写的正则表达式匹配文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-samefile</code></td> <td>指定文件的硬链接。例如 <code class="language-plaintext highlighter-rouge">find . -samefile file</code> 表示查找和 <code class="language-plaintext highlighter-rouge">file</code> 硬链接的文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-links</code></td> <td>指定文件的硬链接数。例如 <code class="language-plaintext highlighter-rouge">find . -links 2</code> 表示查找硬链接数为 <code class="language-plaintext highlighter-rouge">2</code> 的文件，<code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 可以用来表示大于和小于</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">-type</code> 还可以以下类型有：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块设备文件</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字符设备文件</li> <li><code class="language-plaintext highlighter-rouge">p</code>：管道文件</li> <li><code class="language-plaintext highlighter-rouge">s</code>：套接字文件</li> </ul> <p><strong>注意</strong>：使用正则表达式匹配含有某个字符的文件名时，需要使用 <code class="language-plaintext highlighter-rouge">.*</code> 来表示任意数量的字符，例如 <code class="language-plaintext highlighter-rouge">find . -regex ".*pattern.*"</code>，而不能直接使用 <code class="language-plaintext highlighter-rouge">find . -regex "pattern"</code>。</p> <p><strong>注意</strong>：如果要使用复杂的逻辑表达式，需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来分组，例如 <code class="language-plaintext highlighter-rouge">find . \( -name "*.txt" -or -name "*.md" \)</code> 表示查找所有 <code class="language-plaintext highlighter-rouge">txt</code> 或者 <code class="language-plaintext highlighter-rouge">md</code> 文件，其中的括号需要进行转义。</p> <h3 id="指定文件大小">指定文件大小</h3> <p><code class="language-plaintext highlighter-rouge">-size</code> 参数有以下几种单位：</p> <ul> <li><code class="language-plaintext highlighter-rouge">b</code>：块，取决于文件系统，默认是 <code class="language-plaintext highlighter-rouge">512</code> 字节</li> <li><code class="language-plaintext highlighter-rouge">c</code>：字节</li> <li><code class="language-plaintext highlighter-rouge">k</code>：千字节 (1024 字节)</li> <li><code class="language-plaintext highlighter-rouge">M</code>：兆字节 (1024 千字节)</li> <li><code class="language-plaintext highlighter-rouge">G</code>：吉字节 (1024 兆字节)</li> </ul> <p>知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 <code class="language-plaintext highlighter-rouge">find . -size 1M</code> 表示查找大小为 <code class="language-plaintext highlighter-rouge">1</code> 兆字节的文件。</p> <p>但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code> 来表示大于和小于，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件，<code class="language-plaintext highlighter-rouge">find . -size -1M</code> 表示查找小于 <code class="language-plaintext highlighter-rouge">1MB</code> 的文件。 这两者也可以结合使用，例如 <code class="language-plaintext highlighter-rouge">find . -size +1M -size -2M</code> 表示查找大于 <code class="language-plaintext highlighter-rouge">1MB</code> 且小于 <code class="language-plaintext highlighter-rouge">2MB</code> 的文件。</p> <h3 id="对查找到的文件执行操作">对查找到的文件执行操作</h3> <p><code class="language-plaintext highlighter-rouge">-exec</code> 可以对查找到的文件执行操作，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec cat {} \;</code> 表示查找当前目录下的 所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并将其内容输出到标准输出。<code class="language-plaintext highlighter-rouge">{}</code> 会被替换为查找到的文件名，<code class="language-plaintext highlighter-rouge">\;</code> 表示结束。</p> <p>也可以使用 <code class="language-plaintext highlighter-rouge">grep</code> 命令过滤查找到的文件，例如 <code class="language-plaintext highlighter-rouge">find . -name "*.txt" -exec grep "pattern" {} \;</code> 表示查找 当前目录下的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件并在其中查找 <code class="language-plaintext highlighter-rouge">pattern</code>。</p> <h2 id="tar"><code class="language-plaintext highlighter-rouge">tar</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-c</code></td> <td>创建文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>指定文件名</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-z</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">gzip</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-j</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">bzip2</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-J</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">xz</code> 压缩或解压</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-x</code></td> <td>提取文档</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>指定提取的目录</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>查看文档内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--wildcards</code></td> <td>使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 匹配文件。例如 <code class="language-plaintext highlighter-rouge">tar -xf a.tar --wildcards '*.txt'</code> 可以提取 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--delete</code></td> <td>删除文档中的文件。例如 <code class="language-plaintext highlighter-rouge">tar -f a.tar --delete '*.txt'</code> 可以删除 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">--exclude=</code></td> <td>排除文件。例如 <code class="language-plaintext highlighter-rouge">tar -cf a.tar --exclude=*.txt .</code> 可以创建 <code class="language-plaintext highlighter-rouge">a.tar</code> 时排除所有 <code class="language-plaintext highlighter-rouge">txt</code> 文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>向文档中追加文件。例如 <code class="language-plaintext highlighter-rouge">tar -rf a.tar b.txt</code> 可以将 <code class="language-plaintext highlighter-rouge">b.txt</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-A</code></td> <td>向文档中追加另一个文档。例如 <code class="language-plaintext highlighter-rouge">tar -Af a.tar b.tar</code> 可以将 <code class="language-plaintext highlighter-rouge">b.tar</code> 追加到 <code class="language-plaintext highlighter-rouge">a.tar</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-W</code></td> <td>检验文档。例如 <code class="language-plaintext highlighter-rouge">tar -Wf a.tar</code> 可以检验 <code class="language-plaintext highlighter-rouge">a.tar</code> 的完整性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-u</code></td> <td>更新文档。例如 <code class="language-plaintext highlighter-rouge">tar -uf a.tar b.txt</code> 可以更新 <code class="language-plaintext highlighter-rouge">a.tar</code> 中的 <code class="language-plaintext highlighter-rouge">b.txt</code> 文件</td> </tr> </tbody> </table> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">--exclude</code> 时必须使用 <code class="language-plaintext highlighter-rouge">=</code> 进行连接，且 <code class="language-plaintext highlighter-rouge">--exclude</code> 要出现在待打包文件之前。 <code class="language-plaintext highlighter-rouge">tar -cf a.tar . --exclude=*.txt</code> 是错误用法。</p> <p><strong>注意</strong>：在使用 <code class="language-plaintext highlighter-rouge">-u</code> 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 <code class="language-plaintext highlighter-rouge">tar</code> 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。</p> <h2 id="ln"><code class="language-plaintext highlighter-rouge">ln</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>创建软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-f</code></td> <td>强制创建。如果软连接已经存在，会覆盖原有的软连接</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-t</code></td> <td>指定连接的目标目录。<code class="language-plaintext highlighter-rouge">ln -t dir target</code> 与 <code class="language-plaintext highlighter-rouge">ln target dir</code> 效果相同</td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">ln target link_name</code> 创建的时候如果 <code class="language-plaintext highlighter-rouge">link_name</code> 是一个目录，那么会在目录下创建一个名为 <code class="language-plaintext highlighter-rouge">target</code> 的文件。</p> <p><code class="language-plaintext highlighter-rouge">ln</code> 默认创建硬连接。</p> <p>使用 <code class="language-plaintext highlighter-rouge">rm</code> 和 <code class="language-plaintext highlighter-rouge">unlink</code> 命令均可以删除软连接或者硬连接。但是 <code class="language-plaintext highlighter-rouge">unlink</code> 一次只能删除一个文件，而 <code class="language-plaintext highlighter-rouge">rm</code> 可以删除多个文件。</p> <h3 id="硬连接与软连接">硬连接与软连接</h3> <p><code class="language-plaintext highlighter-rouge">ln</code> 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 <code class="language-plaintext highlighter-rouge">inode</code>，而软连接是指一个文件指向 另一个文件。除此之外，硬连接和软连接还有以下区别：</p> <ul> <li>软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件</li> <li>软连接可以指向目录，而硬连接不能指向目录</li> <li>源文件被删除的时候，硬连接不会受到影响，而软连接会失效</li> </ul> <p>在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，可以通过 <code class="language-plaintext highlighter-rouge">ls -l</code> 命令查看文件的硬连接数 (第二列为硬连接数)，硬连接数为 <code class="language-plaintext highlighter-rouge">1</code> 表示只有一个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>，而硬连接数大于 <code class="language-plaintext highlighter-rouge">1</code> 表示有多个文件指向该 <code class="language-plaintext highlighter-rouge">inode</code>。</p> <h2 id="scp"><code class="language-plaintext highlighter-rouge">scp</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>递归复制。如果复制的是目录，需要使用 <code class="language-plaintext highlighter-rouge">-r</code> 选项</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-P</code></td> <td>指定端口。默认端口是 <code class="language-plaintext highlighter-rouge">22</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-p</code></td> <td>保留文件属性 (例如修改时间等)。默认情况下，<code class="language-plaintext highlighter-rouge">scp</code> 不会保留文件的属性，使用 <code class="language-plaintext highlighter-rouge">-p</code> 可以保留文件的属性</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-q</code></td> <td>静默模式。不显示进度信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-v</code></td> <td>显示详细信息。可以使用多个 <code class="language-plaintext highlighter-rouge">-v</code> 来显示更多的信息</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-C</code></td> <td>压缩传输。使用 <code class="language-plaintext highlighter-rouge">-C</code> 可以压缩传输的数据</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>指定密钥文件。默认情况下，<code class="language-plaintext highlighter-rouge">scp</code> 使用 <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code> 作为密钥文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>限制带宽。单位是 <code class="language-plaintext highlighter-rouge">Kb/s</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-3</code></td> <td>通过本机在两个远端之间传输文件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-4</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv4</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-6</code></td> <td>强制使用 <code class="language-plaintext highlighter-rouge">IPv6</code></td> </tr> </tbody> </table> <p>使用 <code class="language-plaintext highlighter-rouge">scp</code> 的时候，如果在 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 中配置了主机信息，可以直接使用主机名进行传输，例如 <code class="language-plaintext highlighter-rouge">scp file host_name:/path/to/file</code>。</p> <p><code class="language-plaintext highlighter-rouge">scp</code> 可以一次拷贝多个文件，例如 <code class="language-plaintext highlighter-rouge">scp file1 file2 host_name:/path/to/</code>。</p> <h2 id="apropos"><code class="language-plaintext highlighter-rouge">apropos</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>逻辑与。可用于匹配多个关键字，例如 <code class="language-plaintext highlighter-rouge">apropos -a keyword1 keyword2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-e</code></td> <td>精确匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-w</code></td> <td>匹配带有 <code class="language-plaintext highlighter-rouge">Shell</code> 支持的通配符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-r</code></td> <td>使用正则表达式匹配</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-l</code></td> <td>不依照终端宽度进行裁剪</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-s</code></td> <td>指定 <code class="language-plaintext highlighter-rouge">man</code> 手册的节。例如 <code class="language-plaintext highlighter-rouge">apropos -s 3 keyword</code> 表示查找第 <code class="language-plaintext highlighter-rouge">3</code> 节的手册</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">man</code> 手册的节有以下几个：</p> <ul> <li><code class="language-plaintext highlighter-rouge">1</code>：命令或程序</li> <li><code class="language-plaintext highlighter-rouge">2</code>：系统调用</li> <li><code class="language-plaintext highlighter-rouge">3</code>：库函数</li> <li><code class="language-plaintext highlighter-rouge">4</code>：特殊文件</li> <li><code class="language-plaintext highlighter-rouge">5</code>：文件格式和约定</li> <li><code class="language-plaintext highlighter-rouge">6</code>：游戏</li> <li><code class="language-plaintext highlighter-rouge">7</code>：杂项</li> <li><code class="language-plaintext highlighter-rouge">8</code>：系统管理命令</li> <li><code class="language-plaintext highlighter-rouge">9</code>：内核相关</li> </ul> <h2 id="tee"><code class="language-plaintext highlighter-rouge">tee</code></h2> <table> <thead> <tr> <th>选项</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">-a</code></td> <td>追加到文件。默认情况下，<code class="language-plaintext highlighter-rouge">tee</code> 会覆盖文件内容，使用 <code class="language-plaintext highlighter-rouge">-a</code> 可以追加到文件末尾</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-i</code></td> <td>忽略中断信号</td> </tr> </tbody> </table> <p>管道在进行传递的时候可能会遇到需要 <code class="language-plaintext highlighter-rouge">root</code> 权限的时候，这时候就需要使用 <code class="language-plaintext highlighter-rouge">sudo tee</code> 从管道中读取信息 并写入到文件中。例如 <code class="language-plaintext highlighter-rouge">echo "content" | sudo tee file</code>。</p> <h1 id="git"><code class="language-plaintext highlighter-rouge">git</code></h1> <h2 id="gitignore"><code class="language-plaintext highlighter-rouge">.gitignore</code></h2> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件用于指定不需要被 <code class="language-plaintext highlighter-rouge">git</code> 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中可以使用 <code class="language-plaintext highlighter-rouge">wildcards</code> 来指定不需要被追踪的文件或目录。</p> <h3 id="wildcards"><code class="language-plaintext highlighter-rouge">wildcards</code></h3> <p><code class="language-plaintext highlighter-rouge">.gitignore</code> 中的 <code class="language-plaintext highlighter-rouge">wildcards</code> 与 <code class="language-plaintext highlighter-rouge">bash</code> 中基本一致，可以查看 <a href="#wildcards-in-linux">Wildcards in Linux</a> 来 了解更多关于 <code class="language-plaintext highlighter-rouge">wildcards</code> 的内容。</p> <h3 id="基本用法">基本用法</h3> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只对 当前目录生效。例如 <code class="language-plaintext highlighter-rouge">/foo</code> 表示只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示忽略所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或 目录。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">.gitignore</code> 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 <code class="language-plaintext highlighter-rouge">/</code> 表示只匹配 目录。例如 <code class="language-plaintext highlighter-rouge">foo/</code> 表示只匹配目录 <code class="language-plaintext highlighter-rouge">foo</code>，而 <code class="language-plaintext highlighter-rouge">foo</code> 表示匹配所有的 <code class="language-plaintext highlighter-rouge">foo</code> 文件或目录。你可能会有疑惑： 在 <code class="language-plaintext highlighter-rouge">Linux</code> 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 <code class="language-plaintext highlighter-rouge">build/</code> 和 <code class="language-plaintext highlighter-rouge">build</code> 表示的意义是不同的，前者表示忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 目录，而后者表示 忽略所有 <code class="language-plaintext highlighter-rouge">build</code> 文件或目录。前者可以保留某个子目录下面的名为 <code class="language-plaintext highlighter-rouge">build</code> 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 <code class="language-plaintext highlighter-rouge">/build/</code> 只忽略当前目录下的 <code class="language-plaintext highlighter-rouge">build</code> 目录。</p> <h3 id="全局忽略">全局忽略</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中可以配置全局忽略文件，通常使用 <code class="language-plaintext highlighter-rouge">.git</code> 管理的仓库不需要追踪一些特定的文件，例如 <code class="language-plaintext highlighter-rouge">*.pyc</code>、 <code class="language-plaintext highlighter-rouge">*.o</code> 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 <code class="language-plaintext highlighter-rouge">~/.config/git/ignore</code>。</p> <h3 id="忽略文件优先级">忽略文件优先级</h3> <p>在 <code class="language-plaintext highlighter-rouge">git</code> 中任何一个目录下都可以有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件，那么这个文件会覆盖父目录下的文件。也就是说，<code class="language-plaintext highlighter-rouge">.gitignore</code> 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。</p> <h1 id="巨人的肩膀">巨人的肩膀</h1> <ul> <li><a href="https://www.tecmint.com/use-wildcards-to-match-filenames-in-linux/">10 Practical Examples Using Wildcards to Match Filenames in Linux</a></li> <li><a href="https://fishshell.com/docs/current/fish_for_bash_users.html#wildcards-globs">fish shell wildcards</a></li> <li><a href="https://ryanstutorials.net/linuxtutorial/cheatsheetgrep.php">Linux Tutorial - Cheat Sheet - grep</a></li> <li><a href="https://www.golinuxcloud.com/grep-command-in-linux/">20 grep command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://linuxhandbook.com/sort-command/">Linux Handbook: sort Command Examples</a></li> <li><a href="https://www.golinuxcloud.com/linux-sort-files/#1_Sort_by_name">15+ Tips to PROPERLY sort files in Linux [Cheat Sheet]</a></li> <li><a href="https://shapeshed.com/unix-sort/">Linux and Unix sort command tutorial with examples</a></li> <li><a href="https://www.baeldung.com/linux/sort-command">Linux sort Command</a></li> <li><a href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/">How to Use the awk Command on Linux</a></li> <li><a href="https://www.golinuxcloud.com/awk-examples-with-command-tutorial-unix-linux/">30+ awk examples for beginners / awk command tutorial in Linux/Unix</a></li> <li><a href="https://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/">8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR</a></li> <li><a href="https://linuxhandbook.com/awk-command-tutorial/">Getting Started With AWK Command [Beginner’s Guide]</a></li> <li><a href="https://www.golinuxcloud.com/find-command-in-linux/">25+ most used find commands in Linux [Cheat Sheet]</a></li> <li><a href="https://onecompiler.com/cheatsheets/find">find Linux Command Cheatsheet</a></li> <li><a href="https://linuxtutorials.org/linux-find-cheatsheet/">Linux Find Cheatsheet</a></li> <li><a href="https://opensource.com/article/21/9/linux-find-command">Find files and directories on Linux with the find command</a></li> <li><a href="https://www.redhat.com/sysadmin/linux-find-command">10 ways to use the Linux find command</a></li> <li><a href="https://quickref.me/find">Find cheatsheet</a></li> <li><a href="https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files">Ignoring files</a></li> <li><a href="https://www.golinuxcloud.com/cat-command-examples/">cat command examples for beginners [cheatsheet]</a></li> <li><a href="https://linux-audit.com/cheat-sheets/tar/">Linux Audit: tar cheat sheet</a></li> <li><a href="https://www.golinuxcloud.com/tar-command-in-linux/">15+ tar command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://www.golinuxcloud.com/create-symbolic-link-linux/">10+ practical examples to create symbolic link in Linux</a></li> <li><a href="https://www.golinuxcloud.com/scp-command-in-linux/">15+ scp command examples in Linux [Cheat Sheet]</a></li> <li><a href="https://phoenixnap.com/kb/apropos-linux">apropos Linux Command Explained</a></li> <li><a href="https://www.golinuxcloud.com/tee-command-in-linux/">10 tee command examples in Linux [Cheat Sheet]</a></li> </ul>]]></content><author><name></name></author><category term="Potpourri"/><category term="Linux"/><category term="CLI"/><summary type="html"><![CDATA[Wildcards in Linux 这里的 wildcards 指的是能够被 shell 扩展的符号。如果在执行的命令中出现这些符号，shell 会对这些 进行解析，解析完成后再传入需要执行的命令。也就是说只要 shell 支持，这些 wildcards 是可以在任意 命令中使用的。 常见的 wildcards 有以下几种： *：匹配任意数量( 包含 0 个 )的字符 **：递归匹配任意数量( 包含 0 个 )的字符 ?：匹配单个任意字符 []：匹配出现在中括号中的某个符号，在中括号中可以使用 - 来表示范围，也可以使用 ! 来表示取反， 例如 [!0-9] 表示匹配不是数字的字符，[!ab] 表示不是 a 也不是 b 的字符 上面的通配符并不是所有的 shell 都支持的，但是在 bash 中是支持的。例如在 fish shell 中，只有 *、** 以及 ? 是支持的，其中 * 和 ? 不会匹配 /，而 ** 会匹配 / ，也就是说 ** 是 递归匹配。 注意：在正则表达式的语法中，* 表示匹配前面的字符 0 次或者多次，? 表示匹配前面的字符 0 次或者 1 次， [] 表示匹配中括号中的任意一个字符，- 表示范围，^ 表示取反。 常用命令 Cheat Sheet cat 选项 说明 -n 显示行号 -b 显示非空行的行号 -s 合并多个空行为一个空行 -v 使用 ^ 和 M- 显示不可打印字符 -E 在每行的结尾显示 $ -T 将制表符显示为 ^I -A 等价于 -v -E -T -e 等价于 -v -E -t 等价于 -v -T - 从标准输入读取内容 使用 cat 可以直接创建带有内容的文件或者追加内容到文件中，例如 cat &gt; file 会等待输入，当输入完成 后，使用 ^D (EOF, end of file) 来结束输入。如果要追加内容到文件中，可以使用 cat &gt;&gt; file。 - 可以出现在多个文件的任意位置，例如 cat file1 - file2 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，而 cat file1 - file2 - file3 表示将标准输入中读取到的内容放置在 file1 和 file2 的内容之间，file2 和 file3 的内容之间，此时会要求输入两次，第一次输入完成后， 使用 ^D 结束，然后输入第二次，再次使用 ^D 结束，第一次输入的内容会放置在 file1 和 file2 的内容 之间，第二次输入的内容会放置在 file2 和 file3 的内容之间。 补充：tac 可以将文件内容逆序输出 (优先输出最后一行)，tac 的名字来源于 cat 的逆序。 题外话：cat 的名字来源于 concatenate，即连接的意思，其可以将多个文件的内容拼接在一起。 grep 选项 说明 -r 递归搜索目录 --include "*.py" 搜索指定文件 --exclude "test*" 排除指定文件 --exclude-dir "test*" 排除指定目录 --color=auto,always,never 何时进行高亮 -n 显示行号。这里的行号指的是文件中的行号 -l 只显示文件名。当对多个文件中的内容进行匹配时，使用 -l 会在匹配成功时只显示文件名，而不是文件中具体的位置 -L 只显示不含有任何匹配的文件名 -i 忽略大小写 -v 反向匹配 -c 显示匹配次数。使用 -v 时，显示反向匹配的数量 -o 只显示匹配的部分 -m 指定匹配的次数。例如 -m 1 表示当有多个匹配的时候只显示第一个匹配。 -f 从文件中读取模式。文件中每行一个模式 -e 指定模式。可以指定多个模式，例如 grep -e pattern1 -e pattern2 -w 只匹配完整单词。完整单词指的是前后均不是字母、数字或者下划线的部分。 -x 只匹配整行 -A 2 显示匹配行的后两行 -B 2 显示匹配行的前两行 -C 2 显示匹配行的前两行和后两行 -E 使用扩展正则表达式 -F 使用固定字符串。这个选项会将模式中的特殊字符当作普通字符对待 -H 显示文件名。默认情况下，当只有一个文件时，grep 不会显示文件名，而使用 -H 可以强制显示文件名 -h 不显示文件名。默认情况下，当有多个文件时，grep 会显示文件名，而使用 -h 可以强制不显示文件名 注意：-m 1 在有多个文件的时候，每个文件都会显示一个匹配的行，而不是总共只显示一个匹配的行。 注意：grep 的正则表达式是基于 POSIX 的基本正则表达式，而 egrep 和 grep -E 是基于 POSIX 的扩展正则表达式。grep 和 egrep 的区别在于 egrep 默认使用扩展正则表达式，而 grep 默认使用基本 正则表达式。 题外话：grep 的名字来源于 g/re/p，其中 g 表示 global，re 表示 regular expression，p 表示 print，直译即全局正则表达式打印。 sort 选项 说明 -r 逆序排序 -n 按照数字排序 -k 按照某一列排序 -u 去重 -t 指定分隔符 -f 忽略大小写。默认情况下，大写会在所有小写的前面，而使用 -f 可以让大小写混合在一起排序 -h 人类可读的排序。例如 1K 会被排序到 512 的前面 -M 按照月份排序 --files0-form=- 从标准输入读取以 NUL 作为文件名分隔符的多个文件内容 --files0-form=filename 从某个文件中读取 NUL 作为文件名分隔符的多个文件内容 -c 检查文件是否已经排序 注意：-k 可以指定多个列，例如 -k2,2 -k1,1 表示先按照第二列排序，然后再按照第一列排序。-k 也 按照某列的部分进行排序，例如 -k2.2,2.3 表示按照第二列的第二个字符到第三个字符进行排序。-k 还可以 指定列的类型，例如 -k2n,2 表示按照第二列的数字进行排序。-r 选项也可以指定到 -k 选项中，例如 -k2r,2 表示按照第二列逆序排序。 awk 选项 说明 -F 指定输入的分隔符。 -f 指定 awk 脚本文件。 打印列 $0: 整行 $1: 第一列 ... $NF: 最后一列 例如可以使用 awk '{print $1,$2,$NF}' 打印出每行的第一列、第二列和最后一列。 分隔符 可以通过 OFS=(Output Field Separator) 来指定输出的分隔符，例如 awk '{print $1,$2,$NF}' OFS="," 表示使用 , 作为分隔符。也可以在 BEGIN 模式串中指定 OFS，例如 awk 'BEGIN {OFS=","} {print $1,$2,$NF}'。 除了 OFS 以外，还有 FS 用于指定输入文件的分隔符。 预定义变量 除了之前提到的 OFS, FS 之外，还有一些预定义变量： NR: 当前行的行号 NF: 当前行的列数 RS：记录分隔符，默认是换行符，也就是每一行作为一条记录 ORS：输出的记录分隔符，默认是换行符 FILENAME：当前文件的文件名 FNR：当前文件的行号，当时用多个文件的时候，NR 记录的是当前的总行号，而 FNR 记录的是当前文件的行号 我们可以使用 awk 'NR &gt; 1' 从第二行开始打印，也可以使用 awk 'NF &gt; 0' 打印列数大于 0 的行 (也就是移除空行)。 如果要打印第一行到第四行，我们可以通过 awk 'NR == 1, NR== 4' 来实现。其中的 , 表示范围，NR == 1 表示第一行，NR == 4 表示第四行。我们还可以使用 awk 'NR &gt; 1 &amp;&amp; NR &lt; 5' 来实现。 模式 BEGIN 和 END 模式串： BEGIN: 在处理输入之前执行 END: 在处理输入之后执行 例如可以使用 awk 'BEGIN {print "Start"} {print $1,$2,$NF} END {print "End"}' 来在处理输入之前和之后 打印出 Start 和 End。 在 awk 中可以使用模式来过滤行，例如 awk '$1 &gt; 10' 表示只打印第一列大于 10 的行 (当不书写动作时， 默认动作是打印整行)。也可以使用搜索模式，例如 awk '/pattern/' 表示只打印包含 pattern 的行，搜索 模式支持正则表达式。 , 也可以和搜索模式一起使用，例如 awk '/pattern1/,/pattern2/' 表示打印找到的 pattern1 到 pattern2 的行。 ~ 可以用来表示是否与搜索模式匹配，例如 awk '$1 ~ /pattern/' 表示第一列是否包含 pattern。!~ 可以 用来表示是否不匹配，例如 awk '$1 !~ /pattern/' 表示第一列是否不包含 pattern。 awk 脚本 我们也可以书写 awk 脚本实现更加复杂的功能，例如下面的脚本可以实现统计文件中每个单词出现的次数： #! /usr/bin/awk -f BEGIN { # 设置输入和输出的分隔符 FS=":" OFS=" " tot_count=0 } { for (i = 1; i &lt;= NF; i++) { words[$i]++ tot_count++ } } END { print "Total words:", tot_count for (word in words) { print word, words[word] } } 注意：由于在 awk file 的意思是对某个文件的内容进行处理，所以要用 awk -f file 来表示将文件作为 脚本执行。 内置函数 awk 中还有一些内置函数，例如 length 函数可以返回字符串的长度，substr 函数可以返回字符串的子串， 我们可以使用下面的命令计算最后一列 (从第二行起) 的数字和： awk 'NR &gt; 1 { printf "%s",$NF"+" }' OFS="" | awk '{ print substr($0, 1, length($0) - 1) }' | bc。 在 awk 中，print 会在输出的字符串后面自动添加换行符，而 printf 可以进行格式化输出，上面的例子中 我们通过 printf 来输出不带换行符的字符串。在 awk 中字符串是可以直接拼接的，例如 printf "%s", $NF"+" 表示将最后一列的值和 + 拼接在一起。 printf 的格式化方法与 C/C++ 中的类似，这里不再进行详细介绍。 当然要实现同样的功能有更简单的命令：awk 'NR &gt; 1 { sum+=$NF } END { print sum }' 或者 awk 'NR &gt; 1 { print sep $NF; sep="+" }' OFS="" ORS=""。 注意：在 awk 中，下标是从 1 开始的，而不是从 0 开始的，且区间是闭区间。 这里再列出一些常用的内置函数： tolower：将字符串转换为小写 toupper：将字符串转换为大写 split：将字符串按照某个分隔符分割为数组，接收三个参数，第一个参数是要分割的字符串，第二个参数是 数组名，第三个参数是分隔符。在分隔符部分，我们可以传入搜索表达式，例如 split($0, words, /:+/) 表示 将当前行按照 : (或者多个连续的 :) 分割为数组。 gsub：全局替换，接收三个参数，第一个参数是查找字符串，第二个参数是替换后的字符串，第三个参数要替换 的文本，例如 gsub(/pattern/, "replace", $0) 表示将当前行中的 pattern 替换为 replace。 system：执行系统命令，例如 system("ls") 会执行 ls 命令并将结果输出到标准输出。 改变分隔符 前面介绍到 FS 和 OFS 可以指定输入和输出的分隔符。如果我们想要直接改变分隔符后输出，我们可能会写出 awk '{print}' FS=':' OFS=' ' 这样的命令，试图将 : 改成空格。但是这样并不能正确工作，在 awk 中 只有当列被修改后 (或者在 print 中打印多个 fields 的时候) 才会使用新的输出分隔符，所以我们可以通过 awk '($1=$1) || 1' FS=':' OFS=' ' 来实现 (这里省略了动作，因此会打印一整行)。 这里的 ($1=$1) || 1 是为了保证能够成功输出原始的空行，因为空行在赋值后返回的是空字符串，而空字符串在 awk 中被当作 false，所以我们需要通过 || 1 来保证输出。这里的括号是必须的，如果没有括号， $1=$1 || 1 会被解释为 $1=($1 || 1)，这样会将 $1 赋值为 1，而不是保留原来的值。 题外话：awk 的名字来源于三个创始人的名字 Alfred Aho、Peter Weinberger 和 Brian Kernighan 的 首字母。 POSIX 字符类 awk 中支持 POSIX 字符类： [:alnum:]：字母和数字 [:alpha:]：字母 [:blank:]：空格和制表符 [:cntrl:]：控制字符 [:digit:]：数字 [:graph:]：可打印字符，不包括空格 [:lower:]：小写字母 [:print:]：可打印字符，包括空格 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制数字 例如，我们可以使用 awk '/[[:digit:]]/' 来匹配包含数字的行。当然也可以写成 awk '/[0-9]/'。 find 选项 说明 -type 指定文件类型。f 表示普通文件，d 表示目录，l 表示符号链接 -readable 查找可读文件或目录 -writable 查找可写文件或目录 -executable 查找可执行文件或目录 -name 指定文件名。可以使用 wildcads -path 指定路径。可以使用 wildcards -iname 忽略大小写的文件名 -ipath 忽略大小写的路径 -empty 查找空文件或者空目录 -perm 指定权限。例如 -perm 644 表示查找权限为 644 的文件或目录 -mtime 指定修改时间。例如 -mtime +1 表示查找修改时间在 1 天前的文件或目录 -atime 指定访问时间。例如 -atime +1 表示查找访问时间在 1 天前的文件或目录 -ctime 指定创建时间。例如 -ctime +1 表示查找创建时间在 1 天前的文件或目录 -mmin 指定修改时间。例如 -mmin +1 表示查找修改时间在 1 分钟前的文件或目录 -amin 指定访问时间。例如 -amin +1 表示查找访问时间在 1 分钟前的文件或目录 -cmin 指定创建时间。例如 -cmin +1 表示查找创建时间在 1 分钟前的文件或目录 -user 指定拥有者 -group 指定所属组 -delete 删除查找到的文件或目录 -maxdepth 指定查找的最大深度 -mindepth 指定查找的最小深度 -and 逻辑与。 -or 逻辑或。 -not 逻辑非。 -P 不跟踪符号链接。默认行为。 -L 跟踪符号链接。 -H 只对命令行参数进行跟踪。例如 find -H /path/to/file -name filename 只对 /path/to/file 进行跟踪 -print0 使用 NUL 作为文件名分隔符 -regex 使用正则表达式匹配文件名 -iregex 使用忽略大小写的正则表达式匹配文件名 -samefile 指定文件的硬链接。例如 find . -samefile file 表示查找和 file 硬链接的文件 -links 指定文件的硬链接数。例如 find . -links 2 表示查找硬链接数为 2 的文件，+ 和 - 可以用来表示大于和小于 -type 还可以以下类型有： b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 注意：使用正则表达式匹配含有某个字符的文件名时，需要使用 .* 来表示任意数量的字符，例如 find . -regex ".*pattern.*"，而不能直接使用 find . -regex "pattern"。 注意：如果要使用复杂的逻辑表达式，需要使用 () 来分组，例如 find . \( -name "*.txt" -or -name "*.md" \) 表示查找所有 txt 或者 md 文件，其中的括号需要进行转义。 指定文件大小 -size 参数有以下几种单位： b：块，取决于文件系统，默认是 512 字节 c：字节 k：千字节 (1024 字节) M：兆字节 (1024 千字节) G：吉字节 (1024 兆字节) 知道了上述单位后，查找某个固定大小的文件只需要指定大小和单位即可，例如 find . -size 1M 表示查找大小为 1 兆字节的文件。 但是通常我们会查找大于或者小于某个大小的文件，这时候我们可以使用 + 和 - 来表示大于和小于，例如 find . -size +1M 表示查找大于 1MB 的文件，find . -size -1M 表示查找小于 1MB 的文件。 这两者也可以结合使用，例如 find . -size +1M -size -2M 表示查找大于 1MB 且小于 2MB 的文件。 对查找到的文件执行操作 -exec 可以对查找到的文件执行操作，例如 find . -name "*.txt" -exec cat {} \; 表示查找当前目录下的 所有 txt 文件并将其内容输出到标准输出。{} 会被替换为查找到的文件名，\; 表示结束。 也可以使用 grep 命令过滤查找到的文件，例如 find . -name "*.txt" -exec grep "pattern" {} \; 表示查找 当前目录下的所有 txt 文件并在其中查找 pattern。 tar 选项 说明 -c 创建文档 -f 指定文件名 -v 显示详细信息 -z 使用 gzip 压缩或解压 -j 使用 bzip2 压缩或解压 -J 使用 xz 压缩或解压 -x 提取文档 -C 指定提取的目录 -t 查看文档内容 --wildcards 使用 wildcards 匹配文件。例如 tar -xf a.tar --wildcards '*.txt' 可以提取 a.tar 中的所有 txt 文件 --delete 删除文档中的文件。例如 tar -f a.tar --delete '*.txt' 可以删除 a.tar 中的所有 txt 文件 --exclude= 排除文件。例如 tar -cf a.tar --exclude=*.txt . 可以创建 a.tar 时排除所有 txt 文件 -r 向文档中追加文件。例如 tar -rf a.tar b.txt 可以将 b.txt 追加到 a.tar 中 -A 向文档中追加另一个文档。例如 tar -Af a.tar b.tar 可以将 b.tar 追加到 a.tar 中 -W 检验文档。例如 tar -Wf a.tar 可以检验 a.tar 的完整性 -u 更新文档。例如 tar -uf a.tar b.txt 可以更新 a.tar 中的 b.txt 文件 注意：在使用 --exclude 时必须使用 = 进行连接，且 --exclude 要出现在待打包文件之前。 tar -cf a.tar . --exclude=*.txt 是错误用法。 注意：在使用 -u 的时候，并不会覆盖旧的文件，而是直接追加新的文件，这样 tar 文件中可能会有多个 同名的文件，目前我并没有找到如何提取旧文件的方法。 ln 选项 说明 -s 创建软连接 -f 强制创建。如果软连接已经存在，会覆盖原有的软连接 -t 指定连接的目标目录。ln -t dir target 与 ln target dir 效果相同 使用 ln target link_name 创建的时候如果 link_name 是一个目录，那么会在目录下创建一个名为 target 的文件。 ln 默认创建硬连接。 使用 rm 和 unlink 命令均可以删除软连接或者硬连接。但是 unlink 一次只能删除一个文件，而 rm 可以删除多个文件。 硬连接与软连接 ln 命令可以创建硬连接和软连接，硬连接是指多个文件指向同一个 inode，而软连接是指一个文件指向 另一个文件。除此之外，硬连接和软连接还有以下区别： 软连接可以指向不同文件系统的文件，而硬连接只能指向同一个文件系统的文件 软连接可以指向目录，而硬连接不能指向目录 源文件被删除的时候，硬连接不会受到影响，而软连接会失效 在 Linux 中，可以通过 ls -l 命令查看文件的硬连接数 (第二列为硬连接数)，硬连接数为 1 表示只有一个文件指向该 inode，而硬连接数大于 1 表示有多个文件指向该 inode。 scp 选项 说明 -r 递归复制。如果复制的是目录，需要使用 -r 选项 -P 指定端口。默认端口是 22 -p 保留文件属性 (例如修改时间等)。默认情况下，scp 不会保留文件的属性，使用 -p 可以保留文件的属性 -q 静默模式。不显示进度信息 -v 显示详细信息。可以使用多个 -v 来显示更多的信息 -C 压缩传输。使用 -C 可以压缩传输的数据 -i 指定密钥文件。默认情况下，scp 使用 ~/.ssh/id_rsa 作为密钥文件 -l 限制带宽。单位是 Kb/s -3 通过本机在两个远端之间传输文件 -4 强制使用 IPv4 -6 强制使用 IPv6 使用 scp 的时候，如果在 ~/.ssh/config 中配置了主机信息，可以直接使用主机名进行传输，例如 scp file host_name:/path/to/file。 scp 可以一次拷贝多个文件，例如 scp file1 file2 host_name:/path/to/。 apropos 选项 说明 -a 逻辑与。可用于匹配多个关键字，例如 apropos -a keyword1 keyword2 -e 精确匹配 -w 匹配带有 Shell 支持的通配符 -r 使用正则表达式匹配 -l 不依照终端宽度进行裁剪 -s 指定 man 手册的节。例如 apropos -s 3 keyword 表示查找第 3 节的手册 man 手册的节有以下几个： 1：命令或程序 2：系统调用 3：库函数 4：特殊文件 5：文件格式和约定 6：游戏 7：杂项 8：系统管理命令 9：内核相关 tee 选项 说明 -a 追加到文件。默认情况下，tee 会覆盖文件内容，使用 -a 可以追加到文件末尾 -i 忽略中断信号 管道在进行传递的时候可能会遇到需要 root 权限的时候，这时候就需要使用 sudo tee 从管道中读取信息 并写入到文件中。例如 echo "content" | sudo tee file。 git .gitignore .gitignore 文件用于指定不需要被 git 追踪的文件或目录，这些文件或目录不会被提交到版本库中。在 .gitignore 文件中可以使用 wildcards 来指定不需要被追踪的文件或目录。 wildcards .gitignore 中的 wildcards 与 bash 中基本一致，可以查看 Wildcards in Linux 来 了解更多关于 wildcards 的内容。 基本用法 默认情况下，.gitignore 中的条目会进行递归的忽略，如果不想进行递归忽略，可以在条目前加上 / 表示只对 当前目录生效。例如 /foo 表示只忽略当前目录下的 foo 文件或目录，而 foo 表示忽略所有的 foo 文件或 目录。 默认情况下，.gitignore 中的条目会匹配目录和文件，如果只想匹配目录则可以在条目末尾加上 / 表示只匹配 目录。例如 foo/ 表示只匹配目录 foo，而 foo 表示匹配所有的 foo 文件或目录。你可能会有疑惑： 在 Linux 中，同一目录下的文件和目录不能够重名，这样做的意义是什么？其实如果不进行递归匹配，确实是 没有意义的，但是 build/ 和 build 表示的意义是不同的，前者表示忽略所有 build 目录，而后者表示 忽略所有 build 文件或目录。前者可以保留某个子目录下面的名为 build 的文件，而后者却做不到这一点。 当然如前面所言，我们可以使用 /build/ 只忽略当前目录下的 build 目录。 全局忽略 在 git 中可以配置全局忽略文件，通常使用 .git 管理的仓库不需要追踪一些特定的文件，例如 *.pyc、 *.o 等，这时候我们可以配置全局忽略文件。全局忽略文件的配置文件是 ~/.config/git/ignore。 忽略文件优先级 在 git 中任何一个目录下都可以有一个 .gitignore 文件，这个文件会对当前目录下的文件和目录生效。如果 在父目录下有一个 .gitignore 文件，那么这个文件会对当前目录下的文件和目录生效，但是如果当前目录下有 一个 .gitignore 文件，那么这个文件会覆盖父目录下的文件。也就是说，.gitignore 文件的优先级是从 子目录到父目录逐渐降低的。全局忽略文件的优先级最低。 巨人的肩膀 10 Practical Examples Using Wildcards to Match Filenames in Linux fish shell wildcards Linux Tutorial - Cheat Sheet - grep 20 grep command examples in Linux [Cheat Sheet] Linux Handbook: sort Command Examples 15+ Tips to PROPERLY sort files in Linux [Cheat Sheet] Linux and Unix sort command tutorial with examples Linux sort Command How to Use the awk Command on Linux 30+ awk examples for beginners / awk command tutorial in Linux/Unix 8 Powerful Awk Built-in Variables – FS, OFS, RS, ORS, NR, NF, FILENAME, FNR Getting Started With AWK Command [Beginner’s Guide] 25+ most used find commands in Linux [Cheat Sheet] find Linux Command Cheatsheet Linux Find Cheatsheet Find files and directories on Linux with the find command 10 ways to use the Linux find command Find cheatsheet Ignoring files cat command examples for beginners [cheatsheet] Linux Audit: tar cheat sheet 15+ tar command examples in Linux [Cheat Sheet] 10+ practical examples to create symbolic link in Linux 15+ scp command examples in Linux [Cheat Sheet] apropos Linux Command Explained 10 tee command examples in Linux [Cheat Sheet]]]></summary></entry><entry><title type="html">Spring-Validation 自定义错误代码</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/" rel="alternate" type="text/html" title="Spring-Validation 自定义错误代码"/><published>2024-08-29T02:38:09+00:00</published><updated>2024-08-29T02:38:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-custom-error-code/"><![CDATA[<p>在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中，我对如何使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 做了简单的介绍。但是只使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 就很难实现了，我们往往需要自定义代码的 实现逻辑。</p> <p>而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。</p> <p>而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。</p> <h1 id="返回信息">返回信息</h1> <p>我们的基本要求是对于错误信息返回如下的 <code class="language-plaintext highlighter-rouge">JSON</code> 数据：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User id must be null when creating a new user"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_ID_NOTNULL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"4"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"5"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"6"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_EMAIL_EMAIL"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"7"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_SIZE"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"8"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"9"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERNAME_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"10"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERSIGNINDTO_USERPASSWORD_NOTBLANK"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"11"</span><span class="p">:</span><span class="w"> </span><span class="s2">"USERNAME_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"12"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EMAIL_ALREADY_EXISTS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"13"</span><span class="p">:</span><span class="w"> </span><span class="s2">"WRONG_SIGN_IN_INFORMATION"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"14"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INVALID_TOKEN"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"15"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ACCESS_DENIED"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MESSAGE_CONVERSION_ERROR"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>对于这样的数据，前端开发者可以很容易将其定义成一个 <code class="language-plaintext highlighter-rouge">enum</code> 类型，这样就可以很方便的进行错误码的比较。</p> <h1 id="自定义校验逻辑">自定义校验逻辑</h1> <p>对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了如何设置全局异常处理器。</p> <h2 id="自定义错误码">自定义错误码</h2> <p>当然，我们首先需要有错误码的信息，我们可以定义如下的 <code class="language-plaintext highlighter-rouge">enum</code> 类型：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ErrorCodeEnum</span> <span class="o">{</span>
    <span class="c1">// This should be ignored, this is to make the ordinal of the enum start from 1</span>
    <span class="no">ZERO_PLACEHOLDER</span><span class="o">,</span>

    <span class="no">USERDTO_ID_NULL</span><span class="o">(</span><span class="s">"UserDTO.id.Null"</span><span class="o">),</span>
    <span class="no">USERDTO_ID_NOTNULL</span><span class="o">(</span><span class="s">"UserDTO.id.NotNull"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_SIZE</span><span class="o">(</span><span class="s">"UserDTO.username.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.email.NotBlank"</span><span class="o">),</span>
    <span class="no">USERDTO_EMAIL_EMAIL</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_SIZE</span><span class="o">(</span><span class="s">"UserDTO.userPassword.Size"</span><span class="o">),</span>
    <span class="no">USERDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERSIGNINDTO_USERNAME_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.username.NotBlank"</span><span class="o">),</span>
    <span class="no">USERSIGNINDTO_USERPASSWORD_NOTBLANK</span><span class="o">(</span><span class="s">"UserSignInDTO.userPassword.NotBlank"</span><span class="o">),</span>

    <span class="no">USERNAME_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"USERNAME_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">EMAIL_ALREADY_EXISTS</span><span class="o">(</span><span class="s">"EMAIL_ALREADY_EXISTS"</span><span class="o">),</span>
    <span class="no">WRONG_SIGN_IN_INFORMATION</span><span class="o">(</span><span class="s">"WRONG_SIGN_IN_INFORMATION"</span><span class="o">),</span>

    <span class="no">INVALID_TOKEN</span><span class="o">(</span><span class="s">"INVALID_TOKEN"</span><span class="o">),</span>
    <span class="no">ACCESS_DENIED</span><span class="o">(</span><span class="s">"ACCESS_DENIED"</span><span class="o">),</span>

    <span class="no">MESSAGE_CONVERSION_ERROR</span><span class="o">(</span><span class="s">"MESSAGE_CONVERSION_ERROR"</span><span class="o">);</span>

    <span class="c1">// code means the error code in the message.properties</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">code</span><span class="o">;</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(){}</span>

    <span class="nc">ErrorCodeEnum</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">code</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通常 <code class="language-plaintext highlighter-rouge">0</code> 代表执行成功，所以我们在上面的 <code class="language-plaintext highlighter-rouge">enum</code> 类型中加入了一个 <code class="language-plaintext highlighter-rouge">ZERO_PLACEHOLDER</code>，这样我们的错误码 就可以从 <code class="language-plaintext highlighter-rouge">1</code> 开始了。</p> <p>为了能够让自己定义的错误也能使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国际化处理，我们通过在 <code class="language-plaintext highlighter-rouge">enum</code> 中定义 <code class="language-plaintext highlighter-rouge">code</code> 将其 与 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码进行对应。这样我们只需要在 <code class="language-plaintext highlighter-rouge">message.properties</code> 添加对应的错误码即可：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.id.Null</span><span class="p">=</span><span class="s">User id must be null when creating a new user</span>
<span class="py">UserDTO.id.NotNull</span><span class="p">=</span><span class="s">User id cannot be null</span>
<span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
<span class="py">UserDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="c"># UserSignInDTO validation messages
</span><span class="py">UserSignInDTO.username.NotBlank</span><span class="p">=</span><span class="s">Username cannot be blank</span>
<span class="py">UserSignInDTO.userPassword.NotBlank</span><span class="p">=</span><span class="s">Password cannot be blank</span>

<span class="py">USERNAME_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Username already exists: {}</span>
<span class="py">EMAIL_ALREADY_EXISTS</span><span class="p">=</span><span class="s">Email already exists: {}</span>
<span class="py">WRONG_SIGN_IN_INFORMATION</span><span class="p">=</span><span class="s">Wrong sign in information</span>

<span class="py">INVALID_TOKEN</span><span class="p">=</span><span class="s">Invalid token: {}</span>
<span class="py">ACCESS_DENIED</span><span class="p">=</span><span class="s">Operation without privileges</span>

<span class="py">MESSAGE_CONVERSION_ERROR</span><span class="p">=</span><span class="s">Error occurs while converting message</span>
</code></pre></div></div> <p>当然我们需要一个工具类来获取错误码的信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">args</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ignore</span>
        <span class="o">}</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">LocaleContextHolder</span><span class="o">.</span><span class="na">getLocale</span><span class="o">());</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>之前我们在 <a href="/blog/2024/spring-validation-intro">使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 进行参数校验</a> 中介绍了 <code class="language-plaintext highlighter-rouge">{min}</code> 、<code class="language-plaintext highlighter-rouge">{max}</code> 等不能通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行替换的参数，所以在这个工具类中，我们先尝试通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 获取信息，如果获取失败，我们就通过正则表达式进行替换。</p> <p>最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">GenericException</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然我们需要定义 <code class="language-plaintext highlighter-rouge">ErrorVO</code> 对象用于返回错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">errorCodeEnum</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">errorCodeEnum</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">GenericException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleGenericException</span><span class="o">(</span>
        <span class="nc">GenericException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error caused by {}:\n {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">INVALID_TOKEN:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">case</span> <span class="nl">ACCESS_DENIED:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="k">new</span> <span class="nc">ErrorVO</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCode</span><span class="o">(),</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="spring-validation">Spring Validation</h1> <p>在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> + <code class="language-plaintext highlighter-rouge">Spring Validation</code> 的时候，我们是通过 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "{UserDTO.username.NotBlank}")</code> 来获取 <code class="language-plaintext highlighter-rouge">message.properties</code> 中的错误码的， <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 的语法是由 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。</p> <p>众所周知，<code class="language-plaintext highlighter-rouge">enum</code> 对于的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法可以通过名称来创建对应的 <code class="language-plaintext highlighter-rouge">enum</code> 对象，例如 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK")</code> 与 <code class="language-plaintext highlighter-rouge">ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK</code> 是等价的， 而在 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 中只会对 <code class="language-plaintext highlighter-rouge">{xxx.xxx.xxx}</code> 进行解析，而其他的部分将会保持不变，例如 <code class="language-plaintext highlighter-rouge">@NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}")</code> 解析后获取到的 错误信息是 <code class="language-plaintext highlighter-rouge">USERDTO_USERNAME_NOTBLANK Username cannot be blank</code>。这也就意味着我们只需要在使用注解的 地方多增加一个 <code class="language-plaintext highlighter-rouge">enum</code> 的名称即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">UserDTO</span><span class="o">(</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NULL {UserDTO.id.Null}"</span><span class="o">)</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_ID_NOTNULL {UserDTO.id.NotNull}"</span><span class="o">)</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_SIZE {UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">username</span><span class="o">,</span>
    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_EMAIL {UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">email</span><span class="o">,</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ValidationConstant</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">userPassword</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p>当然着还没完，我们需要在全局异常处理器中对这种错误进行处理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorVO</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span>
        <span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// we only handle one validation message</span>
    <span class="nc">String</span> <span class="n">codeAndMessage</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getFieldError</span><span class="o">().</span><span class="na">getDefaultMessage</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">firstSpaceIndex</span> <span class="o">=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
    <span class="c1">// There must be a space and not at the end of the message</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">assert</span> <span class="n">firstSpaceIndex</span> <span class="o">!=</span> <span class="n">codeAndMessage</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">var</span> <span class="n">exception</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericException</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">firstSpaceIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
    <span class="n">exception</span><span class="o">.</span><span class="na">setCode</span><span class="o">(</span><span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">codeAndMessage</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">firstSpaceIndex</span><span class="o">)));</span>
    <span class="k">return</span> <span class="nf">handleGenericException</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>再上面的处理中，我们提取到错误码后创建相应的 <code class="language-plaintext highlighter-rouge">GenericException</code> 对象，然后交给 <code class="language-plaintext highlighter-rouge">handleGenericException</code> 进行统一处理。</p> <p>通过上面的操作后，我们已经成功对自定义校验逻辑以及 <code class="language-plaintext highlighter-rouge">Spring Validation</code> 进行了统一处理，而且我们还可以 通过 <code class="language-plaintext highlighter-rouge">MessageSource</code> 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。</p> <h1 id="返回错误码信息">返回错误码信息</h1> <p>我们只需要定义以下的 <code class="language-plaintext highlighter-rouge">controller</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="c1">// 标记只有在开发环境下才会被加载</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">DEV_PROFILE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DevelopmentController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errorCodeConstant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑</span>
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ErrorCodeEnum</span> <span class="n">code</span> <span class="o">:</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="nc">ErrorCodeEnum</span><span class="o">.</span><span class="na">ZERO_PLACEHOLDER</span><span class="o">)</span> <span class="o">{</span> <span class="k">continue</span><span class="o">;</span> <span class="o">}</span>
            <span class="n">errorCodeConstant</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="na">ordinal</span><span class="o">(),</span> <span class="n">code</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getErrorMessage</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">errorCodeConstant</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="最后">最后</h1> <p>上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在 使用 Spring-Validation 进行参数校验 中，我对如何使用 Spring-Validation 做了简单的介绍。但是只使用 Spring-Validation 还是有一些不足的，例如我们在登录的 时候需要检查用户名和密码是否正确，这时候 Spring-Validation 就很难实现了，我们往往需要自定义代码的 实现逻辑。 而对于自定义的校验没有通过的时候，我们也许要返回错误信息，如何将两者的错误信息进行统一是本文要讨论的 问题。 而如果只是单纯的进行统一，我们只需要返回错误信息即可进行统一。而仅仅返回错误信息是不够的，因为错误信息 往往是给用户查看的，对于开发者而言更多需要的是错误码，因为错误码不会因为语言的不同而改变，而且错误码 更加方便比较，这是因为对于错误信息而言，其中可能存在一些填入的参数，这样就可能导致错误信息不一致， 或者是在开发时书写错误信息的时候出现输入错误，而对于错误码我们可以很容易的避免这些问题。 返回信息 我们的基本要求是对于错误信息返回如下的 JSON 数据： { "code": 1, "message": "User id must be null when creating a new user" } 除此之外，我们希望前端可以通过一个接口获取到所有的错误码以及简单描述，返回的数据应该具有以下的形式： { "1": "USERDTO_ID_NULL", "2": "USERDTO_ID_NOTNULL", "3": "USERDTO_USERNAME_SIZE", "4": "USERDTO_USERNAME_NOTBLANK", "5": "USERDTO_EMAIL_NOTBLANK", "6": "USERDTO_EMAIL_EMAIL", "7": "USERDTO_USERPASSWORD_SIZE", "8": "USERDTO_USERPASSWORD_NOTBLANK", "9": "USERSIGNINDTO_USERNAME_NOTBLANK", "10": "USERSIGNINDTO_USERPASSWORD_NOTBLANK", "11": "USERNAME_ALREADY_EXISTS", "12": "EMAIL_ALREADY_EXISTS", "13": "WRONG_SIGN_IN_INFORMATION", "14": "INVALID_TOKEN", "15": "ACCESS_DENIED", "16": "MESSAGE_CONVERSION_ERROR" } 对于这样的数据，前端开发者可以很容易将其定义成一个 enum 类型，这样就可以很方便的进行错误码的比较。 自定义校验逻辑 对于自定义的校验逻辑的处理非常简单，我们只需要在校验没有通过的时候抛出一个异常即可，然后进行全局异常 的统一处理即可。 使用 Spring-Validation 进行参数校验 中介绍了如何设置全局异常处理器。 自定义错误码 当然，我们首先需要有错误码的信息，我们可以定义如下的 enum 类型： public enum ErrorCodeEnum { // This should be ignored, this is to make the ordinal of the enum start from 1 ZERO_PLACEHOLDER, USERDTO_ID_NULL("UserDTO.id.Null"), USERDTO_ID_NOTNULL("UserDTO.id.NotNull"), USERDTO_USERNAME_SIZE("UserDTO.username.Size"), USERDTO_USERNAME_NOTBLANK("UserDTO.username.NotBlank"), USERDTO_EMAIL_NOTBLANK("UserDTO.email.NotBlank"), USERDTO_EMAIL_EMAIL("UserDTO.email.Email"), USERDTO_USERPASSWORD_SIZE("UserDTO.userPassword.Size"), USERDTO_USERPASSWORD_NOTBLANK("UserDTO.userPassword.NotBlank"), USERSIGNINDTO_USERNAME_NOTBLANK("UserSignInDTO.username.NotBlank"), USERSIGNINDTO_USERPASSWORD_NOTBLANK("UserSignInDTO.userPassword.NotBlank"), USERNAME_ALREADY_EXISTS("USERNAME_ALREADY_EXISTS"), EMAIL_ALREADY_EXISTS("EMAIL_ALREADY_EXISTS"), WRONG_SIGN_IN_INFORMATION("WRONG_SIGN_IN_INFORMATION"), INVALID_TOKEN("INVALID_TOKEN"), ACCESS_DENIED("ACCESS_DENIED"), MESSAGE_CONVERSION_ERROR("MESSAGE_CONVERSION_ERROR"); // code means the error code in the message.properties private String code; ErrorCodeEnum(){} ErrorCodeEnum(String code) { this.code = code; } public String getCode() { return code; } } 通常 0 代表执行成功，所以我们在上面的 enum 类型中加入了一个 ZERO_PLACEHOLDER，这样我们的错误码 就可以从 1 开始了。 为了能够让自己定义的错误也能使用 MessageSource 进行国际化处理，我们通过在 enum 中定义 code 将其 与 message.properties 中的错误码进行对应。这样我们只需要在 message.properties 添加对应的错误码即可： # UserDTO validation messages UserDTO.id.Null=User id must be null when creating a new user UserDTO.id.NotNull=User id cannot be null UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.username.NotBlank=Username cannot be blank UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters UserDTO.userPassword.NotBlank=Password cannot be blank # UserSignInDTO validation messages UserSignInDTO.username.NotBlank=Username cannot be blank UserSignInDTO.userPassword.NotBlank=Password cannot be blank USERNAME_ALREADY_EXISTS=Username already exists: {} EMAIL_ALREADY_EXISTS=Email already exists: {} WRONG_SIGN_IN_INFORMATION=Wrong sign in information INVALID_TOKEN=Invalid token: {} ACCESS_DENIED=Operation without privileges MESSAGE_CONVERSION_ERROR=Error occurs while converting message 当然我们需要一个工具类来获取错误码的信息： // 标记 @Component 使其能够通过唯一的注解器对静态变量 MessageSource 进行注入 @Component public class MessageSourceUtil { private static MessageSource messageSource; MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(ErrorCodeEnum code, Object... args) { try { return messageSource.getMessage(code.getCode(), args, LocaleContextHolder.getLocale()); } catch (Exception e) { // ignore } String message=messageSource.getMessage(code.getCode(), null, LocaleContextHolder.getLocale()); Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 之前我们在 使用 Spring-Validation 进行参数校验 中介绍了 {min} 、{max} 等不能通过 MessageSource 进行替换的参数，所以在这个工具类中，我们先尝试通过 MessageSource 获取信息，如果获取失败，我们就通过正则表达式进行替换。 最后我们需要自定义一个包含错误码的异常，用于在自定义校验出错的时候抛出给全局处理器统一处理： @Getter @Setter public class GenericException extends RuntimeException { private ErrorCodeEnum code; public GenericException(String message) { super(message); } public GenericException(ErrorCodeEnum code, Object... args) { super(MessageSourceUtil.getMessage(code, args)); this.code = code; } } 当然我们需要定义 ErrorVO 对象用于返回错误信息： public record ErrorVO(Integer code, String message) { public ErrorVO(ErrorCodeEnum errorCodeEnum, String message) { this(errorCodeEnum.ordinal(), message); } } 经过上述操作后，我们便可以在全局的异常处理器中进行统一处理了： @ExceptionHandler(GenericException.class) public ResponseEntity&lt;ErrorVO&gt; handleGenericException( GenericException e, HttpServletRequest request) { logger.error("Error caused by {}:\n {}", request.getRemoteAddr(), e.getMessage()); switch (e.getCode()) { case INVALID_TOKEN: return ResponseEntity.status(HttpStatus.UNAUTHORIZED) .body(new ErrorVO(e.getCode(), e.getMessage())); case ACCESS_DENIED: return ResponseEntity.status(HttpStatus.FORBIDDEN) .body(new ErrorVO(e.getCode(), e.getMessage())); default: return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(new ErrorVO(e.getCode(), e.getMessage())); } } Spring Validation 在使用 MessageSource + Spring Validation 的时候，我们是通过 @NotBlank(message = "{UserDTO.username.NotBlank}") 来获取 message.properties 中的错误码的， {xxx.xxx.xxx} 的语法是由 Spring Validation 提供的，而如果我们只是单纯这样进行注解的话，我们很难 获取到错误码的信息，而只能获取到错误信息 (当然可以通过比对字符串进行获取，但是由于存在参数占位符， 比较是困难的)，为了解决这个问题，我们可以迂回一下。 众所周知，enum 对于的 valueOf 方法可以通过名称来创建对应的 enum 对象，例如 ErrorCodeEnum.valueOf("USERDTO_USERNAME_NOTBLANK") 与 ErrorCodeEnum.USERDTO_USERNAME_NOTBLANK 是等价的， 而在 Spring Validation 中只会对 {xxx.xxx.xxx} 进行解析，而其他的部分将会保持不变，例如 @NotBlank(message = "USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") 解析后获取到的 错误信息是 USERDTO_USERNAME_NOTBLANK Username cannot be blank。这也就意味着我们只需要在使用注解的 地方多增加一个 enum 的名称即可： public record UserDTO( @Null(groups = CreateGroup.class, message="USERDTO_ID_NULL {UserDTO.id.Null}") @NotNull(groups = UpdateGroup.class, message="USERDTO_ID_NOTNULL {UserDTO.id.NotNull}") Long id, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_USERNAME_LENGTH, max=ValidationConstant.MAX_USERNAME_LENGTH, message="USERDTO_USERNAME_SIZE {UserDTO.username.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERNAME_NOTBLANK {UserDTO.username.NotBlank}") String username, @Email( groups={CreateGroup.class}, message="USERDTO_EMAIL_EMAIL {UserDTO.email.Email}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_EMAIL_NOTBLANK {UserDTO.email.NotBlank}") String email, @Size( groups={CreateGroup.class}, min=ValidationConstant.MIN_PASSWORD_LENGTH, max=ValidationConstant.MAX_PASSWORD_LENGTH, message="USERDTO_USERPASSWORD_SIZE {UserDTO.userPassword.Size}") @NotBlank( groups={CreateGroup.class}, message="USERDTO_USERPASSWORD_NOTBLANK {UserDTO.userPassword.NotBlank}") String userPassword) {} 当然着还没完，我们需要在全局异常处理器中对这种错误进行处理： @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity&lt;ErrorVO&gt; handleMethodArgumentNotValidException( MethodArgumentNotValidException e, HttpServletRequest request) { // we only handle one validation message String codeAndMessage=e.getFieldError().getDefaultMessage(); int firstSpaceIndex=codeAndMessage.indexOf(" "); // There must be a space and not at the end of the message assert firstSpaceIndex != -1; assert firstSpaceIndex != codeAndMessage.length() - 1; var exception=new GenericException(codeAndMessage.substring(firstSpaceIndex + 1)); exception.setCode(ErrorCodeEnum.valueOf(codeAndMessage.substring(0, firstSpaceIndex))); return handleGenericException(exception, request); } 再上面的处理中，我们提取到错误码后创建相应的 GenericException 对象，然后交给 handleGenericException 进行统一处理。 通过上面的操作后，我们已经成功对自定义校验逻辑以及 Spring Validation 进行了统一处理，而且我们还可以 通过 MessageSource 进行国陲化处理，这样我们就可以很方便的进行错误码的管理了。接下来简单介绍一下如何 返回错误码的信息。 返回错误码信息 我们只需要定义以下的 controller 即可： @RestController // 标记只有在开发环境下才会被加载 @Profile(ApplicationConstant.DEV_PROFILE) public class DevelopmentController { private Map&lt;Integer, String&gt; errorCodeConstant=new HashMap&lt;&gt;(); // 这部分当然可以放入构造器中，放在这里是因为完整源代码中存在其他的逻辑 @PostConstruct public void init() { for (ErrorCodeEnum code : ErrorCodeEnum.values()) { if (code == ErrorCodeEnum.ZERO_PLACEHOLDER) { continue; } errorCodeConstant.put(code.ordinal(), code.name()); } } @GetMapping(ApiPathConstant.DEVELOPMENT_GET_ERROR_MESSAGE_API_PATH) public Map&lt;Integer, String&gt; getErrorMessage() { return errorCodeConstant; } } 最后 上面的方法我个人认为并不是很优雅，但是对于我目前能想到的方法确实最好的，拓展性也不差，如果有更好的 方法，欢迎在评论区留言。]]></summary></entry><entry><title type="html">JJWT + Spring Filter 实现 Token 验证</title><link href="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/" rel="alternate" type="text/html" title="JJWT + Spring Filter 实现 Token 验证"/><published>2024-08-27T12:21:37+00:00</published><updated>2024-08-27T12:21:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/filter-jjwt-intro/"><![CDATA[<p>在实际上开发中我们可能会需要涉及到用户的认证和授权功能，<code class="language-plaintext highlighter-rouge">Spring Security</code> 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 <code class="language-plaintext highlighter-rouge">JJWT</code> 就能实现。</p> <h1 id="需求">需求</h1> <p>考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 <code class="language-plaintext highlighter-rouge">token</code> 来进行访问，<code class="language-plaintext highlighter-rouge">token</code> 一定时间内有效，过期后需要重新登录。</p> <p>对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 <code class="language-plaintext highlighter-rouge">token</code> 进行 解析，获取用户信息，然后进行比对。</p> <h2 id="双-token-模式">双 <code class="language-plaintext highlighter-rouge">token</code> 模式</h2> <p>对于 <code class="language-plaintext highlighter-rouge">token</code> 的设计，我们可以采用双 <code class="language-plaintext highlighter-rouge">token</code> 模式，即一个 <code class="language-plaintext highlighter-rouge">access token</code> 和一个 <code class="language-plaintext highlighter-rouge">refresh token</code>，<code class="language-plaintext highlighter-rouge">access token</code> 用于访问，<code class="language-plaintext highlighter-rouge">refresh token</code> 用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>。</p> <p>这样的设计可以有效的保证安全性，因为 <code class="language-plaintext highlighter-rouge">access token</code> 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 <code class="language-plaintext highlighter-rouge">refresh token</code> 通常有效时间较长，但是只能用于刷新 <code class="language-plaintext highlighter-rouge">access token</code>，不能用于访问，且 <code class="language-plaintext highlighter-rouge">refresh token</code> 只有在每次 <code class="language-plaintext highlighter-rouge">access token</code> 过期后才会被传递，这样 <code class="language-plaintext highlighter-rouge">refresh token</code> 暴露的风险较小。</p> <h1 id="实现">实现</h1> <h2 id="jwtutil"><code class="language-plaintext highlighter-rouge">JwtUtil</code></h2> <p>我们首先需要自定义一个工具类，该工具类可以生成和解析 <code class="language-plaintext highlighter-rouge">token</code>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">TOKEN_TYPE_CLAIM</span> <span class="o">=</span> <span class="s">"tokenType"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ID_CLAIM</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">SecretKey</span> <span class="no">SECRET_KEY</span> <span class="o">=</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">SIG</span><span class="o">.</span><span class="na">HS256</span><span class="o">.</span><span class="na">key</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">issuedAt</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">())</span>
                <span class="o">.</span><span class="na">expiration</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span>
                    <span class="o">(</span><span class="n">tokenType</span> <span class="o">==</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span> <span class="o">?</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">ACCESS_TOKEN_EXPIRATION</span> <span class="o">:</span>
                     <span class="nc">ApplicationConstant</span><span class="o">.</span><span class="na">REFRESH_TOKEN_EXPIRATION</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
                <span class="o">.</span><span class="na">claim</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="n">tokenType</span><span class="o">.</span><span class="na">name</span><span class="o">())</span>
                <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compact</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">,</span> <span class="nc">TokenTypeEnum</span> <span class="n">tokenType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">generateToken</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">id</span><span class="o">),</span> <span class="n">tokenType</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getID</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">ID_CLAIM</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TokenTypeEnum</span> <span class="nf">getTokenType</span><span class="o">(</span><span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span>
                <span class="nc">Jwts</span><span class="o">.</span><span class="na">parser</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">verifyWith</span><span class="o">(</span><span class="no">SECRET_KEY</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">parseSignedClaims</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getPayload</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">TOKEN_TYPE_CLAIM</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="filter"><code class="language-plaintext highlighter-rouge">Filter</code></h2> <p>要实现认证和授权，我们可以通过 <code class="language-plaintext highlighter-rouge">Filter</code> 拦截所有的非登录和注册的业务请求，然后进行 <code class="language-plaintext highlighter-rouge">token</code> 的解析和验证：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">LOWEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ignorePath</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_UP_API_PATH</span><span class="o">,</span>
            <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">,</span>
    <span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
        <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">authorize</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getTokenType</span><span class="o">(</span><span class="n">token</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">ACCESS_TOKEN:</span>
                <span class="c1">// ACCESS_TOKEN can not be used for refresh</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="nc">String</span> <span class="n">idInToken</span> <span class="o">=</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
                <span class="k">switch</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethod</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">case</span> <span class="s">"GET"</span><span class="o">:</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">case</span> <span class="s">"POST"</span><span class="o">:</span>
                        <span class="c1">// User can not update other user's information</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">USER_API_PREFIX</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">idInToken</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getFromRequestBody</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="s">"id"</span><span class="o">)))</span> <span class="o">{</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">default</span><span class="o">:</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">REFRESH_TOKEN:</span>
                <span class="c1">// REFRESH_TOKEN can only be used for refresh</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                    <span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">ACCESS_DENIED</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">getFromRequestBody</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getReader</span><span class="o">();</span>
            <span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="o">=</span> <span class="nc">JsonParserFactory</span><span class="o">.</span><span class="na">getJsonParser</span><span class="o">().</span><span class="na">parseMap</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// unlikely to happen</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="signin"><code class="language-plaintext highlighter-rouge">SignIn</code></h2> <p>对于登录接口，我们只需要返回额外 <code class="language-plaintext highlighter-rouge">access token</code> 和 <code class="language-plaintext highlighter-rouge">refresh token</code>，对于刷新服务我们直接返回新的 <code class="language-plaintext highlighter-rouge">access token</code> 即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 我们在 UserVO 中保存 token</span>
<span class="kd">public</span> <span class="n">record</span> <span class="nf">UserVO</span><span class="o">(</span>
    <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">accessToken</span><span class="o">,</span> <span class="nc">String</span> <span class="n">refreshToken</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">UserVO</span><span class="o">(</span><span class="nc">UserPO</span> <span class="n">userPO</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="n">userPO</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">),</span>
                <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span>
                        <span class="n">userPO</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">REFRESH_TOKEN</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticationController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_SIGN_IN_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;?&gt;</span> <span class="n">signIn</span><span class="o">(</span><span class="nd">@Validated</span> <span class="nd">@RequestBody</span> <span class="nc">UserSignInDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryWrapper</span><span class="o">&lt;</span><span class="nc">UserPO</span><span class="o">&gt;();</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">username</span><span class="o">());</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"user_password"</span><span class="o">,</span> <span class="nc">MD5Converter</span><span class="o">.</span><span class="na">convertToMD5</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">userPassword</span><span class="o">()));</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">userService</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">wrapper</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">WRONG_SIGN_IN_INFORMATION</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="k">new</span> <span class="nc">UserVO</span><span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">getOne</span><span class="o">(</span><span class="n">wrapper</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">AUTHENTICATION_REFRESH_API_PATH</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">refreshToken</span><span class="o">(</span><span class="nd">@RequestHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">JwtUtil</span><span class="o">.</span><span class="na">generateToken</span><span class="o">(</span><span class="nc">JwtUtil</span><span class="o">.</span><span class="na">getID</span><span class="o">(</span><span class="n">token</span><span class="o">),</span> <span class="nc">TokenTypeEnum</span><span class="o">.</span><span class="na">ACCESS_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="问题">问题</h1> <h2 id="如何让-token-在用户修改密码后失效">如何让 <code class="language-plaintext highlighter-rouge">token</code> 在用户修改密码后失效</h2> <p>一个情况是当用户发现自己的 <code class="language-plaintext highlighter-rouge">token</code> 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <p>这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 <code class="language-plaintext highlighter-rouge">id</code> 和密码修改的时间，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时，我们 需要验证 <code class="language-plaintext highlighter-rouge">token</code> 的发布时间是否在密码修改时间之前，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p> <h2 id="如何在用户进行登出操作后使-token-失效">如何在用户进行登出操作后使 <code class="language-plaintext highlighter-rouge">token</code> 失效</h2> <p>对于主动让一个 <code class="language-plaintext highlighter-rouge">token</code> 失效，我们可以采用黑名单机制，即将失效的 <code class="language-plaintext highlighter-rouge">token</code> 加入黑名单，每次验证 <code class="language-plaintext highlighter-rouge">token</code> 时， 我们需要验证 <code class="language-plaintext highlighter-rouge">token</code> 是否在黑名单中，如果是则说明 <code class="language-plaintext highlighter-rouge">token</code> 失效。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><category term="Token"/><summary type="html"><![CDATA[在实际上开发中我们可能会需要涉及到用户的认证和授权功能，Spring Security 当然可以实现这一点，但是 对于一些简单的开发场景 (不区分角色)，我们实际上只需要利用 JJWT 就能实现。 需求 考虑这样的场景，用户登录成功后，后续的操作不再需要用户名和密码，可以通过 token 来进行访问，token 一定时间内有效，过期后需要重新登录。 对于一些修改要求，例如修改用户信息，我们需要保证只有用户自己才能修改自己的信息，这时候我们可以对 token 进行 解析，获取用户信息，然后进行比对。 双 token 模式 对于 token 的设计，我们可以采用双 token 模式，即一个 access token 和一个 refresh token，access token 用于访问，refresh token 用于刷新 access token。 这样的设计可以有效的保证安全性，因为 access token 的有效时间较短，即使被盗取，也只能在有效时间内使用， 而 refresh token 通常有效时间较长，但是只能用于刷新 access token，不能用于访问，且 refresh token 只有在每次 access token 过期后才会被传递，这样 refresh token 暴露的风险较小。 实现 JwtUtil 我们首先需要自定义一个工具类，该工具类可以生成和解析 token： public class JwtUtil { private static final String TOKEN_TYPE_CLAIM="tokenType"; private static final String ID_CLAIM="id"; private static final SecretKey SECRET_KEY=Jwts.SIG.HS256.key().build(); public static String generateToken(long id, TokenTypeEnum tokenType) { return Jwts.builder().issuedAt(new Date()) .expiration(new Date(System.currentTimeMillis() + (tokenType == TokenTypeEnum.ACCESS_TOKEN ? ApplicationConstant.ACCESS_TOKEN_EXPIRATION : ApplicationConstant.REFRESH_TOKEN_EXPIRATION))) .claim(ID_CLAIM, id) .claim(TOKEN_TYPE_CLAIM, tokenType.name()) .signWith(SECRET_KEY) .compact(); } public static String generateToken(String id, TokenTypeEnum tokenType) { return generateToken(Long.valueOf(id), tokenType); } public static String getID(String token) { return String.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(ID_CLAIM, Long.class)); } public static TokenTypeEnum getTokenType(String token) { return TokenTypeEnum.valueOf( Jwts.parser() .verifyWith(SECRET_KEY) .build() .parseSignedClaims(token) .getPayload() .get(TOKEN_TYPE_CLAIM, String.class)); } } Filter 要实现认证和授权，我们可以通过 Filter 拦截所有的非登录和注册的业务请求，然后进行 token 的解析和验证： @Component @Order(Ordered.LOWEST_PRECEDENCE) public class JwtFilter extends OncePerRequestFilter { private Set&lt;String&gt; ignorePath=Set.of( ApiPathConstant.AUTHENTICATION_SIGN_UP_API_PATH, ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH, ); @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } private void authorize(HttpServletRequest request, String token) { switch (JwtUtil.getTokenType(token)) { case ACCESS_TOKEN: // ACCESS_TOKEN can not be used for refresh if (request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } String idInToken=JwtUtil.getID(token); switch (request.getMethod()) { case "GET": break; case "POST": // User can not update other user's information if (request.getRequestURI().startsWith(ApiPathConstant.USER_API_PREFIX) &amp;&amp; !idInToken.equals(getFromRequestBody(request, "id"))) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; case REFRESH_TOKEN: // REFRESH_TOKEN can only be used for refresh if (!request.getRequestURI().equals( ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH)) { throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } break; default: throw new AccessDeniedException(ErrorMessageConstant.ACCESS_DENIED); } } private String getFromRequestBody(HttpServletRequest request, String key) { try { BufferedReader reader=request.getReader(); StringBuilder builder=new StringBuilder(); String line=reader.readLine(); while (line != null) { builder.append(line); line=reader.readLine(); } reader.close(); var json=JsonParserFactory.getJsonParser().parseMap(builder.toString()); return json.get(key).toString(); } catch (Exception e) { // unlikely to happen return null; } } } SignIn 对于登录接口，我们只需要返回额外 access token 和 refresh token，对于刷新服务我们直接返回新的 access token 即可： // 我们在 UserVO 中保存 token public record UserVO( Long id, String username, String email, String accessToken, String refreshToken) { public UserVO(UserPO userPO) { this(userPO.getId(), userPO.getUsername(), userPO.getEmail(), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.ACCESS_TOKEN), JwtUtil.generateToken( userPO.getId(), TokenTypeEnum.REFRESH_TOKEN)); } } @RestController public class AuthenticationController { @Autowired private UserService userService; @PostMapping(ApiPathConstant.AUTHENTICATION_SIGN_IN_API_PATH) public ResponseEntity&lt;?&gt; signIn(@Validated @RequestBody UserSignInDTO user) { QueryWrapper&lt;UserPO&gt; wrapper=new QueryWrapper&lt;UserPO&gt;(); wrapper.eq("username", user.username()); wrapper.eq("user_password", MD5Converter.convertToMD5(user.userPassword())); if (!userService.exists(wrapper)) { throw new IllegalArgumentException(ErrorMessageConstant.WRONG_SIGN_IN_INFORMATION); } return ResponseEntity.ok(new UserVO(userService.getOne(wrapper))); } @GetMapping(ApiPathConstant.AUTHENTICATION_REFRESH_API_PATH) public String refreshToken(@RequestHeader("Token") String token) { return JwtUtil.generateToken(JwtUtil.getID(token), TokenTypeEnum.ACCESS_TOKEN); } } 问题 如何让 token 在用户修改密码后失效 一个情况是当用户发现自己的 token 或者密码泄漏后，希望马上进行密码的修改且修改后之前产生的 token 失效。 这里给出一种简单的解决方案：我们需要缓存机制，保存用户的 id 和密码修改的时间，每次验证 token 时，我们 需要验证 token 的发布时间是否在密码修改时间之前，如果是则说明 token 失效。 如何在用户进行登出操作后使 token 失效 对于主动让一个 token 失效，我们可以采用黑名单机制，即将失效的 token 加入黑名单，每次验证 token 时， 我们需要验证 token 是否在黑名单中，如果是则说明 token 失效。]]></summary></entry><entry><title type="html">Spring Filter 全局异常处理器</title><link href="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/" rel="alternate" type="text/html" title="Spring Filter 全局异常处理器"/><published>2024-08-27T12:21:09+00:00</published><updated>2024-08-27T12:21:09+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/exception-handler-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/exception-handler-intro/"><![CDATA[<p>在之前的 <a href="/blog/2024/spring-validation-intro">Spring-Validation</a> 中简单介绍了如何通过 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解来处理全局异常，但是这种方式只能 处理 <code class="language-plaintext highlighter-rouge">Controller</code> 层抛出的异常。</p> <p>这篇文章介绍如何处理自定义 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常。</p> <h1 id="自定义-filter">自定义 <code class="language-plaintext highlighter-rouge">Filter</code></h1> <p>例如我们可能需要一个 <code class="language-plaintext highlighter-rouge">Filter</code> 来检验 <code class="language-plaintext highlighter-rouge">Token</code> 是否合法，而检查的过程中发现 <code class="language-plaintext highlighter-rouge">Token</code> 不合法，则抛出异常。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebFilter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// ignore non business api and some special api</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="nc">ApiPathConstant</span><span class="o">.</span><span class="na">ALL_API_PREFIX</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ignorePath</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// throw exception if authorization failed</span>
        <span class="n">authorize</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Token"</span><span class="o">));</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：通过 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 注释的 <code class="language-plaintext highlighter-rouge">Filter</code> 需要在 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 启动类中添加 <code class="language-plaintext highlighter-rouge">@ServletComponentScan("xxx.xxx.xx")</code> 注解指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的查找路径。</p> <p>上面过程中抛出的异常不会被 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或者 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 捕获。</p> <h1 id="handlerexceptionresolver"><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code></h1> <p>实际上 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 的异常处理是通过 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 来实现的。<code class="language-plaintext highlighter-rouge">Spring Boot</code> 中已经存在 两个默认的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，我们可以通过 <code class="language-plaintext highlighter-rouge">@Qualifier("HandlerExceptionResolver")</code> 配合 <code class="language-plaintext highlighter-rouge">@Autowired</code> 获取到负责处理异常的 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>，然后显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 方法来处理异常。</p> <h1 id="解决方案">解决方案</h1> <p>要实现这些，我们只需要自定义一个 <code class="language-plaintext highlighter-rouge">Filter</code> 并让其第一个执行，对捕获到的异常显式调用 <code class="language-plaintext highlighter-rouge">resolveException</code> 进行处理就可以触发全局定义的异常处理器：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="nc">Ordered</span><span class="o">.</span><span class="na">HIGHEST_PRECEDENCE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExceptionHandlerFiter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"handlerExceptionResolver"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">HandlerExceptionResolver</span> <span class="n">resolver</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="na">resolveException</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>注意：<code class="language-plaintext highlighter-rouge">@WebFilter</code> 不能指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序 (实际上是可以的，通过指定 <code class="language-plaintext highlighter-rouge">@WebFilter</code> 中的 <code class="language-plaintext highlighter-rouge">filterName</code>，执行顺序是按照该字段的字典序)，要指定 <code class="language-plaintext highlighter-rouge">Filter</code> 的执行顺序，我们可以通 <code class="language-plaintext highlighter-rouge">@Order</code> 和 <code class="language-plaintext highlighter-rouge">@Component</code> 来实现，<code class="language-plaintext highlighter-rouge">@Order</code> 的值越小，执行顺序越靠前，上述例子的 <code class="language-plaintext highlighter-rouge">Ordered.HIGHEST_PRECEDENCE</code> 实际上是 <code class="language-plaintext highlighter-rouge">Integer.MIN_VALUE</code>。</p> <p><code class="language-plaintext highlighter-rouge">resolveException</code> 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 <code class="language-plaintext highlighter-rouge">Filter</code> 抛出的异常了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">JwtException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ErrorVO</span> <span class="nf">handleJwtException</span><span class="o">(</span><span class="nc">JwtException</span> <span class="n">e</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Invalid Token from {}"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ErrorVO</span><span class="o">(</span><span class="nc">ErrorMessageConstant</span><span class="o">.</span><span class="na">INVALID_TOKEN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Filter"/><summary type="html"><![CDATA[在之前的 Spring-Validation 中简单介绍了如何通过 @RestControllerAdvice 或者 @ControllerAdvice 注解来处理全局异常，但是这种方式只能 处理 Controller 层抛出的异常。 这篇文章介绍如何处理自定义 Filter 抛出的异常。 自定义 Filter 例如我们可能需要一个 Filter 来检验 Token 是否合法，而检查的过程中发现 Token 不合法，则抛出异常。 @WebFilter public class JwtFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ignore non business api and some special api if (!request.getRequestURI().startsWith(ApiPathConstant.ALL_API_PREFIX) || ignorePath.contains(request.getRequestURI())) { filterChain.doFilter(request, response); return; } // throw exception if authorization failed authorize(request, request.getHeader("Token")); filterChain.doFilter(request, response); } } 注意：通过 @WebFilter 注释的 Filter 需要在 @SpringBootApplication 启动类中添加 @ServletComponentScan("xxx.xxx.xx") 注解指定 Filter 的查找路径。 上面过程中抛出的异常不会被 @RestControllerAdvice 或者 @ControllerAdvice 捕获。 HandlerExceptionResolver 实际上 Spring Boot 的异常处理是通过 HandlerExceptionResolver 来实现的。Spring Boot 中已经存在 两个默认的 HandlerExceptionResolver，我们可以通过 @Qualifier("HandlerExceptionResolver") 配合 @Autowired 获取到负责处理异常的 HandlerExceptionResolver，然后显式调用 resolveException 方法来处理异常。 解决方案 要实现这些，我们只需要自定义一个 Filter 并让其第一个执行，对捕获到的异常显式调用 resolveException 进行处理就可以触发全局定义的异常处理器： @Component @Order(Ordered.HIGHEST_PRECEDENCE) public class ExceptionHandlerFiter extends OncePerRequestFilter { @Autowired @Qualifier("handlerExceptionResolver") private HandlerExceptionResolver resolver; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { filterChain.doFilter(request, response); } catch (Exception e) { resolver.resolveException(request, response, null, e); } } } 注意：@WebFilter 不能指定 Filter 的执行顺序 (实际上是可以的，通过指定 @WebFilter 中的 filterName，执行顺序是按照该字段的字典序)，要指定 Filter 的执行顺序，我们可以通 @Order 和 @Component 来实现，@Order 的值越小，执行顺序越靠前，上述例子的 Ordered.HIGHEST_PRECEDENCE 实际上是 Integer.MIN_VALUE。 resolveException 会自动根据异常的类型找到对应的异常处理器进行处理。这样，我们就可以处理 Filter 抛出的异常了： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(JwtException.class) public ErrorVO handleJwtException(JwtException e, HttpServletRequest request) { logger.error("Invalid Token from {}", request.getRemoteAddr()); return new ErrorVO(ErrorMessageConstant.INVALID_TOKEN); } }]]></summary></entry><entry><title type="html">使用 Spring-Validation 进行数据校验</title><link href="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/" rel="alternate" type="text/html" title="使用 Spring-Validation 进行数据校验"/><published>2024-08-23T02:24:05+00:00</published><updated>2024-08-23T02:24:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-validation-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-validation-intro/"><![CDATA[<p>在开发 <code class="language-plaintext highlighter-rouge">web</code> 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 <code class="language-plaintext highlighter-rouge">if else</code> 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 <code class="language-plaintext highlighter-rouge">Spring-Validation</code> 来进行数据 校验。</p> <h1 id="使用-jsr-303-注解">使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 注解</h1> <p><code class="language-plaintext highlighter-rouge">Spring-Validation</code> 提供了对于 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解的支持，我们可以使用 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解来对数据进行校验。</p> <p>简单来讲，对于一个 <code class="language-plaintext highlighter-rouge">DTO</code> 对象，我们可以在其属性上添加 <code class="language-plaintext highlighter-rouge">JSR 303</code> 中的注解，然后在 <code class="language-plaintext highlighter-rouge">Controller</code> 中对 参数使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解来对数据进行校验。</p> <p>例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 <code class="language-plaintext highlighter-rouge">DTO</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 或者 <code class="language-plaintext highlighter-rouge">@Validated</code> 注解即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过上面的操作后，如果前端传入的数据不符合要求，那么 <code class="language-plaintext highlighter-rouge">Spring</code> 会抛出一个 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code> 异常，这个异常的默认处理方式是返回一个 <code class="language-plaintext highlighter-rouge">400</code> 的状态码和一个 <code class="language-plaintext highlighter-rouge">JSON</code> 格式的错误信息。我们可以自己定义异常处理器。</p> <h1 id="自定义异常处理器">自定义异常处理器</h1> <p>异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 <code class="language-plaintext highlighter-rouge">Controller</code> 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。</p> <h2 id="全局异常处理器">全局异常处理器</h2> <p>要定义一个全局异常处理器，我们可以创建一个类并且添加 <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code> 或 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>
    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">handleMethodArgumentNotValidException</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">e</span><span class="o">.</span><span class="na">getBindingResult</span><span class="o">().</span><span class="na">getFieldErrors</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">error</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">fieldName</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getField</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">errorMessage</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getDefaultMessage</span><span class="o">();</span>
            <span class="n">errors</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">errorMessage</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">errors</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 <code class="language-plaintext highlighter-rouge">Map</code> 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Username length must be between 1 and 20 characters"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="局部异常处理器">局部异常处理器</h2> <p>局部异常处理器的定义只需要将异常处理器定义在某个 <code class="language-plaintext highlighter-rouge">Controller</code> 中即可。</p> <h1 id="分组校验">分组校验</h1> <p>现在我们为上面的 <code class="language-plaintext highlighter-rouge">DTO</code> 对象添加一个 <code class="language-plaintext highlighter-rouge">id</code> 字段，在创建用户的时候，不需要指定 <code class="language-plaintext highlighter-rouge">id</code> 字段，但是在更新 用户的时候，<code class="language-plaintext highlighter-rouge">id</code> 字段是必须的。这时候我们可以使用分组校验来解决这个问题。</p> <p>首先我们需要在 <code class="language-plaintext highlighter-rouge">DTO</code> 对象中定义一个分组：(这里使用内部类进行演示)</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="nd">@Null</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Username length must be between 1 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email format is incorrect"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Email cannot be blank"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Update</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Create</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
        <span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Password length must be between 6 and 20 characters"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Update</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Create</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>然后我们在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">@Validated</code> (此时不能使用 <code class="language-plaintext highlighter-rouge">@Valid</code> 注解) 注解来指定分组：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Create</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PatchMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">updateUser</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserDTO</span><span class="o">.</span><span class="na">Update</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="常用注解">常用注解</h1> <p><code class="language-plaintext highlighter-rouge">JSR 303</code> 中定义了很多注解，这里列出一些常用的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Null</code></td> <td>验证对象是否为 <code class="language-plaintext highlighter-rouge">null</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotNull</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>，无法查检长度为 <code class="language-plaintext highlighter-rouge">0</code>的字符串</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotBlank</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否不为 <code class="language-plaintext highlighter-rouge">null</code>、长度是否大于 <code class="language-plaintext highlighter-rouge">0</code>、是否包含至少一个非空白字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertFalse</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@AssertTrue</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Boolean</code> 对象是否为 <code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Min</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Max</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMin</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否大于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@DecimalMax</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否小于等于指定的值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Digits</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 和 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是指定范围内的数字</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Past</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之前</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Future</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Date</code> 对象是否是在当前时间之后</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Size</code></td> <td>验证对象（<code class="language-plaintext highlighter-rouge">Array</code>、<code class="language-plaintext highlighter-rouge">Collection</code>、<code class="language-plaintext highlighter-rouge">Map</code>、<code class="language-plaintext highlighter-rouge">String</code>）长度是否在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Pattern</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否符合正则表达式的规则</td> </tr> </tbody> </table> <p>下面的注解是 <code class="language-plaintext highlighter-rouge">Hibernate Validator</code> 中定义的注解：</p> <table> <thead> <tr> <th>注解</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">@Email</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是一个合法的电子邮件地址</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Length</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">String</code> 对象是否是在给定的范围之内</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@NotEmpty</code></td> <td>验证对象是否不为 <code class="language-plaintext highlighter-rouge">null</code> 或者 <code class="language-plaintext highlighter-rouge">""</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">@Range</code></td> <td>验证 <code class="language-plaintext highlighter-rouge">Number</code> 对象是否在给定的范围之内</td> </tr> </tbody> </table> <h1 id="messagesource-管理错误信息"><code class="language-plaintext highlighter-rouge">MessageSource</code> 管理错误信息</h1> <p>在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。</p> <p>为了解决这个问题，我们可以使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 来管理错误信息。</p> <p>首先我们在 <code class="language-plaintext highlighter-rouge">application.yml</code> ( 或者 <code class="language-plaintext highlighter-rouge">application.properties</code> ) 中添加如下配置：</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">messages</span><span class="pi">:</span>
    <span class="na">basename</span><span class="pi">:</span> <span class="s">message/message</span>
    <span class="na">encoding</span><span class="pi">:</span> <span class="s">UTF-8</span>
</code></pre></div></div> <p>标识我们的错误信息文件在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下的 <code class="language-plaintext highlighter-rouge">message</code> 目录中，文件名为 <code class="language-plaintext highlighter-rouge">message.properties</code> ( 只能 使用 <code class="language-plaintext highlighter-rouge">properties</code> 文件 )。</p> <p>接下来，我们在 <code class="language-plaintext highlighter-rouge">resources</code> 目录下创建一个 <code class="language-plaintext highlighter-rouge">message</code> 目录，并且在其中创建一个 <code class="language-plaintext highlighter-rouge">message.properties</code> 文件， 在文件中添加如下内容：</p> <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># UserDTO validation messages
</span><span class="py">UserDTO.username.Size</span><span class="p">=</span><span class="s">Username must be between {min} and {max} characters</span>
<span class="py">UserDTO.email.NotBlank</span><span class="p">=</span><span class="s">Email cannot be blank</span>
<span class="py">UserDTO.email.Email</span><span class="p">=</span><span class="s">Email must be a valid email address</span>
<span class="py">UserDTO.userPassword.Size</span><span class="p">=</span><span class="s">Password must be between {min} and {max} characters</span>
</code></pre></div></div> <p>然后我们可以直接在注解中的 <code class="language-plaintext highlighter-rouge">message</code> 部分使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的 <code class="language-plaintext highlighter-rouge">key</code> 来引用错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_USERNAME_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.username.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@Email</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.Email}"</span><span class="o">)</span>
    <span class="nd">@NotBlank</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.email.NotBlank}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UpdateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">CreateGroup</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span><span class="o">,</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">"{UserDTO.userPassword.Size}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面通过 <code class="language-plaintext highlighter-rouge">message = "{xxx.xxx.xxx}"</code> 的方式获取变量是 <code class="language-plaintext highlighter-rouge">Hibernate</code> 提供的支持。而我们编写的字符串中 的 <code class="language-plaintext highlighter-rouge">{min}</code> 和 <code class="language-plaintext highlighter-rouge">{max}</code> 会被替换成注解中的 <code class="language-plaintext highlighter-rouge">min</code> 和 <code class="language-plaintext highlighter-rouge">max</code> 的值。</p> <p>但是我们在使用 <code class="language-plaintext highlighter-rouge">MessageSource</code> 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessageSourceUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">;</span>

    <span class="c1">// 通过构造器注入 MessageSource</span>
    <span class="nc">MessageSourceUtil</span><span class="o">(</span><span class="nc">MessageSource</span> <span class="n">messageSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">messageSource</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值</span>
        <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\{.*?\\}"</span><span class="o">);</span>
        <span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(),</span> <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样我们可以在 <code class="language-plaintext highlighter-rouge">Controller</code> 中使用 <code class="language-plaintext highlighter-rouge">MessageSourceUtil</code> 来获取错误信息：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserControllerTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCreateUserInvalid</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span>
                <span class="sh">"""
                {
                    "name": "test",
                    "email": "invalid email address",
                    "userPassword": ""
                }
                """</span><span class="o">;</span>
        <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>
                        <span class="nc">MockMvcRequestBuilders</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">user</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpectAll</span><span class="o">(</span>
                        <span class="n">status</span><span class="o">().</span><span class="na">isBadRequest</span><span class="o">(),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.email"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span><span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="s">"UserDTO.email.Email"</span><span class="o">))),</span>
                        <span class="n">jsonPath</span><span class="o">(</span>
                                <span class="s">"$.userPassword"</span><span class="o">,</span>
                                <span class="n">equalTo</span><span class="o">(</span>
                                        <span class="nc">MessageSourceUtil</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span>
                                                <span class="s">"UserDTO.userPassword.Size"</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MIN_PASSWORD_LENGTH</span><span class="o">,</span>
                                                <span class="nc">ConstantProperty</span><span class="o">.</span><span class="na">MAX_PASSWORD_LENGTH</span>
                                                <span class="o">))),</span>
                        <span class="n">content</span><span class="o">().</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div> <p>在上面的代码中，我们同样将密码长度等常量信息放在了 <code class="language-plaintext highlighter-rouge">ConstantProperty</code> 类中，这样我们可以在测试中直接 引用这些常量。</p> <h2 id="国际化">国际化</h2> <p>实际上，<code class="language-plaintext highlighter-rouge">MessageSource</code> 是用来支持国际化的。在上面的例子中，我们只是使用了一个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 实际上我们可以使用多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件来支持多种语言。</p> <p>我们只需要在 <code class="language-plaintext highlighter-rouge">resources/message</code> (取决于我们指定的 <code class="language-plaintext highlighter-rouge">basename</code> ) 目录下创建多个 <code class="language-plaintext highlighter-rouge">properties</code> 文件， 例如 <code class="language-plaintext highlighter-rouge">message.properties</code>、<code class="language-plaintext highlighter-rouge">message_en.properties</code>、<code class="language-plaintext highlighter-rouge">message_zh.properties</code> 等等。这样在发送请求的 时候，我们可以在请求头中添加 <code class="language-plaintext highlighter-rouge">Accept-Language</code> 来指定语言，<code class="language-plaintext highlighter-rouge">Spring</code> 会根据请求头中的语言来选择对应的 <code class="language-plaintext highlighter-rouge">properties</code> 文件中的信息。</p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring Validation"/><summary type="html"><![CDATA[在开发 web 项目的过程中，我们往往需要对从前端接收到的数据进行校验，如果我们使用大量的 if else 来进行校验，那么代码会变得非常臃肿，而且不易维护。这时候我们可以使用 Spring-Validation 来进行数据 校验。 使用 JSR 303 注解 Spring-Validation 提供了对于 JSR 303 中的注解的支持，我们可以使用 JSR 303 中的注解来对数据进行校验。 简单来讲，对于一个 DTO 对象，我们可以在其属性上添加 JSR 303 中的注解，然后在 Controller 中对 参数使用 @Valid 或者 @Validated 注解来对数据进行校验。 例如，在进行用户注册的时候，我们从前端接收用户的用户名、密码和邮箱，我们可以创建如下的 DTO 类： @Data public class UserDTO { @Size(min = 1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(message = "Email format is incorrect") @NotBlank(message = "Email cannot be blank") private String email; @Size(min = 6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; } 上面的注解的意思是不言而喻的。接着我们只需要在需要校验的地方使用 @Valid 或者 @Validated 注解即可： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Valid @RequestBody UserDTO user) {} } 通过上面的操作后，如果前端传入的数据不符合要求，那么 Spring 会抛出一个 MethodArgumentNotValidException 异常，这个异常的默认处理方式是返回一个 400 的状态码和一个 JSON 格式的错误信息。我们可以自己定义异常处理器。 自定义异常处理器 异常处理器的定义有两种模式，一种是全局异常处理器，一种是局部异常处理器。局部异常处理器只会处理当前 Controller 中的异常，而全局异常处理器会处理所有的异常。局部异常处理器具有更高的优先级。 全局异常处理器 要定义一个全局异常处理器，我们可以创建一个类并且添加 @RestControllerAdvice 或 @ControllerAdvice 注解： @RestControllerAdvice public class GlobalExceptionHandler { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public Map&lt;String, String&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException e) { Map&lt;String, String&gt; errors=new HashMap&lt;&gt;(); e.getBindingResult().getFieldErrors().forEach((error) -&gt; { String fieldName=error.getField(); String errorMessage=error.getDefaultMessage(); errors.put(fieldName, errorMessage); }); return errors; } } 在上面的例子中，我们只将异常中的字段名和错误信息提取出来，然后返回一个 Map 对象。这样我们就可以 很清楚的从错误信息中看到哪个字段出现了错误。例如在用户名为空的时候，我们可以在响应体中看到： { "username": "Username length must be between 1 and 20 characters" } 局部异常处理器 局部异常处理器的定义只需要将异常处理器定义在某个 Controller 中即可。 分组校验 现在我们为上面的 DTO 对象添加一个 id 字段，在创建用户的时候，不需要指定 id 字段，但是在更新 用户的时候，id 字段是必须的。这时候我们可以使用分组校验来解决这个问题。 首先我们需要在 DTO 对象中定义一个分组：(这里使用内部类进行演示) @Data public class UserDTO { @NotNull(groups = Update.class) @Null(groups = Create.class) private Long id; @Size( groups={Update.class, Create.class}, min=1, max=20, message="Username length must be between 1 and 20 characters") private String username; @Email(groups = {Update.class, Create.class}, message="Email format is incorrect") @NotBlank(groups = {Update.class, Create.class}, message="Email cannot be blank") private String email; @Size( groups={Update.class, Create.class}, min=6, max=20, message="Password length must be between 6 and 20 characters") private String userPassword; public interface Update {} public interface Create {} } 然后我们在 Controller 中使用 @Validated (此时不能使用 @Valid 注解) 注解来指定分组： @Controller @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity&lt;Void&gt; createUser(@Validated(UserDTO.Create.class) @RequestBody UserDTO user) { return null; } @PatchMapping public ResponseEntity&lt;Void&gt; updateUser(@Validated(UserDTO.Update.class) @RequestBody UserDTO user) { return null; } } 常用注解 JSR 303 中定义了很多注解，这里列出一些常用的注解： 注解 说明 @Null 验证对象是否为 null @NotNull 验证对象是否不为 null，无法查检长度为 0的字符串 @NotBlank 验证 String 对象是否不为 null、长度是否大于 0、是否包含至少一个非空白字符 @AssertFalse 验证 Boolean 对象是否为 false @AssertTrue 验证 Boolean 对象是否为 true @Min 验证 Number 对象是否大于等于指定的值 @Max 验证 Number 对象是否小于等于指定的值 @DecimalMin 验证 Number 和 String 对象是否大于等于指定的值 @DecimalMax 验证 Number 和 String 对象是否小于等于指定的值 @Digits 验证 Number 和 String 对象是否是指定范围内的数字 @Past 验证 Date 对象是否是在当前时间之前 @Future 验证 Date 对象是否是在当前时间之后 @Size 验证对象（Array、Collection、Map、String）长度是否在给定的范围之内 @Pattern 验证 String 对象是否符合正则表达式的规则 下面的注解是 Hibernate Validator 中定义的注解： 注解 说明 @Email 验证 String 对象是否是一个合法的电子邮件地址 @Length 验证 String 对象是否是在给定的范围之内 @NotEmpty 验证对象是否不为 null 或者 "" @Range 验证 Number 对象是否在给定的范围之内 MessageSource 管理错误信息 在上面的例子中，我们直接在注解中写入了错误信息，这样的做法并不利于开发。例如，我们如果在编写测试的时候 需要检验错误信息是否一直，我们不得不再次写入错误信息。而修改的时候，我们则需要对多处进行修改。 为了解决这个问题，我们可以使用 MessageSource 来管理错误信息。 首先我们在 application.yml ( 或者 application.properties ) 中添加如下配置： spring: messages: basename: message/message encoding: UTF-8 标识我们的错误信息文件在 resources 目录下的 message 目录中，文件名为 message.properties ( 只能 使用 properties 文件 )。 接下来，我们在 resources 目录下创建一个 message 目录，并且在其中创建一个 message.properties 文件， 在文件中添加如下内容： # UserDTO validation messages UserDTO.username.Size=Username must be between {min} and {max} characters UserDTO.email.NotBlank=Email cannot be blank UserDTO.email.Email=Email must be a valid email address UserDTO.userPassword.Size=Password must be between {min} and {max} characters 然后我们可以直接在注解中的 message 部分使用 MessageSource 的 key 来引用错误信息： @Data public class UserDTO { @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_USERNAME_LENGTH, max=ConstantProperty.MAX_USERNAME_LENGTH, message="{UserDTO.username.Size}") private String username; @Email( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.Email}") @NotBlank( groups={UpdateGroup.class, CreateGroup.class}, message="{UserDTO.email.NotBlank}") private String email; @Size( groups={UpdateGroup.class, CreateGroup.class}, min=ConstantProperty.MIN_PASSWORD_LENGTH, max=ConstantProperty.MAX_PASSWORD_LENGTH, message="{UserDTO.userPassword.Size}") private String userPassword; } 上面通过 message="{xxx.xxx.xxx}" 的方式获取变量是 Hibernate 提供的支持。而我们编写的字符串中 的 {min} 和 {max} 会被替换成注解中的 min 和 max 的值。 但是我们在使用 MessageSource 的时候并不支持这种自动替换的方式，因此我们需要自己书写一个工具类来 替换这些变量： @Component public class MessageSourceUtil { private static MessageSource messageSource; // 通过构造器注入 MessageSource MessageSourceUtil(MessageSource messageSource) { MessageSourceUtil.messageSource = messageSource; } public static String getMessage(String code, Object[] args) { String message=messageSource.getMessage(code, null, null); // 获取到的 message 中包含了 {min} 和 {max} 这样的变量，我们需要将其替换成实际的值 Pattern pattern=Pattern.compile("\\{.*?\\}"); Matcher matcher=pattern.matcher(message); int i=0; while (matcher.find()) { message=message.replace(matcher.group(), args[i].toString()); i++; } return message; } } 这样我们可以在 Controller 中使用 MessageSourceUtil 来获取错误信息： @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mvc; @Test public void testCreateUserInvalid() throws Exception { String user=""" { "name": "test", "email": "invalid email address", "userPassword": "" } """; mvc.perform( MockMvcRequestBuilders.post("/user") .contentType(MediaType.APPLICATION_JSON) .content(user)) .andExpectAll( status().isBadRequest(), jsonPath( "$.email", equalTo(MessageSourceUtil.getMessage("UserDTO.email.Email"))), jsonPath( "$.userPassword", equalTo( MessageSourceUtil.getMessage( "UserDTO.userPassword.Size", ConstantProperty.MIN_PASSWORD_LENGTH, ConstantProperty.MAX_PASSWORD_LENGTH ))), content().contentType(MediaType.APPLICATION_JSON)); } 在上面的代码中，我们同样将密码长度等常量信息放在了 ConstantProperty 类中，这样我们可以在测试中直接 引用这些常量。 国际化 实际上，MessageSource 是用来支持国际化的。在上面的例子中，我们只是使用了一个 properties 文件， 实际上我们可以使用多个 properties 文件来支持多种语言。 我们只需要在 resources/message (取决于我们指定的 basename ) 目录下创建多个 properties 文件， 例如 message.properties、message_en.properties、message_zh.properties 等等。这样在发送请求的 时候，我们可以在请求头中添加 Accept-Language 来指定语言，Spring 会根据请求头中的语言来选择对应的 properties 文件中的信息。]]></summary></entry><entry><title type="html">Python 高级技巧学习</title><link href="https://kaiser-yang.github.io/blog/2024/python-advanced-skills/" rel="alternate" type="text/html" title="Python 高级技巧学习"/><published>2024-08-22T12:34:45+00:00</published><updated>2024-08-22T12:34:45+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/python-advanced-skills</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/python-advanced-skills/"><![CDATA[<p>本文介绍一些 <code class="language-plaintext highlighter-rouge">Python</code> 高级技巧。</p> <h1 id="拆包">拆包</h1> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中，我们可以使用拆包的方式来将一个序列或者字典中的元素赋值给多个变量。下面是最简单的用法：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 1 2
</span></code></pre></div></div> <p>我们还可以使用 <code class="language-plaintext highlighter-rouge">*</code> 来拆包，<code class="language-plaintext highlighter-rouge">*</code> 会将多个元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 1 [2, 3]
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在中间位置，这样可以将中间的元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 1 [2, 3] 4
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在左边，这样可以将右边的元素拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># [1, 2] 3
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以直接用在列表变量中，这样可以将列表中的所有元素拆包为多个变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># [1, 2, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="c1"># 1 2 3
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 还可以用在字典中，这样可以将字典中的所有键拆包为一个列表：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># 'a' ['b', 'c']
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">*</code> 可以用在函数的参数中，这样可以将参数拆包为多个参数：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1"># (1, 2, (3, 4, 5))
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">**</code> 可以用在函数的参数中，这样可以将参数记录成字典：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">g1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">g1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># (1, 2, {'x': 3, 'y': 4, 'z': 5})
</span></code></pre></div></div> <h1 id="fstring"><code class="language-plaintext highlighter-rouge">fstring</code></h1> <p><code class="language-plaintext highlighter-rouge">fstring</code> 是 <code class="language-plaintext highlighter-rouge">Python 3.6</code> 新增的字符串格式化方法，可以使用 <code class="language-plaintext highlighter-rouge">{}</code> 和 <code class="language-plaintext highlighter-rouge">f</code> 前缀来格式化字符串。</p> <h2 id="r-s-和-a"><code class="language-plaintext highlighter-rouge">!r</code>, <code class="language-plaintext highlighter-rouge">!s</code> 和 <code class="language-plaintext highlighter-rouge">!a</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">!r</code> 和 <code class="language-plaintext highlighter-rouge">!s</code> 分别表示调用对象的 <code class="language-plaintext highlighter-rouge">__repr__</code> 和 <code class="language-plaintext highlighter-rouge">__str__</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">!a</code> 则会调用 <code class="language-plaintext highlighter-rouge">ascii</code>，注意这里没有以 <code class="language-plaintext highlighter-rouge">__</code> 开头结尾，这是一个 <code class="language-plaintext highlighter-rouge">Python</code> 提供的方法，不是一个特殊方法。</p> <p>在默认情况下 <code class="language-plaintext highlighter-rouge">f'{number}</code> 会调用 <code class="language-plaintext highlighter-rouge">number.__str__</code> 方法，而 <code class="language-plaintext highlighter-rouge">f'{number!r}</code> 会调用 <code class="language-plaintext highlighter-rouge">number.__repr__</code> 方法。</p> <h2 id="f-e-e-g-和-"><code class="language-plaintext highlighter-rouge">:f</code>, <code class="language-plaintext highlighter-rouge">:e</code>, <code class="language-plaintext highlighter-rouge">:E</code>, <code class="language-plaintext highlighter-rouge">:g</code> 和 <code class="language-plaintext highlighter-rouge">:%</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:f</code>, <code class="language-plaintext highlighter-rouge">:e</code>, <code class="language-plaintext highlighter-rouge">:E</code>, <code class="language-plaintext highlighter-rouge">:g</code> 和 <code class="language-plaintext highlighter-rouge">:%</code> 分别表示浮点数、科学计数法、科学计数法大写、通用格式和百分比。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mf">123.456</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123.456000'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">e</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '1.234560e+02'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">E</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '1.234560E+02'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">g</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123.456'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">%</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '12345.600000%'
</span></code></pre></div></div> <h2 id="--和-"><code class="language-plaintext highlighter-rouge">:&gt;</code>, <code class="language-plaintext highlighter-rouge">:&lt;</code> 和 <code class="language-plaintext highlighter-rouge">:^</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:&gt;</code>, <code class="language-plaintext highlighter-rouge">:&lt;</code> 和 <code class="language-plaintext highlighter-rouge">:^</code> 分别表示右对齐、左对齐和居中对齐。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">123</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '     123'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">&lt;</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '123     '
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="o">^</span><span class="mi">8</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '  123   '
</span></code></pre></div></div> <p>我们还可以指定填充字符，例如 <code class="language-plaintext highlighter-rouge">f'{number:0&gt;8}</code> 表示右对齐，不足 8 位的部分用 <code class="language-plaintext highlighter-rouge">0</code> 填充。</p> <h2 id="b-d-o-x-和-x"><code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code></h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中的 <code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code> 分别表示二进制、十进制、八进制、十六进制小写和十六进制大写。</p> <p>例如 <code class="language-plaintext highlighter-rouge">f'{number:b}</code> 表示将 <code class="language-plaintext highlighter-rouge">number</code> 转换为二进制字符串。还可以通过设置宽度和填充字符来格式化字符串，例如 <code class="language-plaintext highlighter-rouge">f'{number:08b}</code> 表示将 <code class="language-plaintext highlighter-rouge">number</code> 转换为 8 位的二进制字符串，不足 8 位的部分用 <code class="language-plaintext highlighter-rouge">0</code> 填充。</p> <h2 id="千分位分隔符">千分位分隔符</h2> <p><code class="language-plaintext highlighter-rouge">fstring</code> 中可以使用 <code class="language-plaintext highlighter-rouge">,</code> 等来添加千分位分隔符。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">1234567890</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="p">,</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 1,234,567,890
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">_</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 123_456_7890
</span></code></pre></div></div> <h3 id="自定义-__format__-方法">自定义 <code class="language-plaintext highlighter-rouge">__format__</code> 方法</h3> <p>我们可以通过自定义 <code class="language-plaintext highlighter-rouge">__format__</code> 方法来实现自定义的格式化方法。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">b</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">o</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">x</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">format_spec</span> <span class="o">==</span> <span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="si">:</span><span class="mi">08</span><span class="n">X</span><span class="si">}</span><span class="sh">'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">number</span><span class="p">)</span>

<span class="n">number</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">b</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00001010'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00000010'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">o</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '00000012'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">x</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '0000000a'
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">number</span><span class="si">:</span><span class="n">X</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># '0000000A'
</span></code></pre></div></div> <p>上面的代码中，我们更改了 <code class="language-plaintext highlighter-rouge">Number</code> 类的 <code class="language-plaintext highlighter-rouge">__format__</code> 方法，使得 <code class="language-plaintext highlighter-rouge">Number</code> 类的 <code class="language-plaintext highlighter-rouge">:b</code>, <code class="language-plaintext highlighter-rouge">:d</code>, <code class="language-plaintext highlighter-rouge">:o</code>, <code class="language-plaintext highlighter-rouge">:x</code> 和 <code class="language-plaintext highlighter-rouge">:X</code> 变成了 <code class="language-plaintext highlighter-rouge">8</code> 位的二进制、十进制、八进制、十六进制小写和十六进制大写。</p> <h1 id="matchcase-语句"><code class="language-plaintext highlighter-rouge">match/case</code> 语句</h1> <p><code class="language-plaintext highlighter-rouge">Python 3.10</code> 新增了 <code class="language-plaintext highlighter-rouge">match/case</code> 语句，这是一种新的模式匹配语法，可以替代 <code class="language-plaintext highlighter-rouge">if/elif/else</code> 语句。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Blue</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Red
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match</code> 语句会依次匹配 <code class="language-plaintext highlighter-rouge">case</code> 语句，如果匹配成功则执行对应的代码块，如果没有匹配成功则执行 <code class="language-plaintext highlighter-rouge">_</code> 代码块。</p> <p><code class="language-plaintext highlighter-rouge">match</code> 语句还可以使用 <code class="language-plaintext highlighter-rouge">|</code> 来匹配多个值：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Primary</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">magenta</span><span class="sh">'</span> <span class="o">|</span> <span class="sh">'</span><span class="s">yellow</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Secondary</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Primary
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match</code> 语句还可以使用 <code class="language-plaintext highlighter-rouge">if</code> 来添加条件：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">color</span><span class="p">:</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="c1"># Light Red
</span></code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">case</code> 语句中，我们可以指定匹配模式：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="c1"># 也可以使用 *_ 来匹配任意项
</span>        <span class="n">case</span> <span class="p">[</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">light</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">([</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span> <span class="c1"># Light Red
</span><span class="nf">match_color</span><span class="p">([</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span> <span class="c1"># Dark Red
</span></code></pre></div></div> <p>还可以使用 <code class="language-plaintext highlighter-rouge">as</code> 来重新命名变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Light </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Dark </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Light </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">[(</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="k">as</span> <span class="n">color</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Dark </span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">([(</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># Light ('red', True)
</span></code></pre></div></div> <p>需要注意的是，只有以下的类型支持对序列进行拆分的写法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">list</code></li> <li><code class="language-plaintext highlighter-rouge">memoryview</code></li> <li><code class="language-plaintext highlighter-rouge">array.array</code></li> <li><code class="language-plaintext highlighter-rouge">tuple</code></li> <li><code class="language-plaintext highlighter-rouge">range</code></li> <li><code class="language-plaintext highlighter-rouge">collections.deque</code></li> </ul> <p>需要注意的是在序列结构中使用 <code class="language-plaintext highlighter-rouge">str()</code> 等是标明匹配项必须是 <code class="language-plaintext highlighter-rouge">str</code> 类型，而不是进行字符串转换：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nf">bool</span><span class="p">(</span><span class="n">light</span><span class="p">)]</span> <span class="k">if</span> <span class="n">light</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light </span><span class="sh">'</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> <span class="c1"># Unknown
</span><span class="nf">match_color</span><span class="p">((</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> <span class="c1"># Light red
</span></code></pre></div></div> <h1 id="特殊方法">特殊方法</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的特殊方法也叫魔术方法 (<code class="language-plaintext highlighter-rouge">Magic Method</code>)，这些方法以 <code class="language-plaintext highlighter-rouge">__</code> 开头和结尾，比如 <code class="language-plaintext highlighter-rouge">__init__</code>、 <code class="language-plaintext highlighter-rouge">__str__</code>、<code class="language-plaintext highlighter-rouge">__repr__</code> 等。这些方法是 <code class="language-plaintext highlighter-rouge">Python</code> 解释器调用的，我们可以重写这些方法，从而实现自定义的功能。</p> <p>这里给出常用的特殊方法的定义与调用方式。</p> <h2 id="类型转换">类型转换</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__bool__(self)</code></td> <td>布尔化</td> <td><code class="language-plaintext highlighter-rouge">bool(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__int__(self)</code></td> <td>整型化</td> <td><code class="language-plaintext highlighter-rouge">int(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__float__(self)</code></td> <td>浮点化</td> <td><code class="language-plaintext highlighter-rouge">float(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__complex__(self)</code></td> <td>复数化</td> <td><code class="language-plaintext highlighter-rouge">complex(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__bytes__(self)</code></td> <td>字节化</td> <td><code class="language-plaintext highlighter-rouge">bytes(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__str__(self)</code></td> <td>字符串化</td> <td><code class="language-plaintext highlighter-rouge">str(obj)</code></td> </tr> </tbody> </table> <h2 id="一元运算符">一元运算符</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__neg__(self)</code></td> <td>取负</td> <td><code class="language-plaintext highlighter-rouge">-obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__pos__(self)</code></td> <td>取正</td> <td><code class="language-plaintext highlighter-rouge">+obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__abs__(self)</code></td> <td>取绝对值</td> <td><code class="language-plaintext highlighter-rouge">abs(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__round__(self, ndigits)</code></td> <td>四舍五入</td> <td><code class="language-plaintext highlighter-rouge">round(obj, ndigits)</code></td> </tr> </tbody> </table> <h2 id="算数运算">算数运算</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__add__(self, other)</code></td> <td>加法</td> <td><code class="language-plaintext highlighter-rouge">obj + other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__sub__(self, other)</code></td> <td>减法</td> <td><code class="language-plaintext highlighter-rouge">obj - other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__mul__(self, other)</code></td> <td>乘法</td> <td><code class="language-plaintext highlighter-rouge">obj * other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__truediv__(self, other)</code></td> <td>除法</td> <td><code class="language-plaintext highlighter-rouge">obj / other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__floordiv__(self, other)</code></td> <td>整除</td> <td><code class="language-plaintext highlighter-rouge">obj // other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__mod__(self, other)</code></td> <td>取模</td> <td><code class="language-plaintext highlighter-rouge">obj % other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__pow__(self, other)</code></td> <td>幂运算</td> <td><code class="language-plaintext highlighter-rouge">obj ** other</code></td> </tr> </tbody> </table> <p>说明：上述的所有方法增加了 <code class="language-plaintext highlighter-rouge">r</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__radd__</code>、<code class="language-plaintext highlighter-rouge">__rsub__</code> 等，表示反向运算，即 <code class="language-plaintext highlighter-rouge">other + obj</code>。 增加了 <code class="language-plaintext highlighter-rouge">i</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__iadd__</code>、<code class="language-plaintext highlighter-rouge">__isub__</code> 等，表示增量运算，即 <code class="language-plaintext highlighter-rouge">obj += other</code>。</p> <h2 id="比较">比较</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__eq__(self, other)</code></td> <td>等于</td> <td><code class="language-plaintext highlighter-rouge">obj == other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__ne__(self, other)</code></td> <td>不等于</td> <td><code class="language-plaintext highlighter-rouge">obj != other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__lt__(self, other)</code></td> <td>小于</td> <td><code class="language-plaintext highlighter-rouge">obj &lt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__le__(self, other)</code></td> <td>小于等于</td> <td><code class="language-plaintext highlighter-rouge">obj &lt;= other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__gt__(self, other)</code></td> <td>大于</td> <td><code class="language-plaintext highlighter-rouge">obj &gt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__ge__(self, other)</code></td> <td>大于等于</td> <td><code class="language-plaintext highlighter-rouge">obj &gt;= other</code></td> </tr> </tbody> </table> <h2 id="迭代">迭代</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__len__(self)</code></td> <td>长度</td> <td><code class="language-plaintext highlighter-rouge">len(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__getitem__(self, pos)</code></td> <td>获取元素</td> <td><code class="language-plaintext highlighter-rouge">obj[pos]</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__setitem__(self, pos, value)</code></td> <td>设置元素</td> <td><code class="language-plaintext highlighter-rouge">obj[pos] = value</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__iter__(self)</code></td> <td>迭代器</td> <td><code class="language-plaintext highlighter-rouge">for i in obj:</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__contains__(self, value)</code></td> <td>是否包含</td> <td><code class="language-plaintext highlighter-rouge">value in obj</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__next__(self)</code></td> <td>下一个</td> <td><code class="language-plaintext highlighter-rouge">next(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__reversed__(self)</code></td> <td>反向迭代器</td> <td><code class="language-plaintext highlighter-rouge">reversed(obj)</code></td> </tr> </tbody> </table> <h2 id="位运算">位运算</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__and__(self, other)</code></td> <td>与运算</td> <td><code class="language-plaintext highlighter-rouge">obj &amp; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__or__(self, other)</code></td> <td>或运算</td> <td><code class="language-plaintext highlighter-rouge">obj | other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__xor__(self, other)</code></td> <td>异或运算</td> <td><code class="language-plaintext highlighter-rouge">obj ^ other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__lshift__(self, other)</code></td> <td>左移</td> <td><code class="language-plaintext highlighter-rouge">obj &lt;&lt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__rshift__(self, other)</code></td> <td>右移</td> <td><code class="language-plaintext highlighter-rouge">obj &gt;&gt; other</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__invert__(self)</code></td> <td>取反</td> <td><code class="language-plaintext highlighter-rouge">~obj</code></td> </tr> </tbody> </table> <p>说明：上述的所有方法增加了 <code class="language-plaintext highlighter-rouge">r</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__rand__</code>、<code class="language-plaintext highlighter-rouge">__ror__</code> 等，表示反向运算，即 <code class="language-plaintext highlighter-rouge">other &amp; obj</code>。 增加了 <code class="language-plaintext highlighter-rouge">i</code> 前缀，比如 <code class="language-plaintext highlighter-rouge">__iand__</code>、<code class="language-plaintext highlighter-rouge">__ior__</code> 等，表示增量运算，即 <code class="language-plaintext highlighter-rouge">obj &amp;= other</code>。</p> <h2 id="构造与析构">构造与析构</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__init__(self, ...)</code></td> <td>构造方法</td> <td><code class="language-plaintext highlighter-rouge">obj = CalssName(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__new__(cls, ...)</code></td> <td>创建对象</td> <td><code class="language-plaintext highlighter-rouge">obj = ClassName(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__del__(self)</code></td> <td>析构方法</td> <td><code class="language-plaintext highlighter-rouge">del obj</code></td> </tr> </tbody> </table> <p>其中的 <code class="language-plaintext highlighter-rouge">__new__</code> 方法是一个类方法，用于创建对象，而 <code class="language-plaintext highlighter-rouge">__init__</code> 方法是一个实例方法，用于初始化对象。 <code class="language-plaintext highlighter-rouge">__new__</code> 方法需要返回一个对象，通常是调用父类的 <code class="language-plaintext highlighter-rouge">__new__</code> 方法，这个返回值会传递给 <code class="language-plaintext highlighter-rouge">__init__</code> 方法， 而 <code class="language-plaintext highlighter-rouge">__init__</code> 方法不需要返回值。</p> <h2 id="其他">其他</h2> <table> <thead> <tr> <th>方法</th> <th>说明</th> <th>调用方式</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">__repr__(self)</code></td> <td>表示形式</td> <td><code class="language-plaintext highlighter-rouge">repr(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__format__(self, format_spec)</code></td> <td>格式化</td> <td><code class="language-plaintext highlighter-rouge">format(obj, format_spec)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__hash__(self)</code></td> <td>哈希值</td> <td><code class="language-plaintext highlighter-rouge">hash(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__index__</code></td> <td>索引值</td> <td><code class="language-plaintext highlighter-rouge">index(obj)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__call__(self, ...)</code></td> <td>调用</td> <td><code class="language-plaintext highlighter-rouge">obj(...)</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__delitem__(self, pos)</code></td> <td>删除元素</td> <td><code class="language-plaintext highlighter-rouge">del obj[pos]</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__getattr__(self, name)</code></td> <td>获取属性</td> <td><code class="language-plaintext highlighter-rouge">obj.name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__setattr__(self, name, value)</code></td> <td>设置属性</td> <td><code class="language-plaintext highlighter-rouge">obj.name = value</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__delattr__(self, name)</code></td> <td>删除属性</td> <td><code class="language-plaintext highlighter-rouge">del obj.name</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__enter__(self)</code></td> <td>上下文管理器</td> <td><code class="language-plaintext highlighter-rouge">with obj as ...:</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">__exit__(self, exc_type, exc_value, traceback)</code></td> <td>上下文管理器</td> <td><code class="language-plaintext highlighter-rouge">with obj as ...:</code></td> </tr> </tbody> </table> <p>注意：实现方法后的调用方式可能并不只有一种，比如 <code class="language-plaintext highlighter-rouge">__str__</code> 方法可以通过 <code class="language-plaintext highlighter-rouge">str(obj)</code> 或 <code class="language-plaintext highlighter-rouge">print(obj)</code> 来调用。 而如果实现了 <code class="language-plaintext highlighter-rouge">__bool__</code>，那么 <code class="language-plaintext highlighter-rouge">not</code>、<code class="language-plaintext highlighter-rouge">and</code> 和 <code class="language-plaintext highlighter-rouge">or</code> 也会调用这个方法。</p> <p>注意：<code class="language-plaintext highlighter-rouge">Python</code> 中的很多特殊方法即使不进行实现也能使用其支持的调用形式，例如对于一个只实现了 <code class="language-plaintext highlighter-rouge">__add__</code> 方法的类，也可以使用 <code class="language-plaintext highlighter-rouge">a += b</code> 这种形式，此时会被解释为 <code class="language-plaintext highlighter-rouge">a = a + b</code>，即先调用 <code class="language-plaintext highlighter-rouge">__add__</code> 方法，然后进行赋值。</p> <h1 id="海象运算符-">海象运算符 <code class="language-plaintext highlighter-rouge">:=</code></h1> <p>这个符号被称为海象运算符，仅仅是因为它的形状像海象。</p> <p><code class="language-plaintext highlighter-rouge">:=</code> 运算符是 <code class="language-plaintext highlighter-rouge">Python 3.8</code> 新增的，它可以在表达式中赋值，这样我们就可以在表达式中使用赋值的变量：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>一个更加常见的例子是在循环中使用 <code class="language-plaintext highlighter-rouge">:=</code> 运算符：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">while </span><span class="p">(</span><span class="n">line</span> <span class="p">:</span><span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">readline</span><span class="p">()):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">())</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="nb">file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">())</span>
</code></pre></div></div> <p>我们还可以在列表推导式中使用 <code class="language-plaintext highlighter-rouge">:=</code> 运算符。这种情况下，我们往往需要将计算后的结果放到列表中：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="nf">if </span><span class="p">(</span><span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1"># 如果不使用 := 运算符，那么代码会变得更加冗长
</span><span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></div></div> <p>上面的代码能够帮我简化一次 <code class="language-plaintext highlighter-rouge">n * 2</code> 的计算，对于一些复杂的计算，这种方式会更加简洁且效率更高。</p> <h2 id="海象运算符变量的作用域">海象运算符变量的作用域</h2> <p><code class="language-plaintext highlighter-rouge">:=</code> 运算符定义的变量的作用域是当前函数，除非目标变量使用 <code class="language-plaintext highlighter-rouge">global</code> 或者 <code class="language-plaintext highlighter-rouge">nonlocal</code> 修饰：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Length of hello is </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># OK
</span></code></pre></div></div> <h1 id="切片">切片</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的切片是一个非常强大的功能，我们可以使用切片来获取列表、元组、字符串等序列的子序列。</p> <h2 id="切片对象">切片对象</h2> <p>除了基础的切片用法之外，我们可以通过 <code class="language-plaintext highlighter-rouge">slice</code> 类来创建切片对象，这样我们就可以在多个地方使用同一个切片对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">s1</span> <span class="o">=</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># start = 1, end = 5, step = 1
</span><span class="n">s2</span> <span class="o">=</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># start = 1, end = None, step = 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">s1</span><span class="p">])</span> <span class="c1"># [2, 3, 4, 5]
</span><span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">s2</span><span class="p">])</span> <span class="c1"># [2, 3, 4, 5, 6, 7, 8, 9]
</span></code></pre></div></div> <p>切片获取到的对象可以通过赋值来修改原对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 10, 20, 30, 40, 6, 7, 8, 9]
</span></code></pre></div></div> <p>上面的例子说明切片获取到的是引用，对于可变对象而言我们可以修改切片后，原对象也会发生变化：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="c1"># 修改切片的第一个元素的第一个值
</span><span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 等价于 test[0][0] = -1
</span><span class="nf">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="c1"># [[-1, 2, 3], [4, 5, 6], [7, 8, 9]]
</span>
<span class="c1"># test 中保存的是不可变对象，所以 test 本身不会发生变化
</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="c1"># [1, 2, 3]
</span></code></pre></div></div> <h1 id="memoryview"><code class="language-plaintext highlighter-rouge">memoryview</code></h1> <p><code class="language-plaintext highlighter-rouge">memoryview</code> 是一个内置类，它可以让我们直接操作内存，而不需要复制数据。<code class="language-plaintext highlighter-rouge">memoryview</code> 对象可以通过 <code class="language-plaintext highlighter-rouge">memoryview()</code> 函数创建。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1"># 此时 mem 和 number 共享内存，但是此时我们可以随意更改 mem 的形状等
</span><span class="n">mem</span> <span class="o">=</span> <span class="nf">memoryview</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># 2 行 3 列
</span><span class="nf">print</span><span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="nf">tolist</span><span class="p">())</span> <span class="c1"># [[1, 2, 3], [4, 5, 6]]
</span><span class="n">mem</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 2, 3, 4, 5, 100]
</span></code></pre></div></div> <h1 id="字典">字典</h1> <h2 id="字典推导式">字典推导式</h2> <p>我们可以使用列表推导式快速创建列表，实际上，对于字典的创建也有类似的语法：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">}</span>
</code></pre></div></div> <h2 id="在-matchcase-中匹配字典">在 <code class="language-plaintext highlighter-rouge">match/case</code> 中匹配字典</h2> <p><code class="language-plaintext highlighter-rouge">match/case</code> 语句还可以用来匹配字典：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">match_color</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">False</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Red</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Light Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="p">{</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">False</span><span class="p">}:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dark Green</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Unknown</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">match_color</span><span class="p">({</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">light</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span> <span class="c1"># Light Red
</span></code></pre></div></div> <p>上面的匹配式的意思是只要含有这些键值对的都会被匹配，而且顺序不重要，即使是一个 <code class="language-plaintext highlighter-rouge">OrderDict</code> 也会被忽略 顺序。</p> <h1 id="集合">集合</h1> <h2 id="集合推导式">集合推导式</h2> <p>也可以使用集合推导式创建集合：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">}</span>
</code></pre></div></div> <h2 id="判断集合的包含关系">判断集合的包含关系</h2> <p>使用比较运算符可以判断集合的包含关系：</p> <table> <thead> <tr> <th>运算符</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;=</code></td> <td>子集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;</code></td> <td>真子集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;=</code></td> <td>超集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;</code></td> <td>真超集</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">==</code></td> <td>相等</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">!=</code></td> <td>不相等</td> </tr> </tbody> </table> <h1 id="可变对象与不可变对象">可变对象与不可变对象</h1> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的对象分为可变对象和不可变对象，可变对象是指对象的值可以改变，而不可变对象是指对象的值不可以改变。</p> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的不可变对象有：<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">complex</code>、<code class="language-plaintext highlighter-rouge">str</code>、<code class="language-plaintext highlighter-rouge">tuple</code>、<code class="language-plaintext highlighter-rouge">frozenset</code> 等。</p> <p><code class="language-plaintext highlighter-rouge">Python</code> 中的可变对象有：<code class="language-plaintext highlighter-rouge">list</code>、<code class="language-plaintext highlighter-rouge">dict</code>、<code class="language-plaintext highlighter-rouge">set</code> 等。</p> <p>一个对象如果可以通过 <code class="language-plaintext highlighter-rouge">hash</code> 函数计算哈希值且不抛出异常，那么这个对象就是不可变对象。例如我们可以通过 以下的代码来判断一个对象是否是可变对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nf">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">is_mutable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span> <span class="c1"># True
</span></code></pre></div></div> <h2 id="避免可变对象作为默认值">避免可变对象作为默认值</h2> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中如果使用可变对象绑定到默认值，那么在函数调用时会共享这个可变对象，这样会导致默认值的改变：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1, 1]
</span></code></pre></div></div> <p>如果我们想要避免这种情况，我们可以使用 <code class="language-plaintext highlighter-rouge">None</code> 作为默认值，然后在函数内部判断是否为 <code class="language-plaintext highlighter-rouge">None</code>，然后创建一个新的对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">())</span> <span class="c1"># [1]
</span></code></pre></div></div> <h1 id="类属性和实例属性">类属性和实例属性</h1> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 中，存在类属性和实例属性的区分，一般而言，类属性可以通过在类的开头定义，而实例对象可以在 <code class="language-plaintext highlighter-rouge">__init__</code> 方法中定义。类属性可以通过类名或者实例对象访问，而实例属性则可以通过实例对象访问。例如：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">class_attr</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">instance_attr</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">instance_attr</span><span class="p">)</span> <span class="c1"># 2
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span></code></pre></div></div> <p>如果通过实例对象去修改类属性，那么实际上是创建了一个新的实例属性：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 创建一个新的实例对象，名字与类属性相同
</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 3
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
# 可以通过 del 删除实例属性
</span><span class="k">del</span> <span class="n">a</span><span class="p">.</span><span class="n">class_attr</span>
<span class="c1"># 由于实例对象的 class_attr 属性被删除，所以会访问类属性
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">class_attr</span><span class="p">)</span> <span class="c1"># 1
</span></code></pre></div></div> <h2 id="静态方法类方法和实例方法">静态方法、类方法和实例方法</h2> <p>在 <code class="language-plaintext highlighter-rouge">Python</code> 的类中，有三种方法：静态方法、类方法和实例方法。</p> <p>首先介绍最常见的实例方法，实例方法的第一个参数是 <code class="language-plaintext highlighter-rouge">self</code>，表示实例对象本身：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">instance_method</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 实例方法可以访问实例属性
</span>        <span class="k">return</span> <span class="n">self</span>
</code></pre></div></div> <p>实例方法可以通过实例对象调用，也可以通过类对象调用，但是需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">())</span> <span class="c1"># &lt;__main__.A object at 0x7f8b3c7b3d30&gt;
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c1"># &lt;__main__.A object at 0x7f8b3c7b3d30&gt;
</span></code></pre></div></div> <p>类方法使用 <code class="language-plaintext highlighter-rouge">@classmethod</code> 装饰器来定义，类方法的第一个参数是 <code class="language-plaintext highlighter-rouge">cls</code>，表示类对象本身：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_method</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="c1"># 类方法可以访问类属性
</span>        <span class="k">return</span> <span class="n">cls</span>
</code></pre></div></div> <p>类方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">class_method</span><span class="p">())</span> <span class="c1"># &lt;class '__main__.A'&gt;
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">class_method</span><span class="p">())</span> <span class="c1"># &lt;class '__main__.A'&gt;
</span></code></pre></div></div> <p>静态方法使用 <code class="language-plaintext highlighter-rouge">@staticmethod</code> 装饰器来定义，静态方法没有 <code class="language-plaintext highlighter-rouge">self</code> 和 <code class="language-plaintext highlighter-rouge">cls</code> 参数：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_method</span><span class="p">():</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s">static method</span><span class="sh">'</span>
</code></pre></div></div> <p>静态方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nc">A</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">static_method</span><span class="p">())</span> <span class="c1"># static method
</span><span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">static_method</span><span class="p">())</span> <span class="c1"># static method
</span></code></pre></div></div> <p>静态方法其实更像是一个普通的函数，它不能访问类属性和实例属性，但是他可以被实例方法或者类方法调用， 所以如果需要处理的逻辑只会被当前的类多次调用，那么可以使用静态方法实现代码的复用。</p>]]></content><author><name></name></author><category term="Python"/><summary type="html"><![CDATA[本文介绍一些 Python 高级技巧。 拆包 在 Python 中，我们可以使用拆包的方式来将一个序列或者字典中的元素赋值给多个变量。下面是最简单的用法： a, b=(1, 2) print(a, b) # 1 2 我们还可以使用 * 来拆包，* 会将多个元素拆包为一个列表： a, *b = (1, 2, 3) print(a, b) # 1 [2, 3] * 还可以用在中间位置，这样可以将中间的元素拆包为一个列表： a, *b, c=(1, 2, 3, 4) print(a, b, c) # 1 [2, 3] 4 * 还可以用在左边，这样可以将右边的元素拆包为一个列表： *a, b=(1, 2, 3) print(a, b) # [1, 2] 3 * 还可以直接用在列表变量中，这样可以将列表中的所有元素拆包为多个变量： a=[1, 2, 3] print(a) # [1, 2, 3] print(*a) # 1 2 3 * 还可以用在字典中，这样可以将字典中的所有键拆包为一个列表： a, *b = {'a': 1, 'b': 2, 'c': 3} print(a, b) # 'a' ['b', 'c'] * 可以用在函数的参数中，这样可以将参数拆包为多个参数： def f1(a, b, *c): return a, b, c print(f1(1, 2, 3, 4, 5)) # (1, 2, (3, 4, 5)) ** 可以用在函数的参数中，这样可以将参数记录成字典： def g1(a, b, **c): return a, b, c print(g1(1, 2, x=3, y=4, z=5)) # (1, 2, {'x': 3, 'y': 4, 'z': 5}) fstring fstring 是 Python 3.6 新增的字符串格式化方法，可以使用 {} 和 f 前缀来格式化字符串。 !r, !s 和 !a fstring 中的 !r 和 !s 分别表示调用对象的 __repr__ 和 __str__ 方法。 !a 则会调用 ascii，注意这里没有以 __ 开头结尾，这是一个 Python 提供的方法，不是一个特殊方法。 在默认情况下 f'{number} 会调用 number.__str__ 方法，而 f'{number!r} 会调用 number.__repr__ 方法。 :f, :e, :E, :g 和 :% fstring 中的 :f, :e, :E, :g 和 :% 分别表示浮点数、科学计数法、科学计数法大写、通用格式和百分比。 number=123.456 print(f'{number:f}') # '123.456000' print(f'{number:e}') # '1.234560e+02' print(f'{number:E}') # '1.234560E+02' print(f'{number:g}') # '123.456' print(f'{number:%}') # '12345.600000%' :&gt;, :&lt; 和 :^ fstring 中的 :&gt;, :&lt; 和 :^ 分别表示右对齐、左对齐和居中对齐。 number=123 print(f'{number:&gt;8}') # ' 123' print(f'{number:&lt;8}') # '123 ' print(f'{number:^8}') # ' 123 ' 我们还可以指定填充字符，例如 f'{number:0&gt;8} 表示右对齐，不足 8 位的部分用 0 填充。 :b, :d, :o, :x 和 :X fstring 中的 :b, :d, :o, :x 和 :X 分别表示二进制、十进制、八进制、十六进制小写和十六进制大写。 例如 f'{number:b} 表示将 number 转换为二进制字符串。还可以通过设置宽度和填充字符来格式化字符串，例如 f'{number:08b} 表示将 number 转换为 8 位的二进制字符串，不足 8 位的部分用 0 填充。 千分位分隔符 fstring 中可以使用 , 等来添加千分位分隔符。 number=1234567890 print(f'{number:,}') # 1,234,567,890 print(f'{number:_}') # 123_456_7890 自定义 __format__ 方法 我们可以通过自定义 __format__ 方法来实现自定义的格式化方法。 class Number: def __init__(self, number): self.number = number def __format__(self, format_spec): if format_spec== 'b': return f'{self.number:08b}' elif format_spec== 'd': return f'{self.number:08d}' elif format_spec== 'o': return f'{self.number:08o}' elif format_spec== 'x': return f'{self.number:08x}' elif format_spec== 'X': return f'{self.number:08X}' else: return str(self.number) number=Number(10) print(f'{number:b}') # '00001010' print(f'{number:d}') # '00000010' print(f'{number:o}') # '00000012' print(f'{number:x}') # '0000000a' print(f'{number:X}') # '0000000A' 上面的代码中，我们更改了 Number 类的 __format__ 方法，使得 Number 类的 :b, :d, :o, :x 和 :X 变成了 8 位的二进制、十进制、八进制、十六进制小写和十六进制大写。 match/case 语句 Python 3.10 新增了 match/case 语句，这是一种新的模式匹配语法，可以替代 if/elif/else 语句。 def match_color(color): match color: case 'red': print('Red') case 'green': print('Green') case 'blue': print('Blue') case _: print('Unknown') match_color('red') # Red match 语句会依次匹配 case 语句，如果匹配成功则执行对应的代码块，如果没有匹配成功则执行 _ 代码块。 match 语句还可以使用 | 来匹配多个值： def match_color(color): match color: case 'red' | 'green' | 'blue': print('Primary') case 'cyan' | 'magenta' | 'yellow': print('Secondary') case _: print('Unknown') match_color('red') # Primary match 语句还可以使用 if 来添加条件： def match_color(color, light): match color: case 'red' if light: print('Light Red') case 'red': print('Dark Red') case 'green' if light: print('Light Green') case 'green': print('Dark Green') case _: print('Unknown') match_color('red', True) # Light Red 在 case 语句中，我们可以指定匹配模式： def match_color(info): match info: case ['red', _, _, light] if light: print('Light Red') case ['red', _, _, light] if not light: print('Dark Red') case ['green', _, _, light] if light: print('Light Green') # 也可以使用 *_ 来匹配任意项 case ['green', *_, light] if not light: print('Dark Green') case _: print('Unknown') match_color(['red', 1, 2, True]) # Light Red match_color(['red', 1, 2, False]) # Dark Red 还可以使用 as 来重新命名变量： def match_color(info): match info: case [('red', light) as color, _] if light: print(f'Light {color}') case [('red', light) as color, _] if not light: print(f'Dark {color}') case [('green', light) as color, _] if light: print(f'Light {color}') case [('green', light) as color, _] if not light: print(f'Dark {color}') case _: print('Unknown') match_color([('red', True), 1]) # Light ('red', True) 需要注意的是，只有以下的类型支持对序列进行拆分的写法： list memoryview array.array tuple range collections.deque 需要注意的是在序列结构中使用 str() 等是标明匹配项必须是 str 类型，而不是进行字符串转换： def match_color(info): match info: case [str(name), bool(light)] if light: print('Light ' + name) case _: print('Unknown') match_color((1, True)) # Unknown match_color(('red', True)) # Light red 特殊方法 Python 中的特殊方法也叫魔术方法 (Magic Method)，这些方法以 __ 开头和结尾，比如 __init__、 __str__、__repr__ 等。这些方法是 Python 解释器调用的，我们可以重写这些方法，从而实现自定义的功能。 这里给出常用的特殊方法的定义与调用方式。 类型转换 方法 说明 调用方式 __bool__(self) 布尔化 bool(obj) __int__(self) 整型化 int(obj) __float__(self) 浮点化 float(obj) __complex__(self) 复数化 complex(obj) __bytes__(self) 字节化 bytes(obj) __str__(self) 字符串化 str(obj) 一元运算符 方法 说明 调用方式 __neg__(self) 取负 -obj __pos__(self) 取正 +obj __abs__(self) 取绝对值 abs(obj) __round__(self, ndigits) 四舍五入 round(obj, ndigits) 算数运算 方法 说明 调用方式 __add__(self, other) 加法 obj + other __sub__(self, other) 减法 obj - other __mul__(self, other) 乘法 obj * other __truediv__(self, other) 除法 obj / other __floordiv__(self, other) 整除 obj // other __mod__(self, other) 取模 obj % other __pow__(self, other) 幂运算 obj ** other 说明：上述的所有方法增加了 r 前缀，比如 __radd__、__rsub__ 等，表示反向运算，即 other + obj。 增加了 i 前缀，比如 __iadd__、__isub__ 等，表示增量运算，即 obj += other。 比较 方法 说明 调用方式 __eq__(self, other) 等于 obj== other __ne__(self, other) 不等于 obj != other __lt__(self, other) 小于 obj &lt; other __le__(self, other) 小于等于 obj &lt;= other __gt__(self, other) 大于 obj &gt; other __ge__(self, other) 大于等于 obj &gt;= other 迭代 方法 说明 调用方式 __len__(self) 长度 len(obj) __getitem__(self, pos) 获取元素 obj[pos] __setitem__(self, pos, value) 设置元素 obj[pos] = value __iter__(self) 迭代器 for i in obj: __contains__(self, value) 是否包含 value in obj __next__(self) 下一个 next(obj) __reversed__(self) 反向迭代器 reversed(obj) 位运算 方法 说明 调用方式 __and__(self, other) 与运算 obj &amp; other __or__(self, other) 或运算 obj | other __xor__(self, other) 异或运算 obj ^ other __lshift__(self, other) 左移 obj &lt;&lt; other __rshift__(self, other) 右移 obj &gt;&gt; other __invert__(self) 取反 ~obj 说明：上述的所有方法增加了 r 前缀，比如 __rand__、__ror__ 等，表示反向运算，即 other &amp; obj。 增加了 i 前缀，比如 __iand__、__ior__ 等，表示增量运算，即 obj &amp;= other。 构造与析构 方法 说明 调用方式 __init__(self, ...) 构造方法 obj=CalssName(...) __new__(cls, ...) 创建对象 obj=ClassName(...) __del__(self) 析构方法 del obj 其中的 __new__ 方法是一个类方法，用于创建对象，而 __init__ 方法是一个实例方法，用于初始化对象。 __new__ 方法需要返回一个对象，通常是调用父类的 __new__ 方法，这个返回值会传递给 __init__ 方法， 而 __init__ 方法不需要返回值。 其他 方法 说明 调用方式 __repr__(self) 表示形式 repr(obj) __format__(self, format_spec) 格式化 format(obj, format_spec) __hash__(self) 哈希值 hash(obj) __index__ 索引值 index(obj) __call__(self, ...) 调用 obj(...) __delitem__(self, pos) 删除元素 del obj[pos] __getattr__(self, name) 获取属性 obj.name __setattr__(self, name, value) 设置属性 obj.name = value __delattr__(self, name) 删除属性 del obj.name __enter__(self) 上下文管理器 with obj as ...: __exit__(self, exc_type, exc_value, traceback) 上下文管理器 with obj as ...: 注意：实现方法后的调用方式可能并不只有一种，比如 __str__ 方法可以通过 str(obj) 或 print(obj) 来调用。 而如果实现了 __bool__，那么 not、and 和 or 也会调用这个方法。 注意：Python 中的很多特殊方法即使不进行实现也能使用其支持的调用形式，例如对于一个只实现了 __add__ 方法的类，也可以使用 a += b 这种形式，此时会被解释为 a=a + b，即先调用 __add__ 方法，然后进行赋值。 海象运算符 := 这个符号被称为海象运算符，仅仅是因为它的形状像海象。 := 运算符是 Python 3.8 新增的，它可以在表达式中赋值，这样我们就可以在表达式中使用赋值的变量： if (n := len('hello')) &gt; 5: print(f'Length of hello is {n}') # 如果不使用 := 运算符，那么代码会变得更加冗长 n=len('hello') if n &gt; 5: print(f'Length of hello is {n}') 一个更加常见的例子是在循环中使用 := 运算符： file=open(filename, "r") while (line := file.readline()): print(line.strip()) # 如果不使用 := 运算符，那么代码会变得更加冗长 file=open(filename, "r") while True: line=file.readline() if not line: break print(line.strip()) 我们还可以在列表推导式中使用 := 运算符。这种情况下，我们往往需要将计算后的结果放到列表中： numbers=[1, 2, 3, 4, 5] evens=[x for n in numbers if (x := n * 2) &gt;= 10] # 如果不使用 := 运算符，那么代码会变得更加冗长 evens=[n * 2 for n in numbers if n * 2 &gt;= 10] 上面的代码能够帮我简化一次 n * 2 的计算，对于一些复杂的计算，这种方式会更加简洁且效率更高。 海象运算符变量的作用域 := 运算符定义的变量的作用域是当前函数，除非目标变量使用 global 或者 nonlocal 修饰： if (n := len('hello')) &gt; 5: print(f'Length of hello is {n}') print(n) # OK 切片 Python 中的切片是一个非常强大的功能，我们可以使用切片来获取列表、元组、字符串等序列的子序列。 切片对象 除了基础的切片用法之外，我们可以通过 slice 类来创建切片对象，这样我们就可以在多个地方使用同一个切片对象： numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9] s1=slice(1, 5) # start=1, end=5, step=1 s2=slice(1) # start=1, end=None, step=1 print(numbers[s1]) # [2, 3, 4, 5] print(numbers[s2]) # [2, 3, 4, 5, 6, 7, 8, 9] 切片获取到的对象可以通过赋值来修改原对象： numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[1:5] = [10, 20, 30, 40] print(numbers) # [1, 10, 20, 30, 40, 6, 7, 8, 9] 上面的例子说明切片获取到的是引用，对于可变对象而言我们可以修改切片后，原对象也会发生变化： test=[[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 修改切片的第一个元素的第一个值 test[0:2][0][0] = -1 # 等价于 test[0][0] = -1 print(test) # [[-1, 2, 3], [4, 5, 6], [7, 8, 9]] # test 中保存的是不可变对象，所以 test 本身不会发生变化 test=[1, 2, 3] test[0:2][0] = -1 print(test) # [1, 2, 3] memoryview memoryview 是一个内置类，它可以让我们直接操作内存，而不需要复制数据。memoryview 对象可以通过 memoryview() 函数创建。 numbers=array.array('B', [1, 2, 3, 4, 5, 6]) # 此时 mem 和 number 共享内存，但是此时我们可以随意更改 mem 的形状等 mem=memoryview(numbers) mem=mem.cast('B', [2, 3]) # 2 行 3 列 print(mem.tolist()) # [[1, 2, 3], [4, 5, 6]] mem[1, 2] = 100 print(numbers) # [1, 2, 3, 4, 5, 100] 字典 字典推导式 我们可以使用列表推导式快速创建列表，实际上，对于字典的创建也有类似的语法： {key: value for key, value in iterable} 在 match/case 中匹配字典 match/case 语句还可以用来匹配字典： def match_color(info): match info: case {'color': 'red', 'light': True}: print('Light Red') case {'color': 'red', 'light': False}: print('Dark Red') case {'color': 'green', 'light': True}: print('Light Green') case {'color': 'green', 'light': False}: print('Dark Green') case _: print('Unknown') match_color({'color': 'red', 'light': True}) # Light Red 上面的匹配式的意思是只要含有这些键值对的都会被匹配，而且顺序不重要，即使是一个 OrderDict 也会被忽略 顺序。 集合 集合推导式 也可以使用集合推导式创建集合： {value for value in iterable} 判断集合的包含关系 使用比较运算符可以判断集合的包含关系： 运算符 说明 &lt;= 子集 &lt; 真子集 &gt;= 超集 &gt; 真超集 == 相等 != 不相等 可变对象与不可变对象 Python 中的对象分为可变对象和不可变对象，可变对象是指对象的值可以改变，而不可变对象是指对象的值不可以改变。 Python 中的不可变对象有：int、float、complex、str、tuple、frozenset 等。 Python 中的可变对象有：list、dict、set 等。 一个对象如果可以通过 hash 函数计算哈希值且不抛出异常，那么这个对象就是不可变对象。例如我们可以通过 以下的代码来判断一个对象是否是可变对象： def is_mutable(obj): try: hash(obj) return False except TypeError: return True print(is_mutable(1)) # False print(is_mutable('hello')) # False print(is_mutable([1, 2, 3])) # True 避免可变对象作为默认值 在 Python 中如果使用可变对象绑定到默认值，那么在函数调用时会共享这个可变对象，这样会导致默认值的改变： def f(a=[]): a.append(1) return a print(f()) # [1] print(f()) # [1, 1] 如果我们想要避免这种情况，我们可以使用 None 作为默认值，然后在函数内部判断是否为 None，然后创建一个新的对象： def f(a=None): if a is None: a=[] a.append(1) return a print(f()) # [1] print(f()) # [1] 类属性和实例属性 在 Python 中，存在类属性和实例属性的区分，一般而言，类属性可以通过在类的开头定义，而实例对象可以在 __init__ 方法中定义。类属性可以通过类名或者实例对象访问，而实例属性则可以通过实例对象访问。例如： class A: class_attr=1 def __init__(self): self.instance_attr = 2 a=A() print(a.class_attr) # 1 print(a.instance_attr) # 2 print(A.class_attr) # 1 如果通过实例对象去修改类属性，那么实际上是创建了一个新的实例属性： # 创建一个新的实例对象，名字与类属性相同 a.class_attr = 3 print(a.class_attr) # 3 print(A.class_attr) # 1 # 可以通过 del 删除实例属性 del a.class_attr # 由于实例对象的 class_attr 属性被删除，所以会访问类属性 print(a.class_attr) # 1 静态方法、类方法和实例方法 在 Python 的类中，有三种方法：静态方法、类方法和实例方法。 首先介绍最常见的实例方法，实例方法的第一个参数是 self，表示实例对象本身： class A: def instance_method(self): # 实例方法可以访问实例属性 return self 实例方法可以通过实例对象调用，也可以通过类对象调用，但是需要传入实例对象： a=A() print(a.instance_method()) # &lt;__main__.A object at 0x7f8b3c7b3d30&gt; print(A.instance_method(a)) # &lt;__main__.A object at 0x7f8b3c7b3d30&gt; 类方法使用 @classmethod 装饰器来定义，类方法的第一个参数是 cls，表示类对象本身： class A: @classmethod def class_method(cls): # 类方法可以访问类属性 return cls 类方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象： a=A() print(a.class_method()) # &lt;class '__main__.A'&gt; print(A.class_method()) # &lt;class '__main__.A'&gt; 静态方法使用 @staticmethod 装饰器来定义，静态方法没有 self 和 cls 参数： class A: @staticmethod def static_method(): return 'static method' 静态方法可以通过类对象调用，也可以通过实例对象调用，但是不需要传入实例对象： a=A() print(a.static_method()) # static method print(A.static_method()) # static method 静态方法其实更像是一个普通的函数，它不能访问类属性和实例属性，但是他可以被实例方法或者类方法调用， 所以如果需要处理的逻辑只会被当前的类多次调用，那么可以使用静态方法实现代码的复用。]]></summary></entry><entry><title type="html">使用 Spring-Doc 生成接口文档</title><link href="https://kaiser-yang.github.io/blog/2024/spring-doc-intro/" rel="alternate" type="text/html" title="使用 Spring-Doc 生成接口文档"/><published>2024-08-21T13:44:57+00:00</published><updated>2024-08-21T13:44:57+00:00</updated><id>https://kaiser-yang.github.io/blog/2024/spring-doc-intro</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2024/spring-doc-intro/"><![CDATA[<p>本文主要介绍如何使用 <code class="language-plaintext highlighter-rouge">OpenAPI 3.0</code> 为一个 <code class="language-plaintext highlighter-rouge">Spring Boot</code> 项目 (<code class="language-plaintext highlighter-rouge">web</code> 项目) 生成 <code class="language-plaintext highlighter-rouge">API</code> 文档。</p> <h1 id="常用注解">常用注解</h1> <h2 id="tag"><code class="language-plaintext highlighter-rouge">@Tag</code></h2> <p><code class="language-plaintext highlighter-rouge">@Tag</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 分组，可以为 <code class="language-plaintext highlighter-rouge">@Tag</code> 指定 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">description</code>。<code class="language-plaintext highlighter-rouge">name</code> 相同的 <code class="language-plaintext highlighter-rouge">@Tag</code> 会被合并到一起。</p> <p>通常情况下，我们会使用 <code class="language-plaintext highlighter-rouge">@Tag</code> 标识一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类。</p> <h2 id="operation"><code class="language-plaintext highlighter-rouge">@Operation</code></h2> <p><code class="language-plaintext highlighter-rouge">@Operation</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加描述信息，可以为 <code class="language-plaintext highlighter-rouge">@Operation</code> 指定 <code class="language-plaintext highlighter-rouge">summary</code> 和 <code class="language-plaintext highlighter-rouge">description</code>。</p> <h2 id="parameters-和-parameter"><code class="language-plaintext highlighter-rouge">@Parameters</code> 和 <code class="language-plaintext highlighter-rouge">@Parameter</code></h2> <p><code class="language-plaintext highlighter-rouge">@Parameters</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加参数信息，<code class="language-plaintext highlighter-rouge">@Parameters</code> 中包含多个 <code class="language-plaintext highlighter-rouge">@Parameter</code>。</p> <p><code class="language-plaintext highlighter-rouge">@Parameter</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加参数信息，可以为 <code class="language-plaintext highlighter-rouge">@Parameter</code> 指定 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">in</code>、<code class="language-plaintext highlighter-rouge">description</code>、 <code class="language-plaintext highlighter-rouge">required</code>、<code class="language-plaintext highlighter-rouge">schema</code> 等属性。</p> <h2 id="schema"><code class="language-plaintext highlighter-rouge">@Schema</code></h2> <p><code class="language-plaintext highlighter-rouge">@Schema</code> 用于给对象添加描述信息，可以为 <code class="language-plaintext highlighter-rouge">@Schema</code> 指定 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">title</code>、<code class="language-plaintext highlighter-rouge">description</code>、<code class="language-plaintext highlighter-rouge">example</code> 等属性。</p> <h2 id="hidden-parameterhidden--true-和-operationhidden--true"><code class="language-plaintext highlighter-rouge">@Hidden</code>, <code class="language-plaintext highlighter-rouge">@Parameter(hidden = true)</code> 和 <code class="language-plaintext highlighter-rouge">@Operation(hidden = true)</code></h2> <p><code class="language-plaintext highlighter-rouge">@Hidden</code> 用于隐藏一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类，<code class="language-plaintext highlighter-rouge">@Parameter(hidden = true)</code> 用于隐藏一个参数，<code class="language-plaintext highlighter-rouge">@Operation(hidden = true)</code> 用于隐藏一个 <code class="language-plaintext highlighter-rouge">API</code> (方法)。</p> <h2 id="apiresponses-和-apiresponse"><code class="language-plaintext highlighter-rouge">@ApiResponses</code> 和 <code class="language-plaintext highlighter-rouge">@ApiResponse</code></h2> <p><code class="language-plaintext highlighter-rouge">@ApiResponses</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加响应信息，<code class="language-plaintext highlighter-rouge">@ApiResponses</code> 中包含多个 <code class="language-plaintext highlighter-rouge">@ApiResponse</code>。</p> <p><code class="language-plaintext highlighter-rouge">@ApiResponse</code> 用于为 <code class="language-plaintext highlighter-rouge">API</code> 文档中的 <code class="language-plaintext highlighter-rouge">API</code> 添加响应信息，可以为 <code class="language-plaintext highlighter-rouge">@ApiResponse</code> 指定 <code class="language-plaintext highlighter-rouge">responseCode</code>、<code class="language-plaintext highlighter-rouge">description</code>、 <code class="language-plaintext highlighter-rouge">content</code> 等属性。</p> <h1 id="一个完整的例子">一个完整的例子</h1> <p>我们首先为 <code class="language-plaintext highlighter-rouge">DTO</code> 对象添加各种的 <code class="language-plaintext highlighter-rouge">@Schema</code> 注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"User Data Transfer Object"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">accessMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">AccessMode</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"Username"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"Email"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin@cmipt.edu"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
    <span class="nd">@Schema</span><span class="o">(</span><span class="n">description</span> <span class="o">=</span> <span class="s">"User Password (Unencrypted)"</span><span class="o">,</span> <span class="n">requiredMode</span> <span class="o">=</span> <span class="nc">Schema</span><span class="o">.</span><span class="na">RequiredMode</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">,</span> <span class="n">example</span> <span class="o">=</span> <span class="s">"admin"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userPassword</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>接下来我们为一个 <code class="language-plaintext highlighter-rouge">Controller</code> 类添加 <code class="language-plaintext highlighter-rouge">@Tag</code>、<code class="language-plaintext highlighter-rouge">@Operation</code>、<code class="language-plaintext highlighter-rouge">@ApiResponses</code> 和 <code class="language-plaintext highlighter-rouge">@ApiResponse</code> 等注解：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/user"</span><span class="o">)</span>
<span class="nd">@Tag</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"User"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User Related APIs"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="nd">@Operation</span><span class="o">(</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="s">"Create a new user"</span><span class="o">,</span>
        <span class="n">description</span> <span class="o">=</span> <span class="s">"Create a new user with the given information"</span><span class="o">,</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"User"</span><span class="o">,</span> <span class="s">"Post Method"</span> <span class="o">}</span>
    <span class="o">)</span>
    <span class="nd">@ApiResponses</span><span class="o">({</span>
            <span class="nd">@ApiResponse</span><span class="o">(</span><span class="n">responseCode</span> <span class="o">=</span> <span class="s">"200"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User created successfully"</span><span class="o">),</span>
            <span class="nd">@ApiResponse</span><span class="o">(</span><span class="n">responseCode</span> <span class="o">=</span> <span class="s">"400"</span><span class="o">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">"User creation failed"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">UserDTO</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// some code here</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>经过上面的操作后，我们启动程序，访问 <code class="language-plaintext highlighter-rouge">http://localhost:8080/swagger-ui/index.html</code>，就可以看到生成的 <code class="language-plaintext highlighter-rouge">API</code> 文档了。</p> <p><img src="https://raw.githubusercontent.com/Kaiser-Yang/image-hosting-site/main/20240421-20250421/20240821214051.png" alt="" class="img-fluid"/></p>]]></content><author><name></name></author><category term="Java"/><category term="Spring"/><category term="Spring MVC"/><category term="Spring Boot"/><category term="Spring-Doc"/><category term="OpenAPI"/><summary type="html"><![CDATA[本文主要介绍如何使用 OpenAPI 3.0 为一个 Spring Boot 项目 (web 项目) 生成 API 文档。 常用注解 @Tag @Tag 用于为 API 文档中的 API 分组，可以为 @Tag 指定 name 和 description。name 相同的 @Tag 会被合并到一起。 通常情况下，我们会使用 @Tag 标识一个 Controller 类。 @Operation @Operation 用于为 API 文档中的 API 添加描述信息，可以为 @Operation 指定 summary 和 description。 @Parameters 和 @Parameter @Parameters 用于为 API 文档中的 API 添加参数信息，@Parameters 中包含多个 @Parameter。 @Parameter 用于为 API 文档中的 API 添加参数信息，可以为 @Parameter 指定 name、in、description、 required、schema 等属性。 @Schema @Schema 用于给对象添加描述信息，可以为 @Schema 指定 name、title、description、example 等属性。 @Hidden, @Parameter(hidden = true) 和 @Operation(hidden = true) @Hidden 用于隐藏一个 Controller 类，@Parameter(hidden = true) 用于隐藏一个参数，@Operation(hidden = true) 用于隐藏一个 API (方法)。 @ApiResponses 和 @ApiResponse @ApiResponses 用于为 API 文档中的 API 添加响应信息，@ApiResponses 中包含多个 @ApiResponse。 @ApiResponse 用于为 API 文档中的 API 添加响应信息，可以为 @ApiResponse 指定 responseCode、description、 content 等属性。 一个完整的例子 我们首先为 DTO 对象添加各种的 @Schema 注解： @Data @Schema(description = "User Data Transfer Object") public class UserDTO { @Schema(accessMode = Schema.AccessMode.READ_ONLY, description="User ID") private Long id; @Schema(description = "Username", requiredMode=Schema.RequiredMode.REQUIRED, example="admin") private String username; @Schema(description = "Email", requiredMode=Schema.RequiredMode.REQUIRED, example="admin@cmipt.edu") private String email; @Schema(description = "User Password (Unencrypted)", requiredMode=Schema.RequiredMode.REQUIRED, example="admin") private String userPassword; } 接下来我们为一个 Controller 类添加 @Tag、@Operation、@ApiResponses 和 @ApiResponse 等注解： @Controller @RequestMapping("/user") @Tag(name = "User", description="User Related APIs") public class UserController { @Autowired private UserService userService; @PostMapping @Operation( summary="Create a new user", description="Create a new user with the given information", tags={ "User", "Post Method" } ) @ApiResponses({ @ApiResponse(responseCode = "200", description="User created successfully"), @ApiResponse(responseCode = "400", description="User creation failed") }) public ResponseEntity&lt;Void&gt; createUser(@RequestBody UserDTO user) { // some code here return ResponseEntity.ok().build(); } } 经过上面的操作后，我们启动程序，访问 http://localhost:8080/swagger-ui/index.html，就可以看到生成的 API 文档了。]]></summary></entry></feed>