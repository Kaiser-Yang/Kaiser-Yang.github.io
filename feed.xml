<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://kaiser-yang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiser-yang.github.io/" rel="alternate" type="text/html" hreflang="zh"/><updated>2026-01-10T10:45:48+00:00</updated><id>https://kaiser-yang.github.io/feed.xml</id><title type="html">Kaiser’s Homepage</title><subtitle>Sharing everything I know. </subtitle><entry><title type="html">Vim 常用技巧</title><link href="https://kaiser-yang.github.io/blog/2025/vim-skills/" rel="alternate" type="text/html" title="Vim 常用技巧"/><published>2025-12-31T07:42:58+00:00</published><updated>2025-12-31T07:42:58+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/vim-skills</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/vim-skills/"><![CDATA[<p>在 <code class="language-plaintext highlighter-rouge">vim</code> 中 <code class="language-plaintext highlighter-rouge">nrformats</code> 决定了 <code class="language-plaintext highlighter-rouge">CTRL-A</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-X</code> 增减数字时所识别的数字格式， 其一般被设置成 <code class="language-plaintext highlighter-rouge">bin,hex</code> 表示会将 <code class="language-plaintext highlighter-rouge">0b</code> 和 <code class="language-plaintext highlighter-rouge">0B</code> 开头的数字识别成二进制， <code class="language-plaintext highlighter-rouge">0x</code> 和 <code class="language-plaintext highlighter-rouge">0X</code> 开头的数字识别成十六进制。 在这些数字上使用 <code class="language-plaintext highlighter-rouge">CTRL-A</code> 和 <code class="language-plaintext highlighter-rouge">CTRL-X</code> 时会按相应的进制进行增减。 也可以增加 <code class="language-plaintext highlighter-rouge">octal</code> 来识别 <code class="language-plaintext highlighter-rouge">0</code> 开头的八进制数字。</p> <hr/> <p>下面列出 <code class="language-plaintext highlighter-rouge">vim</code> 自带的操作符命令：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">d</code></td> <td>删除</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">c</code></td> <td>更改</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">y</code></td> <td>复制</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&gt;</code></td> <td>向右缩进</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">&lt;</code></td> <td>向左缩进</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">=</code></td> <td>自动缩进</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">g~</code></td> <td>切换大小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">gu</code></td> <td>转换为小写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">gU</code></td> <td>转换为大写</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">!</code></td> <td>过滤</td> </tr> </tbody> </table> <p>上面的操作符后都可以跟一个 <code class="language-plaintext highlighter-rouge">motion</code>。当使用各自最后一个命令时会对当前行进行操作， 例如 <code class="language-plaintext highlighter-rouge">gUU</code> 会让当前行的字母全部变成大写。在可视模式下使用上述命令会作用于选择的内容。</p> <p><code class="language-plaintext highlighter-rouge">u</code>、<code class="language-plaintext highlighter-rouge">U</code>、<code class="language-plaintext highlighter-rouge">~</code> 在可视模式下与 <code class="language-plaintext highlighter-rouge">gu</code>、<code class="language-plaintext highlighter-rouge">gU</code>、<code class="language-plaintext highlighter-rouge">g~</code> 效果相同。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以用 <code class="language-plaintext highlighter-rouge">CTRL-K {cahr1} {char2}</code> 来插入一个特殊字符， 其中 <code class="language-plaintext highlighter-rouge">{char1}</code> 和 <code class="language-plaintext highlighter-rouge">{char2}</code> 是该特殊字符的两个字母缩写。 例如 <code class="language-plaintext highlighter-rouge">CTRL-K &lt;&lt;</code> 会插入 <code class="language-plaintext highlighter-rouge">«</code> 字符，<code class="language-plaintext highlighter-rouge">CTRL-K &gt;&gt;</code> 会插入 <code class="language-plaintext highlighter-rouge">»</code> 字符。 可以通过 <code class="language-plaintext highlighter-rouge">:help digraphs-table</code> 来查看所有可用的字符缩写。这个功能用的并不多。</p> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">vim</code> 中，<code class="language-plaintext highlighter-rouge">CTRL-H</code> 在插入模式和命令行模式下其功能等同于 <code class="language-plaintext highlighter-rouge">Backspace</code> 键， 推荐使用 <code class="language-plaintext highlighter-rouge">CTRL-H</code> 来实现删除前一个字符的功能，因为其比 <code class="language-plaintext highlighter-rouge">Backspace</code> 要好按， 双手可以不用离开键盘的主区域。</p> <p>在 <code class="language-plaintext highlighter-rouge">vim</code> 推荐定义以下的功能键来实现快速删除：</p> <table> <thead> <tr> <th>按键</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-H</code></td> <td>删除光标前的一个字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-U</code></td> <td>删除光标前的整行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-W</code></td> <td>删除光标前的一个单词</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-K</code></td> <td>删除光标后的整行</td> </tr> </tbody> </table> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">CTRL-K</code> 在 <code class="language-plaintext highlighter-rouge">vim</code> 中默认是用于插入特殊字符的，但这个功能很少用到， 所以推荐将其映射为删除光标后的整行。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 的可视模式下可以使用 <code class="language-plaintext highlighter-rouge">o</code> 键在选区的起始位置和结束位置之间切换光标， 这在进行大块文本选择时非常有用，可以快速调整选区的范围。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中 <code class="language-plaintext highlighter-rouge">it</code> 和 <code class="language-plaintext highlighter-rouge">at</code> 分别表示 “inside tag” 和 “around tag”， 可以在 <code class="language-plaintext highlighter-rouge">HTML</code> 或 <code class="language-plaintext highlighter-rouge">XML</code> 文件中使用这些文本对象来选择标签内的内容或包括标签本身的内容。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中在命令行模式下可以使用 <code class="language-plaintext highlighter-rouge">UP</code> 和 <code class="language-plaintext highlighter-rouge">DOWN</code> 来浏览之前输入的命令历史， 如果已经输入了一部分命令，使用 <code class="language-plaintext highlighter-rouge">UP</code> 和 <code class="language-plaintext highlighter-rouge">DOWN</code> 进行过滤的时候则只会显示以输入内容开头的命令。</p> <p><strong>注意</strong>：我发现在命令行模式下使用 <code class="language-plaintext highlighter-rouge">CTRL-P</code>、<code class="language-plaintext highlighter-rouge">CTRL-N</code> 和 <code class="language-plaintext highlighter-rouge">ALT-P</code>、<code class="language-plaintext highlighter-rouge">ALT-N</code> 也可以实现同样的功能。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以使用 <code class="language-plaintext highlighter-rouge">CTRL-G</code> 在可视模式下和选择模式下进行切换。 选择模式和可视模式的一个主要区别是，在选择模式下输入的内容会替换选中的文本， 而在可视模式下如果要替换文本需要先使用 <code class="language-plaintext highlighter-rouge">c</code> 命令进入插入模式。</p> <p>选择模式往往是用于实现 <code class="language-plaintext highlighter-rouge">Snippets</code> 相关功能，实际使用中不太需要自己主动进入选择模式。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以使用 <code class="language-plaintext highlighter-rouge">@:</code> 来重复执行上一次在命令行模式下输入的命令。 也可以使用 <code class="language-plaintext highlighter-rouge">&amp;</code> 来重复执行上一次使用 <code class="language-plaintext highlighter-rouge">:substitute</code> 命令进行的替换操作。</p> <p><code class="language-plaintext highlighter-rouge">@@</code> 可以重复执行上一次在普通模式下使用 <code class="language-plaintext highlighter-rouge">@{0-9a-z":*}</code> 寄存器执行的宏命令。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中使用 <code class="language-plaintext highlighter-rouge">gr</code> 和 <code class="language-plaintext highlighter-rouge">gR</code> （单字符和连续替换） 可以进入 <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式。 <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 和 <code class="language-plaintext highlighter-rouge">Replace</code> 模式的主要区别在于， <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式是按照屏幕上显示宽度进行替换的， 而 <code class="language-plaintext highlighter-rouge">Replace</code> 模式是按照实际字符进行替换的。</p> <p>这在替换包含制表符的文本时非常有用。 在 <code class="language-plaintext highlighter-rouge">Virtual Replace</code> 模式下，如果当前位置是一个显示宽度为多个空格的制表符， 那么输入的字符会插入到制表符之前，当输入的字符数量达到制表符的显示宽度时， 制表符才会被替换掉。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以使用 <code class="language-plaintext highlighter-rouge">CTRL-R {register}</code> 在插入模式或者命令行模式下插入寄存器中的内容。 除此之外，<code class="language-plaintext highlighter-rouge">CTRL-R CTRL-P {register}</code> 也可以实现类似的功能， 但它会自动调整缩进。</p> <p><code class="language-plaintext highlighter-rouge">CTRL-R =</code> 则可以在插入模式或者命令行模式下插入一个表达式的计算结果。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以使用 <code class="language-plaintext highlighter-rouge">CTRL-V {digit}</code> 来插入特殊字符：</p> <table> <thead> <tr> <th>按键组合</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V 123</code></td> <td>以十进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V u1234</code></td> <td>以十六进制插入 Unicode 字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V U12345678</code></td> <td>以十六进制插入 Unicode 字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V o123</code></td> <td>以八进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V O123</code></td> <td>以八进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V x7B</code></td> <td>以十六进制插入字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">CTRL-V X7B</code></td> <td>以十六进制插入字符</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">CTRL-V</code> 后面可以跟一个非数字字符来插入对应的控制字符，例如 <code class="language-plaintext highlighter-rouge">CTRL-V CTRL-M</code> 可以插入回车符。</p> <hr/> <p>下面列出了一些常用的 <code class="language-plaintext highlighter-rouge">Ex</code> 命令：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]d [x]</code></td> <td>删除指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]y [x]</code></td> <td>复制指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[line]pu [x]</code></td> <td>在指定行之后粘贴寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中的内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[line]pu! [x]</code></td> <td>在指定行之前粘贴寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中的内容</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]t {addr}</code></td> <td>复制指定范围的行并将其存入寄存器 <code class="language-plaintext highlighter-rouge">x</code> 中</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]m {addr}</code></td> <td>移动指定范围的行到目标地址处</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]j</code></td> <td>将指定范围的行连接成一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]norm {cmd}</code></td> <td>对指定范围的行执行普通模式下的命令</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]s/{pattern}/{string}/{flags}</code></td> <td>对指定范围的行执行替换操作</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:[range]g/{pattern}/{cmd}</code></td> <td>对指定范围内匹配模式的行执行 <code class="language-plaintext highlighter-rouge">Ex</code> 命令</td> </tr> </tbody> </table> <p>下面给出常用的地址表示方法：</p> <table> <thead> <tr> <th>地址</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">1</code></td> <td>第一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">$</code></td> <td>最后一行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">0</code></td> <td>虚拟行，位于第一行之前</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">.</code></td> <td>当前行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">%</code></td> <td>当前文件的所有行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">N</code></td> <td>第 N 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">+N</code></td> <td>当前行向下 N 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">-N</code></td> <td>当前行向上 N 行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">/pattern/</code></td> <td>向下搜索匹配模式的行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">?pattern?</code></td> <td>向上搜索匹配模式的行</td> </tr> </tbody> </table> <p>对于搜索的范围可以写出 <code class="language-plaintext highlighter-rouge">/&lt;html&gt;/,/&lt;\/html&gt;/</code> 来表示从第一个 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 标签所在行到第一个 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签所在行的范围。</p> <p>例如： <code class="language-plaintext highlighter-rouge">:/&lt;html&gt;/,/&lt;\/html&gt;/p</code> 表示打印从第一个 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 标签所在行到第一个 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签所在行的内容。</p> <p>而搜索范围可以和 <code class="language-plaintext highlighter-rouge">+N</code> 、<code class="language-plaintext highlighter-rouge">-N</code> 结合使用，例如： <code class="language-plaintext highlighter-rouge">:/&lt;html&gt;/+1,/&lt;\/html&gt;/-1d</code> 表示删除从第一个 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 标签下一行到第一个 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签上一行的内容。</p> <p>对于这些命令我们也可以在 <code class="language-plaintext highlighter-rouge">Visual</code> 模式下选中后使用 <code class="language-plaintext highlighter-rouge">:</code> 进入命令行模式， 此时命令行中会自动插入 <code class="language-plaintext highlighter-rouge">'&lt;,'&gt;</code> 来表示选中的范围，我们只需要在后面添加命令即可。</p> <p>这里再给出几个例子：</p> <ul> <li><code class="language-plaintext highlighter-rouge">:%norm A;</code> 在每一行的末尾添加分号</li> <li><code class="language-plaintext highlighter-rouge">:%norm I//</code> 在每一行的开头添加注释符号 <code class="language-plaintext highlighter-rouge">//</code></li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以用 <code class="language-plaintext highlighter-rouge">:ls</code> 来列出当前打开的所有缓冲区。 <code class="language-plaintext highlighter-rouge">%</code> 符号表示当前缓冲区，<code class="language-plaintext highlighter-rouge">#</code> 符号表示轮换文件。 开头的数字则表示缓冲区的编号。</p> <ul> <li><code class="language-plaintext highlighter-rouge">CTRL-^</code> 可以在当前文件和轮换文件之间切换。</li> <li><code class="language-plaintext highlighter-rouge">:b {bufnum}</code> 切换到指定编号的缓冲区。</li> <li><code class="language-plaintext highlighter-rouge">:bp</code> 和 <code class="language-plaintext highlighter-rouge">:bn</code> 来在缓冲区之间切换。</li> <li><code class="language-plaintext highlighter-rouge">:bf</code> 和 <code class="language-plaintext highlighter-rouge">:bl</code> 可以用来切换到第一个和最后一个缓冲区。</li> <li><code class="language-plaintext highlighter-rouge">:bd</code> 可以用来 <code class="language-plaintext highlighter-rouge">unload</code> 一个缓冲区并将其从缓冲区列表中移除。</li> <li><code class="language-plaintext highlighter-rouge">:bun</code> 可以用来 <code class="language-plaintext highlighter-rouge">unload</code> 一个缓冲区但不将其从缓冲区列表中移除。</li> <li><code class="language-plaintext highlighter-rouge">:bufdo {cmd}</code> 可以对所有缓冲区执行指定的命令。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Vim</code> 中的 <code class="language-plaintext highlighter-rouge">:args</code> 命令可以用来设置和查看参数列表。</p> <ul> <li><code class="language-plaintext highlighter-rouge">:next</code> 和 <code class="language-plaintext highlighter-rouge">:prev</code> 可以用来在参数列表中的文件之间进行切换。</li> <li><code class="language-plaintext highlighter-rouge">:argadd</code> 和 <code class="language-plaintext highlighter-rouge">:argdelete</code> 可以用来向参数列表中添加和删除文件。</li> <li><code class="language-plaintext highlighter-rouge">:argdo {cmd}</code> 可以对参数列表中的所有文件执行指定的命令。</li> </ul> <p>例如 <code class="language-plaintext highlighter-rouge">:args *.js</code> 会将当前目录下的所有 <code class="language-plaintext highlighter-rouge">js</code> 文件添加到参数列表中， 然后可以通过 <code class="language-plaintext highlighter-rouge">:next</code> 和 <code class="language-plaintext highlighter-rouge">:prev</code> 来切换这些文件。</p> <p>我们可以使用反引号来将命令的输出作为参数列表，例如：</p> <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">args</span> `<span class="k">find</span> <span class="p">.</span> <span class="p">-</span>name <span class="s1">'*.js'</span>`
</code></pre></div></div> <p>在使用 <code class="language-plaintext highlighter-rouge">:argdo {cmd}</code> 或者 <code class="language-plaintext highlighter-rouge">:bufdo {cmd}</code> 时，其会按照如下的逻辑进行执行：</p> <ul> <li><code class="language-plaintext highlighter-rouge">:first</code> 或者 <code class="language-plaintext highlighter-rouge">:bf</code></li> <li><code class="language-plaintext highlighter-rouge">:{cmd}</code></li> <li><code class="language-plaintext highlighter-rouge">:next</code> 或者 <code class="language-plaintext highlighter-rouge">:bn</code></li> <li><code class="language-plaintext highlighter-rouge">:{cmd}</code></li> <li>……</li> </ul> <p>当执行过程中 <code class="language-plaintext highlighter-rouge">:{cmd}</code> 进行了修改但是没有保存的时候， <code class="language-plaintext highlighter-rouge">:next</code> 和 <code class="language-plaintext highlighter-rouge">:bn</code> 就会执行失败， 我们可以通过设置 <code class="language-plaintext highlighter-rouge">hidden</code> 选项（<code class="language-plaintext highlighter-rouge">Neovim</code> 中默认开启）来允许切换未保存修改的缓冲区。</p> <p>当然我们也可以在 <code class="language-plaintext highlighter-rouge">:{cmd}</code> 结尾加上 <code class="language-plaintext highlighter-rouge">| update</code> 来保存修改，例如： <code class="language-plaintext highlighter-rouge">:bufdo %s/var/let/g | update</code> 会对所有缓冲区进行替换并保存修改。</p> <hr/> <p>下面的一些命令可以用来处理有修改的缓冲区：</p> <table> <thead> <tr> <th>命令</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:w</code></td> <td>保存当前缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:wa</code></td> <td>保存所有缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:e</code></td> <td>重新加载当前缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:qa</code></td> <td>关闭所有缓冲区</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:up</code></td> <td>保存当前缓冲区（如果有修改）</td> </tr> </tbody> </table> <p>上面的命令都可以在结尾加上 <code class="language-plaintext highlighter-rouge">!</code> 来强制执行，例如 <code class="language-plaintext highlighter-rouge">:qa!</code> 会强制关闭所有缓冲区而不保存修改。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以使用 <code class="language-plaintext highlighter-rouge">q:</code>、<code class="language-plaintext highlighter-rouge">q/</code> 和 <code class="language-plaintext highlighter-rouge">q?</code> 来打开命令行窗口， 分别用于查看和编辑命令行模式下的命令历史、向下搜索历史和向上搜索历史。</p> <p>在命令行窗口中，你可以像编辑普通文件一样编辑命令历史，当你在任意一行上按下 <code class="language-plaintext highlighter-rouge">ENTER</code> 的时候， 该行命令将会被执行。<code class="language-plaintext highlighter-rouge">CTRL-C</code> 则会返回到命令行模式。使用 <code class="language-plaintext highlighter-rouge">:q</code> 则可以关闭命令行窗口。</p> <p>如果你当前处在命令行模式下，可以直接按下 <code class="language-plaintext highlighter-rouge">CTRL-F</code> 来打开命令行窗口。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 的命令行模式中可以使用 <code class="language-plaintext highlighter-rouge">SHIFT-LEFT</code>（或 <code class="language-plaintext highlighter-rouge">CTRL-LEFT</code>）和 <code class="language-plaintext highlighter-rouge">SHIFT-RIGHT</code>（或 <code class="language-plaintext highlighter-rouge">CTRL-RIGHT</code>） 将光标按照单词进行移动，类似于普通模式下的 <code class="language-plaintext highlighter-rouge">b</code> 和 <code class="language-plaintext highlighter-rouge">w</code> 按键。</p> <p>推荐进行如下的按键映射：</p> <table> <thead> <tr> <th>原按键</th> <th>映射后</th> </tr> </thead> <tbody> <tr> <td>CTRL-B</td> <td>LEFT</td> </tr> <tr> <td>CTRL-F</td> <td>RIGHT</td> </tr> <tr> <td>ALT-b</td> <td>SHIFT-LEFT</td> </tr> <tr> <td>ALT-f</td> <td>SHIFT-RIGHT</td> </tr> </tbody> </table> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 的命令行模式下可以用 <code class="language-plaintext highlighter-rouge">|</code> 来连接多个命令，例如： <code class="language-plaintext highlighter-rouge">:w | !gcc % -o %&lt; | ./%&lt;</code> 会先保存当前文件，然后编译该文件，最后运行生成的可执行文件。 可以通过 <code class="language-plaintext highlighter-rouge">:h bar</code> 来查看更多的内容。</p> <p>在执行 <code class="language-plaintext highlighter-rouge">SHELL</code> 命令的时候，<code class="language-plaintext highlighter-rouge">vim</code> 会将 <code class="language-plaintext highlighter-rouge">%</code> 解析成当前文件名， <code class="language-plaintext highlighter-rouge">%&lt;</code> 解析成当前文件名去掉扩展名后的名称。 可以通过 <code class="language-plaintext highlighter-rouge">:h cmdline-special</code> 来查看所有可用的特殊符号。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">vim</code> 中可以通过 <code class="language-plaintext highlighter-rouge">:!{cmd}</code> 的方式来执行外部命令，当直接运行 <code class="language-plaintext highlighter-rouge">:!ls</code> 时，<code class="language-plaintext highlighter-rouge">vim</code> 会回显命令的输出， 当命令的输出比较长时，可以用 <code class="language-plaintext highlighter-rouge">:r !{cmd}</code> 的方式来将命令的输出读取到当前光标所在位置。</p> <p>当前我们也可以通过 <code class="language-plaintext highlighter-rouge">:enew | r !{cmd}</code> 的方式来在一个新的缓冲区中读取命令的输出。</p> <p><code class="language-plaintext highlighter-rouge">:[range]w !{cmd}</code> 则做相反的操作， 它会将当前缓冲区的指定内容通过管道传递给外部命令 <code class="language-plaintext highlighter-rouge">cmd</code> 的标准输入。 如果不指定范围则默认是整个缓冲区的内容。</p> <p><code class="language-plaintext highlighter-rouge">:{range}!{filter}</code> 则可以对指定范围内的内容通过管道传递给外部命令 <code class="language-plaintext highlighter-rouge">{filter}</code> 的标准输入， 并将外部命令的输出替换掉指定范围内的内容。 例如 <code class="language-plaintext highlighter-rouge">:2,$!sort -t',' -k2</code> 会对从第二行到最后一行的内容按逗号分隔符的第二列进行排序。</p> <p>我们可以在普通模式下通过 <code class="language-plaintext highlighter-rouge">!</code> 来进入 <code class="language-plaintext highlighter-rouge">Operator-pending</code> 的状态， 在该状态下可以使用各种 <code class="language-plaintext highlighter-rouge">motion</code> 来选择要过滤的内容。 而在可视模式下使用 <code class="language-plaintext highlighter-rouge">!</code> 则会对选中的内容进行过滤。</p>]]></content><author><name></name></author><category term="Potpourri"/><category term="Vim"/><category term="Neovim"/><summary type="html"><![CDATA[本文介绍自己学习到的一些好用的 Vim 技巧。]]></summary></entry><entry><title type="html">文学摘抄</title><link href="https://kaiser-yang.github.io/blog/2025/literature/" rel="alternate" type="text/html" title="文学摘抄"/><published>2025-12-11T06:18:12+00:00</published><updated>2025-12-11T06:18:12+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/literature</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/literature/"><![CDATA[<h2 id="诗词歌赋">诗词歌赋</h2> <blockquote> <p>洛阳春<br/> 岑参<br/> 人到洛阳花似锦，偏我来时不逢春。<br/> 谁道三冬无春色，冰山高处万里银。<br/></p> </blockquote> <hr/> <blockquote> <p>离思五首·其四<br/> 元稹<br/> 曾经沧海难为水，除却巫山不是云。<br/> 取次花丛懒回顾，半缘修道半缘君。<br/></p> </blockquote> <hr/> <blockquote> <p>金缕衣<br/> 佚名<br/> 劝君莫惜金缕衣，劝君惜取少年时。<br/> 花开堪折直须折，莫待无花空折枝。<br/></p> </blockquote> <hr/> <blockquote> <p>梅岭三章·其一<br/> 陈毅<br/> 断头今日意如何？创业艰难百战多。<br/> 此去泉台招旧部，旌旗十万斩阎罗。<br/></p> </blockquote> <hr/> <blockquote> <p>观书有感二首·其一<br/> 朱熹<br/> 半亩方塘一鉴开，天光云影共徘徊。<br/> 问渠那得清如许？为有源头活水来。<br/></p> </blockquote> <hr/> <blockquote> <p>竹枝词九首·其二<br/> 刘禹锡<br/> 山桃红花满上头，蜀江春水拍山流。<br/> 花红易衰似郎意，水流无限似侬愁。<br/></p> </blockquote>]]></content><author><name></name></author><category term="Potpourri"/><category term="Literature"/><summary type="html"><![CDATA[本文收集了一些我喜欢的文学作品中的摘抄。]]></summary></entry><entry><title type="html">Go 学习笔记</title><link href="https://kaiser-yang.github.io/blog/2025/go-learning/" rel="alternate" type="text/html" title="Go 学习笔记"/><published>2025-12-09T11:44:38+00:00</published><updated>2025-12-09T11:44:38+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/go-learning</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/go-learning/"><![CDATA[<p>使用 <code class="language-plaintext highlighter-rouge">fmt.Printf</code> 时可能涉及到相关的格式化动词，以下是一些常用的格式化动词及其含义：</p> <table> <thead> <tr> <th>动词</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td>%v</td> <td>默认格式</td> </tr> <tr> <td>%+v</td> <td>带字段名的结构体格式</td> </tr> <tr> <td>%#v</td> <td>Go 语法表示的值</td> </tr> <tr> <td>%T</td> <td>类型信息</td> </tr> <tr> <td>%t</td> <td>布尔值</td> </tr> <tr> <td>%c</td> <td>对应的 Unicode 字符</td> </tr> <tr> <td>%U</td> <td>Unicode 格式的字符</td> </tr> <tr> <td>%%</td> <td>字符 ‘%’</td> </tr> <tr> <td>%s</td> <td>字符串</td> </tr> <tr> <td>%q</td> <td>带双引号的字符串</td> </tr> <tr> <td>%p</td> <td>指针地址</td> </tr> <tr> <td>%b</td> <td>二进制</td> </tr> <tr> <td>%o/%O</td> <td>八进制（是否带 <code class="language-plaintext highlighter-rouge">0o</code> 前缀）</td> </tr> <tr> <td>%x/%X</td> <td>十六进制（大小写）</td> </tr> <tr> <td>%d/%i</td> <td>十进制整数</td> </tr> <tr> <td>%f</td> <td>十进制浮点数</td> </tr> <tr> <td>%g</td> <td>最简洁的十进制或科学计数法</td> </tr> <tr> <td>%e/%E</td> <td>科学计数法（大小写）</td> </tr> <tr> <td>%w</td> <td>用于错误包装</td> </tr> </tbody> </table> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 中的语句后面通常都不需要使用 <code class="language-plaintext highlighter-rouge">;</code> 来结尾， 并且在条件分支和循环分支中也不需要使用 <code class="language-plaintext highlighter-rouge">()</code> 来包裹条件表达式。 除此之外，在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的条件分支中可以添加一条初始化语句，这条语句会在条件判断之前执行， 并且其作用域仅限于该条件分支内。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">doSomething</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="c">// 处理错误</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c">// 正常处理</span>
<span class="p">}</span>
<span class="c">// err 在这里不可见</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">switch</code> 语句会自动在每个 <code class="language-plaintext highlighter-rouge">case</code> 分支后面添加一个隐式的 <code class="language-plaintext highlighter-rouge">break</code>， 因此不需要显式地使用 <code class="language-plaintext highlighter-rouge">break</code> 语句来终止分支。 如果想要在某个 <code class="language-plaintext highlighter-rouge">case</code> 分支中继续执行下一个分支，可以使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 关键字。</p> <p><code class="language-plaintext highlighter-rouge">fallthrough</code> 的作用是强制执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支的代码，而不进行条件判断。 如果想在执行下一个 <code class="language-plaintext highlighter-rouge">case</code> 后继续执行下下个 <code class="language-plaintext highlighter-rouge">case</code>， 则需要在下一个 <code class="language-plaintext highlighter-rouge">case</code> 分支中再次使用 <code class="language-plaintext highlighter-rouge">fallthrough</code>。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用 <code class="language-plaintext highlighter-rouge">type</code> 关键字来定义新类型或者给已有的类型取别名。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span>
  <span class="n">MyInt</span> <span class="kt">int</span>              <span class="c">// 定义新类型 MyInt，底层类型为 int</span>
  <span class="n">YourInt</span> <span class="o">=</span> <span class="kt">int</span>          <span class="c">// 给 int 类型取别名 YourInt</span>
<span class="p">)</span>
</code></pre></div></div> <p>别名类型和原类型是完全相同的类型，可以互相赋值和转换。 而新类型和原类型是不同的类型，往往需要进行显式的转换。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中的 <code class="language-plaintext highlighter-rouge">var</code>、<code class="language-plaintext highlighter-rouge">const</code>、<code class="language-plaintext highlighter-rouge">type</code>、<code class="language-plaintext highlighter-rouge">import</code> 等关键字都可以使用块语法来声明多个变量、常量或类型。 块语法使用 <code class="language-plaintext highlighter-rouge">()</code> 将多个声明包裹在一起。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
  <span class="n">a</span> <span class="kt">int</span>
  <span class="n">b</span> <span class="kt">string</span>
  <span class="n">c</span> <span class="kt">bool</span>
<span class="p">)</span>
</code></pre></div></div> <p>这种方式可以使代码更加整洁，尤其是在需要声明多个相关变量时。</p> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中，后续的变量会重复使用前一个变量的表达式，除非显式地为其赋值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="m">1</span>
  <span class="n">B</span>        <span class="c">// B 的值为 1</span>
  <span class="n">C</span> <span class="o">=</span> <span class="m">2</span>
  <span class="n">D</span>        <span class="c">// D 的值为 2</span>
<span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">const</code> 块中可以使用 <code class="language-plaintext highlighter-rouge">iota</code>，它的值是当前变量所在的偏移位置（从0开始计算）。 每当遇到一个新的 <code class="language-plaintext highlighter-rouge">const</code> 块时，<code class="language-plaintext highlighter-rouge">iota</code> 会被重置为0，并且在每一行中递增1。 也可以在 <code class="language-plaintext highlighter-rouge">const</code> 块中使用 <code class="language-plaintext highlighter-rouge">_</code> 来忽略某些值。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">A</span> <span class="o">=</span> <span class="no">iota</span>           <span class="c">// A 的值为 0</span>
  <span class="n">B</span>                  <span class="c">// B 的值为 1</span>
  <span class="n">_</span>                  <span class="c">// 忽略该值，iota 递增到 2</span>
  <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="no">iota</span><span class="p">,</span> <span class="no">iota</span>  <span class="c">// C 和 D 的值均为 3</span>
<span class="p">)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以定义 <code class="language-plaintext highlighter-rouge">label</code>，<code class="language-plaintext highlighter-rouge">label</code> 可以用来进行 <code class="language-plaintext highlighter-rouge">continue</code> 或者 <code class="language-plaintext highlighter-rouge">break</code> 操作， 从而跳出多层循环或者指定跳出某个循环。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OuterLoop</span><span class="o">:</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="n">OuterLoop</span> <span class="c">// 跳出当前内层循环，进入下一次外层循环</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="m">2</span> <span class="p">{</span>
      <span class="k">break</span> <span class="n">OuterLoop</span> <span class="c">// 跳出外层循环</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i=%d, j=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中可以使用有显示名称的返回值， 这样只需要在函数体中对这些返回值进行赋值而不需要显式地使用 <code class="language-plaintext highlighter-rouge">return</code> 语句返回它们。 这样的写法在需要根据条件分支返回多个值时非常有用。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 使用有显示名称的返回值</span>
<span class="k">func</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">quotient</span> <span class="kt">int</span><span class="p">,</span> <span class="n">remainder</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">quotient</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
  <span class="k">return</span> <span class="c">// 直接返回命名的返回值，这里的 return 不能省略</span>
<span class="p">}</span>

<span class="c">// 使用无名称的返回值</span>
<span class="k">func</span> <span class="n">divide2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用变长参数来接收不定数量的参数。 变长参数使用 <code class="language-plaintext highlighter-rouge">t ...T</code> 语法来定义，表示可以传入任意数量的该类型参数。 在函数体内，变长参数会被视为一个切片。 变长参数可以匹配多个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数或者一个类型为 <code class="language-plaintext highlighter-rouge">[]T</code> 的参数，但是不能同时匹配两种形式：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">total</span> <span class="o">:=</span> <span class="m">0</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">result1</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>       <span class="c">// 传入多个 int 参数</span>
  <span class="n">result2</span> <span class="o">:=</span> <span class="n">sum</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">}</span><span class="o">...</span><span class="p">)</span> <span class="c">// 传入一个 []int 参数，注意要加上 ...</span>
  <span class="c">// result3 := sum(1, 2, []int{3, 4}...) // 错误，不能同时传入多种形式的参数</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span> <span class="c">// 输出: 10</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span> <span class="c">// 输出: 18</span>
<span class="p">}</span>
</code></pre></div></div> <p>不过上面的规则有个例外：在使用 <code class="language-plaintext highlighter-rouge">append</code> 将一个 <code class="language-plaintext highlighter-rouge">string</code> 变量追加到 <code class="language-plaintext highlighter-rouge">[]byte</code> 切片中的时候是可行的， 编译器会自动将 <code class="language-plaintext highlighter-rouge">string</code> 转换为 <code class="language-plaintext highlighter-rouge">[]byte</code>，然后再进行追加操作：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">"hello"</span><span class="o">...</span><span class="p">)</span> <span class="c">// OK</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">import</code> 进行包的导入，导入时可以给导入的包取别名， 也可以使用 <code class="language-plaintext highlighter-rouge">.</code> 来导入包中的所有标识符。</p> <p>通常而言，在 <code class="language-plaintext highlighter-rouge">Go</code> 导入的包必须要被使用，否则会导致编译错误。 但是可以给包取别名为 <code class="language-plaintext highlighter-rouge">_</code>，这种方式仅执行包的 <code class="language-plaintext highlighter-rouge">init</code> 函数。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
  <span class="n">fmt</span> <span class="s">"fmt"</span>      <span class="c">// 给包取别名 fmt</span>
  <span class="o">.</span> <span class="s">"math"</span>       <span class="c">// 导入包中的所有标识符</span>
  <span class="n">_</span> <span class="s">"net/http"</span>   <span class="c">// 给包取别名 _，仅执行其 init 函数</span>
<span class="p">)</span>
</code></pre></div></div> <p>当两个同名的包（通常指路径中的最后一段相同）导入时就需要使用别名来区分它们。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中有各种字面量可以使用，同时对于数字字面量还支持使用下划线 <code class="language-plaintext highlighter-rouge">_</code> 来分隔数字以提高可读性。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">53</span><span class="n">_700</span>        <span class="c">// 十进制</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">0</span><span class="n">_700</span>         <span class="c">// 0前缀表示八进制</span>
<span class="n">c1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">x_aa_bb_cc</span>
<span class="n">c2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">X_dd_ee_ff</span>  <span class="c">// 0x或0X前缀表示十六进制</span>
<span class="n">d1</span> <span class="o">:=</span> <span class="m">0</span><span class="n">b_1000_0001</span>
<span class="n">d2</span> <span class="o">:=</span> <span class="m">0</span><span class="n">B_1000_0001</span> <span class="c">// 0b或0B前缀表示二进制</span>
<span class="n">e</span> <span class="o">:=</span> <span class="m">.15</span>           <span class="c">// 浮点数，可以省略整数部分的0</span>
<span class="n">f</span> <span class="o">:=</span> <span class="m">82.</span>           <span class="c">// 浮点数，可以省略小数部分的0</span>
<span class="n">g1</span> <span class="o">:=</span> <span class="m">1.5e2</span>        <span class="c">// 科学计数法表示</span>
<span class="n">g2</span> <span class="o">:=</span> <span class="m">1.5E3</span>        <span class="c">// 科学计数法表示</span>
<span class="n">h1</span> <span class="o">:=</span> <span class="m">0x2</span><span class="o">.</span><span class="n">p10</span>      <span class="c">// 十六进制浮点数</span>
<span class="n">h2</span> <span class="o">:=</span> <span class="m">0X1</span><span class="o">.</span><span class="n">Fp0</span>      <span class="c">// 十六进制浮点数</span>

<span class="n">ch1</span> <span class="o">:=</span> <span class="sc">'\u4e2d'</span>     <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch2</span> <span class="o">:=</span> <span class="sc">'\U00004e2d'</span> <span class="c">// Unicode 字符字面量，表示中文“中”</span>
<span class="n">ch3</span> <span class="o">:=</span> <span class="sc">'\x27'</span>       <span class="c">// 字符字面量，表示单引号字符 `'`</span>
<span class="n">ch4</span> <span class="o">:=</span> <span class="sc">'\047'</span>       <span class="c">// 字符字面量，八进制表示的字符 `'`</span>

<span class="n">s1</span> <span class="o">:=</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span>                <span class="c">// 字符串字面量，包含转义字符</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\u4e2d\u6587</span><span class="s">"</span>         <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="s">"</span><span class="se">\U00004e2d\U00006587</span><span class="s">"</span> <span class="c">// 字符串字面量，表示“中文”</span>
<span class="n">s4</span> <span class="o">:=</span> <span class="s">`This is a raw string.
This is the second line.
This is the third line.
\n will not be interpreted.`</span> <span class="c">// 原始字符串字面量</span>

<span class="n">arr1</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr2</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">}</span>
<span class="n">arr3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">5</span><span class="o">:</span> <span class="m">5</span> <span class="p">}</span> <span class="c">// 数组字面量，长度均为 6</span>

<span class="n">sp1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// 切片字面量</span>

<span class="n">mp1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span> <span class="s">"a"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"b"</span><span class="o">:</span> <span class="m">2</span> <span class="p">}</span> <span class="c">// map 字面量</span>
</code></pre></div></div> <p>在使用十六进制的科学计数法进行表示的时候，<code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">P</code> 表示幂运算的底数是 <code class="language-plaintext highlighter-rouge">2</code>。 需要注意的是有效数字的整数部分和小数部分用十六进制来表示，而指数部分用十进制来表示。</p> <p>如果想要在 <code class="language-plaintext highlighter-rouge">raw string</code> 中包含反引号，则可以使用 <code class="language-plaintext highlighter-rouge">+</code> 进行字符串的拼接来实现。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">array[low:high:max]</code> 来基于一个已经存在的数组创建一个切片。 当省略 <code class="language-plaintext highlighter-rouge">max</code> 时，默认 <code class="language-plaintext highlighter-rouge">max</code> 的值为数组的长度。 这个切片的长度是 <code class="language-plaintext highlighter-rouge">high - low</code>，容量是 <code class="language-plaintext highlighter-rouge">max - low</code>。 这也表明 <code class="language-plaintext highlighter-rouge">[low, high)</code> 和 <code class="language-plaintext highlighter-rouge">[low, max)</code> 都是左闭右开区间。</p> <p>需要注意的是基于数组创建的切片的底层是原数组，所以对切片的修改往往会直接影响原数组。 不过在切片发生扩容的时候会创建一个新的底层数组，此时对切片的修改就不会影响原数组了。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
<span class="n">s1</span> <span class="o">:=</span> <span class="n">arr</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>              <span class="c">// 创建切片 s1，包含 arr[1], arr[2], arr[3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>               <span class="c">// 输出: [1 2 3]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// 输出: 3 4</span>
<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>                    <span class="c">// 修改切片 s1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>              <span class="c">// 输出: [0 10 2 3 4]，arr 也被修改了</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span>      <span class="c">// 切片 s1 发生扩容，创建了新的底层数组</span>
<span class="n">s2</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">30</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// 输出: [0 10 2 3 4]，arr 不受影响</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// 输出: [30 2 3 20 30]</span>
</code></pre></div></div> <p>可以使用 <code class="language-plaintext highlighter-rouge">len</code> 和 <code class="language-plaintext highlighter-rouge">cap</code> 函数来获取切片的长度和容量。 但是对于 <code class="language-plaintext highlighter-rouge">map</code> 而言则只能使用 <code class="language-plaintext highlighter-rouge">len</code> 函数来获取其长度。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中通过下标运算符去获取一个 <code class="language-plaintext highlighter-rouge">map</code> 中不存在的键时会返回该类型的零值。 为了区分一个键是不存在还是其值就是类型的零值，可以使用双赋值的形式来获取键对应的值和一个布尔值， 该布尔值表示该键是否存在于 <code class="language-plaintext highlighter-rouge">map</code> 中。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s">"key"</span><span class="p">]</span> <span class="c">// 如果 "key" 不存在，v 为 0，ok 为 false</span>
<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
<span class="c">// 处理键不存在的情况</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c">// 使用 v 进行后续操作</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的 <code class="language-plaintext highlighter-rouge">map</code> 是基于 <code class="language-plaintext highlighter-rouge">hash</code> 的，对其进行遍历时的顺序是随机的。 <code class="language-plaintext highlighter-rouge">Go</code> 为了让开发者不依赖于 <code class="language-plaintext highlighter-rouge">map</code> 的遍历顺序，特意设计成每次遍历的顺序都有可能不一样。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串、字节切片、<code class="language-plaintext highlighter-rouge">rune</code> 切片之间可以方便地进行相互转换。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="k">var</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为字节切片</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[]</span><span class="kt">rune</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 字符串转换为 rune 切片</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>          <span class="c">// 字节切片转换为字符串</span>
<span class="n">s3</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>          <span class="c">// rune 切片转换为字符串</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的字符串是通过 <code class="language-plaintext highlighter-rouge">UTF-8</code> 编码进行存储的，因此可以直接存储和处理多字节的 <code class="language-plaintext highlighter-rouge">Unicode</code> 字符。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">len</code> 获取的字符串的字节数而不是字符数，如果要获取字符数可以使用 <code class="language-plaintext highlighter-rouge">utf8.RuneCountInString</code> 函数。同理通过下标访问字符串时获取的是字节而不是字符。 不过 <code class="language-plaintext highlighter-rouge">for range</code> 遍历时获取的是字符。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"Hello 世界"</span>
<span class="n">lengthInBytes</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                    <span class="c">// 获取字符串的字节数</span>
<span class="n">lengthInRunes</span> <span class="o">:=</span> <span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// 获取字符串的字符数</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>                      <span class="c">// 遍历字符串中的字符</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Character %d: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
  <span class="c">// i 是字符的起始字节索引，r 是对应的 rune 值</span>
  <span class="c">// Character 5: 世</span>
  <span class="c">// Character 8: 界</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Byte %d: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>      <span class="c">// 访问字符串中的字节</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的结构体中可以使用嵌入字段来实现类似于继承的效果。 嵌入字段是指在结构体中直接包含另一个结构体类型，而不需要为其指定字段名。 这样可以直接访问嵌入结构体的字段和方法。例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Person</span>  <span class="c">// 嵌入 Person 结构体</span>
  <span class="n">ID</span>      <span class="kt">string</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">emp</span> <span class="n">Employee</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"Alice"</span>
<span class="n">emp</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="m">30</span>  <span class="c">// 直接访问嵌入结构体的字段</span>
</code></pre></div></div> <p>嵌入按照嵌入类型可以分为以下几种：</p> <ul> <li>接口中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> <li>结构体中嵌入结构体（可以是 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code>）</li> <li>结构体中嵌入接口（只能是 <code class="language-plaintext highlighter-rouge">I</code>）</li> </ul> <p>这里重点介绍一下在一个结构体中嵌入接口的情况。 在结构体中嵌入接口后，这个结构体类型就实现了该接口。 但是我们必须在使用接口中的方法前，为嵌入的接口字段赋值，否则会导致运行时错误：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M1</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">S</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">S</span><span class="p">)</span> <span class="n">M2</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"M2 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I</span> <span class="c">// T 中嵌入接口 I</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span> <span class="c">// 为嵌入的接口字段赋值，否则会导致运行时错误</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们也可以自己在 <code class="language-plaintext highlighter-rouge">T</code> 中实现接口 <code class="language-plaintext highlighter-rouge">I</code> 的方法，当接口变量被赋值且 <code class="language-plaintext highlighter-rouge">T</code> 实现了接口的方法时， <code class="language-plaintext highlighter-rouge">T</code> 实现的方法会优先被调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">"T's M1 called"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{</span>
    <span class="n">I</span><span class="o">:</span> <span class="n">S</span><span class="p">{},</span>
  <span class="p">}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M1</span><span class="p">()</span> <span class="c">// 调用 T 实现的 M1 方法</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M2</span><span class="p">()</span> <span class="c">// 调用 S 实现的 M2 方法</span>
<span class="p">}</span>
</code></pre></div></div> <p>在结构体内嵌入多个接口时，如果这些接口中有同名的方法：</p> <ul> <li>若同名方法的签名不同，则编译时会报错，提示方法冲突。</li> <li>若同名方法的签名相同，则必须在结构体中实现该方法，否则调用时编译器会报错。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">I1</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M1</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">I2</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">M</span><span class="p">()</span>
  <span class="n">M2</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">I1</span>
  <span class="n">I2</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span> <span class="nb">println</span><span class="p">(</span><span class="s">"T.M"</span><span class="p">)</span> <span class="p">}</span> <span class="c">// 必须实现 M 方法，否则 t.M() 会导致编译错误</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{}</span>
  <span class="n">t</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不可以在结构类型 <code class="language-plaintext highlighter-rouge">T</code> 中定义类型为 <code class="language-plaintext highlighter-rouge">T</code> 的字段，也不可以递归定义， 但是可以包含<code class="language-plaintext highlighter-rouge">*T</code>、<code class="language-plaintext highlighter-rouge">[]T</code>、<code class="language-plaintext highlighter-rouge">map[type]T</code> 等类型的字段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// F T         // 错误，不能包含类型为 T 的字段</span>
  <span class="n">F</span> <span class="o">*</span><span class="n">T</span>           <span class="c">// 正确，可以包含类型为 *T 的字段</span>
  <span class="n">G</span> <span class="p">[]</span><span class="n">T</span>          <span class="c">// 正确，可以包含类型为 []T 的字段</span>
  <span class="n">H</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">T</span> <span class="c">// 正确，可以包含类型为 map[type]T 的字段</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T1</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t2</span> <span class="n">T2</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">T2</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">t1</span> <span class="n">T1</span>  <span class="c">// 错误，不能递归定义</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中主要有多种方法可以对自定义类型进行初始化。以下面的自定义类型为例。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Book</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Title</span>  <span class="kt">string</span>
  <span class="n">Author</span> <span class="n">Person</span>
<span class="p">}</span>
</code></pre></div></div> <p>一是可以按照顺序对结构体的字段进行赋值，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b1</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>但是这样的弊端也很明显：如果结构体的字段顺序发生变化，那么初始化的代码也需要进行相应的修改。 且当结构体的字段较多时，代码的可读性也会变差。这就引出了第二种初始化的方式：使用字段名进行赋值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p2</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">30</span><span class="p">}</span>
<span class="n">b2</span> <span class="o">:=</span> <span class="n">Book</span><span class="p">{</span><span class="n">Title</span><span class="o">:</span> <span class="s">"Go Programming"</span><span class="p">,</span> <span class="n">Author</span><span class="o">:</span> <span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">40</span><span class="p">}}</span>
</code></pre></div></div> <p>除此之外还可以自定义方法来根据传入的参数进行初始化，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="n">age</span><span class="p">}</span>
<span class="p">}</span>
<span class="c">// or</span>
<span class="c">// func NewPerson(name string, age int) Person {</span>
<span class="c">//   return Person{Name: name, Age: age}</span>
<span class="c">// }</span>

<span class="n">p3</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// p3 在这里是 *Person 类型</span>
</code></pre></div></div> <p>不过官方推荐使用一种名为 <code class="language-plaintext highlighter-rouge">WithOption</code> 的设计模式来进行复杂类型的初始化， 这种方式可以通过传入不同的选项函数来灵活地配置初始化参数。 例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Name</span> <span class="kt">string</span>
  <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">PersonOption</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">Person</span><span class="p">)</span>
<span class="k">func</span> <span class="n">WithName</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="n">name</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">WithAge</span><span class="p">(</span><span class="n">age</span> <span class="kt">int</span><span class="p">)</span> <span class="n">PersonOption</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Age</span> <span class="o">=</span> <span class="n">age</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">opts</span> <span class="o">...</span><span class="n">PersonOption</span><span class="p">)</span> <span class="o">*</span><span class="n">Person</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span>
    <span class="n">Name</span><span class="o">:</span> <span class="s">"Unknown"</span><span class="p">,</span>
    <span class="n">Age</span><span class="o">:</span>  <span class="m">0</span><span class="p">,</span> <span class="c">// 默认值</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">opts</span> <span class="p">{</span>
    <span class="n">opt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>
<span class="n">p4</span> <span class="o">:=</span> <span class="n">NewPerson</span><span class="p">(</span><span class="n">WithName</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">),</span> <span class="n">WithAge</span><span class="p">(</span><span class="m">30</span><span class="p">))</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言可以对底层类型相同的元素进行隐式转换，编译器会保证这种转换的安全。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">var</span> <span class="n">a</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="m">10</span>
<span class="n">b</span> <span class="o">:=</span> <span class="m">10</span>
<span class="n">c</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="c">// 隐式转换，MyInt 和 int 可以进行运算</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中不能给接口或者指针类型定义方法：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyInt</span> <span class="o">*</span><span class="kt">int</span>
<span class="c">// CE: invalid receiver type MyInt (MyInt is a pointer type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyInt</span><span class="p">)</span> <span class="n">IsNil</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">MyReader</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span>
<span class="c">// CE: invalid receiver type MyReader (MyReader is an interface type)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">MyReader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言对接口的实现是通过 <code class="language-plaintext highlighter-rouge">iface</code> 和 <code class="language-plaintext highlighter-rouge">eface</code> 两种内部数据结构来实现的。 <code class="language-plaintext highlighter-rouge">iface</code> 用于存储非空接口类型的变量，而 <code class="language-plaintext highlighter-rouge">eface</code> 用于存储空接口类型的变量。</p> <p>空接口是指接口中没有任何方法的接口类型，表示可以存储任意类型的值。 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">any</code> 类型实际上就是空接口类型的别名。 非空接口是指除了空接口之外的所有接口类型。</p> <p>在 <code class="language-plaintext highlighter-rouge">eface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">_type</code>：表示具体的类型信息。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>而在 <code class="language-plaintext highlighter-rouge">iface</code> 内部，包含了两个字段：</p> <ul> <li><code class="language-plaintext highlighter-rouge">tab</code>：表示类型信息和方法集合的表。</li> <li><code class="language-plaintext highlighter-rouge">data</code>：表示具体的值。</li> </ul> <p>接口的比较是基于这两个字段的。</p> <p>不管是空接口还是非空接口只有当其两个字段均为 <code class="language-plaintext highlighter-rouge">nil</code> 时才表示接口变量为 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a1</span> <span class="n">any</span>
<span class="k">var</span> <span class="n">a2</span> <span class="n">any</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">e1</span> <span class="kt">error</span>
<span class="k">var</span> <span class="n">e2</span> <span class="kt">error</span> <span class="o">=</span> <span class="no">nil</span>
</code></pre></div></div> <p>上面的四个变量和 <code class="language-plaintext highlighter-rouge">nil</code> 进行比较时均为 <code class="language-plaintext highlighter-rouge">true</code>。 因为上面的四个变量都为 <code class="language-plaintext highlighter-rouge">nil</code> 所以他们在通过 <code class="language-plaintext highlighter-rouge">==</code> 互相比较时都会返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>一旦两个字段中的任意一个不为 <code class="language-plaintext highlighter-rouge">nil</code>，那么接口变量就不再等于 <code class="language-plaintext highlighter-rouge">nil</code>：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">i</span> <span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">m</span> <span class="o">*</span><span class="n">MyError</span> <span class="o">=</span> <span class="no">nil</span>
<span class="k">var</span> <span class="n">a</span> <span class="n">any</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">var</span> <span class="n">e</span> <span class="kt">error</span> <span class="o">=</span> <span class="n">m</span>
</code></pre></div></div> <p>上面例子中的 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">e</code> 都不等于 <code class="language-plaintext highlighter-rouge">nil</code>，因为他们的 <code class="language-plaintext highlighter-rouge">data</code> 字段虽然为 <code class="language-plaintext highlighter-rouge">nil</code>， 但是 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code> ）字段不为 <code class="language-plaintext highlighter-rouge">nil</code>。</p> <p>在接口变量之间进行比较时：</p> <ul> <li>当比较的两个接口变量是空接口（<code class="language-plaintext highlighter-rouge">eface</code>）或两个接口变量是非空接口时， 当且仅当其 <code class="language-plaintext highlighter-rouge">_type</code>（或 <code class="language-plaintext highlighter-rouge">tab</code>）字段相等、<code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> <li>当比较的两个接口变量一个是空接口（<code class="language-plaintext highlighter-rouge">eface</code>），另一个是非空接口（<code class="language-plaintext highlighter-rouge">iface</code>）时， 当且仅当空接口的 <code class="language-plaintext highlighter-rouge">_type</code> 字段等于非空接口的 <code class="language-plaintext highlighter-rouge">tab</code> 字段中的 <code class="language-plaintext highlighter-rouge">_type</code>字段、 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致时才相等。</li> </ul> <p>这里的 <code class="language-plaintext highlighter-rouge">data</code> 字段指向的数据内容一致指的是：</p> <ul> <li>如果接口与指针类型绑定，那么比较的是指针的值是否相等。</li> <li>如果接口与非指针类型绑定，那么比较的是值的内容是否相等。</li> </ul> <p><strong>NOTE</strong>：<code class="language-plaintext highlighter-rouge">iface</code> 代表的是 <code class="language-plaintext highlighter-rouge">interface</code> 的意思，而 <code class="language-plaintext highlighter-rouge">eface</code> 代表的是 <code class="language-plaintext highlighter-rouge">empty interface</code> 的意思。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的方法集合是指某个类型所拥有的方法的集合。 其主要作用是用于判断一个类型是否实现了某个接口。 类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 的方法组成的集合。 类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合是由所有接收者为 <code class="language-plaintext highlighter-rouge">T</code> 或 <code class="language-plaintext highlighter-rouge">*T</code> 的方法组成的集合。 如果一个类型的方法集合是一个接口的超集，那么该类型就实现了该接口。</p> <p>这里解释一下为什么会是这样的定义。 关键在于 <code class="language-plaintext highlighter-rouge">Go</code> 语言中的接口的实现方式。<code class="language-plaintext highlighter-rouge">Go</code> 语言的接口中保存了两部分内容：</p> <ul> <li>具体的类型信息</li> <li>对应的实例数据</li> </ul> <p>当一个非指针类型的变量被赋值给一个接口变量的时候，这个变量的实例数据是原对象的拷贝。 而将一个指针类型的变量赋值给一个接口变量的时候，接口变量数据部分保存的是该指针的值。 这也就意味着，如果真的可以通过一个非指针变量去调用接收者为指针的方法的话， 那么这个方法中对接收者的任何修改都不会反应到原对象上。为了禁止这样反直觉的行为， <code class="language-plaintext highlighter-rouge">Go</code> 语言就采用了上面所说的方法集合的定义。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Animal</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Grow</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Dog</span> <span class="k">struct</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">Dog</span><span class="p">)</span> <span class="n">Grow</span><span class="p">()</span> <span class="p">{</span>
 <span class="c">// some code will change Dog instance</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="n">Animal</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="n">Dog</span><span class="p">{}</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">d</span>
  <span class="n">a</span><span class="o">.</span><span class="n">Grow</span><span class="p">()</span> <span class="c">// 假设这里可以通过编译，d 的状态也不会改变</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果理解了上述的规则我们不难得出嵌套类型的方法集合：</p> <ul> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">U</code> 的方法集合。</li> <li>如果在类型 <code class="language-plaintext highlighter-rouge">T</code> 中嵌入了类型 <code class="language-plaintext highlighter-rouge">*U</code>，那么类型 <code class="language-plaintext highlighter-rouge">T</code> 的方法集合包含了类型 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> <li>不论嵌入类型是 <code class="language-plaintext highlighter-rouge">U</code> 还是 <code class="language-plaintext highlighter-rouge">*U</code>，类型 <code class="language-plaintext highlighter-rouge">*T</code> 的方法集合都包含了 <code class="language-plaintext highlighter-rouge">*U</code> 的方法集合。</li> </ul> <p>需要注意的是一个变量的类型对应的方法集合中没有的方法并不意味着该变量不能调用。 对于可寻址的对象，<code class="language-plaintext highlighter-rouge">Go</code> 语言会自动将其取地址从而调用接收者为指针的方法。 同样地，对于指针类型的变量，<code class="language-plaintext highlighter-rouge">Go</code> 语言也会自动解引用从而调用接收者为非指针的方法。</p> <p>当我们使用 <code class="language-plaintext highlighter-rouge">type</code> 给一个变量取别名或者基于已有的类型定义新的类型时，方法集合会根据原类型而有所不同。</p> <ul> <li>取别名不会改变原类型的方法集合；</li> <li>基于接口类型创建的新类型，其方法集合与原接口类型一致；</li> <li>而基于非接口类型创建的新类型，其方法集合为空。</li> </ul> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中，<code class="language-plaintext highlighter-rouge">map</code> 存储的元素是不可寻址的，而切片中的元素确是可寻址的。 关于这样设计的原因主要有两个：</p> <ul> <li>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，其底层实现是基于哈希表的， 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么在 <code class="language-plaintext highlighter-rouge">map</code> 发生扩容或者重新哈希时， 这些寻址的指针就会变得无效，从而导致不可预期的行为，这里应该主要是考虑红黑树上节点变化的问题。</li> <li>对于切片而言，其底层实现是基于数组的，数组的元素在内存中是连续存储的， 因此允许对切片中的元素进行寻址是安全且高效的； 且即使切片在使用过程中发生了扩容，如果此时有指针指向原数组上的元素，原数组就不会被释放。</li> <li>在 <code class="language-plaintext highlighter-rouge">map</code> 中，如果一个值不存在，那么通过下标运算符获取该值时会返回该类型的零值。 如果允许对 <code class="language-plaintext highlighter-rouge">map</code> 中的元素进行寻址，那么对于不存在的键，其对应的值将无法寻址， 这会导致代码变得复杂且容易出错。</li> </ul> <p>正因为 <code class="language-plaintext highlighter-rouge">map</code> 不可寻址，如果 <code class="language-plaintext highlighter-rouge">map</code> 存储的 <code class="language-plaintext highlighter-rouge">value</code> 部分是非指针，我们是不能调用接收者为指针的方法的。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以通过类型断言来获取一个接口变量的具体类型和值。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">:=</span> <span class="m">10</span>
<span class="k">var</span> <span class="n">x</span> <span class="n">any</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">v1</span><span class="p">,</span> <span class="n">ok1</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c">// ok1 为 true，v1 的值为 10</span>
<span class="n">v2</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="c">// ok2 为 false，v2 的值为 string 类型的零值 ""</span>
<span class="n">v3</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>     <span class="c">// 如果断言失败会引发 panic</span>
</code></pre></div></div> <p>需要注意的是，如果断言的类型是一个接口则语义变成了“变量是否实现了该接口”的判断。 如果断言成功，返回值的类型为实际类型而不是所实现的接口类型。</p> <hr/> <p>在对内置的函数进行 <code class="language-plaintext highlighter-rouge">defer</code> 操作的时候， <code class="language-plaintext highlighter-rouge">append</code>、<code class="language-plaintext highlighter-rouge">cap</code>、<code class="language-plaintext highlighter-rouge">len</code>、<code class="language-plaintext highlighter-rouge">make</code>、<code class="language-plaintext highlighter-rouge">new</code> 等并不能作为 <code class="language-plaintext highlighter-rouge">deferred</code> 函数调用。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中只能通过 <code class="language-plaintext highlighter-rouge">make</code> 来创建 <code class="language-plaintext highlighter-rouge">channel</code>，<code class="language-plaintext highlighter-rouge">make</code> 接收两个参数， 第一个是 <code class="language-plaintext highlighter-rouge">channel</code> 的类型，第二个是 <code class="language-plaintext highlighter-rouge">channel</code> 的缓冲区大小。 缓冲区大小默认为 <code class="language-plaintext highlighter-rouge">0</code>，表示无缓冲 <code class="language-plaintext highlighter-rouge">channel</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// 无缓冲 channel</span>
<span class="n">chBuf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c">// 有缓冲 channel，缓冲区大小为 5</span>
</code></pre></div></div> <p>在使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 的时候，发送方和接收方一定要放在两个不同的 <code class="language-plaintext highlighter-rouge">goroutine</code> 中， 这是因为如果放在同一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中，无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 在发送和接收时都会阻塞当前的 <code class="language-plaintext highlighter-rouge">goroutine</code>， 进而引发协程泄漏。</p> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中使用 <code class="language-plaintext highlighter-rouge">channel</code> 的时候往往是由发送方来关闭， 这是因为接收主有安全的手段来检查 <code class="language-plaintext highlighter-rouge">channel</code> 是否已经关闭，而发送方并没有这样安全的手段。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>     <span class="c">// 当 channel 关闭时，n 会被赋值为类型的零值</span>
<span class="n">m</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// ok 为 false 表示 channel 已经关闭</span>
<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="c">// 当 channel 关闭时，循环会自动结束</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">select</code> 原语，其可以一次监听多个 <code class="language-plaintext highlighter-rouge">channel</code> 的操作。 当其中某个 <code class="language-plaintext highlighter-rouge">channel</code> 准备好进行发送或接收操作时，<code class="language-plaintext highlighter-rouge">select</code> 会执行对应的 <code class="language-plaintext highlighter-rouge">case</code> 分支。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">msg1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Received message from ch1: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg1</span><span class="p">)</span>
<span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">msg2</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Sent message to ch2: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg2</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"No channel is ready"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>当没有使用 <code class="language-plaintext highlighter-rouge">default</code> 的时候，<code class="language-plaintext highlighter-rouge">select</code> 会一直阻塞直到某个 <code class="language-plaintext highlighter-rouge">case</code> 分支可以执行。</p> <p>下面三种是 <code class="language-plaintext highlighter-rouge">select</code> 原语常用的方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">default</code> 分支可以实现 <code class="language-plaintext highlighter-rouge">try</code> 语义。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包可以实现超时控制。</li> <li>配合 <code class="language-plaintext highlighter-rouge">time</code> 包的 <code class="language-plaintext highlighter-rouge">Ticker</code> 可以实现周期任务。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fun</span> <span class="n">TrySend</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">value</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">true</span> <span class="c">// 发送成功</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="no">false</span> <span class="c">// channel 未准备好，发送失败</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ReceiveWithTimeout</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">value</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="no">nil</span> <span class="c">// 成功接收数据</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="m">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"receive timeout"</span><span class="p">)</span> <span class="c">// 超时</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">PeriodicTask</span><span class="p">(</span><span class="n">interval</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">stopCh</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
  <span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">ticker</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">ticker</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="c">// 执行周期任务</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">stopCh</span><span class="o">:</span>
      <span class="k">return</span> <span class="c">// 停止任务</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>有一点需要注意的是，在实现超时控制的时候，如果使用无缓冲 <code class="language-plaintext highlighter-rouge">channel</code> 则可能出现协程泄漏的问题：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// do some work</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}</span>
<span class="p">}()</span>
<span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务完成！"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"任务超时!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，如果任务在 <code class="language-plaintext highlighter-rouge">2</code> 秒内没有完成， 那么超时分支会被执行，而任务协程仍然会继续运行并尝试向 <code class="language-plaintext highlighter-rouge">ch</code> 发送数据。 由于 <code class="language-plaintext highlighter-rouge">ch</code> 是一个无缓冲的 <code class="language-plaintext highlighter-rouge">channel</code>，如果没有其他协程在接收数据， 那么任务协程会一直阻塞在发送操作上，导致协程泄漏。 为了解决这个问题，可以使用有缓冲的 <code class="language-plaintext highlighter-rouge">channel</code> 或者使用 <code class="language-plaintext highlighter-rouge">context</code> 进行超时控制。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中可以使用 <code class="language-plaintext highlighter-rouge">type switch</code> 来方便的判断一个接口变量所属于的类型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="m">10</span>
<span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span> <span class="c">// 只能接口类型可以使用 type switch</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is int: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x is of unknown type</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意 <code class="language-plaintext highlighter-rouge">case</code> 后面的类型必须是实现了该接口的类型，否则会导致编译错误。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的泛型不支持在类型里面内嵌泛型本身，也不支持在泛型方法中接着定义泛型。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="c">// T          // 错误，不能在泛型类型中内嵌泛型本身</span>
<span class="p">}</span>
<span class="c">// 错误，不能在泛型方法中接着定义泛型</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyType</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">MyMethod</span><span class="p">[</span><span class="n">U</span> <span class="n">any</span><span class="p">]()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的类型约束在有些情况下可以简写，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">a1</span><span class="p">[</span><span class="n">I</span> <span class="k">interface</span> <span class="p">{</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">}](</span><span class="n">param</span> <span class="n">I</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">func</span> <span class="n">a2</span><span class="p">[</span><span class="n">T</span> <span class="kt">int</span> <span class="o">|</span> <span class="kt">int32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">int64</span><span class="p">](</span><span class="n">param</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p><strong>注意</strong>：在类型约束中如果使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示只要底层类型是该类型即可， 而不使用 <code class="language-plaintext highlighter-rouge">~</code> 则表示必须是该类型本身。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">panic</code> 表示程序发生了不可恢复的错误，通常会导致程序崩溃。 任意一个 <code class="language-plaintext highlighter-rouge">goroutine</code> 中发生的 <code class="language-plaintext highlighter-rouge">panic</code> 都会导致整个程序崩溃。 可以使用 <code class="language-plaintext highlighter-rouge">recover</code> 函数来捕获 <code class="language-plaintext highlighter-rouge">panic</code>，从而防止程序崩溃。 而 <code class="language-plaintext highlighter-rouge">recover</code> 函数只能在 <code class="language-plaintext highlighter-rouge">defer</code> 函数中调用。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">safeFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="n">r</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Recovered from panic:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c">// 可能引发 panic 的代码</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的包导入时可以在结尾增加版本信息，例如：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"github.com/user/project/v2"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言的包符合 <code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code> 版本规范，官方规定只有当 <code class="language-plaintext highlighter-rouge">Major</code> 变化时才会出现兼容性的问题。 在不书写版本号时，默认导入的是 <code class="language-plaintext highlighter-rouge">v0</code> 或 <code class="language-plaintext highlighter-rouge">v1</code> 版本的包。可以使用 <code class="language-plaintext highlighter-rouge">go list -m -versions &lt;package_name&gt;</code> 来查看某个包的所有可用版本。</p> <p>如果想要移除一个依赖，需要使用 <code class="language-plaintext highlighter-rouge">go get &lt;package_name&gt;</code> 的形式在版本部分添加 <code class="language-plaintext highlighter-rouge">@none</code>， 例如 <code class="language-plaintext highlighter-rouge">go get github.com/go-redis/redis/v8@none</code> 会移除已经添加的 <code class="language-plaintext highlighter-rouge">go-redis v8</code> 依赖。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 中命名的一些规范：</p> <ul> <li>循环和条件变量多采用单个字母命名。</li> <li>函数/方法的参数和返回值以单个单词或字母为主。</li> <li>方法的命名以单个单词为主。</li> <li>函数/类型多以多个单词的复合形式命名。</li> <li>变量中不携带类型信息。</li> <li>包名往往由单个单词进行命名，且尽量与导入路径的最后一个路径分段一致。</li> <li><code class="language-plaintext highlighter-rouge">Go</code> 中如果接口类型只有一个方法，则接口往往命名为该方法名加上 <code class="language-plaintext highlighter-rouge">-er</code> 后缀。 比如 <code class="language-plaintext highlighter-rouge">Read</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Reader</code>，<code class="language-plaintext highlighter-rouge">Write</code> 方法对应的接口名为 <code class="language-plaintext highlighter-rouge">Writer</code>。</li> </ul> <hr/> <p>在 <code class="language-plaintext highlighter-rouge">Go</code> 语言中零值可用是非常重要的概念，比如对于一个指向 <code class="language-plaintext highlighter-rouge">net.TCPAddr</code> 的指针， 如果我们使用 <code class="language-plaintext highlighter-rouge">fmt.Print</code> 对其进行输出则会调用 <code class="language-plaintext highlighter-rouge">func (*TCPAddr) String() string</code> 方法， 在该方法中，其检查了调用的实例是不是一个空指针，并对于空指针直接返回了 <code class="language-plaintext highlighter-rouge">&lt;nil&gt;</code> 字符串。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的参数传递是值传递的，对于一个数组参数其在进行参数传递的时候会对整个数组进行拷贝。 而因为切片、字典等对象实际存储的是指针，所以其在作为参数进行传递时开销会小很多。 除此之外，<code class="language-plaintext highlighter-rouge">Go</code> 语言中 <code class="language-plaintext highlighter-rouge">for i, v := range x</code> 中的 <code class="language-plaintext highlighter-rouge">v</code> 变量也会有一次拷贝， 即使 <code class="language-plaintext highlighter-rouge">x</code> 的类型是切片这样的类型，修改 <code class="language-plaintext highlighter-rouge">v</code> 也不会作用在原切片上。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="c">// CE: declared and not used: v</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">r</span> <span class="p">{</span>
  <span class="n">v</span> <span class="o">=</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的例子中我们尝试通过修改 <code class="language-plaintext highlighter-rouge">v</code> 来实现修改 <code class="language-plaintext highlighter-rouge">r</code> 的目的，但是实际上是不可能的， 因为我们只是对 <code class="language-plaintext highlighter-rouge">v</code> 进行了赋值，<code class="language-plaintext highlighter-rouge">Go</code> 编译器认为我们没有使用 <code class="language-plaintext highlighter-rouge">v</code>。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span>
<span class="k">var</span> <span class="n">r</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span> <span class="p">{</span>
<span class="c">// for i, v := range &amp;a {</span>
<span class="c">// for i, v := range a[:] {</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// 注意这里我们改的是还没有遍历到的数据</span>
    <span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="m">12</span>
    <span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="m">13</span>
    <span class="c">// 不管是使用哪种形式的 for range</span>
    <span class="c">// 对当前遍历对象的修改都不会作用到 v 上</span>
    <span class="c">// 因为 v 已经是 a[0] 的拷贝了</span>
    <span class="c">// a[0] = 10</span>
  <span class="p">}</span>
  <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"r = "</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c">// r = [1 2 3 4 5]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a = "</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c">// a = [1 12 13 4 5]</span>
</code></pre></div></div> <p>由于在调用 <code class="language-plaintext highlighter-rouge">range</code> 的时候会将 <code class="language-plaintext highlighter-rouge">a</code> 进行一次拷贝， 即使我们第一次进行循环的时候修改了 <code class="language-plaintext highlighter-rouge">a[1]</code> 和 <code class="language-plaintext highlighter-rouge">a[2]</code>， 我们也不能看到修改的值。</p> <p>而如果我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range &amp;a</code> 拷贝的就是指针，此时编译器会帮我们解引用而因为是同一个地址， 所以 <code class="language-plaintext highlighter-rouge">v</code> 可以看到这样的影响。</p> <p>同理，当我们使用 <code class="language-plaintext highlighter-rouge">for i, v := range a[:]</code> 拷贝的就是切片，而切片的底层数组是同一个， 所以 <code class="language-plaintext highlighter-rouge">v</code> 也可以看到这样的影响。</p> <p>对于 <code class="language-plaintext highlighter-rouge">map</code> 而言，如果在 <code class="language-plaintext highlighter-rouge">for</code> 过程中添加或者删除键值，则循环的次数是不确定的。 而对于切片而言，其循环次数在一开始就已经确定了。</p> <p>对于 <code class="language-plaintext highlighter-rouge">channel</code> 而言，<code class="language-plaintext highlighter-rouge">for range</code> 只有在 <code class="language-plaintext highlighter-rouge">channel</code> 被关闭后才会结束循环。 如果 <code class="language-plaintext highlighter-rouge">channel</code> 的变量是 <code class="language-plaintext highlighter-rouge">nil</code> 则循环将会永远被阻塞。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 版本之前，<code class="language-plaintext highlighter-rouge">for</code> 循环中变量只会被创建一次， 这会导致一些奇怪的现象：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Customer</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">ID</span>      <span class="kt">string</span>
  <span class="n">Balance</span> <span class="kt">float64</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Customers</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Store</span><span class="p">)</span> <span class="n">storeCustomers</span><span class="p">(</span><span class="n">customers</span> <span class="p">[]</span><span class="n">Customer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">customer</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">customers</span> <span class="p">{</span>
    <span class="c">// 在 go 1.22 之前需要这样写以避免问题，保证每次创建一个新的 customer 变量</span>
    <span class="c">// customer := customer</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Customers</span><span class="p">[</span><span class="n">customer</span><span class="o">.</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">customer</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="n">Store</span><span class="p">{</span><span class="n">Customers</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Customer</span><span class="p">)}</span>
  <span class="n">s</span><span class="o">.</span><span class="n">storeCustomers</span><span class="p">([]</span><span class="n">Customer</span><span class="p">{</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"1"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="o">-</span><span class="m">10</span><span class="p">},</span>
    <span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="s">"3"</span><span class="p">,</span> <span class="n">Balance</span><span class="o">:</span> <span class="m">0</span><span class="p">},</span>
  <span class="p">})</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span><span class="o">.</span><span class="n">Customers</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"id=%s,customer=%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 之前会输出：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id=1, customer=&amp;main.Customer{ID:"3", Balance:0}
id=2, customer=&amp;main.Customer{ID:"3", Balance:0}
id=3, customer=&amp;main.Customer{ID:"3", Balance:0}
</code></pre></div></div> <p>这是因为在 <code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">customer</code> 只会被创建一次， 所以三次赋值都指向了同一个地址，从而导致最后的结果都是相同的。</p> <p>在 <code class="language-plaintext highlighter-rouge">go 1.22</code> 及之后的版本中，<code class="language-plaintext highlighter-rouge">for range</code> 循环中变量 <code class="language-plaintext highlighter-rouge">v</code> 会在每次循环时创建新的变量， 从而避免了上述的问题。</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中除了常见的方法调用方式外，还可以通过 <code class="language-plaintext highlighter-rouge">Method Expression</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">t</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="c">// or</span>
<span class="n">T</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</code></pre></div></div> <p>除了 <code class="language-plaintext highlighter-rouge">Method Expression</code> 以外，还可以使用 <code class="language-plaintext highlighter-rouge">Method Value</code> 进行调用：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
<span class="n">getFunc</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Get</span>
<span class="n">setFunc</span> <span class="o">:=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span>
<span class="n">getFunc</span><span class="p">()</span>   <span class="c">// 等价于 t.Get()</span>
<span class="n">setFunc</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c">// 等价于 t.Set(10)</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">Go</code> 语言中的 <code class="language-plaintext highlighter-rouge">select</code> 的执行过程分为求值阶段和选择阶段。</p> <p>在求值阶段，<code class="language-plaintext highlighter-rouge">select</code> 会在进入后按照从上到下、从左到右进行求值：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">getAChannel</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="n">computeValue1</span><span class="p">()</span><span class="o">:</span>           <span class="c">// getAChannel() 和 computeValue1() 会被调用</span>
<span class="k">case</span> <span class="p">(</span><span class="n">getAStorageArray</span><span class="p">())[</span><span class="m">0</span><span class="p">]</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">getAChannel</span><span class="p">()</span><span class="o">:</span> <span class="c">// getAStorageArray() 不会被调用，getAChannel() 会被调用</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上面的代码中，会依次执行 <code class="language-plaintext highlighter-rouge">&lt;-</code> 左右两部分，但是在赋值语句中，赋值号左边的表达式不会被执行， 只有在其被选中时才会执行。</p>]]></content><author><name></name></author><category term="Potpourri"/><category term="Go"/><summary type="html"><![CDATA[本文记录了我在学习 Go 语言过程中的一些笔记和思考。]]></summary></entry><entry><title type="html">客制化 Neovim</title><link href="https://kaiser-yang.github.io/blog/2025/vim-nvim-customization/" rel="alternate" type="text/html" title="客制化 Neovim"/><published>2025-10-31T08:37:42+00:00</published><updated>2025-10-31T08:37:42+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/vim-nvim-customization</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/vim-nvim-customization/"><![CDATA[<h2 id="前言">前言</h2> <p>一些符号介绍：</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;CR&gt;</code>：回车键；</li> <li><code class="language-plaintext highlighter-rouge">&lt;C-&gt;</code>：表示按住<code class="language-plaintext highlighter-rouge">Control</code>然后点按另一个键；</li> <li><code class="language-plaintext highlighter-rouge">ab</code>：表示在规定的时间内依次按下<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>；</li> <li><code class="language-plaintext highlighter-rouge">&lt;leader&gt;</code>：前置键（前缀键）默认是<code class="language-plaintext highlighter-rouge">,</code>，可以自定义；</li> </ul> <p><strong>注意</strong>：一般以尖括号包围的是指某类特殊按键，而不是需要你输入尖括号。</p> <p><strong>注意</strong>：尖括号中的 <code class="language-plaintext highlighter-rouge">modifier</code> 是不区分大小写的， 也就是说 <code class="language-plaintext highlighter-rouge">&lt;C-O&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;c-O&gt;</code> 都表示按住 <code class="language-plaintext highlighter-rouge">Control</code> 键再点按 <code class="language-plaintext highlighter-rouge">O</code> 键。 <code class="language-plaintext highlighter-rouge">modifier</code> 为 <code class="language-plaintext highlighter-rouge">alt</code> (<code class="language-plaintext highlighter-rouge">&lt;m-&gt;</code> 或者 <code class="language-plaintext highlighter-rouge">&lt;M-&gt;</code>) 时，后面的字符是有大小写之分的。 <code class="language-plaintext highlighter-rouge">&lt;m-p&gt;</code> 表示按住 <code class="language-plaintext highlighter-rouge">Alt</code> 键再点按小写的 <code class="language-plaintext highlighter-rouge">p</code> 键， 而 <code class="language-plaintext highlighter-rouge">&lt;m-P&gt;</code> 则表示按住 <code class="language-plaintext highlighter-rouge">Alt</code> 键再点按大写的 <code class="language-plaintext highlighter-rouge">P</code> 键， 在大小写未锁定的情况下这个可以理解成按住 <code class="language-plaintext highlighter-rouge">Alt</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键再点按 <code class="language-plaintext highlighter-rouge">p</code> 键。</p> <p><strong>注意</strong>：如果不知道想要绑定的按键对应的序列可以在插入模式下先按下 <code class="language-plaintext highlighter-rouge">Ctrl-V</code>， 然后再按下想要绑定的按键，这样就会在文本中插入对应的按键序列。</p> <h2 id="为什么使用-neovim">为什么使用 <code class="language-plaintext highlighter-rouge">Neovim</code></h2> <h3 id="我和-vim">我和 <code class="language-plaintext highlighter-rouge">vim</code></h3> <p>和 <code class="language-plaintext highlighter-rouge">vim</code> 的结缘要说到高中时期，我在高中时期第一次接触到 <code class="language-plaintext highlighter-rouge">vim</code> ，当时我只是觉得这个工具非常的麻烦， 竟然不能够通过鼠标进行操作（当然可以设置开启鼠标功能，但我当时并不知道这一点）， 于是在我高中的时候我对 <code class="language-plaintext highlighter-rouge">vim</code> 的认识只是停留在通过 <code class="language-plaintext highlighter-rouge">h,j,k,l</code> 进行导航， 修改文件需要先按一次 <code class="language-plaintext highlighter-rouge">i</code> 键，输入完成后如果要保存需要按下 <code class="language-plaintext highlighter-rouge">&lt;esc&gt;</code>， 然后输入 <code class="language-plaintext highlighter-rouge">:w&lt;cr&gt;</code> 而且还必须是英文的冒号， 这就导致如果你输入中文之后忘记按 <code class="language-plaintext highlighter-rouge">&lt;shift&gt;</code>（或者没有关闭输入法），那么你的命令将不被<code class="language-plaintext highlighter-rouge">vim</code>所识别。 当时使用最多的操作应该是 <code class="language-plaintext highlighter-rouge">:wq&lt;CR&gt;</code> 保存退出和 <code class="language-plaintext highlighter-rouge">:q!&lt;CR&gt;</code> 退出不保存了吧。</p> <p>我相信很多知道 <code class="language-plaintext highlighter-rouge">vim</code>， 但是没有真正开始学习 <code class="language-plaintext highlighter-rouge">vim</code> 的人和我高中时期是很相像的——知道几条 <code class="language-plaintext highlighter-rouge">vim</code> 的基本指令。</p> <h3 id="烦人的鼠标操作">烦人的鼠标操作</h3> <p>在我高中时觉得 <code class="language-plaintext highlighter-rouge">vim</code> 最难用的就是不能使用鼠标， 而现在我转战 <code class="language-plaintext highlighter-rouge">vim</code> 也是因为我要完成的很多操作都需要使用鼠标，严重影响了我的操作的连贯性。 举一个例子，如果我要在 <code class="language-plaintext highlighter-rouge">markdown</code> 文件中插入一段代码， 那么我需要连续按下三次强调符号（和波浪线在一起符号，也被叫做反引号），然后输入我的代码语言， 接着按下回车键，这个时候有的编辑器例如 <code class="language-plaintext highlighter-rouge">typora</code> 会自动生成一个代码块，可以在里面写代码， 写完后需要通过鼠标或者方向键将光标移到后面的位置，如果你没有在 <code class="language-plaintext highlighter-rouge">markdown</code> 文件后面插入一些空行的习惯， 可能你还需要进入源代码模式进行操作，而如果使用一些没有自动生成代码块的编辑器， 你还需要在输入完代码后继续键入三次强调符号。 上面的过程实在是非常的麻烦，主要是因为鼠标和方向键以及强调符键都与主键盘区（字母集中区）较远， 难以操作，且强调符号键不独立容易按错，比如按到 <code class="language-plaintext highlighter-rouge">1</code> 或者是 <code class="language-plaintext highlighter-rouge">&lt;tab&gt;</code>。</p> <p>正是因为上述的原因我认识到：如果只是单纯的顺序浏览文件，那么使用鼠标是最方便的，我不需要到处跳转， 就算我需要进行一些链接的跳转，我也可以通过鼠标侧键进行返回，而对于需要浏览加编辑的文件， 只使用鼠标是近乎不可能完成的，而使用鼠标和键盘的形式同样不是最优解， 而 <code class="language-plaintext highlighter-rouge">vim</code> 可以只使用键盘完成浏览和编写的操作，如果使用 <code class="language-plaintext highlighter-rouge">vim</code> 编写纯英文的文件是更为方便的。 而作为一个程序员，平常的大部分需要编写的文件应该是满足纯英文条件的 （当然你可能需要写中文注释，或者写一些笔记，但是使用 <code class="language-plaintext highlighter-rouge">vim</code> 进行操作并不会太慢）。</p> <h3 id="the-missing-semester">the missing semester</h3> <p><code class="language-plaintext highlighter-rouge">MIT</code> 的 <code class="language-plaintext highlighter-rouge">the missing semester</code> 让我真正认识到了好的工具的重要性，在三位顶级学府的教授的推荐下， 以及看了他们的实操演示后，我被 <code class="language-plaintext highlighter-rouge">vim</code> 所吸引——使用 <code class="language-plaintext highlighter-rouge">vim</code> 不是单纯地操作鼠标键盘， 而是在大脑里进行一个类似编程的过程。</p> <p>这个过程需要你进一步分解每一个操作，然后完全通过键盘完成相关的操作。</p> <p>比如我要跳到某个函数的开始，那么我就有很多种方法：</p> <ul> <li>通过鼠标滚轮找到这个函数，通过点击鼠标放置鼠标指针；</li> <li>通过搜索函数名字并跳转到函数（当然得能大概记住函数的名字才行）；</li> <li>如果在当前的屏幕内看见函数，那么可以直接通过输入行号进行跳转；</li> <li>如果你刚好在函数的尾部括号处，那么你可以通过<code class="language-plaintext highlighter-rouge">%</code>进行跳转；</li> <li>……</li> </ul> <p>使用鼠标的话，会面临我之前提到的问题，而使用<code class="language-plaintext highlighter-rouge">vim</code>可以轻松的通过后面几种方式实现。</p> <h3 id="值不值">值不值</h3> <p>在我学习了 <code class="language-plaintext highlighter-rouge">vim</code> 并用 <code class="language-plaintext highlighter-rouge">vim</code> 写下一篇 <code class="language-plaintext highlighter-rouge">blog</code> 的时候， 我已经感受到一周 <code class="language-plaintext highlighter-rouge">vim</code> 带给我的速度与我写了几年 <code class="language-plaintext highlighter-rouge">VSCode</code> 的速度相当了 （当然也是因为我比较懒，不会去记忆太多<code class="language-plaintext highlighter-rouge">VSCode</code>的快捷键）。</p> <p>而学会 <code class="language-plaintext highlighter-rouge">vim</code> 可能需要很短的时间，但是你可能需要一生的时间去掌握这一个工具 （这是在<code class="language-plaintext highlighter-rouge">the missing semester</code>里面看到的）。 根据我目前的体验看下来，我是相信 <code class="language-plaintext highlighter-rouge">vim</code> 给我带来的效率提升远远超过我花费的时间， 也就是投入产出比非常小。</p> <h3 id="从-vim-到-neovim">从 <code class="language-plaintext highlighter-rouge">vim</code> 到 <code class="language-plaintext highlighter-rouge">neovim</code></h3> <p>最开始我自己进行了 <code class="language-plaintext highlighter-rouge">vim</code> 的学习并尝试根据自己的需求进行了相关的配置， 这个期间我参考了很多网上成熟的配置。期间主要的模式是通过 <code class="language-plaintext highlighter-rouge">vim-plug</code> 进行插件的管理。 最开始使用的 <code class="language-plaintext highlighter-rouge">YouCompleteMe</code> 等一些比较老牌的插件进行的补全，再在后面换成了 <code class="language-plaintext highlighter-rouge">coc</code>。</p> <p>后面在我持续使用的过程中，我了解到了 <code class="language-plaintext highlighter-rouge">neovim</code> 这个项目，其拥有更加活跃的社区以及更加灵活的配置方式 （当时使用 <code class="language-plaintext highlighter-rouge">vim script</code> 进行配置的时候还是感觉不是很方便，而 <code class="language-plaintext highlighter-rouge">neovim</code> 支持 <code class="language-plaintext highlighter-rouge">lua</code> 进行配置）， 于是我决定转战 <code class="language-plaintext highlighter-rouge">neovim</code>，并且在 <code class="language-plaintext highlighter-rouge">neovim</code> 上重新进行配置。在使用 <code class="language-plaintext highlighter-rouge">neovim</code> 的时候我使用的是 <code class="language-plaintext highlighter-rouge">lazy.nvim</code> 进行插件管理，这个插件管理器支持惰性加载插件，可以大幅度提升 <code class="language-plaintext highlighter-rouge">neovim</code> 的启动速度， 但是我当时不太了解懒加载，没有为其他的插件考虑应该在什么时候进行加载。补全最开始使用的是 <code class="language-plaintext highlighter-rouge">cmp</code>， 后面 <code class="language-plaintext highlighter-rouge">blink.nvim</code> 出现后我就切换到了 <code class="language-plaintext highlighter-rouge">blink.nvim</code>，体验下来确实补全会比 <code class="language-plaintext highlighter-rouge">cmp</code> 快， 自己也给 <code class="language-plaintext highlighter-rouge">blink.nvim</code> 提交过一些 <code class="language-plaintext highlighter-rouge">issues</code> 并写了几个自己平时会用到的 <code class="language-plaintext highlighter-rouge">sources</code>。</p> <h2 id="学习资料">学习资料</h2> <p>主要依靠以下几种方式进行学习:</p> <ul> <li><code class="language-plaintext highlighter-rouge">vimtutor</code>：<code class="language-plaintext highlighter-rouge">vim</code> 自带的教程，适合初学者入门，也是我最开始使用的教程；</li> <li>网上的各种 <code class="language-plaintext highlighter-rouge">vim</code> 配置的介绍：这类视频网上有很多，可以学习到很多实用的配置技巧， 也可以找到很多好用的插件；</li> <li><code class="language-plaintext highlighter-rouge">:help</code>：<code class="language-plaintext highlighter-rouge">vim</code> 自带的帮助文档，内容非常全面，适合有一定基础的用户。 可以使用 <code class="language-plaintext highlighter-rouge">:help &lt;topic&gt;</code> 来查找相关的帮助文档；</li> <li><code class="language-plaintext highlighter-rouge">Vim</code> 实用技巧：这本书介绍了很多 <code class="language-plaintext highlighter-rouge">vim</code> 的实用技巧，适合有一定基础的用户； 看了这本书，你会发现你之前可能并不太会用 <code class="language-plaintext highlighter-rouge">vim</code>；</li> <li>使用过程中优化：在使用 <code class="language-plaintext highlighter-rouge">vim</code> 的过程中，你可能会发现你会频繁的用到一些操作， 或者一些操作在现有的配置下需要多次按键才可以实现，那么在这个时候你就是尝试进行优化， 网上对这类问题往往是有相关讨论的。</li> </ul> <h2 id="配置的迁移">配置的迁移</h2> <p>当你切换电脑的时候，或者需要在多台电脑是进行配置同步的时候，你可能需要将你的配置进行迁移。</p> <p>我个人的做法是将配置文件放在 <code class="language-plaintext highlighter-rouge">GitHub</code> 上。 并实现了一个简单的脚本帮助我安装一些依赖以及将配置文件进行软链接到对应的位置。</p> <p>可以参考：<a href="https://github.com/Kaiser-Yang/dotfiles/blob/main/dotfiles.sh">dotfiles.sh</a>。</p> <p><strong>NOTE</strong>：可以直接把上面的代码扔给 <code class="language-plaintext highlighter-rouge">AI</code> 让 <code class="language-plaintext highlighter-rouge">AI</code> 来解释上面代码的功能。</p> <h2 id="lightboat">LightBoat</h2> <p>网上其实有很多好用的 <code class="language-plaintext highlighter-rouge">neovim</code> 配置。我自己在配置过程中还是发现很多插件对于大文件并不是很友好， 所以我自己就发布了一个 <code class="language-plaintext highlighter-rouge">neovim</code> 配置，叫做 <a href="https://github.com/kaiser-Yang/LightBoat">LightBoat</a>。 <code class="language-plaintext highlighter-rouge">LightBoat</code> 是根据我自己的使用习惯进行配置的，可以进行自定义，并且对于大文件有比较好的支持。</p>]]></content><author><name></name></author><category term="Potpourri"/><category term="Vim/Neovim"/><summary type="html"><![CDATA[本文介绍自己如何客制化 Neovim 以提升编程效率。]]></summary></entry><entry><title type="html">鞋带公式</title><link href="https://kaiser-yang.github.io/blog/2025/shoelace-formula/" rel="alternate" type="text/html" title="鞋带公式"/><published>2025-10-30T08:51:37+00:00</published><updated>2025-10-30T08:51:37+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/shoelace-formula</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/shoelace-formula/"><![CDATA[<p>简单多边形：如果一个多边形的任意两条边都不相交，则称该多边形为简单多边形。</p> <p>鞋带公式是用来求一个简单多边形面积的公式。</p> <p>鞋带公式要求按照顺时针或逆时针的顺序给出多边形的顶点坐标。</p> <p>这里我们定义 \(x_i, y_i\) 分别表示一个简单 \(n\) 边形的第 \(i\) 个顶点的横坐标和纵坐标， 这里选择下标从 \(0\) 开始编号。特别地，我们定义 \(x_n = x_0\)，\(y_n = y_0\)。</p> <p>鞋带公式的表达式为：</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \right|\] <h2 id="原理">原理</h2> <p>鞋带公式实际是通过计算多个梯形的代数面积来求解多边形的面积。 具体地，我们可以将多边形划分为多个梯形， 每个梯形的顶点分别是多边形的两个相邻顶点和 x 轴上的两个投影点。 通过计算每个梯形的面积并累加起来，我们可以得到整个多边形的面积。</p> <p>而上述的过程可以写成如下的方程:</p> \[\text{Area} = \frac{1}{2} \left| \sum_{i=0}^{n-1} (y_i + y_{i+1}) (x_{i+1} - x_i) \right|\] <p>整理后就可以得到最开始给出的鞋带公式。</p> <h2 id="实现">实现</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="n">R</span> <span class="nf">polygon_area</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">R</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">R</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">area</span> <span class="o">-=</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Shoelace Formula"/><summary type="html"><![CDATA[本文介绍鞋带公式的原理及其实现方式。]]></summary></entry><entry><title type="html">背包问题</title><link href="https://kaiser-yang.github.io/blog/2025/knapsack-problem/" rel="alternate" type="text/html" title="背包问题"/><published>2025-10-24T10:39:56+00:00</published><updated>2025-10-24T10:39:56+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/knapsack-problem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/knapsack-problem/"><![CDATA[<p>多重背包问题可以通过如下的转移方程来解决：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>其中，\(dp_{i,j}\) 表示前 \(i\) 种物品放入容量为 \(j\) 的背包所能获得的最大价值， \(w_i\) 和 \(v_i\) 分别表示第 \(i\) 种物品的重量和价值，\(c_i\) 表示第 \(i\) 种物品的数量。</p> <p>通过上面的方法进行转移时，时间复杂度为 \(O(N \cdot M \cdot C)\)， 其中 \(N\) 是物品种类数，\(M\) 是背包容量，\(C\) 是物品数量的最大值。 当 \(C\) 较大时，时间复杂度会变得非常高，这里介绍两种优化方法来降低时间复杂度。</p> <h2 id="二进制优化">二进制优化</h2> <p>对于第 \(i\) 件物品我们将其拆分成 \(1, 2, 4, \ldots, 2^k\) 件，使得 \(1 + 2 + 4 + \ldots + 2^k \leq c_i\)， 再加上剩余的 \(x := c_i - (1 + 2 + 4 + \ldots + 2^k)\) 件，其中的 \(k\) 满足 \(2^{k+1} &gt; c_i\)。</p> <p>经过上述的拆分后，我们可以将多重背包问题转化为 0-1 背包问题，从而将时间复杂度降低到 \(O(N \cdot M \cdot \log C)\)。</p> <p>转换的依据是 \(1, 2, 4, \ldots, 2^k\) 件物品可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1\) 件物品， 而加上剩余的 \(x\) 件物品后，可以组成 \(0, 1, 2, \ldots, 2^{k+1} - 1 + x = c_i\) 件物品。</p> <p>综上所述，这里使用 0-1 背包的方式进行转移依然可以覆盖所有的情况。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="单调栈优化">单调栈优化</h2> <p>我们回到最开始的转移方程：</p> \[dp_{i,j} = \max(dp_{i-1,j-k \cdot w_i} + k \cdot v_i) \quad (0 \leq k \leq c_i \text{且} j - k \cdot w_i \geq 0)\] <p>在上面的方程中我们可以发现 \(dp_{i, j}\) 只依赖于 \(dp_{i-1, j-k \cdot w_i}\)， 因此我们可以以 \(w_i\) 为步长将 \(j\) 分成若干组， 即 \(j \equiv r \text{mod} w_i\)，其中 \(0 \leq r &lt; w_i\)。</p> <p>对于每一组，我们可以将其转移方程改写为：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} + (k - k') \cdot v_i) \quad (0 \leq k - k' \leq c_i)\] <p>整理一下可以得到：</p> \[dp_{i, r + k \cdot w_i} = \max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i) + k \cdot v_i \quad (0 \leq k - k' \leq c_i)\] <p>不难发现上面的 \(\max(dp_{i-1, r + k' \cdot w_i} - k' \cdot v_i)\) 可以通过单调队列来进行优化， 从而将时间复杂度降低到 \(O(N \cdot M)\)。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ndp</span><span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            <span class="n">ndp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ndp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Knapsack Problem"/><summary type="html"><![CDATA[本文介绍多重背包问题的两种优化方法。]]></summary></entry><entry><title type="html">中国剩余定理及其扩展</title><link href="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/" rel="alternate" type="text/html" title="中国剩余定理及其扩展"/><published>2025-10-16T07:22:05+00:00</published><updated>2025-10-16T07:22:05+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/chinese-reminder-theorem/"><![CDATA[<h2 id="中国剩余定理">中国剩余定理</h2> <p>假如给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>其中 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>我们令 \(M = m_1 \cdot m_2 \cdots m_k\)，并且对于每个 \(i\)，定义 \(M_i = \frac{M}{m_i}\)。 由于 \(m_i\) 和 \(M_i\) 互质，可以知道 \(M_i\) 在模 \(m_i\) 意义下是有逆元的， 记为 \(M_i^{-1}\)。不难发现 \(M_i \cdot M_i^{-1} \equiv 1 \text{mod} m_i\) 和 \(M_i \cdot M_i^{-1} \equiv 0 \text{mod} m_j\)（\(j \neq i\)）都成立。 记 \(c_i = a_i \cdot M_i \cdot M_i^{-1}\)，则有：</p> \[\begin{cases} c_i \equiv a_i \text{mod} m_i \\ n_i \equiv 0 \text{mod} m_j \quad (j \neq i) \end{cases}\] <p>由同余的线性性质可知，\(x' = \sum_{i=1}^{k} c_i\) 即为一个特解。</p> <p>不难证明通解可以写成 \(x = x' + t \cdot M \quad (t \in \mathbb{Z})\)。</p> <p>注意在上述的过程中，我们要求解 \(M_i\) 在模 \(m_i\) 意义下的逆元， 只有在 \(m_i\) 两两互质的情况下才能保证每次求解的逆元存在。</p> <p>代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">l</span> <span class="o">*=</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span> <span class="o">*</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="扩展中国剩余定理">扩展中国剩余定理</h2> <p>扩展中国剩余定理是在中国剩余定理的基础上，放宽了对模数的互质要求。 假设给定一组同余方程：</p> \[\begin{cases} x \equiv a_1 \text{mod} m_1 \\ x \equiv a_2 \text{mod} m_2 \\ \vdots \\ x \equiv a_k \text{mod} m_k \end{cases}\] <p>并不保证 \(m_1, m_2, \ldots, m_k\) 两两互质，下面介绍如何求解该组方程。</p> <p>不难发现，\(x = x' + t \cdot M \quad (t \in \mathbb{Z})\) 是同余方程 \(x \equiv x' \text{mod}{M}\) 的解。</p> <p>假设我们已经求出了前 \(i-1\) 个方程的解：</p> \[x = x_{i-1} + t \cdot M_{i-1} \quad (t \in \mathbb{Z}),\] <p>现在考虑如何求其与</p> \[x \equiv a_i \text{mod}{m_i}\] <p>的公共解。</p> <p>将当前的解代入上述方程，得到：</p> \[x_{i-1} + t \cdot M_{i-1} \equiv a_i \text{mod}{m_i},\] <p>即</p> \[t \cdot M_{i-1} \equiv a_i - x_{i-1} \text{mod}{m_i}.\] <p>设 \(d = \gcd(M_{i-1}, m_i)\)，则上式有解的<strong>充要条件</strong>是\(d \mid (a_i - x_{i-1})\)。</p> <p>如果有解，将上式两边同时除以 \(d\)，得到：</p> \[t \cdot \frac{M_{i-1}}{d} \equiv \frac{a_i - x_{i-1}}{d} \text{mod}{\frac{m_i}{d}}.\] <p>由于\(\frac{M_{i-1}}{d}\)和\(\frac{m_i}{d}\)互质， 可以用扩展欧几里得算法求该方程的一个特解 \(t_0\)，则通解可以表示为：</p> \[t = t_0 + k \cdot \frac{m_i}{d} \quad (k \in \mathbb{Z}).\] <p>将通解代入\(x = x_{i-1} + t \cdot M_{i-1}\)中，可以得到：</p> \[x = x_{i-1} + t_0 \cdot M_{i-1} + k \cdot \frac{m_i}{d} \cdot M_{i-1} \quad (k \in \mathbb{Z}).\] <p>因此，新的解可以表示为：</p> \[x = x_i + k \cdot M_i \quad (k \in \mathbb{Z}),\] <p>其中</p> \[\begin{cases} x_i = x_{i-1} + t_0 \cdot M_{i-1} \\ M_i = \frac{m_i}{d} \cdot M_{i-1} \end{cases}\] <p>特别地，我们可以增加一个方程 \(x \equiv 0 \text{mod} 1\) 作为初始条件， 此时 \(x_0 = 0\)，\(M_0 = 1\)。这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ex_crt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ex_gcd</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">_</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">%=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Chinese Remainder Theorem"/><summary type="html"><![CDATA[本文介绍中国剩余定理以及扩展中国剩余定理。]]></summary></entry><entry><title type="html">模逆元</title><link href="https://kaiser-yang.github.io/blog/2025/mod-inverse/" rel="alternate" type="text/html" title="模逆元"/><published>2025-10-15T13:34:31+00:00</published><updated>2025-10-15T13:34:31+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/mod-inverse</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/mod-inverse/"><![CDATA[<p>模逆元的定义如下：</p> <p>给定一个正整数 \(a\) 和一个正模数 \(p\) ，如果存在一个正整数 \(b\) 满足：</p> \[a \cdot b \equiv 1 \ (\text{mod} \ p), 1 \leq b \le p\] <p>则称 \(b\) 为 \(a\) 关于模数 \(p\) 的模逆元，记作 \(a^{-1} \ (\text{mod} \ p)\) 。</p> <h2 id="计算方法">计算方法</h2> <h3 id="单个数的模逆元">单个数的模逆元</h3> <p>对于模逆元的计算，其本质是在求解 \(ax + py = 1\) 这个不定方程的正整数解 \(x\)。</p> <p>由裴蜀定理可知，只有当 \(\gcd(a, p) = 1\) 时，方程才有整数解。</p> <p>所以我们可以使用扩展欧几里得算法来计算模逆元。</p> <p>这里给出计算代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">inverse_of</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ex_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>特别地，当 \(p\) 是质数时，由费马小定理可知：</p> \[a^{p-1} \equiv 1 \ (\text{mod} \ p)\] <p>因此，\(a^{p-2} \ (\text{mod} \ p)\) 即为 \(a\) 关于模数 \(p\) 的模逆元。</p> <h3 id="多个数的模逆元">多个数的模逆元</h3> <p>逆元存在一个重要的性质：对于 \(a\) 和 \(b\)，有</p> \[(a \cdot b)^{-1} \equiv a^{-1} \cdot b^{-1} (\text{mod} \ p)\] <p>有了这个性质，我们可以通过预处理前缀积来计算多个数的模逆元。</p> <p>具体地，我们用 \(prod_i\) 表示 \([1, i)\) 的前缀积取模后的结果，即：</p> \[prod_i = a_{i-1} \cdot prod_{i-1} \ (\text{mod} \ p)\] <p>那么就有 \(a^{-1}_i \equiv prod^{-1}_{i+1} \cdot prod_i \ (\text{mod} \ p)\)。</p> <p>我们只需要计算出 \(prod_n\) 的模逆元，然后从后往前依次计算出每个数的模逆元即可。</p> <p>这里给出代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the inverse of each element in a modulo mod</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inverse_of</span><span class="p">(</span><span class="n">prod</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">mod</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">inv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Modular Inverse"/><summary type="html"><![CDATA[本文介绍模逆元的定义及其计算方法。]]></summary></entry><entry><title type="html">扩展欧几里德算法</title><link href="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/" rel="alternate" type="text/html" title="扩展欧几里德算法"/><published>2025-10-14T10:42:49+00:00</published><updated>2025-10-14T10:42:49+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/extended-euclidean-algorithm/"><![CDATA[<h2 id="前置知识">前置知识</h2> <p>裴蜀定理（Bézout’s Identity）： 对于任意两个整数 \(a\) 和 \(b\)，存在整数 \(x\) 和 \(y\) 使得 \(ax + by = \gcd(a, b)\) 成立。</p> <p>欧几里德算法：对于两个非负整数 \(a\) 和 \(b\)，其最大公约数可以通过以下递归关系计算：</p> \[gcd(a, b) = gcd(b, a \text{mod} b)\] <h2 id="线性丢番图方程">线性丢番图方程</h2> <p>线性丢番图方程是形如 \(ax + by = c\) 的不定方程， 其中 \(a\)、\(b\) 和 \(c\) 是已知整数，\(x\) 和 \(y\) 是未知整数。</p> <p>根据裴蜀定理，线性丢番图方程有整数解的充分必要条件是 \(\gcd(a, b)\) 整除 \(c\)。</p> <h2 id="扩展欧几里德算法">扩展欧几里德算法</h2> <p>扩展欧几里德算法是用来求解 \(ax + by = \gcd(a, b)\) 的一组特解。</p> <p>算法的基本思想是利用欧几里德算法的递归结构，同时在每一步记录下 \(x\) 和 \(y\) 的变化。</p> <p>考虑当我们已经知道 \(gcd(b, a \text{mod} b) = bx_1 + (a \text{mod} b)y_1\) 的解时， 如何求出 \(gcd(a, b) = ax + by\) 的解。</p> <p>我们记 \(a \text{mod} b = a - \lfloor \frac{a}{b} \rfloor \cdot b\)， 则有：</p> \[gcd(b, a \text{mod} b) = bx_1 + (a - \lfloor \frac{a}{b} \rfloor \cdot b)y_1\] <p>注意到 \(gcd(b, a \text{mod} b) = gcd(a, b)\)，我们可以将上式改写为：</p> \[gcd(a, b) = ay_1 + b(x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1) = ax + by\] <p>从而得到：</p> \[\left\{ \begin{array}{l} x = y_1 \\ y = x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1 \end{array} \right.\] <p>而不难发现当 \(b = 0\) 时，\(gcd(a, 0) = a\)，此时方程的解为 \((1, 0)\)。</p> <p>这样我们就可以通过递归的方式来求解 \(ax + by = \gcd(a, b)\)。</p> <p>对于 \(ax + by = c\) 的情况，我们只需要先求出 \(ax_0 + by_0 = \gcd(a, b)\) 的一组解， 此时 \(x = x_0 \cdot \frac{c}{\gcd(a, b)}\)，\(y = y_0 \cdot \frac{c}{\gcd(a, b)}\) 即为 \(ax + by = c\) 的一组特解。</p> <p>接下来我们考虑在知道一组解的情况下，如何求出通解。这里先给出结论：</p> <p>若 \((x_0, y_0)\) 是 \(ax + by = c\) 的一组解，则通解可以表示为：</p> \[\left\{ \begin{array}{l} x = x_0 + k \cdot \frac{b}{\gcd(a, b)} \\ y = y_0 - k \cdot \frac{a}{\gcd(a, b)} \end{array} \right.\] <p>容易证明上述形式的解都满足方程。我们接下来证明所有解都可以表示为上述形式。</p> <p>设 \((x_1, y_1)\) 也是方程的解，则有 \(a(x_1 - x_0) + b(y_1 - y_0) = 0\) 成立。</p> <p>由此可得</p> \[a(x_1 - x_0) = -b(y_1 - y_0)\] <p>两边同时除以 \(\gcd(a, b)\)，有</p> \[\frac{a}{\gcd(a, b)}(x_1 - x_0) = -\frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>可以知道</p> \[\frac{a}{\gcd(a, b)} \mid \frac{b}{\gcd(a, b)}(y_1 - y_0)\] <p>因为 \(\frac{a}{\gcd(a, b)}\) 和 \(\frac{b}{\gcd(a, b)}\) 互质，所以</p> \[\frac{a}{\gcd(a, b)} \mid y_1 - y_0\] <p>即存在整数 \(k\) 使得：</p> \[y_1 - y_0 = k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[y_1 = y_0 + k \cdot \frac{a}{\gcd(a, b)}\] <p>代入前面的等式，有：</p> \[a(x_1 - x_0) = -b \cdot k \cdot \frac{a}{\gcd(a, b)}\] <p>即</p> \[x_1 = x_0 - k \cdot \frac{b}{\gcd(a, b)}\] <p>综上所述，所有解可以表示为上述通解的形式。</p> <p>最后给出扩展欧几里德算法的代码实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the greatest common divisor of a and b,</span>
<span class="c1">// and find x and y such that ax + by = gcd(a, b)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">T</span> <span class="nf">ex_gcd</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ex_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Extended Euclidean Algorithm"/><category term="gcd"/><summary type="html"><![CDATA[本文介绍扩展欧几里德算法的原理及应用。]]></summary></entry><entry><title type="html">Miller Rabin 素数测试</title><link href="https://kaiser-yang.github.io/blog/2025/miller-rabin/" rel="alternate" type="text/html" title="Miller Rabin 素数测试"/><published>2025-10-13T13:11:22+00:00</published><updated>2025-10-13T13:11:22+00:00</updated><id>https://kaiser-yang.github.io/blog/2025/miller-rabin</id><content type="html" xml:base="https://kaiser-yang.github.io/blog/2025/miller-rabin/"><![CDATA[<h2 id="前置知识">前置知识</h2> <h3 id="费马小定理fermats-little-theorem">费马小定理（Fermat’s Little Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(a\) 不是 \(p\) 的倍数， 则 \(a^{p-1} \equiv 1 \text{mod} p\)。</p> <h3 id="二次探测定理quadratic-residue-theorem">二次探测定理（Quadratic Residue Theorem）</h3> <p>如果 \(p\) 是一个素数，且 \(x^2 \equiv 1 \text{mod} p\)， 则 \(x \equiv 1 \text{mod} p\) 或 \(x \equiv n - 1 \text{mod} p\)。</p> <h2 id="miller-rabin-素数测试原理">Miller Rabin 素数测试原理</h2> <p>我们可以发现，费马小定理和二次探测定理都给出了素数的必要条件， 但并不是充分条件。也就是说，如果一个数不满足这些条件， 那么它一定不是素数。</p> <p>Miller Rabin 素数测试是一种基于概率的素数测试算法， 它通过多次随机选择基数 \(a\) 来验证一个数是否为素数。</p> <p>对于一个奇数 \(n\) 而言其可以被写成 \(n - 1 = 2^s \cdot d\) 的形式， 其中 \(d\) 是奇数，\(s \geq 1\)。 根据费马小定理，如果 \(n\) 是素数， 则对于任意不是 \(p\) 倍数的 \(a\)，都有 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\)。 而由二次探测定理可知，我们可以对 \(a^{2^s \cdot d} \equiv 1 \text{mod} n\) 执行开方的操作，其结果一定要是 \(1\) 或 \(n - 1\)。 同时当其结果为 \(1\) 时，则可以继续尝试开方操作，直到结果为 \(n - 1\) 或无法继续开方为止。 如果在某次开方的过程中，结果既不是 \(1\) 也不是 \(n - 1\)， 则 \(n\) 一定不是素数。</p> <p>根据上面的流程我们可以选择多个不同的 \(a\) 来进行测试， 如果所有的测试都通过了，则 \(n\) 很可能是素数。</p> <p>特别地，对于 64 位无符号整数，选择 \(2, 325, 9375, 28178, 450775, 9780504, 1795265022\) 可以保证不会出现误判。</p> <p>另外在实现的过程中，我们往往不会进行开方的操作，取而代之的是平方操作：</p> <ol> <li>将待测试的数 \(n\) 表示为 \(n - 1 = 2^s \cdot d\)，其中 \(d\) 是奇数，\(s \geq 1\)。</li> <li>选择一个基数 \(a\)。</li> <li>计算 \(x = a^d \text{mod} n\)。</li> <li>如果 \(x \equiv 1 \text{mod} n\) 或 \(x \equiv n - 1 \text{mod} n\)，此时进行平方的结果一定是 \(1\)， 所以可以直接认为通过本轮的测试。</li> <li>否则，重复以下步骤 \(s - 1\) 次： <ul> <li>计算 \(x \leftarrow x^2 \text{mod} n\)。</li> <li>如果 \(x \equiv n - 1 \text{mod} n\)，则通过本轮测试。</li> <li>如果在 \(s - 1\) 次操作中都没有出现 \(x \equiv n - 1 \text{mod} n\)，则本轮测试未通过。</li> </ul> </li> </ol> <p>在上述过程的5中，我们只检查了结果是否等于 \(n - 1\)，而没有检查结果是否等于 \(1\)。 这是因为如果当前的结果第一次等于 \(1\)，则说明在前一次平方操作中， 结果既不是 \(1\) 也不是 \(n - 1\)，这就违背了二次探测定理。</p> <p>最后给出Miller Rabin素数测试的代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">a</span> <span class="o">:</span> <span class="n">miller_rabin_test</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// calculate a^d % n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm"/><category term="Miller Rabin"/><category term="Primality Test"/><summary type="html"><![CDATA[本文介绍 Miller Rabin 素数测试的原理及其实现方式。]]></summary></entry></feed>